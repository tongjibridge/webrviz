var _r = Object.defineProperty;
var mr = o => {
	throw TypeError(o)
};
var wr = (o, s, a) => s in o ? _r(o, s, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: a
}) : o[s] = a;
var gr = (o, s, a) => wr(o, typeof s != "symbol" ? s + "" : s, a),
	fr = (o, s, a) => s.has(o) || mr("Cannot " + a);
var vn = (o, s, a) => (fr(o, s, "read from private field"), a ? a.call(o) : s.get(o)),
	rr = (o, s, a) => s.has(o) ? mr("Cannot add the same private member more than once") : s instanceof WeakSet ? s.add(
		o) : s.set(o, a),
	pr = (o, s, a, l) => (fr(o, s, "write to private field"), l ? l.call(o, a) : s.set(o, a), a),
	Gn = (o, s, a) => (fr(o, s, "access private method"), a);
var hr = (o, s, a, l) => ({
	set _(c) {
		pr(o, s, c, a)
	},
	get _() {
		return vn(o, s, l)
	}
});
/**
 * @vue/shared v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function makeMap(o) {
	const s = Object.create(null);
	for (const a of o.split(",")) s[a] = 1;
	return a => a in s
}
const EMPTY_OBJ = {},
	EMPTY_ARR = [],
	NOOP$1 = () => {},
	NO = () => !1,
	isOn = o => o.charCodeAt(0) === 111 && o.charCodeAt(1) === 110 && (o.charCodeAt(2) > 122 || o.charCodeAt(2) < 97),
	isModelListener = o => o.startsWith("onUpdate:"),
	extend = Object.assign,
	remove = (o, s) => {
		const a = o.indexOf(s);
		a > -1 && o.splice(a, 1)
	},
	hasOwnProperty$2 = Object.prototype.hasOwnProperty,
	hasOwn = (o, s) => hasOwnProperty$2.call(o, s),
	isArray$3 = Array.isArray,
	isMap$1 = o => toTypeString(o) === "[object Map]",
	isSet = o => toTypeString(o) === "[object Set]",
	isFunction$3 = o => typeof o == "function",
	isString$3 = o => typeof o == "string",
	isSymbol = o => typeof o == "symbol",
	isObject$3 = o => o !== null && typeof o == "object",
	isPromise$1 = o => (isObject$3(o) || isFunction$3(o)) && isFunction$3(o.then) && isFunction$3(o.catch),
	objectToString = Object.prototype.toString,
	toTypeString = o => objectToString.call(o),
	toRawType = o => toTypeString(o).slice(8, -1),
	isPlainObject$1 = o => toTypeString(o) === "[object Object]",
	isIntegerKey = o => isString$3(o) && o !== "NaN" && o[0] !== "-" && "" + parseInt(o, 10) === o,
	isReservedProp = makeMap(
		",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
		),
	cacheStringFunction = o => {
		const s = Object.create(null);
		return a => s[a] || (s[a] = o(a))
	},
	camelizeRE = /-(\w)/g,
	camelize = cacheStringFunction(o => o.replace(camelizeRE, (s, a) => a ? a.toUpperCase() : "")),
	hyphenateRE = /\B([A-Z])/g,
	hyphenate = cacheStringFunction(o => o.replace(hyphenateRE, "-$1").toLowerCase()),
	capitalize = cacheStringFunction(o => o.charAt(0).toUpperCase() + o.slice(1)),
	toHandlerKey = cacheStringFunction(o => o ? `on${capitalize(o)}` : ""),
	hasChanged = (o, s) => !Object.is(o, s),
	invokeArrayFns = (o, ...s) => {
		for (let a = 0; a < o.length; a++) o[a](...s)
	},
	def = (o, s, a, l = !1) => {
		Object.defineProperty(o, s, {
			configurable: !0,
			enumerable: !1,
			writable: l,
			value: a
		})
	},
	looseToNumber = o => {
		const s = parseFloat(o);
		return isNaN(s) ? o : s
	},
	toNumber = o => {
		const s = isString$3(o) ? Number(o) : NaN;
		return isNaN(s) ? o : s
	};
let _globalThis;
const getGlobalThis = () => _globalThis || (_globalThis = typeof globalThis < "u" ? globalThis : typeof self < "u" ?
	self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function normalizeStyle(o) {
	if (isArray$3(o)) {
		const s = {};
		for (let a = 0; a < o.length; a++) {
			const l = o[a],
				c = isString$3(l) ? parseStringStyle(l) : normalizeStyle(l);
			if (c)
				for (const d in c) s[d] = c[d]
		}
		return s
	} else if (isString$3(o) || isObject$3(o)) return o
}
const listDelimiterRE = /;(?![^(]*\))/g,
	propertyDelimiterRE = /:([^]+)/,
	styleCommentRE = /\/\*[^]*?\*\//g;

function parseStringStyle(o) {
	const s = {};
	return o.replace(styleCommentRE, "").split(listDelimiterRE).forEach(a => {
		if (a) {
			const l = a.split(propertyDelimiterRE);
			l.length > 1 && (s[l[0].trim()] = l[1].trim())
		}
	}), s
}

function normalizeClass(o) {
	let s = "";
	if (isString$3(o)) s = o;
	else if (isArray$3(o))
		for (let a = 0; a < o.length; a++) {
			const l = normalizeClass(o[a]);
			l && (s += l + " ")
		} else if (isObject$3(o))
			for (const a in o) o[a] && (s += a + " ");
	return s.trim()
}

function normalizeProps(o) {
	if (!o) return null;
	let {
		class: s,
		style: a
	} = o;
	return s && !isString$3(s) && (o.class = normalizeClass(s)), a && (o.style = normalizeStyle(a)), o
}
const specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
	isSpecialBooleanAttr = makeMap(specialBooleanAttrs);

function includeBooleanAttr(o) {
	return !!o || o === ""
}
const isRef$1 = o => !!(o && o.__v_isRef === !0),
	toDisplayString = o => isString$3(o) ? o : o == null ? "" : isArray$3(o) || isObject$3(o) && (o.toString ===
		objectToString || !isFunction$3(o.toString)) ? isRef$1(o) ? toDisplayString(o.value) : JSON.stringify(o,
		replacer, 2) : String(o),
	replacer = (o, s) => isRef$1(s) ? replacer(o, s.value) : isMap$1(s) ? {
		[`Map(${s.size})`]: [...s.entries()].reduce((a, [l, c], d) => (a[stringifySymbol(l, d) + " =>"] = c, a), {})
	} : isSet(s) ? {
		[`Set(${s.size})`]: [...s.values()].map(a => stringifySymbol(a))
	} : isSymbol(s) ? stringifySymbol(s) : isObject$3(s) && !isArray$3(s) && !isPlainObject$1(s) ? String(s) : s,
	stringifySymbol = (o, s = "") => {
		var a;
		return isSymbol(o) ? `Symbol(${(a=o.description)!=null?a:s})` : o
	};
/**
 * @vue/reactivity v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let activeEffectScope;
class EffectScope {
	constructor(s = !1) {
		this.detached = s, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this
			.parent = activeEffectScope, !s && activeEffectScope && (this.index = (activeEffectScope.scopes || (
				activeEffectScope.scopes = [])).push(this) - 1)
	}
	get active() {
		return this._active
	}
	pause() {
		if (this._active) {
			this._isPaused = !0;
			let s, a;
			if (this.scopes)
				for (s = 0, a = this.scopes.length; s < a; s++) this.scopes[s].pause();
			for (s = 0, a = this.effects.length; s < a; s++) this.effects[s].pause()
		}
	}
	resume() {
		if (this._active && this._isPaused) {
			this._isPaused = !1;
			let s, a;
			if (this.scopes)
				for (s = 0, a = this.scopes.length; s < a; s++) this.scopes[s].resume();
			for (s = 0, a = this.effects.length; s < a; s++) this.effects[s].resume()
		}
	}
	run(s) {
		if (this._active) {
			const a = activeEffectScope;
			try {
				return activeEffectScope = this, s()
			} finally {
				activeEffectScope = a
			}
		}
	}
	on() {
		activeEffectScope = this
	}
	off() {
		activeEffectScope = this.parent
	}
	stop(s) {
		if (this._active) {
			this._active = !1;
			let a, l;
			for (a = 0, l = this.effects.length; a < l; a++) this.effects[a].stop();
			for (this.effects.length = 0, a = 0, l = this.cleanups.length; a < l; a++) this.cleanups[a]();
			if (this.cleanups.length = 0, this.scopes) {
				for (a = 0, l = this.scopes.length; a < l; a++) this.scopes[a].stop(!0);
				this.scopes.length = 0
			}
			if (!this.detached && this.parent && !s) {
				const c = this.parent.scopes.pop();
				c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index)
			}
			this.parent = void 0
		}
	}
}

function getCurrentScope() {
	return activeEffectScope
}

function onScopeDispose(o, s = !1) {
	activeEffectScope && activeEffectScope.cleanups.push(o)
}
let activeSub;
const pausedQueueEffects = new WeakSet;
class ReactiveEffect {
	constructor(s) {
		this.fn = s, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup =
			void 0, this.scheduler = void 0, activeEffectScope && activeEffectScope.active && activeEffectScope
			.effects.push(this)
	}
	pause() {
		this.flags |= 64
	}
	resume() {
		this.flags & 64 && (this.flags &= -65, pausedQueueEffects.has(this) && (pausedQueueEffects.delete(this),
			this.trigger()))
	}
	notify() {
		this.flags & 2 && !(this.flags & 32) || this.flags & 8 || batch(this)
	}
	run() {
		if (!(this.flags & 1)) return this.fn();
		this.flags |= 2, cleanupEffect(this), prepareDeps(this);
		const s = activeSub,
			a = shouldTrack;
		activeSub = this, shouldTrack = !0;
		try {
			return this.fn()
		} finally {
			cleanupDeps(this), activeSub = s, shouldTrack = a, this.flags &= -3
		}
	}
	stop() {
		if (this.flags & 1) {
			for (let s = this.deps; s; s = s.nextDep) removeSub(s);
			this.deps = this.depsTail = void 0, cleanupEffect(this), this.onStop && this.onStop(), this.flags &= -2
		}
	}
	trigger() {
		this.flags & 64 ? pausedQueueEffects.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
	}
	runIfDirty() {
		isDirty(this) && this.run()
	}
	get dirty() {
		return isDirty(this)
	}
}
let batchDepth = 0,
	batchedSub, batchedComputed;

function batch(o, s = !1) {
	if (o.flags |= 8, s) {
		o.next = batchedComputed, batchedComputed = o;
		return
	}
	o.next = batchedSub, batchedSub = o
}

function startBatch() {
	batchDepth++
}

function endBatch() {
	if (--batchDepth > 0) return;
	if (batchedComputed) {
		let s = batchedComputed;
		for (batchedComputed = void 0; s;) {
			const a = s.next;
			s.next = void 0, s.flags &= -9, s = a
		}
	}
	let o;
	for (; batchedSub;) {
		let s = batchedSub;
		for (batchedSub = void 0; s;) {
			const a = s.next;
			if (s.next = void 0, s.flags &= -9, s.flags & 1) try {
				s.trigger()
			} catch (l) {
				o || (o = l)
			}
			s = a
		}
	}
	if (o) throw o
}

function prepareDeps(o) {
	for (let s = o.deps; s; s = s.nextDep) s.version = -1, s.prevActiveLink = s.dep.activeLink, s.dep.activeLink = s
}

function cleanupDeps(o) {
	let s, a = o.depsTail,
		l = a;
	for (; l;) {
		const c = l.prevDep;
		l.version === -1 ? (l === a && (a = c), removeSub(l), removeDep(l)) : s = l, l.dep.activeLink = l
			.prevActiveLink, l.prevActiveLink = void 0, l = c
	}
	o.deps = s, o.depsTail = a
}

function isDirty(o) {
	for (let s = o.deps; s; s = s.nextDep)
		if (s.dep.version !== s.version || s.dep.computed && (refreshComputed(s.dep.computed) || s.dep.version !== s
				.version)) return !0;
	return !!o._dirty
}

function refreshComputed(o) {
	if (o.flags & 4 && !(o.flags & 16) || (o.flags &= -17, o.globalVersion === globalVersion)) return;
	o.globalVersion = globalVersion;
	const s = o.dep;
	if (o.flags |= 2, s.version > 0 && !o.isSSR && o.deps && !isDirty(o)) {
		o.flags &= -3;
		return
	}
	const a = activeSub,
		l = shouldTrack;
	activeSub = o, shouldTrack = !0;
	try {
		prepareDeps(o);
		const c = o.fn(o._value);
		(s.version === 0 || hasChanged(c, o._value)) && (o._value = c, s.version++)
	} catch (c) {
		throw s.version++, c
	} finally {
		activeSub = a, shouldTrack = l, cleanupDeps(o), o.flags &= -3
	}
}

function removeSub(o, s = !1) {
	const {
		dep: a,
		prevSub: l,
		nextSub: c
	} = o;
	if (l && (l.nextSub = c, o.prevSub = void 0), c && (c.prevSub = l, o.nextSub = void 0), a.subs === o && (a.subs = l,
			!l && a.computed)) {
		a.computed.flags &= -5;
		for (let d = a.computed.deps; d; d = d.nextDep) removeSub(d, !0)
	}!s && !--a.sc && a.map && a.map.delete(a.key)
}

function removeDep(o) {
	const {
		prevDep: s,
		nextDep: a
	} = o;
	s && (s.nextDep = a, o.prevDep = void 0), a && (a.prevDep = s, o.nextDep = void 0)
}
let shouldTrack = !0;
const trackStack = [];

function pauseTracking() {
	trackStack.push(shouldTrack), shouldTrack = !1
}

function resetTracking() {
	const o = trackStack.pop();
	shouldTrack = o === void 0 ? !0 : o
}

function cleanupEffect(o) {
	const {
		cleanup: s
	} = o;
	if (o.cleanup = void 0, s) {
		const a = activeSub;
		activeSub = void 0;
		try {
			s()
		} finally {
			activeSub = a
		}
	}
}
let globalVersion = 0,
	Link$1 = class {
		constructor(s, a) {
			this.sub = s, this.dep = a, this.version = a.version, this.nextDep = this.prevDep = this.nextSub = this
				.prevSub = this.prevActiveLink = void 0
		}
	};
class Dep {
	constructor(s) {
		this.computed = s, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this
			.key = void 0, this.sc = 0
	}
	track(s) {
		if (!activeSub || !shouldTrack || activeSub === this.computed) return;
		let a = this.activeLink;
		if (a === void 0 || a.sub !== activeSub) a = this.activeLink = new Link$1(activeSub, this), activeSub.deps ?
			(a.prevDep = activeSub.depsTail, activeSub.depsTail.nextDep = a, activeSub.depsTail = a) : activeSub
			.deps = activeSub.depsTail = a, addSub(a);
		else if (a.version === -1 && (a.version = this.version, a.nextDep)) {
			const l = a.nextDep;
			l.prevDep = a.prevDep, a.prevDep && (a.prevDep.nextDep = l), a.prevDep = activeSub.depsTail, a.nextDep =
				void 0, activeSub.depsTail.nextDep = a, activeSub.depsTail = a, activeSub.deps === a && (activeSub
					.deps = l)
		}
		return a
	}
	trigger(s) {
		this.version++, globalVersion++, this.notify(s)
	}
	notify(s) {
		startBatch();
		try {
			for (let a = this.subs; a; a = a.prevSub) a.sub.notify() && a.sub.dep.notify()
		} finally {
			endBatch()
		}
	}
}

function addSub(o) {
	if (o.dep.sc++, o.sub.flags & 4) {
		const s = o.dep.computed;
		if (s && !o.dep.subs) {
			s.flags |= 20;
			for (let l = s.deps; l; l = l.nextDep) addSub(l)
		}
		const a = o.dep.subs;
		a !== o && (o.prevSub = a, a && (a.nextSub = o)), o.dep.subs = o
	}
}
const targetMap = new WeakMap,
	ITERATE_KEY = Symbol(""),
	MAP_KEY_ITERATE_KEY = Symbol(""),
	ARRAY_ITERATE_KEY = Symbol("");

function track(o, s, a) {
	if (shouldTrack && activeSub) {
		let l = targetMap.get(o);
		l || targetMap.set(o, l = new Map);
		let c = l.get(a);
		c || (l.set(a, c = new Dep), c.map = l, c.key = a), c.track()
	}
}

function trigger(o, s, a, l, c, d) {
	const f = targetMap.get(o);
	if (!f) {
		globalVersion++;
		return
	}
	const m = g => {
		g && g.trigger()
	};
	if (startBatch(), s === "clear") f.forEach(m);
	else {
		const g = isArray$3(o),
			v = g && isIntegerKey(a);
		if (g && a === "length") {
			const y = Number(l);
			f.forEach((b, C) => {
				(C === "length" || C === ARRAY_ITERATE_KEY || !isSymbol(C) && C >= y) && m(b)
			})
		} else switch ((a !== void 0 || f.has(void 0)) && m(f.get(a)), v && m(f.get(ARRAY_ITERATE_KEY)), s) {
			case "add":
				g ? v && m(f.get("length")) : (m(f.get(ITERATE_KEY)), isMap$1(o) && m(f.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "delete":
				g || (m(f.get(ITERATE_KEY)), isMap$1(o) && m(f.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "set":
				isMap$1(o) && m(f.get(ITERATE_KEY));
				break
		}
	}
	endBatch()
}

function getDepFromReactive(o, s) {
	const a = targetMap.get(o);
	return a && a.get(s)
}

function reactiveReadArray(o) {
	const s = toRaw(o);
	return s === o ? s : (track(s, "iterate", ARRAY_ITERATE_KEY), isShallow(o) ? s : s.map(toReactive))
}

function shallowReadArray(o) {
	return track(o = toRaw(o), "iterate", ARRAY_ITERATE_KEY), o
}
const arrayInstrumentations = {
	__proto__: null,
	[Symbol.iterator]() {
		return iterator(this, Symbol.iterator, toReactive)
	},
	concat(...o) {
		return reactiveReadArray(this).concat(...o.map(s => isArray$3(s) ? reactiveReadArray(s) : s))
	},
	entries() {
		return iterator(this, "entries", o => (o[1] = toReactive(o[1]), o))
	},
	every(o, s) {
		return apply(this, "every", o, s, void 0, arguments)
	},
	filter(o, s) {
		return apply(this, "filter", o, s, a => a.map(toReactive), arguments)
	},
	find(o, s) {
		return apply(this, "find", o, s, toReactive, arguments)
	},
	findIndex(o, s) {
		return apply(this, "findIndex", o, s, void 0, arguments)
	},
	findLast(o, s) {
		return apply(this, "findLast", o, s, toReactive, arguments)
	},
	findLastIndex(o, s) {
		return apply(this, "findLastIndex", o, s, void 0, arguments)
	},
	forEach(o, s) {
		return apply(this, "forEach", o, s, void 0, arguments)
	},
	includes(...o) {
		return searchProxy(this, "includes", o)
	},
	indexOf(...o) {
		return searchProxy(this, "indexOf", o)
	},
	join(o) {
		return reactiveReadArray(this).join(o)
	},
	lastIndexOf(...o) {
		return searchProxy(this, "lastIndexOf", o)
	},
	map(o, s) {
		return apply(this, "map", o, s, void 0, arguments)
	},
	pop() {
		return noTracking(this, "pop")
	},
	push(...o) {
		return noTracking(this, "push", o)
	},
	reduce(o, ...s) {
		return reduce(this, "reduce", o, s)
	},
	reduceRight(o, ...s) {
		return reduce(this, "reduceRight", o, s)
	},
	shift() {
		return noTracking(this, "shift")
	},
	some(o, s) {
		return apply(this, "some", o, s, void 0, arguments)
	},
	splice(...o) {
		return noTracking(this, "splice", o)
	},
	toReversed() {
		return reactiveReadArray(this).toReversed()
	},
	toSorted(o) {
		return reactiveReadArray(this).toSorted(o)
	},
	toSpliced(...o) {
		return reactiveReadArray(this).toSpliced(...o)
	},
	unshift(...o) {
		return noTracking(this, "unshift", o)
	},
	values() {
		return iterator(this, "values", toReactive)
	}
};

function iterator(o, s, a) {
	const l = shallowReadArray(o),
		c = l[s]();
	return l !== o && !isShallow(o) && (c._next = c.next, c.next = () => {
		const d = c._next();
		return d.value && (d.value = a(d.value)), d
	}), c
}
const arrayProto = Array.prototype;

function apply(o, s, a, l, c, d) {
	const f = shallowReadArray(o),
		m = f !== o && !isShallow(o),
		g = f[s];
	if (g !== arrayProto[s]) {
		const b = g.apply(o, d);
		return m ? toReactive(b) : b
	}
	let v = a;
	f !== o && (m ? v = function(b, C) {
		return a.call(this, toReactive(b), C, o)
	} : a.length > 2 && (v = function(b, C) {
		return a.call(this, b, C, o)
	}));
	const y = g.call(f, v, l);
	return m && c ? c(y) : y
}

function reduce(o, s, a, l) {
	const c = shallowReadArray(o);
	let d = a;
	return c !== o && (isShallow(o) ? a.length > 3 && (d = function(f, m, g) {
		return a.call(this, f, m, g, o)
	}) : d = function(f, m, g) {
		return a.call(this, f, toReactive(m), g, o)
	}), c[s](d, ...l)
}

function searchProxy(o, s, a) {
	const l = toRaw(o);
	track(l, "iterate", ARRAY_ITERATE_KEY);
	const c = l[s](...a);
	return (c === -1 || c === !1) && isProxy(a[0]) ? (a[0] = toRaw(a[0]), l[s](...a)) : c
}

function noTracking(o, s, a = []) {
	pauseTracking(), startBatch();
	const l = toRaw(o)[s].apply(o, a);
	return endBatch(), resetTracking(), l
}
const isNonTrackableKeys = makeMap("__proto__,__v_isRef,__isVue"),
	builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).filter(o => o !== "arguments" && o !== "caller").map(
		o => Symbol[o]).filter(isSymbol));

function hasOwnProperty$1(o) {
	isSymbol(o) || (o = String(o));
	const s = toRaw(this);
	return track(s, "has", o), s.hasOwnProperty(o)
}
class BaseReactiveHandler {
	constructor(s = !1, a = !1) {
		this._isReadonly = s, this._isShallow = a
	}
	get(s, a, l) {
		if (a === "__v_skip") return s.__v_skip;
		const c = this._isReadonly,
			d = this._isShallow;
		if (a === "__v_isReactive") return !c;
		if (a === "__v_isReadonly") return c;
		if (a === "__v_isShallow") return d;
		if (a === "__v_raw") return l === (c ? d ? shallowReadonlyMap : readonlyMap : d ? shallowReactiveMap :
			reactiveMap).get(s) || Object.getPrototypeOf(s) === Object.getPrototypeOf(l) ? s : void 0;
		const f = isArray$3(s);
		if (!c) {
			let g;
			if (f && (g = arrayInstrumentations[a])) return g;
			if (a === "hasOwnProperty") return hasOwnProperty$1
		}
		const m = Reflect.get(s, a, isRef(s) ? s : l);
		return (isSymbol(a) ? builtInSymbols.has(a) : isNonTrackableKeys(a)) || (c || track(s, "get", a), d) ? m :
			isRef(m) ? f && isIntegerKey(a) ? m : m.value : isObject$3(m) ? c ? readonly(m) : reactive(m) : m
	}
}
class MutableReactiveHandler extends BaseReactiveHandler {
	constructor(s = !1) {
		super(!1, s)
	}
	set(s, a, l, c) {
		let d = s[a];
		if (!this._isShallow) {
			const g = isReadonly(d);
			if (!isShallow(l) && !isReadonly(l) && (d = toRaw(d), l = toRaw(l)), !isArray$3(s) && isRef(d) && !
				isRef(l)) return g ? !1 : (d.value = l, !0)
		}
		const f = isArray$3(s) && isIntegerKey(a) ? Number(a) < s.length : hasOwn(s, a),
			m = Reflect.set(s, a, l, isRef(s) ? s : c);
		return s === toRaw(c) && (f ? hasChanged(l, d) && trigger(s, "set", a, l) : trigger(s, "add", a, l)), m
	}
	deleteProperty(s, a) {
		const l = hasOwn(s, a);
		s[a];
		const c = Reflect.deleteProperty(s, a);
		return c && l && trigger(s, "delete", a, void 0), c
	}
	has(s, a) {
		const l = Reflect.has(s, a);
		return (!isSymbol(a) || !builtInSymbols.has(a)) && track(s, "has", a), l
	}
	ownKeys(s) {
		return track(s, "iterate", isArray$3(s) ? "length" : ITERATE_KEY), Reflect.ownKeys(s)
	}
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
	constructor(s = !1) {
		super(!0, s)
	}
	set(s, a) {
		return !0
	}
	deleteProperty(s, a) {
		return !0
	}
}
const mutableHandlers = new MutableReactiveHandler,
	readonlyHandlers = new ReadonlyReactiveHandler,
	shallowReactiveHandlers = new MutableReactiveHandler(!0),
	shallowReadonlyHandlers = new ReadonlyReactiveHandler(!0),
	toShallow = o => o,
	getProto = o => Reflect.getPrototypeOf(o);

function createIterableMethod(o, s, a) {
	return function(...l) {
		const c = this.__v_raw,
			d = toRaw(c),
			f = isMap$1(d),
			m = o === "entries" || o === Symbol.iterator && f,
			g = o === "keys" && f,
			v = c[o](...l),
			y = a ? toShallow : s ? toReadonly : toReactive;
		return !s && track(d, "iterate", g ? MAP_KEY_ITERATE_KEY : ITERATE_KEY), {
			next() {
				const {
					value: b,
					done: C
				} = v.next();
				return C ? {
					value: b,
					done: C
				} : {
					value: m ? [y(b[0]), y(b[1])] : y(b),
					done: C
				}
			},
			[Symbol.iterator]() {
				return this
			}
		}
	}
}

function createReadonlyMethod(o) {
	return function(...s) {
		return o === "delete" ? !1 : o === "clear" ? void 0 : this
	}
}

function createInstrumentations(o, s) {
	const a = {
		get(c) {
			const d = this.__v_raw,
				f = toRaw(d),
				m = toRaw(c);
			o || (hasChanged(c, m) && track(f, "get", c), track(f, "get", m));
			const {
				has: g
			} = getProto(f), v = s ? toShallow : o ? toReadonly : toReactive;
			if (g.call(f, c)) return v(d.get(c));
			if (g.call(f, m)) return v(d.get(m));
			d !== f && d.get(c)
		},
		get size() {
			const c = this.__v_raw;
			return !o && track(toRaw(c), "iterate", ITERATE_KEY), Reflect.get(c, "size", c)
		},
		has(c) {
			const d = this.__v_raw,
				f = toRaw(d),
				m = toRaw(c);
			return o || (hasChanged(c, m) && track(f, "has", c), track(f, "has", m)), c === m ? d.has(c) : d.has(
				c) || d.has(m)
		},
		forEach(c, d) {
			const f = this,
				m = f.__v_raw,
				g = toRaw(m),
				v = s ? toShallow : o ? toReadonly : toReactive;
			return !o && track(g, "iterate", ITERATE_KEY), m.forEach((y, b) => c.call(d, v(y), v(b), f))
		}
	};
	return extend(a, o ? {
		add: createReadonlyMethod("add"),
		set: createReadonlyMethod("set"),
		delete: createReadonlyMethod("delete"),
		clear: createReadonlyMethod("clear")
	} : {
		add(c) {
			!s && !isShallow(c) && !isReadonly(c) && (c = toRaw(c));
			const d = toRaw(this);
			return getProto(d).has.call(d, c) || (d.add(c), trigger(d, "add", c, c)), this
		},
		set(c, d) {
			!s && !isShallow(d) && !isReadonly(d) && (d = toRaw(d));
			const f = toRaw(this),
				{
					has: m,
					get: g
				} = getProto(f);
			let v = m.call(f, c);
			v || (c = toRaw(c), v = m.call(f, c));
			const y = g.call(f, c);
			return f.set(c, d), v ? hasChanged(d, y) && trigger(f, "set", c, d) : trigger(f, "add", c, d),
				this
		},
		delete(c) {
			const d = toRaw(this),
				{
					has: f,
					get: m
				} = getProto(d);
			let g = f.call(d, c);
			g || (c = toRaw(c), g = f.call(d, c)), m && m.call(d, c);
			const v = d.delete(c);
			return g && trigger(d, "delete", c, void 0), v
		},
		clear() {
			const c = toRaw(this),
				d = c.size !== 0,
				f = c.clear();
			return d && trigger(c, "clear", void 0, void 0), f
		}
	}), ["keys", "values", "entries", Symbol.iterator].forEach(c => {
		a[c] = createIterableMethod(c, o, s)
	}), a
}

function createInstrumentationGetter(o, s) {
	const a = createInstrumentations(o, s);
	return (l, c, d) => c === "__v_isReactive" ? !o : c === "__v_isReadonly" ? o : c === "__v_raw" ? l : Reflect.get(
		hasOwn(a, c) && c in l ? a : l, c, d)
}
const mutableCollectionHandlers = {
		get: createInstrumentationGetter(!1, !1)
	},
	shallowCollectionHandlers = {
		get: createInstrumentationGetter(!1, !0)
	},
	readonlyCollectionHandlers = {
		get: createInstrumentationGetter(!0, !1)
	},
	shallowReadonlyCollectionHandlers = {
		get: createInstrumentationGetter(!0, !0)
	},
	reactiveMap = new WeakMap,
	shallowReactiveMap = new WeakMap,
	readonlyMap = new WeakMap,
	shallowReadonlyMap = new WeakMap;

function targetTypeMap(o) {
	switch (o) {
		case "Object":
		case "Array":
			return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet":
			return 2;
		default:
			return 0
	}
}

function getTargetType(o) {
	return o.__v_skip || !Object.isExtensible(o) ? 0 : targetTypeMap(toRawType(o))
}

function reactive(o) {
	return isReadonly(o) ? o : createReactiveObject(o, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap)
}

function shallowReactive(o) {
	return createReactiveObject(o, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap)
}

function readonly(o) {
	return createReactiveObject(o, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap)
}

function shallowReadonly(o) {
	return createReactiveObject(o, !0, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap)
}

function createReactiveObject(o, s, a, l, c) {
	if (!isObject$3(o) || o.__v_raw && !(s && o.__v_isReactive)) return o;
	const d = c.get(o);
	if (d) return d;
	const f = getTargetType(o);
	if (f === 0) return o;
	const m = new Proxy(o, f === 2 ? l : a);
	return c.set(o, m), m
}

function isReactive(o) {
	return isReadonly(o) ? isReactive(o.__v_raw) : !!(o && o.__v_isReactive)
}

function isReadonly(o) {
	return !!(o && o.__v_isReadonly)
}

function isShallow(o) {
	return !!(o && o.__v_isShallow)
}

function isProxy(o) {
	return o ? !!o.__v_raw : !1
}

function toRaw(o) {
	const s = o && o.__v_raw;
	return s ? toRaw(s) : o
}

function markRaw(o) {
	return !hasOwn(o, "__v_skip") && Object.isExtensible(o) && def(o, "__v_skip", !0), o
}
const toReactive = o => isObject$3(o) ? reactive(o) : o,
	toReadonly = o => isObject$3(o) ? readonly(o) : o;

function isRef(o) {
	return o ? o.__v_isRef === !0 : !1
}

function ref(o) {
	return createRef(o, !1)
}

function shallowRef(o) {
	return createRef(o, !0)
}

function createRef(o, s) {
	return isRef(o) ? o : new RefImpl(o, s)
}
class RefImpl {
	constructor(s, a) {
		this.dep = new Dep, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = a ? s : toRaw(s), this
			._value = a ? s : toReactive(s), this.__v_isShallow = a
	}
	get value() {
		return this.dep.track(), this._value
	}
	set value(s) {
		const a = this._rawValue,
			l = this.__v_isShallow || isShallow(s) || isReadonly(s);
		s = l ? s : toRaw(s), hasChanged(s, a) && (this._rawValue = s, this._value = l ? s : toReactive(s), this.dep
			.trigger())
	}
}

function unref(o) {
	return isRef(o) ? o.value : o
}

function toValue(o) {
	return isFunction$3(o) ? o() : unref(o)
}
const shallowUnwrapHandlers = {
	get: (o, s, a) => s === "__v_raw" ? o : unref(Reflect.get(o, s, a)),
	set: (o, s, a, l) => {
		const c = o[s];
		return isRef(c) && !isRef(a) ? (c.value = a, !0) : Reflect.set(o, s, a, l)
	}
};

function proxyRefs(o) {
	return isReactive(o) ? o : new Proxy(o, shallowUnwrapHandlers)
}

function toRefs(o) {
	const s = isArray$3(o) ? new Array(o.length) : {};
	for (const a in o) s[a] = propertyToRef(o, a);
	return s
}
class ObjectRefImpl {
	constructor(s, a, l) {
		this._object = s, this._key = a, this._defaultValue = l, this.__v_isRef = !0, this._value = void 0
	}
	get value() {
		const s = this._object[this._key];
		return this._value = s === void 0 ? this._defaultValue : s
	}
	set value(s) {
		this._object[this._key] = s
	}
	get dep() {
		return getDepFromReactive(toRaw(this._object), this._key)
	}
}
class GetterRefImpl {
	constructor(s) {
		this._getter = s, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0
	}
	get value() {
		return this._value = this._getter()
	}
}

function toRef(o, s, a) {
	return isRef(o) ? o : isFunction$3(o) ? new GetterRefImpl(o) : isObject$3(o) && arguments.length > 1 ?
		propertyToRef(o, s, a) : ref(o)
}

function propertyToRef(o, s, a) {
	const l = o[s];
	return isRef(l) ? l : new ObjectRefImpl(o, s, a)
}
class ComputedRefImpl {
	constructor(s, a, l) {
		this.fn = s, this.setter = a, this._value = void 0, this.dep = new Dep(this), this.__v_isRef = !0, this
			.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = globalVersion - 1, this
			.next = void 0, this.effect = this, this.__v_isReadonly = !a, this.isSSR = l
	}
	notify() {
		if (this.flags |= 16, !(this.flags & 8) && activeSub !== this) return batch(this, !0), !0
	}
	get value() {
		const s = this.dep.track();
		return refreshComputed(this), s && (s.version = this.dep.version), this._value
	}
	set value(s) {
		this.setter && this.setter(s)
	}
}

function computed$1(o, s, a = !1) {
	let l, c;
	return isFunction$3(o) ? l = o : (l = o.get, c = o.set), new ComputedRefImpl(l, c, a)
}
const INITIAL_WATCHER_VALUE = {},
	cleanupMap = new WeakMap;
let activeWatcher;

function onWatcherCleanup(o, s = !1, a = activeWatcher) {
	if (a) {
		let l = cleanupMap.get(a);
		l || cleanupMap.set(a, l = []), l.push(o)
	}
}

function watch$1(o, s, a = EMPTY_OBJ) {
	const {
		immediate: l,
		deep: c,
		once: d,
		scheduler: f,
		augmentJob: m,
		call: g
	} = a, v = D => c ? D : isShallow(D) || c === !1 || c === 0 ? traverse(D, 1) : traverse(D);
	let y, b, C, _, S = !1,
		w = !1;
	if (isRef(o) ? (b = () => o.value, S = isShallow(o)) : isReactive(o) ? (b = () => v(o), S = !0) : isArray$3(o) ? (
			w = !0, S = o.some(D => isReactive(D) || isShallow(D)), b = () => o.map(D => {
				if (isRef(D)) return D.value;
				if (isReactive(D)) return v(D);
				if (isFunction$3(D)) return g ? g(D, 2) : D()
			})) : isFunction$3(o) ? s ? b = g ? () => g(o, 2) : o : b = () => {
			if (C) {
				pauseTracking();
				try {
					C()
				} finally {
					resetTracking()
				}
			}
			const D = activeWatcher;
			activeWatcher = y;
			try {
				return g ? g(o, 3, [_]) : o(_)
			} finally {
				activeWatcher = D
			}
		} : b = NOOP$1, s && c) {
		const D = b,
			F = c === !0 ? 1 / 0 : c;
		b = () => traverse(D(), F)
	}
	const T = getCurrentScope(),
		A = () => {
			y.stop(), T && T.active && remove(T.effects, y)
		};
	if (d && s) {
		const D = s;
		s = (...F) => {
			D(...F), A()
		}
	}
	let k = w ? new Array(o.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
	const M = D => {
		if (!(!(y.flags & 1) || !y.dirty && !D))
			if (s) {
				const F = y.run();
				if (c || S || (w ? F.some((R, O) => hasChanged(R, k[O])) : hasChanged(F, k))) {
					C && C();
					const R = activeWatcher;
					activeWatcher = y;
					try {
						const O = [F, k === INITIAL_WATCHER_VALUE ? void 0 : w && k[0] === INITIAL_WATCHER_VALUE ?
						[] : k, _];
						g ? g(s, 3, O) : s(...O), k = F
					} finally {
						activeWatcher = R
					}
				}
			} else y.run()
	};
	return m && m(M), y = new ReactiveEffect(b), y.scheduler = f ? () => f(M, !1) : M, _ = D => onWatcherCleanup(D, !1,
			y), C = y.onStop = () => {
			const D = cleanupMap.get(y);
			if (D) {
				if (g) g(D, 4);
				else
					for (const F of D) F();
				cleanupMap.delete(y)
			}
		}, s ? l ? M(!0) : k = y.run() : f ? f(M.bind(null, !0), !0) : y.run(), A.pause = y.pause.bind(y), A.resume = y
		.resume.bind(y), A.stop = A, A
}

function traverse(o, s = 1 / 0, a) {
	if (s <= 0 || !isObject$3(o) || o.__v_skip || (a = a || new Set, a.has(o))) return o;
	if (a.add(o), s--, isRef(o)) traverse(o.value, s, a);
	else if (isArray$3(o))
		for (let l = 0; l < o.length; l++) traverse(o[l], s, a);
	else if (isSet(o) || isMap$1(o)) o.forEach(l => {
		traverse(l, s, a)
	});
	else if (isPlainObject$1(o)) {
		for (const l in o) traverse(o[l], s, a);
		for (const l of Object.getOwnPropertySymbols(o)) Object.prototype.propertyIsEnumerable.call(o, l) && traverse(o[
			l], s, a)
	}
	return o
}
/**
 * @vue/runtime-core v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const stack = [];
let isWarning = !1;

function warn$1(o, ...s) {
	if (isWarning) return;
	isWarning = !0, pauseTracking();
	const a = stack.length ? stack[stack.length - 1].component : null,
		l = a && a.appContext.config.warnHandler,
		c = getComponentTrace();
	if (l) callWithErrorHandling(l, a, 11, [o + s.map(d => {
		var f, m;
		return (m = (f = d.toString) == null ? void 0 : f.call(d)) != null ? m : JSON.stringify(d)
	}).join(""), a && a.proxy, c.map(({
		vnode: d
	}) => `at <${formatComponentName(a,d.type)}>`).join(`
`), c]);
	else {
		const d = [`[Vue warn]: ${o}`, ...s];
		c.length && d.push(`
`, ...formatTrace(c)), console.warn(...d)
	}
	resetTracking(), isWarning = !1
}

function getComponentTrace() {
	let o = stack[stack.length - 1];
	if (!o) return [];
	const s = [];
	for (; o;) {
		const a = s[0];
		a && a.vnode === o ? a.recurseCount++ : s.push({
			vnode: o,
			recurseCount: 0
		});
		const l = o.component && o.component.parent;
		o = l && l.vnode
	}
	return s
}

function formatTrace(o) {
	const s = [];
	return o.forEach((a, l) => {
		s.push(...l === 0 ? [] : [`
`], ...formatTraceEntry(a))
	}), s
}

function formatTraceEntry({
	vnode: o,
	recurseCount: s
}) {
	const a = s > 0 ? `... (${s} recursive calls)` : "",
		l = o.component ? o.component.parent == null : !1,
		c = ` at <${formatComponentName(o.component,o.type,l)}`,
		d = ">" + a;
	return o.props ? [c, ...formatProps(o.props), d] : [c + d]
}

function formatProps(o) {
	const s = [],
		a = Object.keys(o);
	return a.slice(0, 3).forEach(l => {
		s.push(...formatProp(l, o[l]))
	}), a.length > 3 && s.push(" ..."), s
}

function formatProp(o, s, a) {
	return isString$3(s) ? (s = JSON.stringify(s), a ? s : [`${o}=${s}`]) : typeof s == "number" || typeof s ==
		"boolean" || s == null ? a ? s : [`${o}=${s}`] : isRef(s) ? (s = formatProp(o, toRaw(s.value), !0), a ? s : [
			`${o}=Ref<`, s, ">"
		]) : isFunction$3(s) ? [`${o}=fn${s.name?`<${s.name}>`:""}`] : (s = toRaw(s), a ? s : [`${o}=`, s])
}

function callWithErrorHandling(o, s, a, l) {
	try {
		return l ? o(...l) : o()
	} catch (c) {
		handleError(c, s, a)
	}
}

function callWithAsyncErrorHandling(o, s, a, l) {
	if (isFunction$3(o)) {
		const c = callWithErrorHandling(o, s, a, l);
		return c && isPromise$1(c) && c.catch(d => {
			handleError(d, s, a)
		}), c
	}
	if (isArray$3(o)) {
		const c = [];
		for (let d = 0; d < o.length; d++) c.push(callWithAsyncErrorHandling(o[d], s, a, l));
		return c
	}
}

function handleError(o, s, a, l = !0) {
	const c = s ? s.vnode : null,
		{
			errorHandler: d,
			throwUnhandledErrorInProduction: f
		} = s && s.appContext.config || EMPTY_OBJ;
	if (s) {
		let m = s.parent;
		const g = s.proxy,
			v = `https://vuejs.org/error-reference/#runtime-${a}`;
		for (; m;) {
			const y = m.ec;
			if (y) {
				for (let b = 0; b < y.length; b++)
					if (y[b](o, g, v) === !1) return
			}
			m = m.parent
		}
		if (d) {
			pauseTracking(), callWithErrorHandling(d, null, 10, [o, g, v]), resetTracking();
			return
		}
	}
	logError(o, a, c, l, f)
}

function logError(o, s, a, l = !0, c = !1) {
	if (c) throw o;
	console.error(o)
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null,
	postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;

function nextTick(o) {
	const s = currentFlushPromise || resolvedPromise;
	return o ? s.then(this ? o.bind(this) : o) : s
}

function findInsertionIndex(o) {
	let s = flushIndex + 1,
		a = queue.length;
	for (; s < a;) {
		const l = s + a >>> 1,
			c = queue[l],
			d = getId(c);
		d < o || d === o && c.flags & 2 ? s = l + 1 : a = l
	}
	return s
}

function queueJob(o) {
	if (!(o.flags & 1)) {
		const s = getId(o),
			a = queue[queue.length - 1];
		!a || !(o.flags & 2) && s >= getId(a) ? queue.push(o) : queue.splice(findInsertionIndex(s), 0, o), o.flags |= 1,
			queueFlush()
	}
}

function queueFlush() {
	currentFlushPromise || (currentFlushPromise = resolvedPromise.then(flushJobs))
}

function queuePostFlushCb(o) {
	isArray$3(o) ? pendingPostFlushCbs.push(...o) : activePostFlushCbs && o.id === -1 ? activePostFlushCbs.splice(
		postFlushIndex + 1, 0, o) : o.flags & 1 || (pendingPostFlushCbs.push(o), o.flags |= 1), queueFlush()
}

function flushPreFlushCbs(o, s, a = flushIndex + 1) {
	for (; a < queue.length; a++) {
		const l = queue[a];
		if (l && l.flags & 2) {
			if (o && l.id !== o.uid) continue;
			queue.splice(a, 1), a--, l.flags & 4 && (l.flags &= -2), l(), l.flags & 4 || (l.flags &= -2)
		}
	}
}

function flushPostFlushCbs(o) {
	if (pendingPostFlushCbs.length) {
		const s = [...new Set(pendingPostFlushCbs)].sort((a, l) => getId(a) - getId(l));
		if (pendingPostFlushCbs.length = 0, activePostFlushCbs) {
			activePostFlushCbs.push(...s);
			return
		}
		for (activePostFlushCbs = s, postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
			const a = activePostFlushCbs[postFlushIndex];
			a.flags & 4 && (a.flags &= -2), a.flags & 8 || a(), a.flags &= -2
		}
		activePostFlushCbs = null, postFlushIndex = 0
	}
}
const getId = o => o.id == null ? o.flags & 2 ? -1 : 1 / 0 : o.id;

function flushJobs(o) {
	try {
		for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
			const s = queue[flushIndex];
			s && !(s.flags & 8) && (s.flags & 4 && (s.flags &= -2), callWithErrorHandling(s, s.i, s.i ? 15 : 14), s
				.flags & 4 || (s.flags &= -2))
		}
	} finally {
		for (; flushIndex < queue.length; flushIndex++) {
			const s = queue[flushIndex];
			s && (s.flags &= -2)
		}
		flushIndex = -1, queue.length = 0, flushPostFlushCbs(), currentFlushPromise = null, (queue.length ||
			pendingPostFlushCbs.length) && flushJobs()
	}
}
let currentRenderingInstance = null,
	currentScopeId = null;

function setCurrentRenderingInstance(o) {
	const s = currentRenderingInstance;
	return currentRenderingInstance = o, currentScopeId = o && o.type.__scopeId || null, s
}

function withCtx(o, s = currentRenderingInstance, a) {
	if (!s || o._n) return o;
	const l = (...c) => {
		l._d && setBlockTracking(-1);
		const d = setCurrentRenderingInstance(s);
		let f;
		try {
			f = o(...c)
		} finally {
			setCurrentRenderingInstance(d), l._d && setBlockTracking(1)
		}
		return f
	};
	return l._n = !0, l._c = !0, l._d = !0, l
}

function withDirectives(o, s) {
	if (currentRenderingInstance === null) return o;
	const a = getComponentPublicInstance(currentRenderingInstance),
		l = o.dirs || (o.dirs = []);
	for (let c = 0; c < s.length; c++) {
		let [d, f, m, g = EMPTY_OBJ] = s[c];
		d && (isFunction$3(d) && (d = {
			mounted: d,
			updated: d
		}), d.deep && traverse(f), l.push({
			dir: d,
			instance: a,
			value: f,
			oldValue: void 0,
			arg: m,
			modifiers: g
		}))
	}
	return o
}

function invokeDirectiveHook(o, s, a, l) {
	const c = o.dirs,
		d = s && s.dirs;
	for (let f = 0; f < c.length; f++) {
		const m = c[f];
		d && (m.oldValue = d[f].value);
		let g = m.dir[l];
		g && (pauseTracking(), callWithAsyncErrorHandling(g, a, 8, [o.el, m, o, s]), resetTracking())
	}
}
const TeleportEndKey = Symbol("_vte"),
	isTeleport = o => o.__isTeleport,
	isTeleportDisabled = o => o && (o.disabled || o.disabled === ""),
	isTeleportDeferred = o => o && (o.defer || o.defer === ""),
	isTargetSVG = o => typeof SVGElement < "u" && o instanceof SVGElement,
	isTargetMathML = o => typeof MathMLElement == "function" && o instanceof MathMLElement,
	resolveTarget = (o, s) => {
		const a = o && o.to;
		return isString$3(a) ? s ? s(a) : null : a
	},
	TeleportImpl = {
		name: "Teleport",
		__isTeleport: !0,
		process(o, s, a, l, c, d, f, m, g, v) {
			const {
				mc: y,
				pc: b,
				pbc: C,
				o: {
					insert: _,
					querySelector: S,
					createText: w,
					createComment: T
				}
			} = v, A = isTeleportDisabled(s.props);
			let {
				shapeFlag: k,
				children: M,
				dynamicChildren: D
			} = s;
			if (o == null) {
				const F = s.el = w(""),
					R = s.anchor = w("");
				_(F, a, l), _(R, a, l);
				const O = (V, z) => {
						k & 16 && (c && c.isCE && (c.ce._teleportTarget = V), y(M, V, z, c, d, f, m, g))
					},
					U = () => {
						const V = s.target = resolveTarget(s.props, S),
							z = prepareAnchor(V, s, w, _);
						V && (f !== "svg" && isTargetSVG(V) ? f = "svg" : f !== "mathml" && isTargetMathML(V) && (f =
							"mathml"), A || (O(V, z), updateCssVars(s, !1)))
					};
				A && (O(a, R), updateCssVars(s, !0)), isTeleportDeferred(s.props) ? queuePostRenderEffect(() => {
					U(), s.el.__isMounted = !0
				}, d) : U()
			} else {
				if (isTeleportDeferred(s.props) && !o.el.__isMounted) {
					queuePostRenderEffect(() => {
						TeleportImpl.process(o, s, a, l, c, d, f, m, g, v), delete o.el.__isMounted
					}, d);
					return
				}
				s.el = o.el, s.targetStart = o.targetStart;
				const F = s.anchor = o.anchor,
					R = s.target = o.target,
					O = s.targetAnchor = o.targetAnchor,
					U = isTeleportDisabled(o.props),
					V = U ? a : R,
					z = U ? F : O;
				if (f === "svg" || isTargetSVG(R) ? f = "svg" : (f === "mathml" || isTargetMathML(R)) && (f = "mathml"),
					D ? (C(o.dynamicChildren, D, V, c, d, f, m), traverseStaticChildren(o, s, !0)) : g || b(o, s, V, z,
						c, d, f, m, !1), A) U ? s.props && o.props && s.props.to !== o.props.to && (s.props.to = o.props
					.to) : moveTeleport(s, a, F, v, 1);
				else if ((s.props && s.props.to) !== (o.props && o.props.to)) {
					const j = s.target = resolveTarget(s.props, S);
					j && moveTeleport(s, j, null, v, 0)
				} else U && moveTeleport(s, R, O, v, 1);
				updateCssVars(s, A)
			}
		},
		remove(o, s, a, {
			um: l,
			o: {
				remove: c
			}
		}, d) {
			const {
				shapeFlag: f,
				children: m,
				anchor: g,
				targetStart: v,
				targetAnchor: y,
				target: b,
				props: C
			} = o;
			if (b && (c(v), c(y)), d && c(g), f & 16) {
				const _ = d || !isTeleportDisabled(C);
				for (let S = 0; S < m.length; S++) {
					const w = m[S];
					l(w, s, a, _, !!w.dynamicChildren)
				}
			}
		},
		move: moveTeleport,
		hydrate: hydrateTeleport
	};

function moveTeleport(o, s, a, {
	o: {
		insert: l
	},
	m: c
}, d = 2) {
	d === 0 && l(o.targetAnchor, s, a);
	const {
		el: f,
		anchor: m,
		shapeFlag: g,
		children: v,
		props: y
	} = o, b = d === 2;
	if (b && l(f, s, a), (!b || isTeleportDisabled(y)) && g & 16)
		for (let C = 0; C < v.length; C++) c(v[C], s, a, 2);
	b && l(m, s, a)
}

function hydrateTeleport(o, s, a, l, c, d, {
	o: {
		nextSibling: f,
		parentNode: m,
		querySelector: g,
		insert: v,
		createText: y
	}
}, b) {
	const C = s.target = resolveTarget(s.props, g);
	if (C) {
		const _ = isTeleportDisabled(s.props),
			S = C._lpa || C.firstChild;
		if (s.shapeFlag & 16)
			if (_) s.anchor = b(f(o), s, m(o), a, l, c, d), s.targetStart = S, s.targetAnchor = S && f(S);
			else {
				s.anchor = f(o);
				let w = S;
				for (; w;) {
					if (w && w.nodeType === 8) {
						if (w.data === "teleport start anchor") s.targetStart = w;
						else if (w.data === "teleport anchor") {
							s.targetAnchor = w, C._lpa = s.targetAnchor && f(s.targetAnchor);
							break
						}
					}
					w = f(w)
				}
				s.targetAnchor || prepareAnchor(C, s, y, v), b(S && f(S), s, C, a, l, c, d)
			} updateCssVars(s, _)
	}
	return s.anchor && f(s.anchor)
}
const Teleport = TeleportImpl;

function updateCssVars(o, s) {
	const a = o.ctx;
	if (a && a.ut) {
		let l, c;
		for (s ? (l = o.el, c = o.anchor) : (l = o.targetStart, c = o.targetAnchor); l && l !== c;) l.nodeType === 1 &&
			l.setAttribute("data-v-owner", a.uid), l = l.nextSibling;
		a.ut()
	}
}

function prepareAnchor(o, s, a, l) {
	const c = s.targetStart = a(""),
		d = s.targetAnchor = a("");
	return c[TeleportEndKey] = d, o && (l(c, o), l(d, o)), d
}
const leaveCbKey = Symbol("_leaveCb"),
	enterCbKey$1 = Symbol("_enterCb");

function useTransitionState() {
	const o = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: new Map
	};
	return onMounted(() => {
		o.isMounted = !0
	}), onBeforeUnmount(() => {
		o.isUnmounting = !0
	}), o
}
const TransitionHookValidator = [Function, Array],
	BaseTransitionPropsValidators = {
		mode: String,
		appear: Boolean,
		persisted: Boolean,
		onBeforeEnter: TransitionHookValidator,
		onEnter: TransitionHookValidator,
		onAfterEnter: TransitionHookValidator,
		onEnterCancelled: TransitionHookValidator,
		onBeforeLeave: TransitionHookValidator,
		onLeave: TransitionHookValidator,
		onAfterLeave: TransitionHookValidator,
		onLeaveCancelled: TransitionHookValidator,
		onBeforeAppear: TransitionHookValidator,
		onAppear: TransitionHookValidator,
		onAfterAppear: TransitionHookValidator,
		onAppearCancelled: TransitionHookValidator
	},
	recursiveGetSubtree = o => {
		const s = o.subTree;
		return s.component ? recursiveGetSubtree(s.component) : s
	},
	BaseTransitionImpl = {
		name: "BaseTransition",
		props: BaseTransitionPropsValidators,
		setup(o, {
			slots: s
		}) {
			const a = getCurrentInstance(),
				l = useTransitionState();
			return () => {
				const c = s.default && getTransitionRawChildren(s.default(), !0);
				if (!c || !c.length) return;
				const d = findNonCommentChild(c),
					f = toRaw(o),
					{
						mode: m
					} = f;
				if (l.isLeaving) return emptyPlaceholder(d);
				const g = getInnerChild$1(d);
				if (!g) return emptyPlaceholder(d);
				let v = resolveTransitionHooks(g, f, l, a, b => v = b);
				g.type !== Comment$1 && setTransitionHooks(g, v);
				let y = a.subTree && getInnerChild$1(a.subTree);
				if (y && y.type !== Comment$1 && !isSameVNodeType(g, y) && recursiveGetSubtree(a).type !==
					Comment$1) {
					let b = resolveTransitionHooks(y, f, l, a);
					if (setTransitionHooks(y, b), m === "out-in" && g.type !== Comment$1) return l.isLeaving = !0, b
						.afterLeave = () => {
							l.isLeaving = !1, a.job.flags & 8 || a.update(), delete b.afterLeave, y = void 0
						}, emptyPlaceholder(d);
					m === "in-out" && g.type !== Comment$1 ? b.delayLeave = (C, _, S) => {
						const w = getLeavingNodesForType(l, y);
						w[String(y.key)] = y, C[leaveCbKey] = () => {
							_(), C[leaveCbKey] = void 0, delete v.delayedLeave, y = void 0
						}, v.delayedLeave = () => {
							S(), delete v.delayedLeave, y = void 0
						}
					} : y = void 0
				} else y && (y = void 0);
				return d
			}
		}
	};

function findNonCommentChild(o) {
	let s = o[0];
	if (o.length > 1) {
		for (const a of o)
			if (a.type !== Comment$1) {
				s = a;
				break
			}
	}
	return s
}
const BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(o, s) {
	const {
		leavingVNodes: a
	} = o;
	let l = a.get(s.type);
	return l || (l = Object.create(null), a.set(s.type, l)), l
}

function resolveTransitionHooks(o, s, a, l, c) {
	const {
		appear: d,
		mode: f,
		persisted: m = !1,
		onBeforeEnter: g,
		onEnter: v,
		onAfterEnter: y,
		onEnterCancelled: b,
		onBeforeLeave: C,
		onLeave: _,
		onAfterLeave: S,
		onLeaveCancelled: w,
		onBeforeAppear: T,
		onAppear: A,
		onAfterAppear: k,
		onAppearCancelled: M
	} = s, D = String(o.key), F = getLeavingNodesForType(a, o), R = (V, z) => {
		V && callWithAsyncErrorHandling(V, l, 9, z)
	}, O = (V, z) => {
		const j = z[1];
		R(V, z), isArray$3(V) ? V.every(ge => ge.length <= 1) && j() : V.length <= 1 && j()
	}, U = {
		mode: f,
		persisted: m,
		beforeEnter(V) {
			let z = g;
			if (!a.isMounted)
				if (d) z = T || g;
				else return;
			V[leaveCbKey] && V[leaveCbKey](!0);
			const j = F[D];
			j && isSameVNodeType(o, j) && j.el[leaveCbKey] && j.el[leaveCbKey](), R(z, [V])
		},
		enter(V) {
			let z = v,
				j = y,
				ge = b;
			if (!a.isMounted)
				if (d) z = A || v, j = k || y, ge = M || b;
				else return;
			let me = !1;
			const he = V[enterCbKey$1] = ce => {
				me || (me = !0, ce ? R(ge, [V]) : R(j, [V]), U.delayedLeave && U.delayedLeave(), V[
					enterCbKey$1] = void 0)
			};
			z ? O(z, [V, he]) : he()
		},
		leave(V, z) {
			const j = String(o.key);
			if (V[enterCbKey$1] && V[enterCbKey$1](!0), a.isUnmounting) return z();
			R(C, [V]);
			let ge = !1;
			const me = V[leaveCbKey] = he => {
				ge || (ge = !0, z(), he ? R(w, [V]) : R(S, [V]), V[leaveCbKey] = void 0, F[j] === o && delete F[
					j])
			};
			F[j] = o, _ ? O(_, [V, me]) : me()
		},
		clone(V) {
			const z = resolveTransitionHooks(V, s, a, l, c);
			return c && c(z), z
		}
	};
	return U
}

function emptyPlaceholder(o) {
	if (isKeepAlive(o)) return o = cloneVNode(o), o.children = null, o
}

function getInnerChild$1(o) {
	if (!isKeepAlive(o)) return isTeleport(o.type) && o.children ? findNonCommentChild(o.children) : o;
	const {
		shapeFlag: s,
		children: a
	} = o;
	if (a) {
		if (s & 16) return a[0];
		if (s & 32 && isFunction$3(a.default)) return a.default()
	}
}

function setTransitionHooks(o, s) {
	o.shapeFlag & 6 && o.component ? (o.transition = s, setTransitionHooks(o.component.subTree, s)) : o.shapeFlag &
		128 ? (o.ssContent.transition = s.clone(o.ssContent), o.ssFallback.transition = s.clone(o.ssFallback)) : o
		.transition = s
}

function getTransitionRawChildren(o, s = !1, a) {
	let l = [],
		c = 0;
	for (let d = 0; d < o.length; d++) {
		let f = o[d];
		const m = a == null ? f.key : String(a) + String(f.key != null ? f.key : d);
		f.type === Fragment ? (f.patchFlag & 128 && c++, l = l.concat(getTransitionRawChildren(f.children, s, m))) : (
			s || f.type !== Comment$1) && l.push(m != null ? cloneVNode(f, {
			key: m
		}) : f)
	}
	if (c > 1)
		for (let d = 0; d < l.length; d++) l[d].patchFlag = -2;
	return l
} /*! #__NO_SIDE_EFFECTS__ */
function defineComponent(o, s) {
	return isFunction$3(o) ? extend({
		name: o.name
	}, s, {
		setup: o
	}) : o
}

function markAsyncBoundary(o) {
	o.ids = [o.ids[0] + o.ids[2]++ + "-", 0, 0]
}

function setRef(o, s, a, l, c = !1) {
	if (isArray$3(o)) {
		o.forEach((S, w) => setRef(S, s && (isArray$3(s) ? s[w] : s), a, l, c));
		return
	}
	if (isAsyncWrapper(l) && !c) {
		l.shapeFlag & 512 && l.type.__asyncResolved && l.component.subTree.component && setRef(o, s, a, l.component
			.subTree);
		return
	}
	const d = l.shapeFlag & 4 ? getComponentPublicInstance(l.component) : l.el,
		f = c ? null : d,
		{
			i: m,
			r: g
		} = o,
		v = s && s.r,
		y = m.refs === EMPTY_OBJ ? m.refs = {} : m.refs,
		b = m.setupState,
		C = toRaw(b),
		_ = b === EMPTY_OBJ ? () => !1 : S => hasOwn(C, S);
	if (v != null && v !== g && (isString$3(v) ? (y[v] = null, _(v) && (b[v] = null)) : isRef(v) && (v.value = null)),
		isFunction$3(g)) callWithErrorHandling(g, m, 12, [f, y]);
	else {
		const S = isString$3(g),
			w = isRef(g);
		if (S || w) {
			const T = () => {
				if (o.f) {
					const A = S ? _(g) ? b[g] : y[g] : g.value;
					c ? isArray$3(A) && remove(A, d) : isArray$3(A) ? A.includes(d) || A.push(d) : S ? (y[g] = [d],
						_(g) && (b[g] = y[g])) : (g.value = [d], o.k && (y[o.k] = g.value))
				} else S ? (y[g] = f, _(g) && (b[g] = f)) : w && (g.value = f, o.k && (y[o.k] = f))
			};
			f ? (T.id = -1, queuePostRenderEffect(T, a)) : T()
		}
	}
}
getGlobalThis().requestIdleCallback;
getGlobalThis().cancelIdleCallback;
const isAsyncWrapper = o => !!o.type.__asyncLoader,
	isKeepAlive = o => o.type.__isKeepAlive;

function onActivated(o, s) {
	registerKeepAliveHook(o, "a", s)
}

function onDeactivated(o, s) {
	registerKeepAliveHook(o, "da", s)
}

function registerKeepAliveHook(o, s, a = currentInstance) {
	const l = o.__wdc || (o.__wdc = () => {
		let c = a;
		for (; c;) {
			if (c.isDeactivated) return;
			c = c.parent
		}
		return o()
	});
	if (injectHook(s, l, a), a) {
		let c = a.parent;
		for (; c && c.parent;) isKeepAlive(c.parent.vnode) && injectToKeepAliveRoot(l, s, a, c), c = c.parent
	}
}

function injectToKeepAliveRoot(o, s, a, l) {
	const c = injectHook(s, o, l, !0);
	onUnmounted(() => {
		remove(l[s], c)
	}, a)
}

function injectHook(o, s, a = currentInstance, l = !1) {
	if (a) {
		const c = a[o] || (a[o] = []),
			d = s.__weh || (s.__weh = (...f) => {
				pauseTracking();
				const m = setCurrentInstance(a),
					g = callWithAsyncErrorHandling(s, a, o, f);
				return m(), resetTracking(), g
			});
		return l ? c.unshift(d) : c.push(d), d
	}
}
const createHook = o => (s, a = currentInstance) => {
		(!isInSSRComponentSetup || o === "sp") && injectHook(o, (...l) => s(...l), a)
	},
	onBeforeMount = createHook("bm"),
	onMounted = createHook("m"),
	onBeforeUpdate = createHook("bu"),
	onUpdated = createHook("u"),
	onBeforeUnmount = createHook("bum"),
	onUnmounted = createHook("um"),
	onServerPrefetch = createHook("sp"),
	onRenderTriggered = createHook("rtg"),
	onRenderTracked = createHook("rtc");

function onErrorCaptured(o, s = currentInstance) {
	injectHook("ec", o, s)
}
const COMPONENTS = "components";

function resolveComponent(o, s) {
	return resolveAsset(COMPONENTS, o, !0, s) || o
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");

function resolveDynamicComponent(o) {
	return isString$3(o) ? resolveAsset(COMPONENTS, o, !1) || o : o || NULL_DYNAMIC_COMPONENT
}

function resolveAsset(o, s, a = !0, l = !1) {
	const c = currentRenderingInstance || currentInstance;
	if (c) {
		const d = c.type; {
			const m = getComponentName(d, !1);
			if (m && (m === s || m === camelize(s) || m === capitalize(camelize(s)))) return d
		}
		const f = resolve(c[o] || d[o], s) || resolve(c.appContext[o], s);
		return !f && l ? d : f
	}
}

function resolve(o, s) {
	return o && (o[s] || o[camelize(s)] || o[capitalize(camelize(s))])
}

function renderList(o, s, a, l) {
	let c;
	const d = a,
		f = isArray$3(o);
	if (f || isString$3(o)) {
		const m = f && isReactive(o);
		let g = !1;
		m && (g = !isShallow(o), o = shallowReadArray(o)), c = new Array(o.length);
		for (let v = 0, y = o.length; v < y; v++) c[v] = s(g ? toReactive(o[v]) : o[v], v, void 0, d)
	} else if (typeof o == "number") {
		c = new Array(o);
		for (let m = 0; m < o; m++) c[m] = s(m + 1, m, void 0, d)
	} else if (isObject$3(o))
		if (o[Symbol.iterator]) c = Array.from(o, (m, g) => s(m, g, void 0, d));
		else {
			const m = Object.keys(o);
			c = new Array(m.length);
			for (let g = 0, v = m.length; g < v; g++) {
				const y = m[g];
				c[g] = s(o[y], y, g, d)
			}
		}
	else c = [];
	return c
}

function createSlots(o, s) {
	for (let a = 0; a < s.length; a++) {
		const l = s[a];
		if (isArray$3(l))
			for (let c = 0; c < l.length; c++) o[l[c].name] = l[c].fn;
		else l && (o[l.name] = l.key ? (...c) => {
			const d = l.fn(...c);
			return d && (d.key = l.key), d
		} : l.fn)
	}
	return o
}

function renderSlot(o, s, a = {}, l, c) {
	if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance
			.parent) && currentRenderingInstance.parent.ce) return s !== "default" && (a.name = s), openBlock(),
		createBlock(Fragment, null, [createVNode("slot", a, l && l())], 64);
	let d = o[s];
	d && d._c && (d._d = !1), openBlock();
	const f = d && ensureValidVNode(d(a)),
		m = a.key || f && f.key,
		g = createBlock(Fragment, {
			key: (m && !isSymbol(m) ? m : `_${s}`) + (!f && l ? "_fb" : "")
		}, f || (l ? l() : []), f && o._ === 1 ? 64 : -2);
	return g.scopeId && (g.slotScopeIds = [g.scopeId + "-s"]), d && d._c && (d._d = !0), g
}

function ensureValidVNode(o) {
	return o.some(s => isVNode(s) ? !(s.type === Comment$1 || s.type === Fragment && !ensureValidVNode(s.children)) : !
		0) ? o : null
}
const getPublicInstance = o => o ? isStatefulComponent(o) ? getComponentPublicInstance(o) : getPublicInstance(o
	.parent) : null,
	publicPropertiesMap = extend(Object.create(null), {
		$: o => o,
		$el: o => o.vnode.el,
		$data: o => o.data,
		$props: o => o.props,
		$attrs: o => o.attrs,
		$slots: o => o.slots,
		$refs: o => o.refs,
		$parent: o => getPublicInstance(o.parent),
		$root: o => getPublicInstance(o.root),
		$host: o => o.ce,
		$emit: o => o.emit,
		$options: o => resolveMergedOptions(o),
		$forceUpdate: o => o.f || (o.f = () => {
			queueJob(o.update)
		}),
		$nextTick: o => o.n || (o.n = nextTick.bind(o.proxy)),
		$watch: o => instanceWatch.bind(o)
	}),
	hasSetupBinding = (o, s) => o !== EMPTY_OBJ && !o.__isScriptSetup && hasOwn(o, s),
	PublicInstanceProxyHandlers = {
		get({
			_: o
		}, s) {
			if (s === "__v_skip") return !0;
			const {
				ctx: a,
				setupState: l,
				data: c,
				props: d,
				accessCache: f,
				type: m,
				appContext: g
			} = o;
			let v;
			if (s[0] !== "$") {
				const _ = f[s];
				if (_ !== void 0) switch (_) {
					case 1:
						return l[s];
					case 2:
						return c[s];
					case 4:
						return a[s];
					case 3:
						return d[s]
				} else {
					if (hasSetupBinding(l, s)) return f[s] = 1, l[s];
					if (c !== EMPTY_OBJ && hasOwn(c, s)) return f[s] = 2, c[s];
					if ((v = o.propsOptions[0]) && hasOwn(v, s)) return f[s] = 3, d[s];
					if (a !== EMPTY_OBJ && hasOwn(a, s)) return f[s] = 4, a[s];
					shouldCacheAccess && (f[s] = 0)
				}
			}
			const y = publicPropertiesMap[s];
			let b, C;
			if (y) return s === "$attrs" && track(o.attrs, "get", ""), y(o);
			if ((b = m.__cssModules) && (b = b[s])) return b;
			if (a !== EMPTY_OBJ && hasOwn(a, s)) return f[s] = 4, a[s];
			if (C = g.config.globalProperties, hasOwn(C, s)) return C[s]
		},
		set({
			_: o
		}, s, a) {
			const {
				data: l,
				setupState: c,
				ctx: d
			} = o;
			return hasSetupBinding(c, s) ? (c[s] = a, !0) : l !== EMPTY_OBJ && hasOwn(l, s) ? (l[s] = a, !0) :
				hasOwn(o.props, s) || s[0] === "$" && s.slice(1) in o ? !1 : (d[s] = a, !0)
		},
		has({
			_: {
				data: o,
				setupState: s,
				accessCache: a,
				ctx: l,
				appContext: c,
				propsOptions: d
			}
		}, f) {
			let m;
			return !!a[f] || o !== EMPTY_OBJ && hasOwn(o, f) || hasSetupBinding(s, f) || (m = d[0]) && hasOwn(m, f) ||
				hasOwn(l, f) || hasOwn(publicPropertiesMap, f) || hasOwn(c.config.globalProperties, f)
		},
		defineProperty(o, s, a) {
			return a.get != null ? o._.accessCache[s] = 0 : hasOwn(a, "value") && this.set(o, s, a.value, null), Reflect
				.defineProperty(o, s, a)
		}
	};

function normalizePropsOrEmits(o) {
	return isArray$3(o) ? o.reduce((s, a) => (s[a] = null, s), {}) : o
}
let shouldCacheAccess = !0;

function applyOptions(o) {
	const s = resolveMergedOptions(o),
		a = o.proxy,
		l = o.ctx;
	shouldCacheAccess = !1, s.beforeCreate && callHook$1(s.beforeCreate, o, "bc");
	const {
		data: c,
		computed: d,
		methods: f,
		watch: m,
		provide: g,
		inject: v,
		created: y,
		beforeMount: b,
		mounted: C,
		beforeUpdate: _,
		updated: S,
		activated: w,
		deactivated: T,
		beforeDestroy: A,
		beforeUnmount: k,
		destroyed: M,
		unmounted: D,
		render: F,
		renderTracked: R,
		renderTriggered: O,
		errorCaptured: U,
		serverPrefetch: V,
		expose: z,
		inheritAttrs: j,
		components: ge,
		directives: me,
		filters: he
	} = s;
	if (v && resolveInjections(v, l, null), f)
		for (const fe in f) {
			const q = f[fe];
			isFunction$3(q) && (l[fe] = q.bind(a))
		}
	if (c) {
		const fe = c.call(a, a);
		isObject$3(fe) && (o.data = reactive(fe))
	}
	if (shouldCacheAccess = !0, d)
		for (const fe in d) {
			const q = d[fe],
				le = isFunction$3(q) ? q.bind(a, a) : isFunction$3(q.get) ? q.get.bind(a, a) : NOOP$1,
				de = !isFunction$3(q) && isFunction$3(q.set) ? q.set.bind(a) : NOOP$1,
				_e = computed({
					get: le,
					set: de
				});
			Object.defineProperty(l, fe, {
				enumerable: !0,
				configurable: !0,
				get: () => _e.value,
				set: ke => _e.value = ke
			})
		}
	if (m)
		for (const fe in m) createWatcher(m[fe], l, a, fe);
	if (g) {
		const fe = isFunction$3(g) ? g.call(a) : g;
		Reflect.ownKeys(fe).forEach(q => {
			provide(q, fe[q])
		})
	}
	y && callHook$1(y, o, "c");

	function ae(fe, q) {
		isArray$3(q) ? q.forEach(le => fe(le.bind(a))) : q && fe(q.bind(a))
	}
	if (ae(onBeforeMount, b), ae(onMounted, C), ae(onBeforeUpdate, _), ae(onUpdated, S), ae(onActivated, w), ae(
			onDeactivated, T), ae(onErrorCaptured, U), ae(onRenderTracked, R), ae(onRenderTriggered, O), ae(
			onBeforeUnmount, k), ae(onUnmounted, D), ae(onServerPrefetch, V), isArray$3(z))
		if (z.length) {
			const fe = o.exposed || (o.exposed = {});
			z.forEach(q => {
				Object.defineProperty(fe, q, {
					get: () => a[q],
					set: le => a[q] = le
				})
			})
		} else o.exposed || (o.exposed = {});
	F && o.render === NOOP$1 && (o.render = F), j != null && (o.inheritAttrs = j), ge && (o.components = ge), me && (o
		.directives = me), V && markAsyncBoundary(o)
}

function resolveInjections(o, s, a = NOOP$1) {
	isArray$3(o) && (o = normalizeInject(o));
	for (const l in o) {
		const c = o[l];
		let d;
		isObject$3(c) ? "default" in c ? d = inject(c.from || l, c.default, !0) : d = inject(c.from || l) : d = inject(
			c), isRef(d) ? Object.defineProperty(s, l, {
			enumerable: !0,
			configurable: !0,
			get: () => d.value,
			set: f => d.value = f
		}) : s[l] = d
	}
}

function callHook$1(o, s, a) {
	callWithAsyncErrorHandling(isArray$3(o) ? o.map(l => l.bind(s.proxy)) : o.bind(s.proxy), s, a)
}

function createWatcher(o, s, a, l) {
	let c = l.includes(".") ? createPathGetter(a, l) : () => a[l];
	if (isString$3(o)) {
		const d = s[o];
		isFunction$3(d) && watch(c, d)
	} else if (isFunction$3(o)) watch(c, o.bind(a));
	else if (isObject$3(o))
		if (isArray$3(o)) o.forEach(d => createWatcher(d, s, a, l));
		else {
			const d = isFunction$3(o.handler) ? o.handler.bind(a) : s[o.handler];
			isFunction$3(d) && watch(c, d, o)
		}
}

function resolveMergedOptions(o) {
	const s = o.type,
		{
			mixins: a,
			extends: l
		} = s,
		{
			mixins: c,
			optionsCache: d,
			config: {
				optionMergeStrategies: f
			}
		} = o.appContext,
		m = d.get(s);
	let g;
	return m ? g = m : !c.length && !a && !l ? g = s : (g = {}, c.length && c.forEach(v => mergeOptions(g, v, f, !0)),
		mergeOptions(g, s, f)), isObject$3(s) && d.set(s, g), g
}

function mergeOptions(o, s, a, l = !1) {
	const {
		mixins: c,
		extends: d
	} = s;
	d && mergeOptions(o, d, a, !0), c && c.forEach(f => mergeOptions(o, f, a, !0));
	for (const f in s)
		if (!(l && f === "expose")) {
			const m = internalOptionMergeStrats[f] || a && a[f];
			o[f] = m ? m(o[f], s[f]) : s[f]
		} return o
}
const internalOptionMergeStrats = {
	data: mergeDataFn,
	props: mergeEmitsOrPropsOptions,
	emits: mergeEmitsOrPropsOptions,
	methods: mergeObjectOptions,
	computed: mergeObjectOptions,
	beforeCreate: mergeAsArray,
	created: mergeAsArray,
	beforeMount: mergeAsArray,
	mounted: mergeAsArray,
	beforeUpdate: mergeAsArray,
	updated: mergeAsArray,
	beforeDestroy: mergeAsArray,
	beforeUnmount: mergeAsArray,
	destroyed: mergeAsArray,
	unmounted: mergeAsArray,
	activated: mergeAsArray,
	deactivated: mergeAsArray,
	errorCaptured: mergeAsArray,
	serverPrefetch: mergeAsArray,
	components: mergeObjectOptions,
	directives: mergeObjectOptions,
	watch: mergeWatchOptions,
	provide: mergeDataFn,
	inject: mergeInject
};

function mergeDataFn(o, s) {
	return s ? o ? function() {
		return extend(isFunction$3(o) ? o.call(this, this) : o, isFunction$3(s) ? s.call(this, this) : s)
	} : s : o
}

function mergeInject(o, s) {
	return mergeObjectOptions(normalizeInject(o), normalizeInject(s))
}

function normalizeInject(o) {
	if (isArray$3(o)) {
		const s = {};
		for (let a = 0; a < o.length; a++) s[o[a]] = o[a];
		return s
	}
	return o
}

function mergeAsArray(o, s) {
	return o ? [...new Set([].concat(o, s))] : s
}

function mergeObjectOptions(o, s) {
	return o ? extend(Object.create(null), o, s) : s
}

function mergeEmitsOrPropsOptions(o, s) {
	return o ? isArray$3(o) && isArray$3(s) ? [...new Set([...o, ...s])] : extend(Object.create(null),
		normalizePropsOrEmits(o), normalizePropsOrEmits(s ?? {})) : s
}

function mergeWatchOptions(o, s) {
	if (!o) return s;
	if (!s) return o;
	const a = extend(Object.create(null), o);
	for (const l in s) a[l] = mergeAsArray(o[l], s[l]);
	return a
}

function createAppContext() {
	return {
		app: null,
		config: {
			isNativeTag: NO,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {}
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap,
		propsCache: new WeakMap,
		emitsCache: new WeakMap
	}
}
let uid$1 = 0;

function createAppAPI(o, s) {
	return function(l, c = null) {
		isFunction$3(l) || (l = extend({}, l)), c != null && !isObject$3(c) && (c = null);
		const d = createAppContext(),
			f = new WeakSet,
			m = [];
		let g = !1;
		const v = d.app = {
			_uid: uid$1++,
			_component: l,
			_props: c,
			_container: null,
			_context: d,
			_instance: null,
			version,
			get config() {
				return d.config
			},
			set config(y) {},
			use(y, ...b) {
				return f.has(y) || (y && isFunction$3(y.install) ? (f.add(y), y.install(v, ...b)) :
					isFunction$3(y) && (f.add(y), y(v, ...b))), v
			},
			mixin(y) {
				return d.mixins.includes(y) || d.mixins.push(y), v
			},
			component(y, b) {
				return b ? (d.components[y] = b, v) : d.components[y]
			},
			directive(y, b) {
				return b ? (d.directives[y] = b, v) : d.directives[y]
			},
			mount(y, b, C) {
				if (!g) {
					const _ = v._ceVNode || createVNode(l, c);
					return _.appContext = d, C === !0 ? C = "svg" : C === !1 && (C = void 0), o(_, y, C), g = !
						0, v._container = y, y.__vue_app__ = v, getComponentPublicInstance(_.component)
				}
			},
			onUnmount(y) {
				m.push(y)
			},
			unmount() {
				g && (callWithAsyncErrorHandling(m, v._instance, 16), o(null, v._container), delete v._container
					.__vue_app__)
			},
			provide(y, b) {
				return d.provides[y] = b, v
			},
			runWithContext(y) {
				const b = currentApp;
				currentApp = v;
				try {
					return y()
				} finally {
					currentApp = b
				}
			}
		};
		return v
	}
}
let currentApp = null;

function provide(o, s) {
	if (currentInstance) {
		let a = currentInstance.provides;
		const l = currentInstance.parent && currentInstance.parent.provides;
		l === a && (a = currentInstance.provides = Object.create(l)), a[o] = s
	}
}

function inject(o, s, a = !1) {
	const l = currentInstance || currentRenderingInstance;
	if (l || currentApp) {
		const c = currentApp ? currentApp._context.provides : l ? l.parent == null ? l.vnode.appContext && l.vnode
			.appContext.provides : l.parent.provides : void 0;
		if (c && o in c) return c[o];
		if (arguments.length > 1) return a && isFunction$3(s) ? s.call(l && l.proxy) : s
	}
}
const internalObjectProto = {},
	createInternalObject = () => Object.create(internalObjectProto),
	isInternalObject = o => Object.getPrototypeOf(o) === internalObjectProto;

function initProps(o, s, a, l = !1) {
	const c = {},
		d = createInternalObject();
	o.propsDefaults = Object.create(null), setFullProps(o, s, c, d);
	for (const f in o.propsOptions[0]) f in c || (c[f] = void 0);
	a ? o.props = l ? c : shallowReactive(c) : o.type.props ? o.props = c : o.props = d, o.attrs = d
}

function updateProps(o, s, a, l) {
	const {
		props: c,
		attrs: d,
		vnode: {
			patchFlag: f
		}
	} = o, m = toRaw(c), [g] = o.propsOptions;
	let v = !1;
	if ((l || f > 0) && !(f & 16)) {
		if (f & 8) {
			const y = o.vnode.dynamicProps;
			for (let b = 0; b < y.length; b++) {
				let C = y[b];
				if (isEmitListener(o.emitsOptions, C)) continue;
				const _ = s[C];
				if (g)
					if (hasOwn(d, C)) _ !== d[C] && (d[C] = _, v = !0);
					else {
						const S = camelize(C);
						c[S] = resolvePropValue(g, m, S, _, o, !1)
					}
				else _ !== d[C] && (d[C] = _, v = !0)
			}
		}
	} else {
		setFullProps(o, s, c, d) && (v = !0);
		let y;
		for (const b in m)(!s || !hasOwn(s, b) && ((y = hyphenate(b)) === b || !hasOwn(s, y))) && (g ? a && (a[b] !==
			void 0 || a[y] !== void 0) && (c[b] = resolvePropValue(g, m, b, void 0, o, !0)) : delete c[b]);
		if (d !== m)
			for (const b in d)(!s || !hasOwn(s, b)) && (delete d[b], v = !0)
	}
	v && trigger(o.attrs, "set", "")
}

function setFullProps(o, s, a, l) {
	const [c, d] = o.propsOptions;
	let f = !1,
		m;
	if (s)
		for (let g in s) {
			if (isReservedProp(g)) continue;
			const v = s[g];
			let y;
			c && hasOwn(c, y = camelize(g)) ? !d || !d.includes(y) ? a[y] = v : (m || (m = {}))[y] = v : isEmitListener(
				o.emitsOptions, g) || (!(g in l) || v !== l[g]) && (l[g] = v, f = !0)
		}
	if (d) {
		const g = toRaw(a),
			v = m || EMPTY_OBJ;
		for (let y = 0; y < d.length; y++) {
			const b = d[y];
			a[b] = resolvePropValue(c, g, b, v[b], o, !hasOwn(v, b))
		}
	}
	return f
}

function resolvePropValue(o, s, a, l, c, d) {
	const f = o[a];
	if (f != null) {
		const m = hasOwn(f, "default");
		if (m && l === void 0) {
			const g = f.default;
			if (f.type !== Function && !f.skipFactory && isFunction$3(g)) {
				const {
					propsDefaults: v
				} = c;
				if (a in v) l = v[a];
				else {
					const y = setCurrentInstance(c);
					l = v[a] = g.call(null, s), y()
				}
			} else l = g;
			c.ce && c.ce._setProp(a, l)
		}
		f[0] && (d && !m ? l = !1 : f[1] && (l === "" || l === hyphenate(a)) && (l = !0))
	}
	return l
}
const mixinPropsCache = new WeakMap;

function normalizePropsOptions(o, s, a = !1) {
	const l = a ? mixinPropsCache : s.propsCache,
		c = l.get(o);
	if (c) return c;
	const d = o.props,
		f = {},
		m = [];
	let g = !1;
	if (!isFunction$3(o)) {
		const y = b => {
			g = !0;
			const [C, _] = normalizePropsOptions(b, s, !0);
			extend(f, C), _ && m.push(..._)
		};
		!a && s.mixins.length && s.mixins.forEach(y), o.extends && y(o.extends), o.mixins && o.mixins.forEach(y)
	}
	if (!d && !g) return isObject$3(o) && l.set(o, EMPTY_ARR), EMPTY_ARR;
	if (isArray$3(d))
		for (let y = 0; y < d.length; y++) {
			const b = camelize(d[y]);
			validatePropName(b) && (f[b] = EMPTY_OBJ)
		} else if (d)
			for (const y in d) {
				const b = camelize(y);
				if (validatePropName(b)) {
					const C = d[y],
						_ = f[b] = isArray$3(C) || isFunction$3(C) ? {
							type: C
						} : extend({}, C),
						S = _.type;
					let w = !1,
						T = !0;
					if (isArray$3(S))
						for (let A = 0; A < S.length; ++A) {
							const k = S[A],
								M = isFunction$3(k) && k.name;
							if (M === "Boolean") {
								w = !0;
								break
							} else M === "String" && (T = !1)
						} else w = isFunction$3(S) && S.name === "Boolean";
					_[0] = w, _[1] = T, (w || hasOwn(_, "default")) && m.push(b)
				}
			}
	const v = [f, m];
	return isObject$3(o) && l.set(o, v), v
}

function validatePropName(o) {
	return o[0] !== "$" && !isReservedProp(o)
}
const isInternalKey = o => o[0] === "_" || o === "$stable",
	normalizeSlotValue = o => isArray$3(o) ? o.map(normalizeVNode) : [normalizeVNode(o)],
	normalizeSlot = (o, s, a) => {
		if (s._n) return s;
		const l = withCtx((...c) => normalizeSlotValue(s(...c)), a);
		return l._c = !1, l
	},
	normalizeObjectSlots = (o, s, a) => {
		const l = o._ctx;
		for (const c in o) {
			if (isInternalKey(c)) continue;
			const d = o[c];
			if (isFunction$3(d)) s[c] = normalizeSlot(c, d, l);
			else if (d != null) {
				const f = normalizeSlotValue(d);
				s[c] = () => f
			}
		}
	},
	normalizeVNodeSlots = (o, s) => {
		const a = normalizeSlotValue(s);
		o.slots.default = () => a
	},
	assignSlots = (o, s, a) => {
		for (const l in s)(a || l !== "_") && (o[l] = s[l])
	},
	initSlots = (o, s, a) => {
		const l = o.slots = createInternalObject();
		if (o.vnode.shapeFlag & 32) {
			const c = s._;
			c ? (assignSlots(l, s, a), a && def(l, "_", c, !0)) : normalizeObjectSlots(s, l)
		} else s && normalizeVNodeSlots(o, s)
	},
	updateSlots = (o, s, a) => {
		const {
			vnode: l,
			slots: c
		} = o;
		let d = !0,
			f = EMPTY_OBJ;
		if (l.shapeFlag & 32) {
			const m = s._;
			m ? a && m === 1 ? d = !1 : assignSlots(c, s, a) : (d = !s.$stable, normalizeObjectSlots(s, c)), f = s
		} else s && (normalizeVNodeSlots(o, s), f = {
			default: 1
		});
		if (d)
			for (const m in c) !isInternalKey(m) && f[m] == null && delete c[m]
	},
	queuePostRenderEffect = queueEffectWithSuspense;

function createRenderer(o) {
	return baseCreateRenderer(o)
}

function baseCreateRenderer(o, s) {
	const a = getGlobalThis();
	a.__VUE__ = !0;
	const {
		insert: l,
		remove: c,
		patchProp: d,
		createElement: f,
		createText: m,
		createComment: g,
		setText: v,
		setElementText: y,
		parentNode: b,
		nextSibling: C,
		setScopeId: _ = NOOP$1,
		insertStaticContent: S
	} = o, w = (Ae, xe, ye, Le = null, Ue = null, nt = null, ot = void 0, at = null, Je = !!xe.dynamicChildren) => {
		if (Ae === xe) return;
		Ae && !isSameVNodeType(Ae, xe) && (Le = Ve(Ae), ke(Ae, Ue, nt, !0), Ae = null), xe.patchFlag === -2 && (
			Je = !1, xe.dynamicChildren = null);
		const {
			type: Ne,
			ref: we,
			shapeFlag: Ce
		} = xe;
		switch (Ne) {
			case Text:
				T(Ae, xe, ye, Le);
				break;
			case Comment$1:
				A(Ae, xe, ye, Le);
				break;
			case Static:
				Ae == null && k(xe, ye, Le, ot);
				break;
			case Fragment:
				ge(Ae, xe, ye, Le, Ue, nt, ot, at, Je);
				break;
			default:
				Ce & 1 ? F(Ae, xe, ye, Le, Ue, nt, ot, at, Je) : Ce & 6 ? me(Ae, xe, ye, Le, Ue, nt, ot, at, Je) : (
					Ce & 64 || Ce & 128) && Ne.process(Ae, xe, ye, Le, Ue, nt, ot, at, Je, dt)
		}
		we != null && Ue && setRef(we, Ae && Ae.ref, nt, xe || Ae, !xe)
	}, T = (Ae, xe, ye, Le) => {
		if (Ae == null) l(xe.el = m(xe.children), ye, Le);
		else {
			const Ue = xe.el = Ae.el;
			xe.children !== Ae.children && v(Ue, xe.children)
		}
	}, A = (Ae, xe, ye, Le) => {
		Ae == null ? l(xe.el = g(xe.children || ""), ye, Le) : xe.el = Ae.el
	}, k = (Ae, xe, ye, Le) => {
		[Ae.el, Ae.anchor] = S(Ae.children, xe, ye, Le, Ae.el, Ae.anchor)
	}, M = ({
		el: Ae,
		anchor: xe
	}, ye, Le) => {
		let Ue;
		for (; Ae && Ae !== xe;) Ue = C(Ae), l(Ae, ye, Le), Ae = Ue;
		l(xe, ye, Le)
	}, D = ({
		el: Ae,
		anchor: xe
	}) => {
		let ye;
		for (; Ae && Ae !== xe;) ye = C(Ae), c(Ae), Ae = ye;
		c(xe)
	}, F = (Ae, xe, ye, Le, Ue, nt, ot, at, Je) => {
		xe.type === "svg" ? ot = "svg" : xe.type === "math" && (ot = "mathml"), Ae == null ? R(xe, ye, Le, Ue, nt,
			ot, at, Je) : V(Ae, xe, Ue, nt, ot, at, Je)
	}, R = (Ae, xe, ye, Le, Ue, nt, ot, at) => {
		let Je, Ne;
		const {
			props: we,
			shapeFlag: Ce,
			transition: $e,
			dirs: Fe
		} = Ae;
		if (Je = Ae.el = f(Ae.type, nt, we && we.is, we), Ce & 8 ? y(Je, Ae.children) : Ce & 16 && U(Ae.children,
				Je, null, Le, Ue, resolveChildrenNamespace(Ae, nt), ot, at), Fe && invokeDirectiveHook(Ae, null, Le,
				"created"), O(Je, Ae, Ae.scopeId, ot, Le), we) {
			for (const ze in we) ze !== "value" && !isReservedProp(ze) && d(Je, ze, null, we[ze], nt, Le);
			"value" in we && d(Je, "value", null, we.value, nt), (Ne = we.onVnodeBeforeMount) && invokeVNodeHook(Ne,
				Le, Ae)
		}
		Fe && invokeDirectiveHook(Ae, null, Le, "beforeMount");
		const Ge = needTransition(Ue, $e);
		Ge && $e.beforeEnter(Je), l(Je, xe, ye), ((Ne = we && we.onVnodeMounted) || Ge || Fe) &&
			queuePostRenderEffect(() => {
				Ne && invokeVNodeHook(Ne, Le, Ae), Ge && $e.enter(Je), Fe && invokeDirectiveHook(Ae, null, Le,
					"mounted")
			}, Ue)
	}, O = (Ae, xe, ye, Le, Ue) => {
		if (ye && _(Ae, ye), Le)
			for (let nt = 0; nt < Le.length; nt++) _(Ae, Le[nt]);
		if (Ue) {
			let nt = Ue.subTree;
			if (xe === nt || isSuspense(nt.type) && (nt.ssContent === xe || nt.ssFallback === xe)) {
				const ot = Ue.vnode;
				O(Ae, ot, ot.scopeId, ot.slotScopeIds, Ue.parent)
			}
		}
	}, U = (Ae, xe, ye, Le, Ue, nt, ot, at, Je = 0) => {
		for (let Ne = Je; Ne < Ae.length; Ne++) {
			const we = Ae[Ne] = at ? cloneIfMounted(Ae[Ne]) : normalizeVNode(Ae[Ne]);
			w(null, we, xe, ye, Le, Ue, nt, ot, at)
		}
	}, V = (Ae, xe, ye, Le, Ue, nt, ot) => {
		const at = xe.el = Ae.el;
		let {
			patchFlag: Je,
			dynamicChildren: Ne,
			dirs: we
		} = xe;
		Je |= Ae.patchFlag & 16;
		const Ce = Ae.props || EMPTY_OBJ,
			$e = xe.props || EMPTY_OBJ;
		let Fe;
		if (ye && toggleRecurse(ye, !1), (Fe = $e.onVnodeBeforeUpdate) && invokeVNodeHook(Fe, ye, xe, Ae), we &&
			invokeDirectiveHook(xe, Ae, ye, "beforeUpdate"), ye && toggleRecurse(ye, !0), (Ce.innerHTML && $e
				.innerHTML == null || Ce.textContent && $e.textContent == null) && y(at, ""), Ne ? z(Ae
				.dynamicChildren, Ne, at, ye, Le, resolveChildrenNamespace(xe, Ue), nt) : ot || q(Ae, xe, at, null,
				ye, Le, resolveChildrenNamespace(xe, Ue), nt, !1), Je > 0) {
			if (Je & 16) j(at, Ce, $e, ye, Ue);
			else if (Je & 2 && Ce.class !== $e.class && d(at, "class", null, $e.class, Ue), Je & 4 && d(at, "style",
					Ce.style, $e.style, Ue), Je & 8) {
				const Ge = xe.dynamicProps;
				for (let ze = 0; ze < Ge.length; ze++) {
					const Oe = Ge[ze],
						Xe = Ce[Oe],
						rt = $e[Oe];
					(rt !== Xe || Oe === "value") && d(at, Oe, Xe, rt, Ue, ye)
				}
			}
			Je & 1 && Ae.children !== xe.children && y(at, xe.children)
		} else !ot && Ne == null && j(at, Ce, $e, ye, Ue);
		((Fe = $e.onVnodeUpdated) || we) && queuePostRenderEffect(() => {
			Fe && invokeVNodeHook(Fe, ye, xe, Ae), we && invokeDirectiveHook(xe, Ae, ye, "updated")
		}, Le)
	}, z = (Ae, xe, ye, Le, Ue, nt, ot) => {
		for (let at = 0; at < xe.length; at++) {
			const Je = Ae[at],
				Ne = xe[at],
				we = Je.el && (Je.type === Fragment || !isSameVNodeType(Je, Ne) || Je.shapeFlag & 70) ? b(Je.el) :
				ye;
			w(Je, Ne, we, null, Le, Ue, nt, ot, !0)
		}
	}, j = (Ae, xe, ye, Le, Ue) => {
		if (xe !== ye) {
			if (xe !== EMPTY_OBJ)
				for (const nt in xe) !isReservedProp(nt) && !(nt in ye) && d(Ae, nt, xe[nt], null, Ue, Le);
			for (const nt in ye) {
				if (isReservedProp(nt)) continue;
				const ot = ye[nt],
					at = xe[nt];
				ot !== at && nt !== "value" && d(Ae, nt, at, ot, Ue, Le)
			}
			"value" in ye && d(Ae, "value", xe.value, ye.value, Ue)
		}
	}, ge = (Ae, xe, ye, Le, Ue, nt, ot, at, Je) => {
		const Ne = xe.el = Ae ? Ae.el : m(""),
			we = xe.anchor = Ae ? Ae.anchor : m("");
		let {
			patchFlag: Ce,
			dynamicChildren: $e,
			slotScopeIds: Fe
		} = xe;
		Fe && (at = at ? at.concat(Fe) : Fe), Ae == null ? (l(Ne, ye, Le), l(we, ye, Le), U(xe.children || [], ye,
			we, Ue, nt, ot, at, Je)) : Ce > 0 && Ce & 64 && $e && Ae.dynamicChildren ? (z(Ae.dynamicChildren,
			$e, ye, Ue, nt, ot, at), (xe.key != null || Ue && xe === Ue.subTree) && traverseStaticChildren(
			Ae, xe, !0)) : q(Ae, xe, ye, we, Ue, nt, ot, at, Je)
	}, me = (Ae, xe, ye, Le, Ue, nt, ot, at, Je) => {
		xe.slotScopeIds = at, Ae == null ? xe.shapeFlag & 512 ? Ue.ctx.activate(xe, ye, Le, ot, Je) : he(xe, ye, Le,
			Ue, nt, ot, Je) : ce(Ae, xe, Je)
	}, he = (Ae, xe, ye, Le, Ue, nt, ot) => {
		const at = Ae.component = createComponentInstance(Ae, Le, Ue);
		if (isKeepAlive(Ae) && (at.ctx.renderer = dt), setupComponent(at, !1, ot), at.asyncDep) {
			if (Ue && Ue.registerDep(at, ae, ot), !Ae.el) {
				const Je = at.subTree = createVNode(Comment$1);
				A(null, Je, xe, ye)
			}
		} else ae(at, Ae, xe, ye, Ue, nt, ot)
	}, ce = (Ae, xe, ye) => {
		const Le = xe.component = Ae.component;
		if (shouldUpdateComponent(Ae, xe, ye))
			if (Le.asyncDep && !Le.asyncResolved) {
				fe(Le, xe, ye);
				return
			} else Le.next = xe, Le.update();
		else xe.el = Ae.el, Le.vnode = xe
	}, ae = (Ae, xe, ye, Le, Ue, nt, ot) => {
		const at = () => {
			if (Ae.isMounted) {
				let {
					next: Ce,
					bu: $e,
					u: Fe,
					parent: Ge,
					vnode: ze
				} = Ae; {
					const gt = locateNonHydratedAsyncRoot(Ae);
					if (gt) {
						Ce && (Ce.el = ze.el, fe(Ae, Ce, ot)), gt.asyncDep.then(() => {
							Ae.isUnmounted || at()
						});
						return
					}
				}
				let Oe = Ce,
					Xe;
				toggleRecurse(Ae, !1), Ce ? (Ce.el = ze.el, fe(Ae, Ce, ot)) : Ce = ze, $e && invokeArrayFns($e),
					(Xe = Ce.props && Ce.props.onVnodeBeforeUpdate) && invokeVNodeHook(Xe, Ge, Ce, ze),
					toggleRecurse(Ae, !0);
				const rt = renderComponentRoot(Ae),
					ut = Ae.subTree;
				Ae.subTree = rt, w(ut, rt, b(ut.el), Ve(ut), Ae, Ue, nt), Ce.el = rt.el, Oe === null &&
					updateHOCHostEl(Ae, rt.el), Fe && queuePostRenderEffect(Fe, Ue), (Xe = Ce.props && Ce.props
						.onVnodeUpdated) && queuePostRenderEffect(() => invokeVNodeHook(Xe, Ge, Ce, ze), Ue)
			} else {
				let Ce;
				const {
					el: $e,
					props: Fe
				} = xe, {
					bm: Ge,
					m: ze,
					parent: Oe,
					root: Xe,
					type: rt
				} = Ae, ut = isAsyncWrapper(xe);
				toggleRecurse(Ae, !1), Ge && invokeArrayFns(Ge), !ut && (Ce = Fe && Fe.onVnodeBeforeMount) &&
					invokeVNodeHook(Ce, Oe, xe), toggleRecurse(Ae, !0); {
					Xe.ce && Xe.ce._injectChildStyle(rt);
					const gt = Ae.subTree = renderComponentRoot(Ae);
					w(null, gt, ye, Le, Ae, Ue, nt), xe.el = gt.el
				}
				if (ze && queuePostRenderEffect(ze, Ue), !ut && (Ce = Fe && Fe.onVnodeMounted)) {
					const gt = xe;
					queuePostRenderEffect(() => invokeVNodeHook(Ce, Oe, gt), Ue)
				}(xe.shapeFlag & 256 || Oe && isAsyncWrapper(Oe.vnode) && Oe.vnode.shapeFlag & 256) && Ae.a &&
					queuePostRenderEffect(Ae.a, Ue), Ae.isMounted = !0, xe = ye = Le = null
			}
		};
		Ae.scope.on();
		const Je = Ae.effect = new ReactiveEffect(at);
		Ae.scope.off();
		const Ne = Ae.update = Je.run.bind(Je),
			we = Ae.job = Je.runIfDirty.bind(Je);
		we.i = Ae, we.id = Ae.uid, Je.scheduler = () => queueJob(we), toggleRecurse(Ae, !0), Ne()
	}, fe = (Ae, xe, ye) => {
		xe.component = Ae;
		const Le = Ae.vnode.props;
		Ae.vnode = xe, Ae.next = null, updateProps(Ae, xe.props, Le, ye), updateSlots(Ae, xe.children, ye),
			pauseTracking(), flushPreFlushCbs(Ae), resetTracking()
	}, q = (Ae, xe, ye, Le, Ue, nt, ot, at, Je = !1) => {
		const Ne = Ae && Ae.children,
			we = Ae ? Ae.shapeFlag : 0,
			Ce = xe.children,
			{
				patchFlag: $e,
				shapeFlag: Fe
			} = xe;
		if ($e > 0) {
			if ($e & 128) {
				de(Ne, Ce, ye, Le, Ue, nt, ot, at, Je);
				return
			} else if ($e & 256) {
				le(Ne, Ce, ye, Le, Ue, nt, ot, at, Je);
				return
			}
		}
		Fe & 8 ? (we & 16 && Me(Ne, Ue, nt), Ce !== Ne && y(ye, Ce)) : we & 16 ? Fe & 16 ? de(Ne, Ce, ye, Le, Ue,
			nt, ot, at, Je) : Me(Ne, Ue, nt, !0) : (we & 8 && y(ye, ""), Fe & 16 && U(Ce, ye, Le, Ue, nt, ot,
			at, Je))
	}, le = (Ae, xe, ye, Le, Ue, nt, ot, at, Je) => {
		Ae = Ae || EMPTY_ARR, xe = xe || EMPTY_ARR;
		const Ne = Ae.length,
			we = xe.length,
			Ce = Math.min(Ne, we);
		let $e;
		for ($e = 0; $e < Ce; $e++) {
			const Fe = xe[$e] = Je ? cloneIfMounted(xe[$e]) : normalizeVNode(xe[$e]);
			w(Ae[$e], Fe, ye, null, Ue, nt, ot, at, Je)
		}
		Ne > we ? Me(Ae, Ue, nt, !0, !1, Ce) : U(xe, ye, Le, Ue, nt, ot, at, Je, Ce)
	}, de = (Ae, xe, ye, Le, Ue, nt, ot, at, Je) => {
		let Ne = 0;
		const we = xe.length;
		let Ce = Ae.length - 1,
			$e = we - 1;
		for (; Ne <= Ce && Ne <= $e;) {
			const Fe = Ae[Ne],
				Ge = xe[Ne] = Je ? cloneIfMounted(xe[Ne]) : normalizeVNode(xe[Ne]);
			if (isSameVNodeType(Fe, Ge)) w(Fe, Ge, ye, null, Ue, nt, ot, at, Je);
			else break;
			Ne++
		}
		for (; Ne <= Ce && Ne <= $e;) {
			const Fe = Ae[Ce],
				Ge = xe[$e] = Je ? cloneIfMounted(xe[$e]) : normalizeVNode(xe[$e]);
			if (isSameVNodeType(Fe, Ge)) w(Fe, Ge, ye, null, Ue, nt, ot, at, Je);
			else break;
			Ce--, $e--
		}
		if (Ne > Ce) {
			if (Ne <= $e) {
				const Fe = $e + 1,
					Ge = Fe < we ? xe[Fe].el : Le;
				for (; Ne <= $e;) w(null, xe[Ne] = Je ? cloneIfMounted(xe[Ne]) : normalizeVNode(xe[Ne]), ye, Ge, Ue,
					nt, ot, at, Je), Ne++
			}
		} else if (Ne > $e)
			for (; Ne <= Ce;) ke(Ae[Ne], Ue, nt, !0), Ne++;
		else {
			const Fe = Ne,
				Ge = Ne,
				ze = new Map;
			for (Ne = Ge; Ne <= $e; Ne++) {
				const Ye = xe[Ne] = Je ? cloneIfMounted(xe[Ne]) : normalizeVNode(xe[Ne]);
				Ye.key != null && ze.set(Ye.key, Ne)
			}
			let Oe, Xe = 0;
			const rt = $e - Ge + 1;
			let ut = !1,
				gt = 0;
			const Et = new Array(rt);
			for (Ne = 0; Ne < rt; Ne++) Et[Ne] = 0;
			for (Ne = Fe; Ne <= Ce; Ne++) {
				const Ye = Ae[Ne];
				if (Xe >= rt) {
					ke(Ye, Ue, nt, !0);
					continue
				}
				let ct;
				if (Ye.key != null) ct = ze.get(Ye.key);
				else
					for (Oe = Ge; Oe <= $e; Oe++)
						if (Et[Oe - Ge] === 0 && isSameVNodeType(Ye, xe[Oe])) {
							ct = Oe;
							break
						} ct === void 0 ? ke(Ye, Ue, nt, !0) : (Et[ct - Ge] = Ne + 1, ct >= gt ? gt = ct : ut = !0,
					w(Ye, xe[ct], ye, null, Ue, nt, ot, at, Je), Xe++)
			}
			const Ze = ut ? getSequence(Et) : EMPTY_ARR;
			for (Oe = Ze.length - 1, Ne = rt - 1; Ne >= 0; Ne--) {
				const Ye = Ge + Ne,
					ct = xe[Ye],
					yt = Ye + 1 < we ? xe[Ye + 1].el : Le;
				Et[Ne] === 0 ? w(null, ct, ye, yt, Ue, nt, ot, at, Je) : ut && (Oe < 0 || Ne !== Ze[Oe] ? _e(ct, ye,
					yt, 2) : Oe--)
			}
		}
	}, _e = (Ae, xe, ye, Le, Ue = null) => {
		const {
			el: nt,
			type: ot,
			transition: at,
			children: Je,
			shapeFlag: Ne
		} = Ae;
		if (Ne & 6) {
			_e(Ae.component.subTree, xe, ye, Le);
			return
		}
		if (Ne & 128) {
			Ae.suspense.move(xe, ye, Le);
			return
		}
		if (Ne & 64) {
			ot.move(Ae, xe, ye, dt);
			return
		}
		if (ot === Fragment) {
			l(nt, xe, ye);
			for (let Ce = 0; Ce < Je.length; Ce++) _e(Je[Ce], xe, ye, Le);
			l(Ae.anchor, xe, ye);
			return
		}
		if (ot === Static) {
			M(Ae, xe, ye);
			return
		}
		if (Le !== 2 && Ne & 1 && at)
			if (Le === 0) at.beforeEnter(nt), l(nt, xe, ye), queuePostRenderEffect(() => at.enter(nt), Ue);
			else {
				const {
					leave: Ce,
					delayLeave: $e,
					afterLeave: Fe
				} = at, Ge = () => l(nt, xe, ye), ze = () => {
					Ce(nt, () => {
						Ge(), Fe && Fe()
					})
				};
				$e ? $e(nt, Ge, ze) : ze()
			}
		else l(nt, xe, ye)
	}, ke = (Ae, xe, ye, Le = !1, Ue = !1) => {
		const {
			type: nt,
			props: ot,
			ref: at,
			children: Je,
			dynamicChildren: Ne,
			shapeFlag: we,
			patchFlag: Ce,
			dirs: $e,
			cacheIndex: Fe
		} = Ae;
		if (Ce === -2 && (Ue = !1), at != null && setRef(at, null, ye, Ae, !0), Fe != null && (xe.renderCache[Fe] =
				void 0), we & 256) {
			xe.ctx.deactivate(Ae);
			return
		}
		const Ge = we & 1 && $e,
			ze = !isAsyncWrapper(Ae);
		let Oe;
		if (ze && (Oe = ot && ot.onVnodeBeforeUnmount) && invokeVNodeHook(Oe, xe, Ae), we & 6) be(Ae.component, ye,
			Le);
		else {
			if (we & 128) {
				Ae.suspense.unmount(ye, Le);
				return
			}
			Ge && invokeDirectiveHook(Ae, null, xe, "beforeUnmount"), we & 64 ? Ae.type.remove(Ae, xe, ye, dt, Le) :
				Ne && !Ne.hasOnce && (nt !== Fragment || Ce > 0 && Ce & 64) ? Me(Ne, xe, ye, !1, !0) : (nt ===
					Fragment && Ce & 384 || !Ue && we & 16) && Me(Je, xe, ye), Le && De(Ae)
		}(ze && (Oe = ot && ot.onVnodeUnmounted) || Ge) && queuePostRenderEffect(() => {
			Oe && invokeVNodeHook(Oe, xe, Ae), Ge && invokeDirectiveHook(Ae, null, xe, "unmounted")
		}, ye)
	}, De = Ae => {
		const {
			type: xe,
			el: ye,
			anchor: Le,
			transition: Ue
		} = Ae;
		if (xe === Fragment) {
			Se(ye, Le);
			return
		}
		if (xe === Static) {
			D(Ae);
			return
		}
		const nt = () => {
			c(ye), Ue && !Ue.persisted && Ue.afterLeave && Ue.afterLeave()
		};
		if (Ae.shapeFlag & 1 && Ue && !Ue.persisted) {
			const {
				leave: ot,
				delayLeave: at
			} = Ue, Je = () => ot(ye, nt);
			at ? at(Ae.el, nt, Je) : Je()
		} else nt()
	}, Se = (Ae, xe) => {
		let ye;
		for (; Ae !== xe;) ye = C(Ae), c(Ae), Ae = ye;
		c(xe)
	}, be = (Ae, xe, ye) => {
		const {
			bum: Le,
			scope: Ue,
			job: nt,
			subTree: ot,
			um: at,
			m: Je,
			a: Ne
		} = Ae;
		invalidateMount(Je), invalidateMount(Ne), Le && invokeArrayFns(Le), Ue.stop(), nt && (nt.flags |= 8, ke(ot,
				Ae, xe, ye)), at && queuePostRenderEffect(at, xe), queuePostRenderEffect(() => {
				Ae.isUnmounted = !0
			}, xe), xe && xe.pendingBranch && !xe.isUnmounted && Ae.asyncDep && !Ae.asyncResolved && Ae
			.suspenseId === xe.pendingId && (xe.deps--, xe.deps === 0 && xe.resolve())
	}, Me = (Ae, xe, ye, Le = !1, Ue = !1, nt = 0) => {
		for (let ot = nt; ot < Ae.length; ot++) ke(Ae[ot], xe, ye, Le, Ue)
	}, Ve = Ae => {
		if (Ae.shapeFlag & 6) return Ve(Ae.component.subTree);
		if (Ae.shapeFlag & 128) return Ae.suspense.next();
		const xe = C(Ae.anchor || Ae.el),
			ye = xe && xe[TeleportEndKey];
		return ye ? C(ye) : xe
	};
	let it = !1;
	const pt = (Ae, xe, ye) => {
			Ae == null ? xe._vnode && ke(xe._vnode, null, null, !0) : w(xe._vnode || null, Ae, xe, null, null, null,
				ye), xe._vnode = Ae, it || (it = !0, flushPreFlushCbs(), flushPostFlushCbs(), it = !1)
		},
		dt = {
			p: w,
			um: ke,
			m: _e,
			r: De,
			mt: he,
			mc: U,
			pc: q,
			pbc: z,
			n: Ve,
			o
		};
	return {
		render: pt,
		hydrate: void 0,
		createApp: createAppAPI(pt)
	}
}

function resolveChildrenNamespace({
	type: o,
	props: s
}, a) {
	return a === "svg" && o === "foreignObject" || a === "mathml" && o === "annotation-xml" && s && s.encoding && s
		.encoding.includes("html") ? void 0 : a
}

function toggleRecurse({
	effect: o,
	job: s
}, a) {
	a ? (o.flags |= 32, s.flags |= 4) : (o.flags &= -33, s.flags &= -5)
}

function needTransition(o, s) {
	return (!o || o && !o.pendingBranch) && s && !s.persisted
}

function traverseStaticChildren(o, s, a = !1) {
	const l = o.children,
		c = s.children;
	if (isArray$3(l) && isArray$3(c))
		for (let d = 0; d < l.length; d++) {
			const f = l[d];
			let m = c[d];
			m.shapeFlag & 1 && !m.dynamicChildren && ((m.patchFlag <= 0 || m.patchFlag === 32) && (m = c[d] =
					cloneIfMounted(c[d]), m.el = f.el), !a && m.patchFlag !== -2 && traverseStaticChildren(f, m)), m
				.type === Text && (m.el = f.el)
		}
}

function getSequence(o) {
	const s = o.slice(),
		a = [0];
	let l, c, d, f, m;
	const g = o.length;
	for (l = 0; l < g; l++) {
		const v = o[l];
		if (v !== 0) {
			if (c = a[a.length - 1], o[c] < v) {
				s[l] = c, a.push(l);
				continue
			}
			for (d = 0, f = a.length - 1; d < f;) m = d + f >> 1, o[a[m]] < v ? d = m + 1 : f = m;
			v < o[a[d]] && (d > 0 && (s[l] = a[d - 1]), a[d] = l)
		}
	}
	for (d = a.length, f = a[d - 1]; d-- > 0;) a[d] = f, f = s[f];
	return a
}

function locateNonHydratedAsyncRoot(o) {
	const s = o.subTree.component;
	if (s) return s.asyncDep && !s.asyncResolved ? s : locateNonHydratedAsyncRoot(s)
}

function invalidateMount(o) {
	if (o)
		for (let s = 0; s < o.length; s++) o[s].flags |= 8
}
const ssrContextKey = Symbol.for("v-scx"),
	useSSRContext = () => inject(ssrContextKey);

function watchEffect(o, s) {
	return doWatch(o, null, s)
}

function watch(o, s, a) {
	return doWatch(o, s, a)
}

function doWatch(o, s, a = EMPTY_OBJ) {
	const {
		immediate: l,
		deep: c,
		flush: d,
		once: f
	} = a, m = extend({}, a), g = s && l || !s && d !== "post";
	let v;
	if (isInSSRComponentSetup) {
		if (d === "sync") {
			const _ = useSSRContext();
			v = _.__watcherHandles || (_.__watcherHandles = [])
		} else if (!g) {
			const _ = () => {};
			return _.stop = NOOP$1, _.resume = NOOP$1, _.pause = NOOP$1, _
		}
	}
	const y = currentInstance;
	m.call = (_, S, w) => callWithAsyncErrorHandling(_, y, S, w);
	let b = !1;
	d === "post" ? m.scheduler = _ => {
		queuePostRenderEffect(_, y && y.suspense)
	} : d !== "sync" && (b = !0, m.scheduler = (_, S) => {
		S ? _() : queueJob(_)
	}), m.augmentJob = _ => {
		s && (_.flags |= 4), b && (_.flags |= 2, y && (_.id = y.uid, _.i = y))
	};
	const C = watch$1(o, s, m);
	return isInSSRComponentSetup && (v ? v.push(C) : g && C()), C
}

function instanceWatch(o, s, a) {
	const l = this.proxy,
		c = isString$3(o) ? o.includes(".") ? createPathGetter(l, o) : () => l[o] : o.bind(l, l);
	let d;
	isFunction$3(s) ? d = s : (d = s.handler, a = s);
	const f = setCurrentInstance(this),
		m = doWatch(c, d.bind(l), a);
	return f(), m
}

function createPathGetter(o, s) {
	const a = s.split(".");
	return () => {
		let l = o;
		for (let c = 0; c < a.length && l; c++) l = l[a[c]];
		return l
	}
}
const getModelModifiers = (o, s) => s === "modelValue" || s === "model-value" ? o.modelModifiers : o[`${s}Modifiers`] ||
	o[`${camelize(s)}Modifiers`] || o[`${hyphenate(s)}Modifiers`];

function emit(o, s, ...a) {
	if (o.isUnmounted) return;
	const l = o.vnode.props || EMPTY_OBJ;
	let c = a;
	const d = s.startsWith("update:"),
		f = d && getModelModifiers(l, s.slice(7));
	f && (f.trim && (c = a.map(y => isString$3(y) ? y.trim() : y)), f.number && (c = a.map(looseToNumber)));
	let m, g = l[m = toHandlerKey(s)] || l[m = toHandlerKey(camelize(s))];
	!g && d && (g = l[m = toHandlerKey(hyphenate(s))]), g && callWithAsyncErrorHandling(g, o, 6, c);
	const v = l[m + "Once"];
	if (v) {
		if (!o.emitted) o.emitted = {};
		else if (o.emitted[m]) return;
		o.emitted[m] = !0, callWithAsyncErrorHandling(v, o, 6, c)
	}
}

function normalizeEmitsOptions(o, s, a = !1) {
	const l = s.emitsCache,
		c = l.get(o);
	if (c !== void 0) return c;
	const d = o.emits;
	let f = {},
		m = !1;
	if (!isFunction$3(o)) {
		const g = v => {
			const y = normalizeEmitsOptions(v, s, !0);
			y && (m = !0, extend(f, y))
		};
		!a && s.mixins.length && s.mixins.forEach(g), o.extends && g(o.extends), o.mixins && o.mixins.forEach(g)
	}
	return !d && !m ? (isObject$3(o) && l.set(o, null), null) : (isArray$3(d) ? d.forEach(g => f[g] = null) : extend(f,
		d), isObject$3(o) && l.set(o, f), f)
}

function isEmitListener(o, s) {
	return !o || !isOn(s) ? !1 : (s = s.slice(2).replace(/Once$/, ""), hasOwn(o, s[0].toLowerCase() + s.slice(1)) ||
		hasOwn(o, hyphenate(s)) || hasOwn(o, s))
}

function markAttrsAccessed() {}

function renderComponentRoot(o) {
	const {
		type: s,
		vnode: a,
		proxy: l,
		withProxy: c,
		propsOptions: [d],
		slots: f,
		attrs: m,
		emit: g,
		render: v,
		renderCache: y,
		props: b,
		data: C,
		setupState: _,
		ctx: S,
		inheritAttrs: w
	} = o, T = setCurrentRenderingInstance(o);
	let A, k;
	try {
		if (a.shapeFlag & 4) {
			const D = c || l,
				F = D;
			A = normalizeVNode(v.call(F, D, y, b, _, C, S)), k = m
		} else {
			const D = s;
			A = normalizeVNode(D.length > 1 ? D(b, {
				attrs: m,
				slots: f,
				emit: g
			}) : D(b, null)), k = s.props ? m : getFunctionalFallthrough(m)
		}
	} catch (D) {
		blockStack.length = 0, handleError(D, o, 1), A = createVNode(Comment$1)
	}
	let M = A;
	if (k && w !== !1) {
		const D = Object.keys(k),
			{
				shapeFlag: F
			} = M;
		D.length && F & 7 && (d && D.some(isModelListener) && (k = filterModelListeners(k, d)), M = cloneVNode(M, k, !1,
			!0))
	}
	return a.dirs && (M = cloneVNode(M, null, !1, !0), M.dirs = M.dirs ? M.dirs.concat(a.dirs) : a.dirs), a
		.transition && setTransitionHooks(M, a.transition), A = M, setCurrentRenderingInstance(T), A
}
const getFunctionalFallthrough = o => {
		let s;
		for (const a in o)(a === "class" || a === "style" || isOn(a)) && ((s || (s = {}))[a] = o[a]);
		return s
	},
	filterModelListeners = (o, s) => {
		const a = {};
		for (const l in o)(!isModelListener(l) || !(l.slice(9) in s)) && (a[l] = o[l]);
		return a
	};

function shouldUpdateComponent(o, s, a) {
	const {
		props: l,
		children: c,
		component: d
	} = o, {
		props: f,
		children: m,
		patchFlag: g
	} = s, v = d.emitsOptions;
	if (s.dirs || s.transition) return !0;
	if (a && g >= 0) {
		if (g & 1024) return !0;
		if (g & 16) return l ? hasPropsChanged(l, f, v) : !!f;
		if (g & 8) {
			const y = s.dynamicProps;
			for (let b = 0; b < y.length; b++) {
				const C = y[b];
				if (f[C] !== l[C] && !isEmitListener(v, C)) return !0
			}
		}
	} else return (c || m) && (!m || !m.$stable) ? !0 : l === f ? !1 : l ? f ? hasPropsChanged(l, f, v) : !0 : !!f;
	return !1
}

function hasPropsChanged(o, s, a) {
	const l = Object.keys(s);
	if (l.length !== Object.keys(o).length) return !0;
	for (let c = 0; c < l.length; c++) {
		const d = l[c];
		if (s[d] !== o[d] && !isEmitListener(a, d)) return !0
	}
	return !1
}

function updateHOCHostEl({
	vnode: o,
	parent: s
}, a) {
	for (; s;) {
		const l = s.subTree;
		if (l.suspense && l.suspense.activeBranch === o && (l.el = o.el), l === o)(o = s.vnode).el = a, s = s.parent;
		else break
	}
}
const isSuspense = o => o.__isSuspense;

function queueEffectWithSuspense(o, s) {
	s && s.pendingBranch ? isArray$3(o) ? s.effects.push(...o) : s.effects.push(o) : queuePostFlushCb(o)
}
const Fragment = Symbol.for("v-fgt"),
	Text = Symbol.for("v-txt"),
	Comment$1 = Symbol.for("v-cmt"),
	Static = Symbol.for("v-stc"),
	blockStack = [];
let currentBlock = null;

function openBlock(o = !1) {
	blockStack.push(currentBlock = o ? null : [])
}

function closeBlock() {
	blockStack.pop(), currentBlock = blockStack[blockStack.length - 1] || null
}
let isBlockTreeEnabled = 1;

function setBlockTracking(o, s = !1) {
	isBlockTreeEnabled += o, o < 0 && currentBlock && s && (currentBlock.hasOnce = !0)
}

function setupBlock(o) {
	return o.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null, closeBlock(),
		isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(o), o
}

function createElementBlock(o, s, a, l, c, d) {
	return setupBlock(createBaseVNode(o, s, a, l, c, d, !0))
}

function createBlock(o, s, a, l, c) {
	return setupBlock(createVNode(o, s, a, l, c, !0))
}

function isVNode(o) {
	return o ? o.__v_isVNode === !0 : !1
}

function isSameVNodeType(o, s) {
	return o.type === s.type && o.key === s.key
}
const normalizeKey = ({
		key: o
	}) => o ?? null,
	normalizeRef = ({
		ref: o,
		ref_key: s,
		ref_for: a
	}) => (typeof o == "number" && (o = "" + o), o != null ? isString$3(o) || isRef(o) || isFunction$3(o) ? {
		i: currentRenderingInstance,
		r: o,
		k: s,
		f: !!a
	} : o : null);

function createBaseVNode(o, s = null, a = null, l = 0, c = null, d = o === Fragment ? 0 : 1, f = !1, m = !1) {
	const g = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: o,
		props: s,
		key: s && normalizeKey(s),
		ref: s && normalizeRef(s),
		scopeId: currentScopeId,
		slotScopeIds: null,
		children: a,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetStart: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: d,
		patchFlag: l,
		dynamicProps: c,
		dynamicChildren: null,
		appContext: null,
		ctx: currentRenderingInstance
	};
	return m ? (normalizeChildren(g, a), d & 128 && o.normalize(g)) : a && (g.shapeFlag |= isString$3(a) ? 8 : 16),
		isBlockTreeEnabled > 0 && !f && currentBlock && (g.patchFlag > 0 || d & 6) && g.patchFlag !== 32 && currentBlock
		.push(g), g
}
const createVNode = _createVNode;

function _createVNode(o, s = null, a = null, l = 0, c = null, d = !1) {
	if ((!o || o === NULL_DYNAMIC_COMPONENT) && (o = Comment$1), isVNode(o)) {
		const m = cloneVNode(o, s, !0);
		return a && normalizeChildren(m, a), isBlockTreeEnabled > 0 && !d && currentBlock && (m.shapeFlag & 6 ?
			currentBlock[currentBlock.indexOf(o)] = m : currentBlock.push(m)), m.patchFlag = -2, m
	}
	if (isClassComponent(o) && (o = o.__vccOpts), s) {
		s = guardReactiveProps(s);
		let {
			class: m,
			style: g
		} = s;
		m && !isString$3(m) && (s.class = normalizeClass(m)), isObject$3(g) && (isProxy(g) && !isArray$3(g) && (g =
			extend({}, g)), s.style = normalizeStyle(g))
	}
	const f = isString$3(o) ? 1 : isSuspense(o) ? 128 : isTeleport(o) ? 64 : isObject$3(o) ? 4 : isFunction$3(o) ? 2 :
	0;
	return createBaseVNode(o, s, a, l, c, f, d, !0)
}

function guardReactiveProps(o) {
	return o ? isProxy(o) || isInternalObject(o) ? extend({}, o) : o : null
}

function cloneVNode(o, s, a = !1, l = !1) {
	const {
		props: c,
		ref: d,
		patchFlag: f,
		children: m,
		transition: g
	} = o, v = s ? mergeProps(c || {}, s) : c, y = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: o.type,
		props: v,
		key: v && normalizeKey(v),
		ref: s && s.ref ? a && d ? isArray$3(d) ? d.concat(normalizeRef(s)) : [d, normalizeRef(s)] : normalizeRef(
			s) : d,
		scopeId: o.scopeId,
		slotScopeIds: o.slotScopeIds,
		children: m,
		target: o.target,
		targetStart: o.targetStart,
		targetAnchor: o.targetAnchor,
		staticCount: o.staticCount,
		shapeFlag: o.shapeFlag,
		patchFlag: s && o.type !== Fragment ? f === -1 ? 16 : f | 16 : f,
		dynamicProps: o.dynamicProps,
		dynamicChildren: o.dynamicChildren,
		appContext: o.appContext,
		dirs: o.dirs,
		transition: g,
		component: o.component,
		suspense: o.suspense,
		ssContent: o.ssContent && cloneVNode(o.ssContent),
		ssFallback: o.ssFallback && cloneVNode(o.ssFallback),
		el: o.el,
		anchor: o.anchor,
		ctx: o.ctx,
		ce: o.ce
	};
	return g && l && setTransitionHooks(y, g.clone(y)), y
}

function createTextVNode(o = " ", s = 0) {
	return createVNode(Text, null, o, s)
}

function createStaticVNode(o, s) {
	const a = createVNode(Static, null, o);
	return a.staticCount = s, a
}

function createCommentVNode(o = "", s = !1) {
	return s ? (openBlock(), createBlock(Comment$1, null, o)) : createVNode(Comment$1, null, o)
}

function normalizeVNode(o) {
	return o == null || typeof o == "boolean" ? createVNode(Comment$1) : isArray$3(o) ? createVNode(Fragment, null, o
		.slice()) : isVNode(o) ? cloneIfMounted(o) : createVNode(Text, null, String(o))
}

function cloneIfMounted(o) {
	return o.el === null && o.patchFlag !== -1 || o.memo ? o : cloneVNode(o)
}

function normalizeChildren(o, s) {
	let a = 0;
	const {
		shapeFlag: l
	} = o;
	if (s == null) s = null;
	else if (isArray$3(s)) a = 16;
	else if (typeof s == "object")
		if (l & 65) {
			const c = s.default;
			c && (c._c && (c._d = !1), normalizeChildren(o, c()), c._c && (c._d = !0));
			return
		} else {
			a = 32;
			const c = s._;
			!c && !isInternalObject(s) ? s._ctx = currentRenderingInstance : c === 3 && currentRenderingInstance && (
				currentRenderingInstance.slots._ === 1 ? s._ = 1 : (s._ = 2, o.patchFlag |= 1024))
		}
	else isFunction$3(s) ? (s = {
		default: s,
		_ctx: currentRenderingInstance
	}, a = 32) : (s = String(s), l & 64 ? (a = 16, s = [createTextVNode(s)]) : a = 8);
	o.children = s, o.shapeFlag |= a
}

function mergeProps(...o) {
	const s = {};
	for (let a = 0; a < o.length; a++) {
		const l = o[a];
		for (const c in l)
			if (c === "class") s.class !== l.class && (s.class = normalizeClass([s.class, l.class]));
			else if (c === "style") s.style = normalizeStyle([s.style, l.style]);
		else if (isOn(c)) {
			const d = s[c],
				f = l[c];
			f && d !== f && !(isArray$3(d) && d.includes(f)) && (s[c] = d ? [].concat(d, f) : f)
		} else c !== "" && (s[c] = l[c])
	}
	return s
}

function invokeVNodeHook(o, s, a, l = null) {
	callWithAsyncErrorHandling(o, s, 7, [a, l])
}
const emptyAppContext = createAppContext();
let uid = 0;

function createComponentInstance(o, s, a) {
	const l = o.type,
		c = (s ? s.appContext : o.appContext) || emptyAppContext,
		d = {
			uid: uid++,
			vnode: o,
			type: l,
			parent: s,
			appContext: c,
			root: null,
			next: null,
			subTree: null,
			effect: null,
			update: null,
			job: null,
			scope: new EffectScope(!0),
			render: null,
			proxy: null,
			exposed: null,
			exposeProxy: null,
			withProxy: null,
			provides: s ? s.provides : Object.create(c.provides),
			ids: s ? s.ids : ["", 0, 0],
			accessCache: null,
			renderCache: [],
			components: null,
			directives: null,
			propsOptions: normalizePropsOptions(l, c),
			emitsOptions: normalizeEmitsOptions(l, c),
			emit: null,
			emitted: null,
			propsDefaults: EMPTY_OBJ,
			inheritAttrs: l.inheritAttrs,
			ctx: EMPTY_OBJ,
			data: EMPTY_OBJ,
			props: EMPTY_OBJ,
			attrs: EMPTY_OBJ,
			slots: EMPTY_OBJ,
			refs: EMPTY_OBJ,
			setupState: EMPTY_OBJ,
			setupContext: null,
			suspense: a,
			suspenseId: a ? a.pendingId : 0,
			asyncDep: null,
			asyncResolved: !1,
			isMounted: !1,
			isUnmounted: !1,
			isDeactivated: !1,
			bc: null,
			c: null,
			bm: null,
			m: null,
			bu: null,
			u: null,
			um: null,
			bum: null,
			da: null,
			a: null,
			rtg: null,
			rtc: null,
			ec: null,
			sp: null
		};
	return d.ctx = {
		_: d
	}, d.root = s ? s.root : d, d.emit = emit.bind(null, d), o.ce && o.ce(d), d
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance, setInSSRSetupState; {
	const o = getGlobalThis(),
		s = (a, l) => {
			let c;
			return (c = o[a]) || (c = o[a] = []), c.push(l), d => {
				c.length > 1 ? c.forEach(f => f(d)) : c[0](d)
			}
		};
	internalSetCurrentInstance = s("__VUE_INSTANCE_SETTERS__", a => currentInstance = a), setInSSRSetupState = s(
		"__VUE_SSR_SETTERS__", a => isInSSRComponentSetup = a)
}
const setCurrentInstance = o => {
		const s = currentInstance;
		return internalSetCurrentInstance(o), o.scope.on(), () => {
			o.scope.off(), internalSetCurrentInstance(s)
		}
	},
	unsetCurrentInstance = () => {
		currentInstance && currentInstance.scope.off(), internalSetCurrentInstance(null)
	};

function isStatefulComponent(o) {
	return o.vnode.shapeFlag & 4
}
let isInSSRComponentSetup = !1;

function setupComponent(o, s = !1, a = !1) {
	s && setInSSRSetupState(s);
	const {
		props: l,
		children: c
	} = o.vnode, d = isStatefulComponent(o);
	initProps(o, l, d, s), initSlots(o, c, a);
	const f = d ? setupStatefulComponent(o, s) : void 0;
	return s && setInSSRSetupState(!1), f
}

function setupStatefulComponent(o, s) {
	const a = o.type;
	o.accessCache = Object.create(null), o.proxy = new Proxy(o.ctx, PublicInstanceProxyHandlers);
	const {
		setup: l
	} = a;
	if (l) {
		pauseTracking();
		const c = o.setupContext = l.length > 1 ? createSetupContext(o) : null,
			d = setCurrentInstance(o),
			f = callWithErrorHandling(l, o, 0, [o.props, c]),
			m = isPromise$1(f);
		if (resetTracking(), d(), (m || o.sp) && !isAsyncWrapper(o) && markAsyncBoundary(o), m) {
			if (f.then(unsetCurrentInstance, unsetCurrentInstance), s) return f.then(g => {
				handleSetupResult(o, g)
			}).catch(g => {
				handleError(g, o, 0)
			});
			o.asyncDep = f
		} else handleSetupResult(o, f)
	} else finishComponentSetup(o)
}

function handleSetupResult(o, s, a) {
	isFunction$3(s) ? o.type.__ssrInlineRender ? o.ssrRender = s : o.render = s : isObject$3(s) && (o.setupState =
		proxyRefs(s)), finishComponentSetup(o)
}

function finishComponentSetup(o, s, a) {
	const l = o.type;
	o.render || (o.render = l.render || NOOP$1); {
		const c = setCurrentInstance(o);
		pauseTracking();
		try {
			applyOptions(o)
		} finally {
			resetTracking(), c()
		}
	}
}
const attrsProxyHandlers = {
	get(o, s) {
		return track(o, "get", ""), o[s]
	}
};

function createSetupContext(o) {
	const s = a => {
		o.exposed = a || {}
	};
	return {
		attrs: new Proxy(o.attrs, attrsProxyHandlers),
		slots: o.slots,
		emit: o.emit,
		expose: s
	}
}

function getComponentPublicInstance(o) {
	return o.exposed ? o.exposeProxy || (o.exposeProxy = new Proxy(proxyRefs(markRaw(o.exposed)), {
		get(s, a) {
			if (a in s) return s[a];
			if (a in publicPropertiesMap) return publicPropertiesMap[a](o)
		},
		has(s, a) {
			return a in s || a in publicPropertiesMap
		}
	})) : o.proxy
}
const classifyRE = /(?:^|[-_])(\w)/g,
	classify = o => o.replace(classifyRE, s => s.toUpperCase()).replace(/[-_]/g, "");

function getComponentName(o, s = !0) {
	return isFunction$3(o) ? o.displayName || o.name : o.name || s && o.__name
}

function formatComponentName(o, s, a = !1) {
	let l = getComponentName(s);
	if (!l && s.__file) {
		const c = s.__file.match(/([^/\\]+)\.\w+$/);
		c && (l = c[1])
	}
	if (!l && o && o.parent) {
		const c = d => {
			for (const f in d)
				if (d[f] === s) return f
		};
		l = c(o.components || o.parent.type.components) || c(o.appContext.components)
	}
	return l ? classify(l) : a ? "App" : "Anonymous"
}

function isClassComponent(o) {
	return isFunction$3(o) && "__vccOpts" in o
}
const computed = (o, s) => computed$1(o, s, isInSSRComponentSetup);

function h(o, s, a) {
	const l = arguments.length;
	return l === 2 ? isObject$3(s) && !isArray$3(s) ? isVNode(s) ? createVNode(o, null, [s]) : createVNode(o, s) :
		createVNode(o, null, s) : (l > 3 ? a = Array.prototype.slice.call(arguments, 2) : l === 3 && isVNode(a) && (
			a = [a]), createVNode(o, s, a))
}
const version = "3.5.13";
/**
 * @vue/runtime-dom v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let policy;
const tt = typeof window < "u" && window.trustedTypes;
if (tt) try {
	policy = tt.createPolicy("vue", {
		createHTML: o => o
	})
} catch {}
const unsafeToTrustedHTML = policy ? o => policy.createHTML(o) : o => o,
	svgNS = "http://www.w3.org/2000/svg",
	mathmlNS = "http://www.w3.org/1998/Math/MathML",
	doc = typeof document < "u" ? document : null,
	templateContainer = doc && doc.createElement("template"),
	nodeOps = {
		insert: (o, s, a) => {
			s.insertBefore(o, a || null)
		},
		remove: o => {
			const s = o.parentNode;
			s && s.removeChild(o)
		},
		createElement: (o, s, a, l) => {
			const c = s === "svg" ? doc.createElementNS(svgNS, o) : s === "mathml" ? doc.createElementNS(mathmlNS,
				o) : a ? doc.createElement(o, {
				is: a
			}) : doc.createElement(o);
			return o === "select" && l && l.multiple != null && c.setAttribute("multiple", l.multiple), c
		},
		createText: o => doc.createTextNode(o),
		createComment: o => doc.createComment(o),
		setText: (o, s) => {
			o.nodeValue = s
		},
		setElementText: (o, s) => {
			o.textContent = s
		},
		parentNode: o => o.parentNode,
		nextSibling: o => o.nextSibling,
		querySelector: o => doc.querySelector(o),
		setScopeId(o, s) {
			o.setAttribute(s, "")
		},
		insertStaticContent(o, s, a, l, c, d) {
			const f = a ? a.previousSibling : s.lastChild;
			if (c && (c === d || c.nextSibling))
				for (; s.insertBefore(c.cloneNode(!0), a), !(c === d || !(c = c.nextSibling)););
			else {
				templateContainer.innerHTML = unsafeToTrustedHTML(l === "svg" ? `<svg>${o}</svg>` : l === "mathml" ?
					`<math>${o}</math>` : o);
				const m = templateContainer.content;
				if (l === "svg" || l === "mathml") {
					const g = m.firstChild;
					for (; g.firstChild;) m.appendChild(g.firstChild);
					m.removeChild(g)
				}
				s.insertBefore(m, a)
			}
			return [f ? f.nextSibling : s.firstChild, a ? a.previousSibling : s.lastChild]
		}
	},
	TRANSITION = "transition",
	ANIMATION = "animation",
	vtcKey = Symbol("_vtc"),
	DOMTransitionPropsValidators = {
		name: String,
		type: String,
		css: {
			type: Boolean,
			default: !0
		},
		duration: [String, Number, Object],
		enterFromClass: String,
		enterActiveClass: String,
		enterToClass: String,
		appearFromClass: String,
		appearActiveClass: String,
		appearToClass: String,
		leaveFromClass: String,
		leaveActiveClass: String,
		leaveToClass: String
	},
	TransitionPropsValidators = extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators),
	decorate$1 = o => (o.displayName = "Transition", o.props = TransitionPropsValidators, o),
	Transition = decorate$1((o, {
		slots: s
	}) => h(BaseTransition, resolveTransitionProps(o), s)),
	callHook = (o, s = []) => {
		isArray$3(o) ? o.forEach(a => a(...s)) : o && o(...s)
	},
	hasExplicitCallback = o => o ? isArray$3(o) ? o.some(s => s.length > 1) : o.length > 1 : !1;

function resolveTransitionProps(o) {
	const s = {};
	for (const ge in o) ge in DOMTransitionPropsValidators || (s[ge] = o[ge]);
	if (o.css === !1) return s;
	const {
		name: a = "v",
		type: l,
		duration: c,
		enterFromClass: d = `${a}-enter-from`,
		enterActiveClass: f = `${a}-enter-active`,
		enterToClass: m = `${a}-enter-to`,
		appearFromClass: g = d,
		appearActiveClass: v = f,
		appearToClass: y = m,
		leaveFromClass: b = `${a}-leave-from`,
		leaveActiveClass: C = `${a}-leave-active`,
		leaveToClass: _ = `${a}-leave-to`
	} = o, S = normalizeDuration(c), w = S && S[0], T = S && S[1], {
		onBeforeEnter: A,
		onEnter: k,
		onEnterCancelled: M,
		onLeave: D,
		onLeaveCancelled: F,
		onBeforeAppear: R = A,
		onAppear: O = k,
		onAppearCancelled: U = M
	} = s, V = (ge, me, he, ce) => {
		ge._enterCancelled = ce, removeTransitionClass(ge, me ? y : m), removeTransitionClass(ge, me ? v : f), he &&
			he()
	}, z = (ge, me) => {
		ge._isLeaving = !1, removeTransitionClass(ge, b), removeTransitionClass(ge, _), removeTransitionClass(ge,
			C), me && me()
	}, j = ge => (me, he) => {
		const ce = ge ? O : k,
			ae = () => V(me, ge, he);
		callHook(ce, [me, ae]), nextFrame(() => {
			removeTransitionClass(me, ge ? g : d), addTransitionClass(me, ge ? y : m), hasExplicitCallback(
				ce) || whenTransitionEnds(me, l, w, ae)
		})
	};
	return extend(s, {
		onBeforeEnter(ge) {
			callHook(A, [ge]), addTransitionClass(ge, d), addTransitionClass(ge, f)
		},
		onBeforeAppear(ge) {
			callHook(R, [ge]), addTransitionClass(ge, g), addTransitionClass(ge, v)
		},
		onEnter: j(!1),
		onAppear: j(!0),
		onLeave(ge, me) {
			ge._isLeaving = !0;
			const he = () => z(ge, me);
			addTransitionClass(ge, b), ge._enterCancelled ? (addTransitionClass(ge, C), forceReflow()) : (
				forceReflow(), addTransitionClass(ge, C)), nextFrame(() => {
				ge._isLeaving && (removeTransitionClass(ge, b), addTransitionClass(ge, _),
					hasExplicitCallback(D) || whenTransitionEnds(ge, l, T, he))
			}), callHook(D, [ge, he])
		},
		onEnterCancelled(ge) {
			V(ge, !1, void 0, !0), callHook(M, [ge])
		},
		onAppearCancelled(ge) {
			V(ge, !0, void 0, !0), callHook(U, [ge])
		},
		onLeaveCancelled(ge) {
			z(ge), callHook(F, [ge])
		}
	})
}

function normalizeDuration(o) {
	if (o == null) return null;
	if (isObject$3(o)) return [NumberOf(o.enter), NumberOf(o.leave)]; {
		const s = NumberOf(o);
		return [s, s]
	}
}

function NumberOf(o) {
	return toNumber(o)
}

function addTransitionClass(o, s) {
	s.split(/\s+/).forEach(a => a && o.classList.add(a)), (o[vtcKey] || (o[vtcKey] = new Set)).add(s)
}

function removeTransitionClass(o, s) {
	s.split(/\s+/).forEach(l => l && o.classList.remove(l));
	const a = o[vtcKey];
	a && (a.delete(s), a.size || (o[vtcKey] = void 0))
}

function nextFrame(o) {
	requestAnimationFrame(() => {
		requestAnimationFrame(o)
	})
}
let endId = 0;

function whenTransitionEnds(o, s, a, l) {
	const c = o._endId = ++endId,
		d = () => {
			c === o._endId && l()
		};
	if (a != null) return setTimeout(d, a);
	const {
		type: f,
		timeout: m,
		propCount: g
	} = getTransitionInfo(o, s);
	if (!f) return l();
	const v = f + "end";
	let y = 0;
	const b = () => {
			o.removeEventListener(v, C), d()
		},
		C = _ => {
			_.target === o && ++y >= g && b()
		};
	setTimeout(() => {
		y < g && b()
	}, m + 1), o.addEventListener(v, C)
}

function getTransitionInfo(o, s) {
	const a = window.getComputedStyle(o),
		l = S => (a[S] || "").split(", "),
		c = l(`${TRANSITION}Delay`),
		d = l(`${TRANSITION}Duration`),
		f = getTimeout(c, d),
		m = l(`${ANIMATION}Delay`),
		g = l(`${ANIMATION}Duration`),
		v = getTimeout(m, g);
	let y = null,
		b = 0,
		C = 0;
	s === TRANSITION ? f > 0 && (y = TRANSITION, b = f, C = d.length) : s === ANIMATION ? v > 0 && (y = ANIMATION, b =
		v, C = g.length) : (b = Math.max(f, v), y = b > 0 ? f > v ? TRANSITION : ANIMATION : null, C = y ? y ===
		TRANSITION ? d.length : g.length : 0);
	const _ = y === TRANSITION && /\b(transform|all)(,|$)/.test(l(`${TRANSITION}Property`).toString());
	return {
		type: y,
		timeout: b,
		propCount: C,
		hasTransform: _
	}
}

function getTimeout(o, s) {
	for (; o.length < s.length;) o = o.concat(o);
	return Math.max(...s.map((a, l) => toMs(a) + toMs(o[l])))
}

function toMs(o) {
	return o === "auto" ? 0 : Number(o.slice(0, -1).replace(",", ".")) * 1e3
}

function forceReflow() {
	return document.body.offsetHeight
}

function patchClass(o, s, a) {
	const l = o[vtcKey];
	l && (s = (s ? [s, ...l] : [...l]).join(" ")), s == null ? o.removeAttribute("class") : a ? o.setAttribute("class",
		s) : o.className = s
}
const vShowOriginalDisplay = Symbol("_vod"),
	vShowHidden = Symbol("_vsh"),
	vShow = {
		beforeMount(o, {
			value: s
		}, {
			transition: a
		}) {
			o[vShowOriginalDisplay] = o.style.display === "none" ? "" : o.style.display, a && s ? a.beforeEnter(o) :
				setDisplay(o, s)
		},
		mounted(o, {
			value: s
		}, {
			transition: a
		}) {
			a && s && a.enter(o)
		},
		updated(o, {
			value: s,
			oldValue: a
		}, {
			transition: l
		}) {
			!s != !a && (l ? s ? (l.beforeEnter(o), setDisplay(o, !0), l.enter(o)) : l.leave(o, () => {
				setDisplay(o, !1)
			}) : setDisplay(o, s))
		},
		beforeUnmount(o, {
			value: s
		}) {
			setDisplay(o, s)
		}
	};

function setDisplay(o, s) {
	o.style.display = s ? o[vShowOriginalDisplay] : "none", o[vShowHidden] = !s
}
const CSS_VAR_TEXT = Symbol(""),
	displayRE = /(^|;)\s*display\s*:/;

function patchStyle(o, s, a) {
	const l = o.style,
		c = isString$3(a);
	let d = !1;
	if (a && !c) {
		if (s)
			if (isString$3(s))
				for (const f of s.split(";")) {
					const m = f.slice(0, f.indexOf(":")).trim();
					a[m] == null && setStyle(l, m, "")
				} else
					for (const f in s) a[f] == null && setStyle(l, f, "");
		for (const f in a) f === "display" && (d = !0), setStyle(l, f, a[f])
	} else if (c) {
		if (s !== a) {
			const f = l[CSS_VAR_TEXT];
			f && (a += ";" + f), l.cssText = a, d = displayRE.test(a)
		}
	} else s && o.removeAttribute("style");
	vShowOriginalDisplay in o && (o[vShowOriginalDisplay] = d ? l.display : "", o[vShowHidden] && (l.display = "none"))
}
const importantRE = /\s*!important$/;

function setStyle(o, s, a) {
	if (isArray$3(a)) a.forEach(l => setStyle(o, s, l));
	else if (a == null && (a = ""), s.startsWith("--")) o.setProperty(s, a);
	else {
		const l = autoPrefix(o, s);
		importantRE.test(a) ? o.setProperty(hyphenate(l), a.replace(importantRE, ""), "important") : o[l] = a
	}
}
const prefixes = ["Webkit", "Moz", "ms"],
	prefixCache = {};

function autoPrefix(o, s) {
	const a = prefixCache[s];
	if (a) return a;
	let l = camelize(s);
	if (l !== "filter" && l in o) return prefixCache[s] = l;
	l = capitalize(l);
	for (let c = 0; c < prefixes.length; c++) {
		const d = prefixes[c] + l;
		if (d in o) return prefixCache[s] = d
	}
	return s
}
const xlinkNS = "http://www.w3.org/1999/xlink";

function patchAttr(o, s, a, l, c, d = isSpecialBooleanAttr(s)) {
	l && s.startsWith("xlink:") ? a == null ? o.removeAttributeNS(xlinkNS, s.slice(6, s.length)) : o.setAttributeNS(
		xlinkNS, s, a) : a == null || d && !includeBooleanAttr(a) ? o.removeAttribute(s) : o.setAttribute(s, d ?
		"" : isSymbol(a) ? String(a) : a)
}

function patchDOMProp(o, s, a, l, c) {
	if (s === "innerHTML" || s === "textContent") {
		a != null && (o[s] = s === "innerHTML" ? unsafeToTrustedHTML(a) : a);
		return
	}
	const d = o.tagName;
	if (s === "value" && d !== "PROGRESS" && !d.includes("-")) {
		const m = d === "OPTION" ? o.getAttribute("value") || "" : o.value,
			g = a == null ? o.type === "checkbox" ? "on" : "" : String(a);
		(m !== g || !("_value" in o)) && (o.value = g), a == null && o.removeAttribute(s), o._value = a;
		return
	}
	let f = !1;
	if (a === "" || a == null) {
		const m = typeof o[s];
		m === "boolean" ? a = includeBooleanAttr(a) : a == null && m === "string" ? (a = "", f = !0) : m === "number" &&
			(a = 0, f = !0)
	}
	try {
		o[s] = a
	} catch {}
	f && o.removeAttribute(c || s)
}

function addEventListener(o, s, a, l) {
	o.addEventListener(s, a, l)
}

function removeEventListener(o, s, a, l) {
	o.removeEventListener(s, a, l)
}
const veiKey = Symbol("_vei");

function patchEvent(o, s, a, l, c = null) {
	const d = o[veiKey] || (o[veiKey] = {}),
		f = d[s];
	if (l && f) f.value = l;
	else {
		const [m, g] = parseName(s);
		if (l) {
			const v = d[s] = createInvoker(l, c);
			addEventListener(o, m, v, g)
		} else f && (removeEventListener(o, m, f, g), d[s] = void 0)
	}
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;

function parseName(o) {
	let s;
	if (optionsModifierRE.test(o)) {
		s = {};
		let l;
		for (; l = o.match(optionsModifierRE);) o = o.slice(0, o.length - l[0].length), s[l[0].toLowerCase()] = !0
	}
	return [o[2] === ":" ? o.slice(3) : hyphenate(o.slice(2)), s]
}
let cachedNow = 0;
const p = Promise.resolve(),
	getNow$1 = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());

function createInvoker(o, s) {
	const a = l => {
		if (!l._vts) l._vts = Date.now();
		else if (l._vts <= a.attached) return;
		callWithAsyncErrorHandling(patchStopImmediatePropagation(l, a.value), s, 5, [l])
	};
	return a.value = o, a.attached = getNow$1(), a
}

function patchStopImmediatePropagation(o, s) {
	if (isArray$3(s)) {
		const a = o.stopImmediatePropagation;
		return o.stopImmediatePropagation = () => {
			a.call(o), o._stopped = !0
		}, s.map(l => c => !c._stopped && l && l(c))
	} else return s
}
const isNativeOn = o => o.charCodeAt(0) === 111 && o.charCodeAt(1) === 110 && o.charCodeAt(2) > 96 && o.charCodeAt(2) <
	123,
	patchProp = (o, s, a, l, c, d) => {
		const f = c === "svg";
		s === "class" ? patchClass(o, l, f) : s === "style" ? patchStyle(o, a, l) : isOn(s) ? isModelListener(s) ||
			patchEvent(o, s, a, l, d) : (s[0] === "." ? (s = s.slice(1), !0) : s[0] === "^" ? (s = s.slice(1), !1) :
				shouldSetAsProp(o, s, l, f)) ? (patchDOMProp(o, s, l), !o.tagName.includes("-") && (s === "value" ||
				s === "checked" || s === "selected") && patchAttr(o, s, l, f, d, s !== "value")) : o._isVueCE && (
				/[A-Z]/.test(s) || !isString$3(l)) ? patchDOMProp(o, camelize(s), l, d, s) : (s === "true-value" ? o
				._trueValue = l : s === "false-value" && (o._falseValue = l), patchAttr(o, s, l, f))
	};

function shouldSetAsProp(o, s, a, l) {
	if (l) return !!(s === "innerHTML" || s === "textContent" || s in o && isNativeOn(s) && isFunction$3(a));
	if (s === "spellcheck" || s === "draggable" || s === "translate" || s === "form" || s === "list" && o.tagName ===
		"INPUT" || s === "type" && o.tagName === "TEXTAREA") return !1;
	if (s === "width" || s === "height") {
		const c = o.tagName;
		if (c === "IMG" || c === "VIDEO" || c === "CANVAS" || c === "SOURCE") return !1
	}
	return isNativeOn(s) && isString$3(a) ? !1 : s in o
}
const positionMap = new WeakMap,
	newPositionMap = new WeakMap,
	moveCbKey = Symbol("_moveCb"),
	enterCbKey = Symbol("_enterCb"),
	decorate = o => (delete o.props.mode, o),
	TransitionGroupImpl = decorate({
		name: "TransitionGroup",
		props: extend({}, TransitionPropsValidators, {
			tag: String,
			moveClass: String
		}),
		setup(o, {
			slots: s
		}) {
			const a = getCurrentInstance(),
				l = useTransitionState();
			let c, d;
			return onUpdated(() => {
				if (!c.length) return;
				const f = o.moveClass || `${o.name||"v"}-move`;
				if (!hasCSSTransform(c[0].el, a.vnode.el, f)) return;
				c.forEach(callPendingCbs), c.forEach(recordPosition);
				const m = c.filter(applyTranslation);
				forceReflow(), m.forEach(g => {
					const v = g.el,
						y = v.style;
					addTransitionClass(v, f), y.transform = y.webkitTransform = y
						.transitionDuration = "";
					const b = v[moveCbKey] = C => {
						C && C.target !== v || (!C || /transform$/.test(C.propertyName)) && (v
							.removeEventListener("transitionend", b), v[moveCbKey] = null,
							removeTransitionClass(v, f))
					};
					v.addEventListener("transitionend", b)
				})
			}), () => {
				const f = toRaw(o),
					m = resolveTransitionProps(f);
				let g = f.tag || Fragment;
				if (c = [], d)
					for (let v = 0; v < d.length; v++) {
						const y = d[v];
						y.el && y.el instanceof Element && (c.push(y), setTransitionHooks(y,
							resolveTransitionHooks(y, m, l, a)), positionMap.set(y, y.el
							.getBoundingClientRect()))
					}
				d = s.default ? getTransitionRawChildren(s.default()) : [];
				for (let v = 0; v < d.length; v++) {
					const y = d[v];
					y.key != null && setTransitionHooks(y, resolveTransitionHooks(y, m, l, a))
				}
				return createVNode(g, null, d)
			}
		}
	}),
	TransitionGroup = TransitionGroupImpl;

function callPendingCbs(o) {
	const s = o.el;
	s[moveCbKey] && s[moveCbKey](), s[enterCbKey] && s[enterCbKey]()
}

function recordPosition(o) {
	newPositionMap.set(o, o.el.getBoundingClientRect())
}

function applyTranslation(o) {
	const s = positionMap.get(o),
		a = newPositionMap.get(o),
		l = s.left - a.left,
		c = s.top - a.top;
	if (l || c) {
		const d = o.el.style;
		return d.transform = d.webkitTransform = `translate(${l}px,${c}px)`, d.transitionDuration = "0s", o
	}
}

function hasCSSTransform(o, s, a) {
	const l = o.cloneNode(),
		c = o[vtcKey];
	c && c.forEach(m => {
		m.split(/\s+/).forEach(g => g && l.classList.remove(g))
	}), a.split(/\s+/).forEach(m => m && l.classList.add(m)), l.style.display = "none";
	const d = s.nodeType === 1 ? s : s.parentNode;
	d.appendChild(l);
	const {
		hasTransform: f
	} = getTransitionInfo(l);
	return d.removeChild(l), f
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"],
	modifierGuards = {
		stop: o => o.stopPropagation(),
		prevent: o => o.preventDefault(),
		self: o => o.target !== o.currentTarget,
		ctrl: o => !o.ctrlKey,
		shift: o => !o.shiftKey,
		alt: o => !o.altKey,
		meta: o => !o.metaKey,
		left: o => "button" in o && o.button !== 0,
		middle: o => "button" in o && o.button !== 1,
		right: o => "button" in o && o.button !== 2,
		exact: (o, s) => systemModifiers.some(a => o[`${a}Key`] && !s.includes(a))
	},
	withModifiers = (o, s) => {
		const a = o._withMods || (o._withMods = {}),
			l = s.join(".");
		return a[l] || (a[l] = (c, ...d) => {
			for (let f = 0; f < s.length; f++) {
				const m = modifierGuards[s[f]];
				if (m && m(c, s)) return
			}
			return o(c, ...d)
		})
	},
	keyNames = {
		esc: "escape",
		space: " ",
		up: "arrow-up",
		left: "arrow-left",
		right: "arrow-right",
		down: "arrow-down",
		delete: "backspace"
	},
	withKeys = (o, s) => {
		const a = o._withKeys || (o._withKeys = {}),
			l = s.join(".");
		return a[l] || (a[l] = c => {
			if (!("key" in c)) return;
			const d = hyphenate(c.key);
			if (s.some(f => f === d || keyNames[f] === d)) return o(c)
		})
	},
	rendererOptions = extend({
		patchProp
	}, nodeOps);
let renderer;

function ensureRenderer() {
	return renderer || (renderer = createRenderer(rendererOptions))
}
const render = (...o) => {
		ensureRenderer().render(...o)
	},
	createApp = (...o) => {
		const s = ensureRenderer().createApp(...o),
			{
				mount: a
			} = s;
		return s.mount = l => {
			const c = normalizeContainer(l);
			if (!c) return;
			const d = s._component;
			!isFunction$3(d) && !d.render && !d.template && (d.template = c.innerHTML), c.nodeType === 1 && (c
				.textContent = "");
			const f = a(c, !1, resolveRootNamespace(c));
			return c instanceof Element && (c.removeAttribute("v-cloak"), c.setAttribute("data-v-app", "")), f
		}, s
	};

function resolveRootNamespace(o) {
	if (o instanceof SVGElement) return "svg";
	if (typeof MathMLElement == "function" && o instanceof MathMLElement) return "mathml"
}

function normalizeContainer(o) {
	return isString$3(o) ? document.querySelector(o) : o
}
const opt$1 = Object.prototype.toString;

function isArray$2(o) {
	return opt$1.call(o) === "[object Array]"
}

function isNull$1(o) {
	return opt$1.call(o) === "[object Null]"
}

function isBoolean$2(o) {
	return opt$1.call(o) === "[object Boolean]"
}

function isObject$2(o) {
	return opt$1.call(o) === "[object Object]"
}
const isPromise = o => opt$1.call(o) === "[object Promise]";

function isString$2(o) {
	return opt$1.call(o) === "[object String]"
}

function isNumber$2(o) {
	return opt$1.call(o) === "[object Number]" && o === o
}

function isUndefined$1(o) {
	return o === void 0
}

function isFunction$2(o) {
	return typeof o == "function"
}

function isEmptyObject$1(o) {
	return isObject$2(o) && Object.keys(o).length === 0
}

function isExist(o) {
	return o || o === 0
}

function isWindow(o) {
	return o === window
}
const isComponentInstance = o => (o == null ? void 0 : o.$) !== void 0,
	isQuarter = o => /\[Q]Q/.test(o);

function isDayjs(o) {
	return isObject$2(o) && "$y" in o && "$M" in o && "$D" in o && "$d" in o && "$H" in o && "$m" in o && "$s" in o
}
const configProviderInjectionKey = Symbol("ArcoConfigProvider"),
	calendarLang = {
		formatYear: "YYYY 年",
		formatMonth: "YYYY 年 MM 月",
		today: "今天",
		view: {
			month: "月",
			year: "年",
			week: "周",
			day: "日"
		},
		month: {
			long: {
				January: "一月",
				February: "二月",
				March: "三月",
				April: "四月",
				May: "五月",
				June: "六月",
				July: "七月",
				August: "八月",
				September: "九月",
				October: "十月",
				November: "十一月",
				December: "十二月"
			},
			short: {
				January: "一月",
				February: "二月",
				March: "三月",
				April: "四月",
				May: "五月",
				June: "六月",
				July: "七月",
				August: "八月",
				September: "九月",
				October: "十月",
				November: "十一月",
				December: "十二月"
			}
		},
		week: {
			long: {
				self: "周",
				monday: "周一",
				tuesday: "周二",
				wednesday: "周三",
				thursday: "周四",
				friday: "周五",
				saturday: "周六",
				sunday: "周日"
			},
			short: {
				self: "周",
				monday: "一",
				tuesday: "二",
				wednesday: "三",
				thursday: "四",
				friday: "五",
				saturday: "六",
				sunday: "日"
			}
		}
	},
	lang = {
		locale: "zh-CN",
		empty: {
			description: "暂无数据"
		},
		drawer: {
			okText: "确定",
			cancelText: "取消"
		},
		popconfirm: {
			okText: "确定",
			cancelText: "取消"
		},
		modal: {
			okText: "确定",
			cancelText: "取消"
		},
		pagination: {
			goto: "前往",
			page: "页",
			countPerPage: "条/页",
			total: "共 {0} 条"
		},
		table: {
			okText: "确定",
			resetText: "重置"
		},
		upload: {
			start: "开始",
			cancel: "取消",
			delete: "删除",
			retry: "点击重试",
			buttonText: "点击上传",
			preview: "预览",
			drag: "点击或拖拽文件到此处上传",
			dragHover: "释放文件并开始上传",
			error: "上传失败"
		},
		calendar: calendarLang,
		datePicker: {
			view: calendarLang.view,
			month: calendarLang.month,
			week: calendarLang.week,
			placeholder: {
				date: "请选择日期",
				week: "请选择周",
				month: "请选择月份",
				year: "请选择年份",
				quarter: "请选择季度",
				time: "请选择时间"
			},
			rangePlaceholder: {
				date: ["开始日期", "结束日期"],
				week: ["开始周", "结束周"],
				month: ["开始月份", "结束月份"],
				year: ["开始年份", "结束年份"],
				quarter: ["开始季度", "结束季度"],
				time: ["开始时间", "结束时间"]
			},
			selectTime: "选择时间",
			today: "今天",
			now: "此刻",
			ok: "确定"
		},
		image: {
			loading: "加载中"
		},
		imagePreview: {
			fullScreen: "全屏",
			rotateRight: "向右旋转",
			rotateLeft: "向左旋转",
			zoomIn: "放大",
			zoomOut: "缩小",
			originalSize: "原始尺寸"
		},
		typography: {
			copied: "已复制",
			copy: "复制",
			expand: "展开",
			collapse: "折叠",
			edit: "编辑"
		},
		form: {
			validateMessages: {
				required: "#{field} 是必填项",
				type: {
					string: "#{field} 不是合法的文本类型",
					number: "#{field} 不是合法的数字类型",
					boolean: "#{field} 不是合法的布尔类型",
					array: "#{field} 不是合法的数组类型",
					object: "#{field} 不是合法的对象类型",
					url: "#{field} 不是合法的 url 地址",
					email: "#{field} 不是合法的邮箱地址",
					ip: "#{field} 不是合法的 IP 地址"
				},
				number: {
					min: "`#{value}` 小于最小值 `#{min}`",
					max: "`#{value}` 大于最大值 `#{max}`",
					equal: "`#{value}` 不等于 `#{equal}`",
					range: "`#{value}` 不在 `#{min} ~ #{max}` 范围内",
					positive: "`#{value}` 不是正数",
					negative: "`#{value}` 不是负数"
				},
				array: {
					length: "`#{field}` 个数不等于 #{length}",
					minLength: "`#{field}` 个数最少为 #{minLength}",
					maxLength: "`#{field}` 个数最多为 #{maxLength}",
					includes: "#{field} 不包含 #{includes}",
					deepEqual: "#{field} 不等于 #{deepEqual}",
					empty: "`#{field}` 不是空数组"
				},
				string: {
					minLength: "字符数最少为 #{minLength}",
					maxLength: "字符数最多为 #{maxLength}",
					length: "字符数必须是 #{length}",
					match: "`#{value}` 不符合模式 #{pattern}",
					uppercase: "`#{value}` 必须全大写",
					lowercase: "`#{value}` 必须全小写"
				},
				object: {
					deepEqual: "`#{field}` 不等于期望值",
					hasKeys: "`#{field}` 不包含必须字段",
					empty: "`#{field}` 不是对象"
				},
				boolean: {
					true: "期望是 `true`",
					false: "期望是 `false`"
				}
			}
		},
		colorPicker: {
			history: "最近使用颜色",
			preset: "系统预设颜色",
			empty: "暂无"
		}
	},
	LOCALE = ref("zh-CN"),
	I18N_MESSAGES = reactive({
		"zh-CN": lang
	}),
	addI18nMessages = (o, s) => {
		for (const a of Object.keys(o))(!I18N_MESSAGES[a] || s != null && s.overwrite) && (I18N_MESSAGES[a] = o[a])
	},
	useLocale = o => {
		if (!I18N_MESSAGES[o]) {
			console.warn(`use ${o} failed! Please add ${o} first`);
			return
		}
		LOCALE.value = o
	},
	getLocale = () => LOCALE.value,
	useI18n = () => {
		const o = inject(configProviderInjectionKey, void 0),
			s = computed(() => {
				var c;
				return (c = o == null ? void 0 : o.locale) != null ? c : I18N_MESSAGES[LOCALE.value]
			}),
			a = computed(() => s.value.locale);
		return {
			i18nMessage: s,
			locale: a,
			t: (c, ...d) => {
				const f = c.split(".");
				let m = s.value;
				for (const g of f) {
					if (!m[g]) return c;
					m = m[g]
				}
				return isString$2(m) && d.length > 0 ? m.replace(/{(\d+)}/g, (g, v) => {
					var y;
					return (y = d[v]) != null ? y : g
				}) : m
			}
		}
	},
	COMPONENT_PREFIX = "A",
	CLASS_PREFIX = "arco",
	GLOBAL_CONFIG_NAME = "$arco",
	getComponentPrefix = o => {
		var s;
		return (s = o == null ? void 0 : o.componentPrefix) != null ? s : COMPONENT_PREFIX
	},
	setGlobalConfig = (o, s) => {
		var a;
		s && s.classPrefix && (o.config.globalProperties[GLOBAL_CONFIG_NAME] = {
			...(a = o.config.globalProperties[GLOBAL_CONFIG_NAME]) != null ? a : {},
			classPrefix: s.classPrefix
		})
	},
	getPrefixCls = o => {
		var s, a, l;
		const c = getCurrentInstance(),
			d = inject(configProviderInjectionKey, void 0),
			f = (l = (a = d == null ? void 0 : d.prefixCls) != null ? a : (s = c == null ? void 0 : c.appContext.config
				.globalProperties[GLOBAL_CONFIG_NAME]) == null ? void 0 : s.classPrefix) != null ? l : CLASS_PREFIX;
		return o ? `${f}-${o}` : f
	};
var MapShim = function() {
		if (typeof Map < "u") return Map;

		function o(s, a) {
			var l = -1;
			return s.some(function(c, d) {
				return c[0] === a ? (l = d, !0) : !1
			}), l
		}
		return function() {
			function s() {
				this.__entries__ = []
			}
			return Object.defineProperty(s.prototype, "size", {
				get: function() {
					return this.__entries__.length
				},
				enumerable: !0,
				configurable: !0
			}), s.prototype.get = function(a) {
				var l = o(this.__entries__, a),
					c = this.__entries__[l];
				return c && c[1]
			}, s.prototype.set = function(a, l) {
				var c = o(this.__entries__, a);
				~c ? this.__entries__[c][1] = l : this.__entries__.push([a, l])
			}, s.prototype.delete = function(a) {
				var l = this.__entries__,
					c = o(l, a);
				~c && l.splice(c, 1)
			}, s.prototype.has = function(a) {
				return !!~o(this.__entries__, a)
			}, s.prototype.clear = function() {
				this.__entries__.splice(0)
			}, s.prototype.forEach = function(a, l) {
				l === void 0 && (l = null);
				for (var c = 0, d = this.__entries__; c < d.length; c++) {
					var f = d[c];
					a.call(l, f[1], f[0])
				}
			}, s
		}()
	}(),
	isBrowser = typeof window < "u" && typeof document < "u" && window.document === document,
	global$1 = function() {
		return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self :
			typeof window < "u" && window.Math === Math ? window : Function("return this")()
	}(),
	requestAnimationFrame$1 = function() {
		return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function(o) {
			return setTimeout(function() {
				return o(Date.now())
			}, 1e3 / 60)
		}
	}(),
	trailingTimeout = 2;

function throttle$1(o, s) {
	var a = !1,
		l = !1,
		c = 0;

	function d() {
		a && (a = !1, o()), l && m()
	}

	function f() {
		requestAnimationFrame$1(d)
	}

	function m() {
		var g = Date.now();
		if (a) {
			if (g - c < trailingTimeout) return;
			l = !0
		} else a = !0, l = !1, setTimeout(f, s);
		c = g
	}
	return m
}
var REFRESH_DELAY = 20,
	transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
	mutationObserverSupported = typeof MutationObserver < "u",
	ResizeObserverController = function() {
		function o() {
			this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [],
				this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle$1(this.refresh.bind(
					this), REFRESH_DELAY)
		}
		return o.prototype.addObserver = function(s) {
			~this.observers_.indexOf(s) || this.observers_.push(s), this.connected_ || this.connect_()
		}, o.prototype.removeObserver = function(s) {
			var a = this.observers_,
				l = a.indexOf(s);
			~l && a.splice(l, 1), !a.length && this.connected_ && this.disconnect_()
		}, o.prototype.refresh = function() {
			var s = this.updateObservers_();
			s && this.refresh()
		}, o.prototype.updateObservers_ = function() {
			var s = this.observers_.filter(function(a) {
				return a.gatherActive(), a.hasActive()
			});
			return s.forEach(function(a) {
				return a.broadcastActive()
			}), s.length > 0
		}, o.prototype.connect_ = function() {
			!isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_),
				window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this
					.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(
						document, {
							attributes: !0,
							childList: !0,
							characterData: !0,
							subtree: !0
						})) : (document.addEventListener("DOMSubtreeModified", this.refresh), this
					.mutationEventsAdded_ = !0), this.connected_ = !0)
		}, o.prototype.disconnect_ = function() {
			!isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_),
				window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this
				.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener(
					"DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this
				.mutationEventsAdded_ = !1, this.connected_ = !1)
		}, o.prototype.onTransitionEnd_ = function(s) {
			var a = s.propertyName,
				l = a === void 0 ? "" : a,
				c = transitionKeys.some(function(d) {
					return !!~l.indexOf(d)
				});
			c && this.refresh()
		}, o.getInstance = function() {
			return this.instance_ || (this.instance_ = new o), this.instance_
		}, o.instance_ = null, o
	}(),
	defineConfigurable = function(o, s) {
		for (var a = 0, l = Object.keys(s); a < l.length; a++) {
			var c = l[a];
			Object.defineProperty(o, c, {
				value: s[c],
				enumerable: !1,
				writable: !1,
				configurable: !0
			})
		}
		return o
	},
	getWindowOf = function(o) {
		var s = o && o.ownerDocument && o.ownerDocument.defaultView;
		return s || global$1
	},
	emptyRect = createRectInit(0, 0, 0, 0);

function toFloat(o) {
	return parseFloat(o) || 0
}

function getBordersSize(o) {
	for (var s = [], a = 1; a < arguments.length; a++) s[a - 1] = arguments[a];
	return s.reduce(function(l, c) {
		var d = o["border-" + c + "-width"];
		return l + toFloat(d)
	}, 0)
}

function getPaddings(o) {
	for (var s = ["top", "right", "bottom", "left"], a = {}, l = 0, c = s; l < c.length; l++) {
		var d = c[l],
			f = o["padding-" + d];
		a[d] = toFloat(f)
	}
	return a
}

function getSVGContentRect(o) {
	var s = o.getBBox();
	return createRectInit(0, 0, s.width, s.height)
}

function getHTMLElementContentRect(o) {
	var s = o.clientWidth,
		a = o.clientHeight;
	if (!s && !a) return emptyRect;
	var l = getWindowOf(o).getComputedStyle(o),
		c = getPaddings(l),
		d = c.left + c.right,
		f = c.top + c.bottom,
		m = toFloat(l.width),
		g = toFloat(l.height);
	if (l.boxSizing === "border-box" && (Math.round(m + d) !== s && (m -= getBordersSize(l, "left", "right") + d), Math
			.round(g + f) !== a && (g -= getBordersSize(l, "top", "bottom") + f)), !isDocumentElement(o)) {
		var v = Math.round(m + d) - s,
			y = Math.round(g + f) - a;
		Math.abs(v) !== 1 && (m -= v), Math.abs(y) !== 1 && (g -= y)
	}
	return createRectInit(c.left, c.top, m, g)
}
var isSVGGraphicsElement = function() {
	return typeof SVGGraphicsElement < "u" ? function(o) {
		return o instanceof getWindowOf(o).SVGGraphicsElement
	} : function(o) {
		return o instanceof getWindowOf(o).SVGElement && typeof o.getBBox == "function"
	}
}();

function isDocumentElement(o) {
	return o === getWindowOf(o).document.documentElement
}

function getContentRect(o) {
	return isBrowser ? isSVGGraphicsElement(o) ? getSVGContentRect(o) : getHTMLElementContentRect(o) : emptyRect
}

function createReadOnlyRect(o) {
	var s = o.x,
		a = o.y,
		l = o.width,
		c = o.height,
		d = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
		f = Object.create(d.prototype);
	return defineConfigurable(f, {
		x: s,
		y: a,
		width: l,
		height: c,
		top: a,
		right: s + l,
		bottom: c + a,
		left: s
	}), f
}

function createRectInit(o, s, a, l) {
	return {
		x: o,
		y: s,
		width: a,
		height: l
	}
}
var ResizeObservation = function() {
		function o(s) {
			this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this
				.target = s
		}
		return o.prototype.isActive = function() {
			var s = getContentRect(this.target);
			return this.contentRect_ = s, s.width !== this.broadcastWidth || s.height !== this.broadcastHeight
		}, o.prototype.broadcastRect = function() {
			var s = this.contentRect_;
			return this.broadcastWidth = s.width, this.broadcastHeight = s.height, s
		}, o
	}(),
	ResizeObserverEntry = function() {
		function o(s, a) {
			var l = createReadOnlyRect(a);
			defineConfigurable(this, {
				target: s,
				contentRect: l
			})
		}
		return o
	}(),
	ResizeObserverSPI = function() {
		function o(s, a, l) {
			if (this.activeObservations_ = [], this.observations_ = new MapShim, typeof s != "function")
			throw new TypeError("The callback provided as parameter 1 is not a function.");
			this.callback_ = s, this.controller_ = a, this.callbackCtx_ = l
		}
		return o.prototype.observe = function(s) {
			if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
			if (!(typeof Element > "u" || !(Element instanceof Object))) {
				if (!(s instanceof getWindowOf(s).Element)) throw new TypeError(
					'parameter 1 is not of type "Element".');
				var a = this.observations_;
				a.has(s) || (a.set(s, new ResizeObservation(s)), this.controller_.addObserver(this), this
					.controller_.refresh())
			}
		}, o.prototype.unobserve = function(s) {
			if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
			if (!(typeof Element > "u" || !(Element instanceof Object))) {
				if (!(s instanceof getWindowOf(s).Element)) throw new TypeError(
					'parameter 1 is not of type "Element".');
				var a = this.observations_;
				a.has(s) && (a.delete(s), a.size || this.controller_.removeObserver(this))
			}
		}, o.prototype.disconnect = function() {
			this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this)
		}, o.prototype.gatherActive = function() {
			var s = this;
			this.clearActive(), this.observations_.forEach(function(a) {
				a.isActive() && s.activeObservations_.push(a)
			})
		}, o.prototype.broadcastActive = function() {
			if (this.hasActive()) {
				var s = this.callbackCtx_,
					a = this.activeObservations_.map(function(l) {
						return new ResizeObserverEntry(l.target, l.broadcastRect())
					});
				this.callback_.call(s, a, s), this.clearActive()
			}
		}, o.prototype.clearActive = function() {
			this.activeObservations_.splice(0)
		}, o.prototype.hasActive = function() {
			return this.activeObservations_.length > 0
		}, o
	}(),
	observers = typeof WeakMap < "u" ? new WeakMap : new MapShim,
	ResizeObserver$3 = function() {
		function o(s) {
			if (!(this instanceof o)) throw new TypeError("Cannot call a class as a function.");
			if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
			var a = ResizeObserverController.getInstance(),
				l = new ResizeObserverSPI(s, a, this);
			observers.set(this, l)
		}
		return o
	}();
["observe", "unobserve", "disconnect"].forEach(function(o) {
	ResizeObserver$3.prototype[o] = function() {
		var s;
		return (s = observers.get(this))[o].apply(s, arguments)
	}
});
var index$1 = function() {
	return typeof global$1.ResizeObserver < "u" ? global$1.ResizeObserver : ResizeObserver$3
}();
const isElement = o => !!(o && o.shapeFlag & 1),
	isComponent = (o, s) => !!(o && o.shapeFlag & 6),
	isTextChildren = (o, s) => !!(o && o.shapeFlag & 8),
	isArrayChildren = (o, s) => !!(o && o.shapeFlag & 16),
	isSlotsChildren = (o, s) => !!(o && o.shapeFlag & 32),
	getFirstComponent = o => {
		var s, a;
		if (o)
			for (const l of o) {
				if (isElement(l) || isComponent(l)) return l;
				if (isArrayChildren(l, l.children)) {
					const c = getFirstComponent(l.children);
					if (c) return c
				} else if (isSlotsChildren(l, l.children)) {
					const c = (a = (s = l.children).default) == null ? void 0 : a.call(s);
					if (c) {
						const d = getFirstComponent(c);
						if (d) return d
					}
				} else if (isArray$2(l)) {
					const c = getFirstComponent(l);
					if (c) return c
				}
			}
	},
	isEmptyChildren = o => {
		if (!o) return !0;
		for (const s of o)
			if (s.children) return !1;
		return !0
	},
	mergeFirstChild = (o, s) => {
		if (o && o.length > 0)
			for (let a = 0; a < o.length; a++) {
				const l = o[a];
				if (isElement(l) || isComponent(l)) {
					const d = isFunction$2(s) ? s(l) : s;
					return o[a] = cloneVNode(l, d, !0), !0
				}
				const c = getChildrenArray(l);
				if (c && c.length > 0 && mergeFirstChild(c, s)) return !0
			}
		return !1
	},
	getChildrenArray = o => {
		if (isArrayChildren(o, o.children)) return o.children;
		if (isArray$2(o)) return o
	},
	getFirstElementFromVNode = o => {
		var s, a;
		if (isElement(o)) return o.el;
		if (isComponent(o)) {
			if (((s = o.el) == null ? void 0 : s.nodeType) === 1) return o.el;
			if ((a = o.component) != null && a.subTree) {
				const l = getFirstElementFromVNode(o.component.subTree);
				if (l) return l
			}
		} else {
			const l = getChildrenArray(o);
			return getFirstElementFromChildren(l)
		}
	},
	getFirstElementFromChildren = o => {
		if (o && o.length > 0)
			for (const s of o) {
				const a = getFirstElementFromVNode(s);
				if (a) return a
			}
	},
	getAllElements = (o, s = !1) => {
		var a, l;
		const c = [];
		for (const d of o ?? []) isElement(d) || isComponent(d) || s && isTextChildren(d, d.children) ? c.push(d) :
			isArrayChildren(d, d.children) ? c.push(...getAllElements(d.children, s)) : isSlotsChildren(d, d.children) ?
			c.push(...getAllElements((l = (a = d.children).default) == null ? void 0 : l.call(a), s)) : isArray$2(d) &&
			c.push(...getAllElements(d, s));
		return c
	};

function unFragment(o) {
	function s(a) {
		const l = [];
		return a.forEach(c => {
			var d, f;
			isVNode(c) && c.type === Fragment ? isSlotsChildren(c, c.children) ? l.push(...s(((f = (d = c
					.children).default) == null ? void 0 : f.call(d)) || [])) : isArrayChildren(c, c.children) ?
				l.push(...s(c.children)) : isString$2(c.children) && l.push(c.children) : l.push(c)
		}), l
	}
	return s(o)
}
const getSlotFunction = o => {
		if (o) return isFunction$2(o) ? o : () => o
	},
	getComponentsFromVNode = (o, s) => {
		var a;
		const l = [];
		if (isComponent(o, o.type)) o.type.name === s ? o.component && l.push(o.component.uid) : (a = o.component) !=
			null && a.subTree && l.push(...getComponentsFromVNode(o.component.subTree, s));
		else {
			const c = getChildrenArray(o);
			c && l.push(...getComponentsFromChildren(c, s))
		}
		return l
	},
	getComponentsFromChildren = (o, s) => {
		const a = [];
		if (o && o.length > 0)
			for (const l of o) a.push(...getComponentsFromVNode(l, s));
		return a
	};
var ResizeObserver$2 = defineComponent({
	name: "ResizeObserver",
	emits: ["resize"],
	setup(o, {
		emit: s,
		slots: a
	}) {
		let l;
		const c = ref(),
			d = computed(() => isComponentInstance(c.value) ? c.value.$el : c.value),
			f = g => {
				g && (l = new index$1(v => {
					const y = v[0];
					s("resize", y)
				}), l.observe(g))
			},
			m = () => {
				l && (l.disconnect(), l = null)
			};
		return watch(d, g => {
			l && m(), g && f(g)
		}), onMounted(() => {
			d.value && f(d.value)
		}), onUnmounted(() => {
			m()
		}), () => {
			var g, v;
			const y = getFirstComponent((v = (g = a.default) == null ? void 0 : g.call(a)) != null ? v :
		[]);
			return y ? cloneVNode(y, {
				ref: c
			}, !0) : null
		}
	}
});
const target$1 = typeof window > "u" ? global : window,
	raf = target$1.requestAnimationFrame,
	caf = target$1.cancelAnimationFrame;

function throttleByRaf(o) {
	let s = 0;
	const a = (...l) => {
		s && caf(s), s = raf(() => {
			o(...l), s = 0
		})
	};
	return a.cancel = () => {
		caf(s), s = 0
	}, a
}
const NOOP = () => {},
	getDocumentSize = () => {
		const {
			body: o
		} = document, s = document.documentElement;
		let a;
		try {
			a = (window.top || window.self || window).document.body
		} catch {}
		return {
			height: Math.max(o.scrollHeight, o.offsetHeight, s.clientHeight, s.scrollHeight, s.offsetHeight, (a ==
				null ? void 0 : a.scrollHeight) || 0, (a == null ? void 0 : a.clientHeight) || 0),
			width: Math.max(o.scrollWidth, o.offsetWidth, s.clientWidth, s.scrollWidth, s.offsetWidth, (a == null ?
				void 0 : a.scrollWidth) || 0, (a == null ? void 0 : a.clientWidth) || 0)
		}
	},
	isServerRendering = (() => {
		try {
			return !(typeof window < "u" && document !== void 0)
		} catch {
			return !0
		}
	})(),
	on = isServerRendering ? NOOP : (o, s, a, l = !1) => {
		o.addEventListener(s, a, l)
	},
	off = isServerRendering ? NOOP : (o, s, a, l = !1) => {
		o.removeEventListener(s, a, l)
	},
	contains = (o, s) => {
		if (!o || !s) return !1;
		let a = s;
		for (; a;) {
			if (a === o) return !0;
			a = a.parentNode
		}
		return !1
	},
	getOverlay = o => {
		const s = document.createElement("div");
		return s.setAttribute("class", `arco-overlay arco-overlay-${o}`), s
	},
	querySelector = (o, s) => {
		var a;
		return isServerRendering ? NOOP() : (a = (s ?? document).querySelector(o)) != null ? a : void 0
	},
	getElement = (o, s) => {
		if (isString$2(o)) {
			const a = o[0] === "#" ? `[id='${o.slice(1)}']` : o;
			return querySelector(a, s)
		}
		return o
	},
	getRelativeRect = (o, s) => {
		const a = o.getBoundingClientRect(),
			l = s.getBoundingClientRect();
		return {
			top: a.top - l.top,
			bottom: l.bottom - a.bottom,
			left: a.left - l.left,
			right: l.right - a.right,
			width: a.width,
			height: a.height
		}
	},
	isScroll = o => o.tagName === "BODY" ? document.documentElement.scrollHeight > window.innerHeight : o.scrollHeight >
	o.offsetHeight,
	getScrollBarWidth = o => o.tagName === "BODY" ? window.innerWidth - getDocumentSize().width : o.offsetWidth - o
	.clientWidth;
var _export_sfc$1 = (o, s) => {
	for (const [a, l] of s) o[a] = l;
	return o
};

function getTargetRect(o) {
	return isWindow(o) ? {
		top: 0,
		bottom: window.innerHeight
	} : o.getBoundingClientRect()
}
const _sfc_main$3h = defineComponent({
		name: "Affix",
		components: {
			ResizeObserver: ResizeObserver$2
		},
		props: {
			offsetTop: {
				type: Number,
				default: 0
			},
			offsetBottom: {
				type: Number
			},
			target: {
				type: [String, Object, Function]
			},
			targetContainer: {
				type: [String, Object, Function]
			}
		},
		emits: {
			change: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("affix"),
				{
					target: l,
					targetContainer: c
				} = toRefs(o),
				d = ref(),
				f = ref(),
				m = ref(!1),
				g = ref({}),
				v = ref({}),
				y = computed(() => ({
					[a]: m.value
				})),
				b = throttleByRaf(() => {
					if (!d.value || !f.value) return;
					const {
						offsetTop: C,
						offsetBottom: _
					} = o, S = isUndefined$1(_) ? "top" : "bottom", w = d.value.getBoundingClientRect(), T =
						getTargetRect(f.value);
					let A = !1,
						k = {};
					const M = {
						width: `${d.value.offsetWidth}px`,
						height: `${d.value.offsetHeight}px`
					};
					S === "top" ? (A = w.top - T.top < (C || 0), k = A ? {
						position: "fixed",
						top: `${T.top+(C||0)}px`
					} : {}) : (A = T.bottom - w.bottom < (_ || 0), k = A ? {
						position: "fixed",
						bottom: `${window.innerHeight-T.bottom+(_||0)}px`
					} : {}), A !== m.value && (m.value = A, s("change", A)), g.value = M, v.value = {
						...k,
						...A ? M : {}
					}
				});
			return onMounted(() => {
				watchEffect(C => {
					const _ = l && l.value !== window && getElement(l.value) || window;
					f.value = _, _ && (on(_, "scroll", b), on(_, "resize", b), C(() => {
						off(_, "scroll", b), off(_, "resize", b)
					}))
				}), watchEffect(C => {
					if (!f.value) return;
					const _ = c && c.value !== window && getElement(c.value) || window;
					_ && (on(_, "scroll", b), on(_, "resize", b), C(() => {
						off(_, "scroll", b), off(_, "resize", b)
					}))
				})
			}), {
				wrapperRef: d,
				isFixed: m,
				classNames: y,
				placeholderStyles: g,
				fixedStyles: v,
				updatePositionThrottle: b
			}
		},
		methods: {
			updatePosition() {
				this.updatePositionThrottle()
			}
		}
	}),
	_hoisted_1$1l = {
		ref: "wrapperRef"
	};

function _sfc_render$2$(o, s, a, l, c, d) {
	const f = resolveComponent("ResizeObserver");
	return openBlock(), createBlock(f, {
		onResize: o.updatePositionThrottle
	}, {
		default: withCtx(() => [createBaseVNode("div", _hoisted_1$1l, [o.isFixed ? (openBlock(),
			createElementBlock("div", {
				key: 0,
				style: normalizeStyle(o.placeholderStyles)
			}, null, 4)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
			class: normalizeClass(o.classNames),
			style: normalizeStyle(o.fixedStyles)
		}, [createVNode(f, {
			onResize: o.updatePositionThrottle
		}, {
			default: withCtx(() => [renderSlot(o.$slots, "default")]),
			_: 3
		}, 8, ["onResize"])], 6)], 512)]),
		_: 3
	}, 8, ["onResize"])
}
var _Affix = _export_sfc$1(_sfc_main$3h, [
	["render", _sfc_render$2$]
]);
const Affix = Object.assign(_Affix, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Affix.name, _Affix)
		}
	}),
	_sfc_main$3g = defineComponent({
		name: "IconHover",
		props: {
			prefix: {
				type: String
			},
			size: {
				type: String,
				default: "medium"
			},
			disabled: {
				type: Boolean,
				default: !1
			}
		},
		setup() {
			return {
				prefixCls: getPrefixCls("icon-hover")
			}
		}
	});

function _sfc_render$2_(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("span", {
		class: normalizeClass([o.prefixCls, {
			[`${o.prefix}-icon-hover`]: o.prefix,
			[`${o.prefixCls}-size-${o.size}`]: o.size !== "medium",
			[`${o.prefixCls}-disabled`]: o.disabled
		}])
	}, [renderSlot(o.$slots, "default")], 2)
}
var IconHover = _export_sfc$1(_sfc_main$3g, [
	["render", _sfc_render$2_]
]);
const _sfc_main$3f = defineComponent({
		name: "IconClose",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-close`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1k = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2Z(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M9.857 9.858 24 24m0 0 14.142 14.142M24 24 38.142 9.858M24 24 9.857 38.142"
	}, null, -1)]), 14, _hoisted_1$1k)
}
var _IconClose = _export_sfc$1(_sfc_main$3f, [
	["render", _sfc_render$2Z]
]);
const IconClose = Object.assign(_IconClose, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconClose.name, _IconClose)
		}
	}),
	_sfc_main$3e = defineComponent({
		name: "IconInfoCircleFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-info-circle-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1j = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2Y(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm2-30a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2Zm0 17h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1v-8a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v11Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$1j)
}
var _IconInfoCircleFill = _export_sfc$1(_sfc_main$3e, [
	["render", _sfc_render$2Y]
]);
const IconInfoCircleFill = Object.assign(_IconInfoCircleFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconInfoCircleFill.name, _IconInfoCircleFill)
		}
	}),
	_sfc_main$3d = defineComponent({
		name: "IconCheckCircleFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-check-circle-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1i = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2X(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm10.207-24.379a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0L22 26.172l-4.878-4.88a1 1 0 0 0-1.415 0l-1.414 1.415a1 1 0 0 0 0 1.414l7 7a1 1 0 0 0 1.414 0l11.5-11.5Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$1i)
}
var _IconCheckCircleFill = _export_sfc$1(_sfc_main$3d, [
	["render", _sfc_render$2X]
]);
const IconCheckCircleFill = Object.assign(_IconCheckCircleFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconCheckCircleFill.name, _IconCheckCircleFill)
		}
	}),
	_sfc_main$3c = defineComponent({
		name: "IconExclamationCircleFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-exclamation-circle-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1h = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2W(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm-2-11a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2Zm4-18a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V15Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$1h)
}
var _IconExclamationCircleFill = _export_sfc$1(_sfc_main$3c, [
	["render", _sfc_render$2W]
]);
const IconExclamationCircleFill = Object.assign(_IconExclamationCircleFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconExclamationCircleFill.name, _IconExclamationCircleFill)
		}
	}),
	_sfc_main$3b = defineComponent({
		name: "IconCloseCircleFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-close-circle-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1g = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2V(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm4.955-27.771-4.95 4.95-4.95-4.95a1 1 0 0 0-1.414 0l-1.414 1.414a1 1 0 0 0 0 1.414l4.95 4.95-4.95 4.95a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l4.95-4.95 4.95 4.95a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-4.95-4.95 4.95-4.95a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$1g)
}
var _IconCloseCircleFill = _export_sfc$1(_sfc_main$3b, [
	["render", _sfc_render$2V]
]);
const IconCloseCircleFill = Object.assign(_IconCloseCircleFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconCloseCircleFill.name, _IconCloseCircleFill)
		}
	}),
	_sfc_main$3a = defineComponent({
		name: "Alert",
		components: {
			IconHover,
			IconClose,
			IconInfoCircleFill,
			IconCheckCircleFill,
			IconExclamationCircleFill,
			IconCloseCircleFill
		},
		props: {
			type: {
				type: String,
				default: "info"
			},
			showIcon: {
				type: Boolean,
				default: !0
			},
			closable: {
				type: Boolean,
				default: !1
			},
			title: String,
			banner: {
				type: Boolean,
				default: !1
			},
			center: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			close: o => !0,
			afterClose: () => !0
		},
		setup(o, {
			slots: s,
			emit: a
		}) {
			const l = getPrefixCls("alert"),
				c = ref(!0),
				d = g => {
					c.value = !1, a("close", g)
				},
				f = () => {
					a("afterClose")
				},
				m = computed(() => [l, `${l}-${o.type}`, {
					[`${l}-with-title`]: !!(o.title || s.title),
					[`${l}-banner`]: o.banner,
					[`${l}-center`]: o.center
				}]);
			return {
				prefixCls: l,
				cls: m,
				visible: c,
				handleClose: d,
				handleAfterLeave: f
			}
		}
	});

function _sfc_render$2U(o, s, a, l, c, d) {
	const f = resolveComponent("icon-info-circle-fill"),
		m = resolveComponent("icon-check-circle-fill"),
		g = resolveComponent("icon-exclamation-circle-fill"),
		v = resolveComponent("icon-close-circle-fill"),
		y = resolveComponent("icon-close"),
		b = resolveComponent("icon-hover");
	return openBlock(), createBlock(Transition, {
		name: "zoom-in-top",
		onAfterLeave: o.handleAfterLeave
	}, {
		default: withCtx(() => [o.visible ? (openBlock(), createElementBlock("div", {
			key: 0,
			role: "alert",
			class: normalizeClass(o.cls)
		}, [o.showIcon && !(o.type === "normal" && !o.$slots.icon) ? (openBlock(),
				createElementBlock("div", {
					key: 0,
					class: normalizeClass(`${o.prefixCls}-icon`)
				}, [renderSlot(o.$slots, "icon", {}, () => [o.type === "info" ? (
					openBlock(), createBlock(f, {
						key: 0
					})) : o.type === "success" ? (openBlock(), createBlock(
					m, {
						key: 1
					})) : o.type === "warning" ? (openBlock(), createBlock(
					g, {
						key: 2
					})) : o.type === "error" ? (openBlock(), createBlock(
				v, {
					key: 3
				})) : createCommentVNode("v-if", !0)])], 2)) : createCommentVNode("v-if", !
				0), createBaseVNode("div", {
				class: normalizeClass(`${o.prefixCls}-body`)
			}, [o.title || o.$slots.title ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-title`)
			}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(
				toDisplayString(o.title), 1)])], 2)) : createCommentVNode("v-if", !
				0), createBaseVNode("div", {
				class: normalizeClass(`${o.prefixCls}-content`)
			}, [renderSlot(o.$slots, "default")], 2)], 2), o.$slots.action ? (openBlock(),
				createElementBlock("div", {
					key: 1,
					class: normalizeClass(`${o.prefixCls}-action`)
				}, [renderSlot(o.$slots, "action")], 2)) : createCommentVNode("v-if", !0), o
			.closable ? (openBlock(), createElementBlock("div", {
				key: 2,
				tabindex: "-1",
				role: "button",
				"aria-label": "Close",
				class: normalizeClass(`${o.prefixCls}-close-btn`),
				onClick: s[0] || (s[0] = (...C) => o.handleClose && o.handleClose(
					...C))
			}, [renderSlot(o.$slots, "close-element", {}, () => [createVNode(b,
				null, {
					default: withCtx(() => [createVNode(y)]),
					_: 1
				})])], 2)) : createCommentVNode("v-if", !0)
		], 2)) : createCommentVNode("v-if", !0)]),
		_: 3
	}, 8, ["onAfterLeave"])
}
var _Alert = _export_sfc$1(_sfc_main$3a, [
	["render", _sfc_render$2U]
]);
const Alert = Object.assign(_Alert, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Alert.name, _Alert)
	}
});

function t$1(o) {
	return typeof o == "object" && o != null && o.nodeType === 1
}

function e(o, s) {
	return (!s || o !== "hidden") && o !== "visible" && o !== "clip"
}

function n(o, s) {
	if (o.clientHeight < o.scrollHeight || o.clientWidth < o.scrollWidth) {
		var a = getComputedStyle(o, null);
		return e(a.overflowY, s) || e(a.overflowX, s) || function(l) {
			var c = function(d) {
				if (!d.ownerDocument || !d.ownerDocument.defaultView) return null;
				try {
					return d.ownerDocument.defaultView.frameElement
				} catch {
					return null
				}
			}(l);
			return !!c && (c.clientHeight < l.scrollHeight || c.clientWidth < l.scrollWidth)
		}(o)
	}
	return !1
}

function r(o, s, a, l, c, d, f, m) {
	return d < o && f > s || d > o && f < s ? 0 : d <= o && m <= a || f >= s && m >= a ? d - o - l : f > s && m < a ||
		d < o && m > a ? f - s + c : 0
}
var i = function(o, s) {
		var a = window,
			l = s.scrollMode,
			c = s.block,
			d = s.inline,
			f = s.boundary,
			m = s.skipOverflowHiddenElements,
			g = typeof f == "function" ? f : function(ye) {
				return ye !== f
			};
		if (!t$1(o)) throw new TypeError("Invalid target");
		for (var v, y, b = document.scrollingElement || document.documentElement, C = [], _ = o; t$1(_) && g(_);) {
			if ((_ = (y = (v = _).parentElement) == null ? v.getRootNode().host || null : y) === b) {
				C.push(_);
				break
			}
			_ != null && _ === document.body && n(_) && !n(document.documentElement) || _ != null && n(_, m) && C.push(
				_)
		}
		for (var S = a.visualViewport ? a.visualViewport.width : innerWidth, w = a.visualViewport ? a.visualViewport
				.height : innerHeight, T = window.scrollX || pageXOffset, A = window.scrollY || pageYOffset, k = o
				.getBoundingClientRect(), M = k.height, D = k.width, F = k.top, R = k.right, O = k.bottom, U = k.left,
				V = c === "start" || c === "nearest" ? F : c === "end" ? O : F + M / 2, z = d === "center" ? U + D / 2 :
				d === "end" ? R : U, j = [], ge = 0; ge < C.length; ge++) {
			var me = C[ge],
				he = me.getBoundingClientRect(),
				ce = he.height,
				ae = he.width,
				fe = he.top,
				q = he.right,
				le = he.bottom,
				de = he.left;
			if (l === "if-needed" && F >= 0 && U >= 0 && O <= w && R <= S && F >= fe && O <= le && U >= de && R <= q)
				return j;
			var _e = getComputedStyle(me),
				ke = parseInt(_e.borderLeftWidth, 10),
				De = parseInt(_e.borderTopWidth, 10),
				Se = parseInt(_e.borderRightWidth, 10),
				be = parseInt(_e.borderBottomWidth, 10),
				Me = 0,
				Ve = 0,
				it = "offsetWidth" in me ? me.offsetWidth - me.clientWidth - ke - Se : 0,
				pt = "offsetHeight" in me ? me.offsetHeight - me.clientHeight - De - be : 0,
				dt = "offsetWidth" in me ? me.offsetWidth === 0 ? 0 : ae / me.offsetWidth : 0,
				He = "offsetHeight" in me ? me.offsetHeight === 0 ? 0 : ce / me.offsetHeight : 0;
			if (b === me) Me = c === "start" ? V : c === "end" ? V - w : c === "nearest" ? r(A, A + w, w, De, be, A + V,
					A + V + M, M) : V - w / 2, Ve = d === "start" ? z : d === "center" ? z - S / 2 : d === "end" ? z -
				S : r(T, T + S, S, ke, Se, T + z, T + z + D, D), Me = Math.max(0, Me + A), Ve = Math.max(0, Ve + T);
			else {
				Me = c === "start" ? V - fe - De : c === "end" ? V - le + be + pt : c === "nearest" ? r(fe, le, ce, De,
						be + pt, V, V + M, M) : V - (fe + ce / 2) + pt / 2, Ve = d === "start" ? z - de - ke : d ===
					"center" ? z - (de + ae / 2) + it / 2 : d === "end" ? z - q + Se + it : r(de, q, ae, ke, Se + it, z,
						z + D, D);
				var Ae = me.scrollLeft,
					xe = me.scrollTop;
				V += xe - (Me = Math.max(0, Math.min(xe + Me / He, me.scrollHeight - ce / He + pt))), z += Ae - (Ve =
					Math.max(0, Math.min(Ae + Ve / dt, me.scrollWidth - ae / dt + it)))
			}
			j.push({
				el: me,
				top: Me,
				left: Ve
			})
		}
		return j
	},
	easeInBy = function(o) {
		return function(s) {
			return Math.pow(s, o)
		}
	},
	easeOutBy = function(o) {
		return function(s) {
			return 1 - Math.abs(Math.pow(s - 1, o))
		}
	},
	easeInOutBy = function(o) {
		return function(s) {
			return s < .5 ? easeInBy(o)(s * 2) / 2 : easeOutBy(o)(s * 2 - 1) / 2 + .5
		}
	},
	linear = function(o) {
		return o
	},
	quadIn = easeInBy(2),
	quadOut = easeOutBy(2),
	quadInOut = easeInOutBy(2),
	cubicIn = easeInBy(3),
	cubicOut = easeOutBy(3),
	cubicInOut = easeInOutBy(3),
	quartIn = easeInBy(4),
	quartOut = easeOutBy(4),
	quartInOut = easeInOutBy(4),
	quintIn = easeInBy(5),
	quintOut = easeOutBy(5),
	quintInOut = easeInOutBy(5),
	sineIn = function(o) {
		return 1 + Math.sin(Math.PI / 2 * o - Math.PI / 2)
	},
	sineOut = function(o) {
		return Math.sin(Math.PI / 2 * o)
	},
	sineInOut = function(o) {
		return (1 + Math.sin(Math.PI * o - Math.PI / 2)) / 2
	},
	bounceOut = function(o) {
		var s = 7.5625,
			a = 2.75;
		return o < 1 / a ? s * o * o : o < 2 / a ? (o -= 1.5 / a, s * o * o + .75) : o < 2.5 / a ? (o -= 2.25 / a, s *
			o * o + .9375) : (o -= 2.625 / a, s * o * o + .984375)
	},
	bounceIn = function(o) {
		return 1 - bounceOut(1 - o)
	},
	bounceInOut = function(o) {
		return o < .5 ? bounceIn(o * 2) * .5 : bounceOut(o * 2 - 1) * .5 + .5
	},
	easing = Object.freeze({
		linear,
		quadIn,
		quadOut,
		quadInOut,
		cubicIn,
		cubicOut,
		cubicInOut,
		quartIn,
		quartOut,
		quartInOut,
		quintIn,
		quintOut,
		quintInOut,
		sineIn,
		sineOut,
		sineInOut,
		bounceOut,
		bounceIn,
		bounceInOut
	}),
	Tween = function(s) {
		var a = s.from,
			l = s.to,
			c = s.duration,
			d = s.delay,
			f = s.easing,
			m = s.onStart,
			g = s.onUpdate,
			v = s.onFinish;
		for (var y in a) l[y] === void 0 && (l[y] = a[y]);
		for (var b in l) a[b] === void 0 && (a[b] = l[b]);
		this.from = a, this.to = l, this.duration = c || 500, this.delay = d || 0, this.easing = f || "linear", this
			.onStart = m, this.onUpdate = g || function() {}, this.onFinish = v, this.startTime = Date.now() + this
			.delay, this.started = !1, this.finished = !1, this.timer = null, this.keys = {}
	};
Tween.prototype.update = function() {
	if (this.time = Date.now(), !(this.time < this.startTime) && !this.finished) {
		if (this.elapsed === this.duration) {
			this.finished || (this.finished = !0, this.onFinish && this.onFinish(this.keys));
			return
		}
		this.elapsed = this.time - this.startTime, this.elapsed = this.elapsed > this.duration ? this.duration :
			this.elapsed;
		for (var s in this.to) this.keys[s] = this.from[s] + (this.to[s] - this.from[s]) * easing[this.easing](this
			.elapsed / this.duration);
		this.started || (this.onStart && this.onStart(this.keys), this.started = !0), this.onUpdate(this.keys)
	}
};
Tween.prototype.start = function() {
	var s = this;
	this.startTime = Date.now() + this.delay;
	var a = function() {
		s.update(), s.timer = requestAnimationFrame(a), s.finished && (cancelAnimationFrame(s.timer), s.timer =
			null)
	};
	a()
};
Tween.prototype.stop = function() {
	cancelAnimationFrame(this.timer), this.timer = null
};

function slide(o, s, a) {
	new Tween({
		from: {
			scrollTop: o.scrollTop
		},
		to: {
			scrollTop: s
		},
		easing: "quartOut",
		duration: 300,
		onUpdate: c => {
			o.scrollTop = c.scrollTop
		},
		onFinish: () => {
			isFunction$2(a) && a()
		}
	}).start()
}
const anchorInjectionKey = Symbol("ArcoAnchor"),
	BOUNDARY_POSITIONS = ["start", "end", "center", "nearest"],
	_sfc_main$39 = defineComponent({
		name: "Anchor",
		props: {
			boundary: {
				type: [Number, String],
				default: "start",
				validator: o => isNumber$2(o) || BOUNDARY_POSITIONS.includes(o)
			},
			lineLess: {
				type: Boolean,
				default: !1
			},
			scrollContainer: {
				type: [String, Object]
			},
			changeHash: {
				type: Boolean,
				default: !0
			},
			smooth: {
				type: Boolean,
				default: !0
			}
		},
		emits: {
			select: (o, s) => !0,
			change: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("anchor"),
				l = ref(),
				c = ref(),
				d = reactive({}),
				f = ref(""),
				m = ref(!1),
				g = ref(),
				v = ref(),
				y = (F, R) => {
					F && (d[F] = R)
				},
				b = F => {
					delete d[F]
				},
				C = (F, R) => {
					o.changeHash || F.preventDefault(), R && (_(R), w(R)), s("select", R, f.value)
				},
				_ = F => {
					try {
						const R = getElement(F);
						if (!R) return;
						let O, U = 0;
						isNumber$2(o.boundary) ? (O = "start", U = o.boundary) : O = o.boundary;
						const V = i(R, {
							block: O
						});
						if (!V.length) return;
						const {
							el: z,
							top: j
						} = V[0], ge = j - U;
						slide(z, ge, () => {
							m.value = !1
						}), m.value = !0
					} catch (R) {
						console.error(R)
					}
				},
				S = throttleByRaf(() => {
					if (m.value) return;
					const F = T();
					if (F && F.id) {
						const R = `#${F.id}`;
						w(R)
					}
				}),
				w = F => {
					if (!d[F] && l.value) {
						const R = getElement(`a[data-href='${F}']`, l.value);
						if (!R) return;
						d[F] = R
					}
					F !== f.value && (f.value = F, nextTick(() => {
						s("change", F)
					}))
				},
				T = () => {
					if (!g.value || !v.value) return;
					const F = isNumber$2(o.boundary) ? o.boundary : 0,
						R = v.value.getBoundingClientRect();
					for (const O of Object.keys(d)) {
						const U = getElement(O);
						if (U) {
							const {
								top: V
							} = U.getBoundingClientRect(), z = isWindow(g.value) ? V - F : V - R.top - F;
							if (z >= 0 && z <= R.height / 2) return U
						}
					}
				};
			watch(f, () => {
				const F = d[f.value];
				!o.lineLess && F && c.value && (c.value.style.top = `${F.offsetTop}px`)
			});
			const A = () => {
					g.value && on(g.value, "scroll", S)
				},
				k = () => {
					g.value && off(g.value, "scroll", S)
				},
				M = () => {
					o.scrollContainer ? (g.value = isWindow(o.scrollContainer) ? window : getElement(o
							.scrollContainer), v.value = isWindow(o.scrollContainer) ? document
						.documentElement : getElement(o.scrollContainer)) : (g.value = window, v.value =
						document.documentElement)
				};
			onMounted(() => {
				M();
				const F = decodeURIComponent(window.location.hash);
				F ? (_(F), w(F)) : S(), A()
			}), onBeforeUnmount(() => {
				k()
			}), provide(anchorInjectionKey, reactive({
				currentLink: f,
				addLink: y,
				removeLink: b,
				handleClick: C
			}));
			const D = computed(() => [a, {
				[`${a}-line-less`]: o.lineLess
			}]);
			return {
				prefixCls: a,
				cls: D,
				anchorRef: l,
				lineSliderRef: c
			}
		}
	});

function _sfc_render$2T(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		ref: "anchorRef",
		class: normalizeClass(o.cls)
	}, [o.lineLess ? createCommentVNode("v-if", !0) : (openBlock(), createElementBlock("div", {
		key: 0,
		ref: "lineSliderRef",
		class: normalizeClass(`${o.prefixCls}-line-slider`)
	}, null, 2)), createBaseVNode("ul", {
		class: normalizeClass(`${o.prefixCls}-list`)
	}, [renderSlot(o.$slots, "default")], 2)], 2)
}
var _Anchor = _export_sfc$1(_sfc_main$39, [
	["render", _sfc_render$2T]
]);
const _sfc_main$38 = defineComponent({
		name: "AnchorLink",
		props: {
			title: String,
			href: String
		},
		setup(o) {
			const s = getPrefixCls("anchor"),
				a = `${s}-link`,
				l = ref(),
				c = inject(anchorInjectionKey, void 0);
			onMounted(() => {
				o.href && l.value && (c == null || c.addLink(o.href, l.value))
			});
			const d = computed(() => [`${a}-item`, {
				[`${a}-active`]: (c == null ? void 0 : c.currentLink) === o.href
			}]);
			return {
				prefixCls: s,
				linkCls: a,
				cls: d,
				linkRef: l,
				handleClick: m => c == null ? void 0 : c.handleClick(m, o.href)
			}
		}
	}),
	_hoisted_1$1f = ["href"];

function _sfc_render$2S(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("li", {
		ref: "linkRef",
		class: normalizeClass(o.cls)
	}, [createBaseVNode("a", {
			class: normalizeClass(o.linkCls),
			href: o.href,
			onClick: s[0] || (s[0] = (...f) => o.handleClick && o.handleClick(...f))
		}, [renderSlot(o.$slots, "default", {}, () => [createTextVNode(toDisplayString(o.title), 1)])], 10,
		_hoisted_1$1f), o.$slots.sublist ? (openBlock(), createElementBlock("ul", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-sublist`)
	}, [renderSlot(o.$slots, "sublist")], 2)) : createCommentVNode("v-if", !0)], 2)
}
var AnchorLink = _export_sfc$1(_sfc_main$38, [
	["render", _sfc_render$2S]
]);
const Anchor = Object.assign(_Anchor, {
		Link: AnchorLink,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Anchor.name, _Anchor), o.component(a + AnchorLink.name, AnchorLink)
		}
	}),
	MESSAGE_TYPES = ["info", "success", "warning", "error"],
	INPUT_EVENTS = ["onFocus", "onFocusin", "onFocusout", "onBlur", "onChange", "onBeforeinput", "onInput", "onReset",
		"onSubmit", "onInvalid", "onKeydown", "onKeypress", "onKeyup", "onCopy", "onCut", "onPaste",
		"onCompositionstart", "onCompositionupdate", "onCompositionend", "onSelect", "autocomplete", "autofocus",
		"maxlength", "minlength", "name", "pattern", "readonly", "required"
	],
	_sfc_main$37 = defineComponent({
		name: "IconLoading",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-loading`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1e = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2R(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6"
	}, null, -1)]), 14, _hoisted_1$1e)
}
var _IconLoading = _export_sfc$1(_sfc_main$37, [
	["render", _sfc_render$2R]
]);
const IconLoading = Object.assign(_IconLoading, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconLoading.name, _IconLoading)
		}
	}),
	_sfc_main$36 = defineComponent({
		name: "FeedbackIcon",
		components: {
			IconLoading,
			IconCheckCircleFill,
			IconExclamationCircleFill,
			IconCloseCircleFill
		},
		props: {
			type: {
				type: String
			}
		},
		setup(o) {
			const s = getPrefixCls("feedback-icon");
			return {
				cls: computed(() => [s, `${s}-status-${o.type}`])
			}
		}
	});

function _sfc_render$2Q(o, s, a, l, c, d) {
	const f = resolveComponent("icon-loading"),
		m = resolveComponent("icon-check-circle-fill"),
		g = resolveComponent("icon-exclamation-circle-fill"),
		v = resolveComponent("icon-close-circle-fill");
	return openBlock(), createElementBlock("span", {
		class: normalizeClass(o.cls)
	}, [o.type === "validating" ? (openBlock(), createBlock(f, {
		key: 0
	})) : o.type === "success" ? (openBlock(), createBlock(m, {
		key: 1
	})) : o.type === "warning" ? (openBlock(), createBlock(g, {
		key: 2
	})) : o.type === "error" ? (openBlock(), createBlock(v, {
		key: 3
	})) : createCommentVNode("v-if", !0)], 2)
}
var FeedbackIcon = _export_sfc$1(_sfc_main$36, [
	["render", _sfc_render$2Q]
]);
const Enter = {
		key: "Enter"
	},
	Backspace = {
		key: "Backspace",
		code: "Backspace"
	},
	ArrowLeft = {
		code: "ArrowLeft"
	},
	ArrowRight = {
		code: "ArrowRight"
	},
	omit = (o, s) => {
		const a = {
			...o
		};
		for (const l of s) l in a && delete a[l];
		return a
	};

function pick(o, s) {
	const a = {};
	return s.forEach(l => {
		const c = l;
		l in o && (a[c] = o[c])
	}), a
}
const formItemInjectionKey = Symbol("ArcoFormItemContext"),
	formInjectionKey = Symbol("ArcoFormContext"),
	useFormItem = ({
		size: o,
		disabled: s,
		error: a,
		uninject: l
	} = {}) => {
		const c = l ? {} : inject(formItemInjectionKey, {}),
			d = computed(() => {
				var y;
				return (y = o == null ? void 0 : o.value) != null ? y : c.size
			}),
			f = computed(() => (s == null ? void 0 : s.value) || c.disabled),
			m = computed(() => (a == null ? void 0 : a.value) || c.error),
			g = toRef(c, "feedback"),
			v = toRef(c, "eventHandlers");
		return {
			formItemCtx: c,
			mergedSize: d,
			mergedDisabled: f,
			mergedError: m,
			feedback: g,
			eventHandlers: v
		}
	},
	useSize$1 = (o, {
		defaultValue: s = "medium"
	} = {}) => {
		const a = inject(configProviderInjectionKey, void 0);
		return {
			mergedSize: computed(() => {
				var c, d;
				return (d = (c = o == null ? void 0 : o.value) != null ? c : a == null ? void 0 : a.size) !=
					null ? d : s
			})
		}
	};

function useCursor(o) {
	const s = ref();

	function a() {
		if (!o.value) return;
		const {
			selectionStart: c,
			selectionEnd: d,
			value: f
		} = o.value;
		if (c == null || d == null) return;
		const m = f.slice(0, Math.max(0, c)),
			g = f.slice(Math.max(0, d));
		s.value = {
			selectionStart: c,
			selectionEnd: d,
			value: f,
			beforeTxt: m,
			afterTxt: g
		}
	}

	function l() {
		if (!o.value || !s.value) return;
		const {
			value: c
		} = o.value, {
			beforeTxt: d,
			afterTxt: f,
			selectionStart: m
		} = s.value;
		if (!d || !f || !m) return;
		let g = c.length;
		if (c.endsWith(f)) g = c.length - f.length;
		else if (c.startsWith(d)) g = d.length;
		else {
			const v = d[m - 1],
				y = c.indexOf(v, m - 1);
			y !== -1 && (g = y + 1)
		}
		o.value.setSelectionRange(g, g)
	}
	return [a, l]
}
var _Input = defineComponent({
	name: "Input",
	inheritAttrs: !1,
	props: {
		modelValue: String,
		defaultValue: {
			type: String,
			default: ""
		},
		size: {
			type: String
		},
		allowClear: {
			type: Boolean,
			default: !1
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		readonly: {
			type: Boolean,
			default: !1
		},
		error: {
			type: Boolean,
			default: !1
		},
		placeholder: String,
		maxLength: {
			type: [Number, Object],
			default: 0
		},
		showWordLimit: {
			type: Boolean,
			default: !1
		},
		wordLength: {
			type: Function
		},
		wordSlice: {
			type: Function
		},
		inputAttrs: {
			type: Object
		},
		type: {
			type: String,
			default: "text"
		},
		prepend: String,
		append: String
	},
	emits: {
		"update:modelValue": o => !0,
		input: (o, s) => !0,
		change: (o, s) => !0,
		pressEnter: o => !0,
		clear: o => !0,
		focus: o => !0,
		blur: o => !0
	},
	setup(o, {
		emit: s,
		slots: a,
		attrs: l
	}) {
		const {
			size: c,
			disabled: d,
			error: f,
			modelValue: m
		} = toRefs(o), g = getPrefixCls("input"), v = ref(), {
			mergedSize: y,
			mergedDisabled: b,
			mergedError: C,
			feedback: _,
			eventHandlers: S
		} = useFormItem({
			size: c,
			disabled: d,
			error: f
		}), {
			mergedSize: w
		} = useSize$1(y), [T, A] = useCursor(v), k = ref(o.defaultValue), M = computed(() => {
			var xe;
			return (xe = o.modelValue) != null ? xe : k.value
		});
		let D = M.value;
		watch(m, xe => {
			(isUndefined$1(xe) || isNull$1(xe)) && (k.value = "")
		}), watch(M, (xe, ye) => {
			D = ye
		});
		const F = ref(!1),
			R = computed(() => o.allowClear && !o.readonly && !b.value && !!M.value),
			O = ref(!1),
			U = ref(""),
			V = xe => {
				var ye;
				return isFunction$2(o.wordLength) ? o.wordLength(xe) : (ye = xe.length) != null ? ye : 0
			},
			z = computed(() => V(M.value)),
			j = computed(() => C.value || !!(isObject$2(o.maxLength) && o.maxLength.errorOnly && z.value > me
				.value)),
			ge = computed(() => isObject$2(o.maxLength) && !!o.maxLength.errorOnly),
			me = computed(() => isObject$2(o.maxLength) ? o.maxLength.length : o.maxLength),
			he = computed(() => {
				const xe = V("a");
				return Math.floor(me.value / xe)
			}),
			ce = xe => {
				var ye, Le;
				me.value && !ge.value && V(xe) > me.value && (xe = (Le = (ye = o.wordSlice) == null ? void 0 :
					ye.call(o, xe, me.value)) != null ? Le : xe.slice(0, he.value)), k.value = xe, s(
					"update:modelValue", xe)
			},
			ae = xe => {
				v.value && xe.target !== v.value && (xe.preventDefault(), v.value.focus())
			},
			fe = (xe, ye) => {
				var Le, Ue;
				xe !== D && (D = xe, s("change", xe, ye), (Ue = (Le = S.value) == null ? void 0 : Le
					.onChange) == null || Ue.call(Le, ye))
			},
			q = xe => {
				var ye, Le;
				F.value = !0, s("focus", xe), (Le = (ye = S.value) == null ? void 0 : ye.onFocus) == null || Le
					.call(ye, xe)
			},
			le = xe => {
				var ye, Le;
				F.value = !1, fe(M.value, xe), s("blur", xe), (Le = (ye = S.value) == null ? void 0 : ye
					.onBlur) == null || Le.call(ye, xe)
			},
			de = xe => {
				var ye, Le, Ue;
				const {
					value: nt,
					selectionStart: ot,
					selectionEnd: at
				} = xe.target;
				if (xe.type === "compositionend") {
					if (O.value = !1, U.value = "", me.value && !ge.value && z.value >= me.value && V(nt) > me
						.value && ot === at) {
						_e();
						return
					}
					ce(nt), s("input", nt, xe), (Le = (ye = S.value) == null ? void 0 : ye.onInput) == null ||
						Le.call(ye, xe), _e()
				} else O.value = !0, U.value = M.value + ((Ue = xe.data) != null ? Ue : "")
			},
			_e = () => {
				T(), nextTick(() => {
					v.value && M.value !== v.value.value && (v.value.value = M.value, A())
				})
			},
			ke = xe => {
				var ye, Le;
				const {
					value: Ue
				} = xe.target;
				if (!O.value) {
					if (me.value && !ge.value && z.value >= me.value && V(Ue) > me.value && xe.inputType ===
						"insertText") {
						_e();
						return
					}
					ce(Ue), s("input", Ue, xe), (Le = (ye = S.value) == null ? void 0 : ye.onInput) == null ||
						Le.call(ye, xe), _e()
				}
			},
			De = xe => {
				ce(""), fe("", xe), s("clear", xe)
			},
			Se = xe => {
				const ye = xe.key || xe.code;
				!O.value && ye === Enter.key && (fe(M.value, xe), s("pressEnter", xe))
			},
			be = computed(() => [`${g}-outer`, `${g}-outer-size-${w.value}`, {
				[`${g}-outer-has-suffix`]: !!a.suffix,
				[`${g}-outer-disabled`]: b.value
			}]),
			Me = computed(() => [`${g}-wrapper`, {
				[`${g}-error`]: j.value,
				[`${g}-disabled`]: b.value,
				[`${g}-focus`]: F.value
			}]),
			Ve = computed(() => [g, `${g}-size-${w.value}`]),
			it = computed(() => omit(l, INPUT_EVENTS)),
			pt = computed(() => pick(l, INPUT_EVENTS)),
			dt = computed(() => {
				const xe = {
					...pt.value,
					...o.inputAttrs
				};
				return j.value && (xe["aria-invalid"] = !0), xe
			}),
			He = xe => {
				var ye;
				return createVNode("span", mergeProps({
					class: Me.value,
					onMousedown: ae
				}, xe ? void 0 : it.value), [a.prefix && createVNode("span", {
					class: `${g}-prefix`
				}, [a.prefix()]), createVNode("input", mergeProps({
					ref: v,
					class: Ve.value,
					value: M.value,
					type: o.type,
					placeholder: o.placeholder,
					readonly: o.readonly,
					disabled: b.value,
					onInput: ke,
					onKeydown: Se,
					onFocus: q,
					onBlur: le,
					onCompositionstart: de,
					onCompositionupdate: de,
					onCompositionend: de
				}, dt.value), null), R.value && createVNode(IconHover, {
					prefix: g,
					class: `${g}-clear-btn`,
					onClick: De
				}, {
					default: () => [createVNode(IconClose, null, null)]
				}), (a.suffix || !!o.maxLength && o.showWordLimit || !!_.value) && createVNode(
					"span", {
						class: [`${g}-suffix`, {
							[`${g}-suffix-has-feedback`]: _.value
						}]
					}, [!!o.maxLength && o.showWordLimit && createVNode("span", {
							class: `${g}-word-limit`
						}, [z.value, createTextVNode("/"), me.value]), (ye = a.suffix) == null ?
						void 0 : ye.call(a), !!_.value && createVNode(FeedbackIcon, {
							type: _.value
						}, null)
					])])
			};
		return {
			inputRef: v,
			render: () => a.prepend || a.append || o.prepend || o.append ? createVNode("span", mergeProps({
				class: be.value
			}, it.value), [(a.prepend || o.prepend) && createVNode("span", {
					class: `${g}-prepend`
				}, [a.prepend ? a.prepend() : o.prepend]), He(!0), (a.append || o.append) &&
				createVNode("span", {
					class: `${g}-append`
				}, [a.append ? a.append() : o.append])
			]) : He()
		}
	},
	methods: {
		focus() {
			var o;
			(o = this.inputRef) == null || o.focus()
		},
		blur() {
			var o;
			(o = this.inputRef) == null || o.blur()
		}
	},
	render() {
		return this.render()
	}
});
const _sfc_main$35 = defineComponent({
		name: "IconSearch",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-search`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1d = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2P(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M33.072 33.071c6.248-6.248 6.248-16.379 0-22.627-6.249-6.249-16.38-6.249-22.628 0-6.248 6.248-6.248 16.379 0 22.627 6.248 6.248 16.38 6.248 22.628 0Zm0 0 8.485 8.485"
	}, null, -1)]), 14, _hoisted_1$1d)
}
var _IconSearch = _export_sfc$1(_sfc_main$35, [
	["render", _sfc_render$2P]
]);
const IconSearch = Object.assign(_IconSearch, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconSearch.name, _IconSearch)
		}
	}),
	buttonGroupInjectionKey = Symbol("ArcoButtonGroup"),
	_sfc_main$34 = defineComponent({
		name: "Button",
		components: {
			IconLoading
		},
		props: {
			type: {
				type: String
			},
			shape: {
				type: String
			},
			status: {
				type: String
			},
			size: {
				type: String
			},
			long: {
				type: Boolean,
				default: !1
			},
			loading: {
				type: Boolean,
				default: !1
			},
			disabled: {
				type: Boolean
			},
			htmlType: {
				type: String,
				default: "button"
			},
			autofocus: {
				type: Boolean,
				default: !1
			},
			href: String
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const {
				size: a,
				disabled: l
			} = toRefs(o), c = getPrefixCls("btn"), d = inject(buttonGroupInjectionKey, void 0), f = computed(
		() => {
				var _;
				return (_ = a.value) != null ? _ : d == null ? void 0 : d.size
			}), m = computed(() => !!(l.value || d != null && d.disabled)), {
				mergedSize: g,
				mergedDisabled: v
			} = useFormItem({
				size: f,
				disabled: m
			}), {
				mergedSize: y
			} = useSize$1(g), b = computed(() => {
				var _, S, w, T, A, k;
				return [c, `${c}-${(S=(_=o.type)!=null?_:d==null?void 0:d.type)!=null?S:"secondary"}`,
					`${c}-shape-${(T=(w=o.shape)!=null?w:d==null?void 0:d.shape)!=null?T:"square"}`,
					`${c}-size-${y.value}`,
					`${c}-status-${(k=(A=o.status)!=null?A:d==null?void 0:d.status)!=null?k:"normal"}`,
					{
						[`${c}-long`]: o.long,
						[`${c}-loading`]: o.loading,
						[`${c}-disabled`]: v.value,
						[`${c}-link`]: isString$2(o.href)
					}
				]
			});
			return {
				prefixCls: c,
				cls: b,
				mergedDisabled: v,
				handleClick: _ => {
					if (o.disabled || o.loading) {
						_.preventDefault();
						return
					}
					s("click", _)
				}
			}
		}
	}),
	_hoisted_1$1c = ["href"],
	_hoisted_2$7 = ["type", "disabled", "autofocus"];

function _sfc_render$2O(o, s, a, l, c, d) {
	const f = resolveComponent("icon-loading");
	return o.href ? (openBlock(), createElementBlock("a", {
		key: 0,
		class: normalizeClass([o.cls, {
			[`${o.prefixCls}-only-icon`]: o.$slots.icon && !o.$slots.default
		}]),
		href: o.mergedDisabled || o.loading ? void 0 : o.href,
		onClick: s[0] || (s[0] = (...m) => o.handleClick && o.handleClick(...m))
	}, [o.loading || o.$slots.icon ? (openBlock(), createElementBlock("span", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-icon`)
	}, [o.loading ? (openBlock(), createBlock(f, {
		key: 0,
		spin: "true"
	})) : renderSlot(o.$slots, "icon", {
		key: 1
	})], 2)) : createCommentVNode("v-if", !0), renderSlot(o.$slots, "default")], 10, _hoisted_1$1c)) : (openBlock(),
		createElementBlock("button", {
			key: 1,
			class: normalizeClass([o.cls, {
				[`${o.prefixCls}-only-icon`]: o.$slots.icon && !o.$slots.default
			}]),
			type: o.htmlType,
			disabled: o.mergedDisabled,
			autofocus: o.autofocus,
			onClick: s[1] || (s[1] = (...m) => o.handleClick && o.handleClick(...m))
		}, [o.loading || o.$slots.icon ? (openBlock(), createElementBlock("span", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-icon`)
		}, [o.loading ? (openBlock(), createBlock(f, {
			key: 0,
			spin: !0
		})) : renderSlot(o.$slots, "icon", {
			key: 1
		})], 2)) : createCommentVNode("v-if", !0), renderSlot(o.$slots, "default")], 10, _hoisted_2$7))
}
var _Button = _export_sfc$1(_sfc_main$34, [
	["render", _sfc_render$2O]
]);
const _sfc_main$33 = defineComponent({
	name: "ButtonGroup",
	props: {
		type: {
			type: String
		},
		status: {
			type: String
		},
		shape: {
			type: String
		},
		size: {
			type: String
		},
		disabled: {
			type: Boolean
		}
	},
	setup(o) {
		const {
			type: s,
			size: a,
			status: l,
			disabled: c,
			shape: d
		} = toRefs(o), f = getPrefixCls("btn-group");
		return provide(buttonGroupInjectionKey, reactive({
			type: s,
			size: a,
			shape: d,
			status: l,
			disabled: c
		})), {
			prefixCls: f
		}
	}
});

function _sfc_render$2N(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [renderSlot(o.$slots, "default")], 2)
}
var ButtonGroup = _export_sfc$1(_sfc_main$33, [
	["render", _sfc_render$2N]
]);
const Button = Object.assign(_Button, {
	Group: ButtonGroup,
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Button.name, _Button), o.component(a + ButtonGroup.name, ButtonGroup)
	}
});
var InputSearch = defineComponent({
	name: "InputSearch",
	props: {
		searchButton: {
			type: Boolean,
			default: !1
		},
		loading: {
			type: Boolean,
			default: !1
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		size: {
			type: String
		},
		buttonText: {
			type: String
		},
		buttonProps: {
			type: Object
		}
	},
	emits: {
		search: (o, s) => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			size: l
		} = toRefs(o), c = getPrefixCls("input-search"), {
			mergedSize: d
		} = useSize$1(l), f = ref(), m = b => {
			f.value.inputRef && s("search", f.value.inputRef.value, b)
		}, g = () => {
			var b;
			return createVNode(Fragment, null, [o.loading ? createVNode(IconLoading, null, null) :
				createVNode(IconHover, {
					onClick: m
				}, {
					default: () => [createVNode(IconSearch, null, null)]
				}), (b = a.suffix) == null ? void 0 : b.call(a)
			])
		}, v = () => {
			var b;
			let C = {};
			return o.buttonText || a["button-default"] || a["button-icon"] ? C = {
				default: (b = a["button-default"]) != null ? b : o.buttonText ? () => o.buttonText :
					void 0,
				icon: a["button-icon"]
			} : C = {
				icon: () => createVNode(IconSearch, null, null)
			}, createVNode(Button, mergeProps({
				type: "primary",
				class: `${c}-btn`,
				disabled: o.disabled,
				size: d.value,
				loading: o.loading
			}, o.buttonProps, {
				onClick: m
			}), C)
		};
		return {
			inputRef: f,
			render: () => createVNode(_Input, {
				ref: f,
				class: c,
				size: d.value,
				disabled: o.disabled
			}, {
				prepend: a.prepend,
				prefix: a.prefix,
				suffix: o.searchButton ? a.suffix : g,
				append: o.searchButton ? v : a.append
			})
		}
	},
	methods: {
		focus() {
			var o;
			(o = this.inputRef) == null || o.focus()
		},
		blur() {
			var o;
			(o = this.inputRef) == null || o.blur()
		}
	},
	render() {
		return this.render()
	}
});
const _sfc_main$32 = defineComponent({
		name: "IconEye",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-eye`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1b = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2M(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"clip-rule": "evenodd",
		d: "M24 37c6.627 0 12.627-4.333 18-13-5.373-8.667-11.373-13-18-13-6.627 0-12.627 4.333-18 13 5.373 8.667 11.373 13 18 13Z"
	}, null, -1), createBaseVNode("path", {
		d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
	}, null, -1)]), 14, _hoisted_1$1b)
}
var _IconEye = _export_sfc$1(_sfc_main$32, [
	["render", _sfc_render$2M]
]);
const IconEye = Object.assign(_IconEye, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconEye.name, _IconEye)
		}
	}),
	_sfc_main$31 = defineComponent({
		name: "IconEyeInvisible",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-eye-invisible`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1a = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2L(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M14 14.5c-2.69 2-5.415 5.33-8 9.5 5.373 8.667 11.373 13 18 13 3.325 0 6.491-1.09 9.5-3.271M17.463 12.5C19 11 21.75 11 24 11c6.627 0 12.627 4.333 18 13-1.766 2.848-3.599 5.228-5.5 7.14"
	}, null, -1), createBaseVNode("path", {
		d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0ZM6.852 7.103l34.294 34.294"
	}, null, -1)]), 14, _hoisted_1$1a)
}
var _IconEyeInvisible = _export_sfc$1(_sfc_main$31, [
	["render", _sfc_render$2L]
]);
const IconEyeInvisible = Object.assign(_IconEyeInvisible, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconEyeInvisible.name, _IconEyeInvisible)
	}
});

function useState(o) {
	const s = ref(o);
	return [s, l => {
		s.value = l
	}]
}

function useMergeState(o, s) {
	const {
		value: a
	} = toRefs(s), [l, c] = useState(isUndefined$1(a.value) ? o : a.value);
	return watch(a, f => {
		isUndefined$1(f) && c(void 0)
	}), [computed(() => isUndefined$1(a.value) ? l.value : a.value), c, l]
}
const _sfc_main$30 = defineComponent({
	name: "InputPassword",
	components: {
		IconEye,
		IconEyeInvisible,
		AIconHover: IconHover,
		AInput: _Input
	},
	props: {
		visibility: {
			type: Boolean,
			default: void 0
		},
		defaultVisibility: {
			type: Boolean,
			default: !0
		},
		invisibleButton: {
			type: Boolean,
			default: !0
		}
	},
	emits: ["visibility-change", "update:visibility"],
	setup(o, {
		emit: s
	}) {
		const {
			visibility: a,
			defaultVisibility: l
		} = toRefs(o), c = ref(), d = () => {
			g(!f.value)
		}, [f, m] = useMergeState(l.value, reactive({
			value: a
		})), g = v => {
			v !== f.value && (s("visibility-change", v), s("update:visibility", v), m(v))
		};
		return {
			inputRef: c,
			mergedVisible: f,
			handleInvisible: d
		}
	},
	methods: {
		focus() {
			var o;
			(o = this.inputRef) == null || o.focus()
		},
		blur() {
			var o;
			(o = this.inputRef) == null || o.blur()
		}
	}
});

function _sfc_render$2K(o, s, a, l, c, d) {
	const f = resolveComponent("icon-eye"),
		m = resolveComponent("icon-eye-invisible"),
		g = resolveComponent("a-icon-hover"),
		v = resolveComponent("a-input");
	return openBlock(), createBlock(v, {
		ref: "inputRef",
		type: o.mergedVisible ? "password" : "text"
	}, createSlots({
		_: 2
	}, [o.$slots.prepend ? {
		name: "prepend",
		fn: withCtx(() => [renderSlot(o.$slots, "prepend")]),
		key: "0"
	} : void 0, o.$slots.prefix ? {
		name: "prefix",
		fn: withCtx(() => [renderSlot(o.$slots, "prefix")]),
		key: "1"
	} : void 0, o.invisibleButton || o.$slots.suffix ? {
		name: "suffix",
		fn: withCtx(() => [o.invisibleButton ? (openBlock(), createBlock(g, {
				key: 0,
				onClick: o.handleInvisible,
				onMousedown: s[0] || (s[0] = withModifiers(() => {}, ["prevent"])),
				onMouseup: s[1] || (s[1] = withModifiers(() => {}, ["prevent"]))
			}, {
				default: withCtx(() => [o.mergedVisible ? (openBlock(), createBlock(m, {
					key: 1
				})) : (openBlock(), createBlock(f, {
					key: 0
				}))]),
				_: 1
			}, 8, ["onClick"])) : createCommentVNode("v-if", !0), renderSlot(o.$slots,
			"suffix")]),
		key: "2"
	} : void 0, o.$slots.append ? {
		name: "append",
		fn: withCtx(() => [renderSlot(o.$slots, "append")]),
		key: "3"
	} : void 0]), 1032, ["type"])
}
var InputPassword = _export_sfc$1(_sfc_main$30, [
	["render", _sfc_render$2K]
]);
const _sfc_main$2$ = defineComponent({
	name: "InputGroup",
	setup() {
		return {
			prefixCls: getPrefixCls("input-group")
		}
	}
});

function _sfc_render$2J(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [renderSlot(o.$slots, "default")], 2)
}
var InputGroup = _export_sfc$1(_sfc_main$2$, [
	["render", _sfc_render$2J]
]);
const Input = Object.assign(_Input, {
		Search: InputSearch,
		Password: InputPassword,
		Group: InputGroup,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Input.name, _Input), o.component(a + InputGroup.name, InputGroup), o.component(a +
				InputSearch.name, InputSearch), o.component(a + InputPassword.name, InputPassword)
		}
	}),
	getViewPortSize = () => {
		const {
			height: o,
			width: s
		} = getDocumentSize();
		return {
			width: Math.min(s, window.innerWidth),
			height: Math.min(o, window.innerHeight)
		}
	},
	getElementScrollRect = (o, s) => {
		var a, l;
		const c = o.getBoundingClientRect();
		return {
			top: c.top,
			bottom: c.bottom,
			left: c.left,
			right: c.right,
			scrollTop: c.top - s.top,
			scrollBottom: c.bottom - s.top,
			scrollLeft: c.left - s.left,
			scrollRight: c.right - s.left,
			width: (a = o.offsetWidth) != null ? a : o.clientWidth,
			height: (l = o.offsetHeight) != null ? l : o.clientHeight
		}
	},
	getBoundaryPosition = o => {
		switch (o) {
			case "top":
			case "tl":
			case "tr":
				return "top";
			case "bottom":
			case "bl":
			case "br":
				return "bottom";
			case "left":
			case "lt":
			case "lb":
				return "left";
			case "right":
			case "rt":
			case "rb":
				return "right";
			default:
				return "top"
		}
	},
	changePosition = (o, s) => {
		switch (s) {
			case "top":
				switch (o) {
					case "bottom":
						return "top";
					case "bl":
						return "tl";
					case "br":
						return "tr";
					default:
						return o
				}
			case "bottom":
				switch (o) {
					case "top":
						return "bottom";
					case "tl":
						return "bl";
					case "tr":
						return "br";
					default:
						return o
				}
			case "left":
				switch (o) {
					case "right":
						return "left";
					case "rt":
						return "lt";
					case "rb":
						return "lb";
					default:
						return o
				}
			case "right":
				switch (o) {
					case "left":
						return "right";
					case "lt":
						return "rt";
					case "lb":
						return "rb";
					default:
						return o
				}
			default:
				return o
		}
	},
	getFitPosition = (o, s, {
		containerRect: a,
		triggerRect: l,
		popupRect: c,
		offset: d,
		translate: f
	}) => {
		const m = getBoundaryPosition(o),
			g = getViewPortSize(),
			v = {
				top: a.top + s.top,
				bottom: g.height - (a.top + s.top + c.height),
				left: a.left + s.left,
				right: g.width - (a.left + s.left + c.width)
			};
		let y = o;
		if (m === "top" && v.top < 0)
			if (l.top > c.height) s.top = -a.top;
			else {
				const b = getPopupOffset("bottom", l, c, {
					offset: d,
					translate: f
				});
				g.height - (a.top + b.top + c.height) > 0 && (y = changePosition(o, "bottom"), s.top = b.top)
			} if (m === "bottom" && v.bottom < 0)
			if (g.height - l.bottom > c.height) s.top = -a.top + (g.height - c.height);
			else {
				const b = getPopupOffset("top", l, c, {
					offset: d,
					translate: f
				});
				a.top + b.top > 0 && (y = changePosition(o, "top"), s.top = b.top)
			} if (m === "left" && v.left < 0)
			if (l.left > c.width) s.left = -a.left;
			else {
				const b = getPopupOffset("right", l, c, {
					offset: d,
					translate: f
				});
				g.width - (a.left + b.left + c.width) > 0 && (y = changePosition(o, "right"), s.left = b.left)
			} if (m === "right" && v.right < 0)
			if (g.width - l.right > c.width) s.left = -a.left + (g.width - c.width);
			else {
				const b = getPopupOffset("left", l, c, {
					offset: d,
					translate: f
				});
				a.left + b.left > 0 && (y = changePosition(o, "left"), s.left = b.left)
			} return (m === "top" || m === "bottom") && (v.left < 0 ? s.left = -a.left : v.right < 0 && (s.left = -a
			.left + (g.width - c.width))), (m === "left" || m === "right") && (v.top < 0 ? s.top = -a.top : v
			.bottom < 0 && (s.top = -a.top + (g.height - c.height))), {
			popupPosition: s,
			position: y
		}
	},
	getPopupOffset = (o, s, a, {
		offset: l = 0,
		translate: c = [0, 0]
	} = {}) => {
		var d;
		const f = (d = isArray$2(c) ? c : c[o]) != null ? d : [0, 0];
		switch (o) {
			case "top":
				return {
					left: s.scrollLeft + Math.round(s.width / 2) - Math.round(a.width / 2) + f[0], top: s.scrollTop - a
						.height - l + f[1]
				};
			case "tl":
				return {
					left: s.scrollLeft + f[0], top: s.scrollTop - a.height - l + f[1]
				};
			case "tr":
				return {
					left: s.scrollRight - a.width + f[0], top: s.scrollTop - a.height - l + f[1]
				};
			case "bottom":
				return {
					left: s.scrollLeft + Math.round(s.width / 2) - Math.round(a.width / 2) + f[0], top: s.scrollBottom +
						l + f[1]
				};
			case "bl":
				return {
					left: s.scrollLeft + f[0], top: s.scrollBottom + l + f[1]
				};
			case "br":
				return {
					left: s.scrollRight - a.width + f[0], top: s.scrollBottom + l + f[1]
				};
			case "left":
				return {
					left: s.scrollLeft - a.width - l + f[0], top: s.scrollTop + Math.round(s.height / 2) - Math.round(a
						.height / 2) + f[1]
				};
			case "lt":
				return {
					left: s.scrollLeft - a.width - l + f[0], top: s.scrollTop + f[1]
				};
			case "lb":
				return {
					left: s.scrollLeft - a.width - l + f[0], top: s.scrollBottom - a.height + f[1]
				};
			case "right":
				return {
					left: s.scrollRight + l + f[0], top: s.scrollTop + Math.round(s.height / 2) - Math.round(a.height /
						2) + f[1]
				};
			case "rt":
				return {
					left: s.scrollRight + l + f[0], top: s.scrollTop + f[1]
				};
			case "rb":
				return {
					left: s.scrollRight + l + f[0], top: s.scrollBottom - a.height + f[1]
				};
			default:
				return {
					left: 0, top: 0
				}
		}
	},
	getTransformOrigin = o => {
		let s = "0";
		["top", "bottom"].includes(o) ? s = "50%" : ["left", "lt", "lb", "tr", "br"].includes(o) && (s = "100%");
		let a = "0";
		return ["left", "right"].includes(o) ? a = "50%" : ["top", "tl", "tr", "lb", "rb"].includes(o) && (a = "100%"),
			`${s} ${a}`
	},
	getPopupStyle = (o, s, a, l, {
		offset: c = 0,
		translate: d = [0, 0],
		customStyle: f = {},
		autoFitPosition: m = !1
	} = {}) => {
		let g = o,
			v = getPopupOffset(o, a, l, {
				offset: c,
				translate: d
			});
		if (m) {
			const b = getFitPosition(o, v, {
				containerRect: s,
				popupRect: l,
				triggerRect: a,
				offset: c,
				translate: d
			});
			v = b.popupPosition, g = b.position
		}
		return {
			style: {
				left: `${v.left}px`,
				top: `${v.top}px`,
				...f
			},
			position: g
		}
	},
	getArrowStyle = (o, s, a, {
		customStyle: l = {}
	}) => {
		if (["top", "tl", "tr", "bottom", "bl", "br"].includes(o)) {
			let d = Math.abs(s.scrollLeft + s.width / 2 - a.scrollLeft);
			return d > a.width - 8 && (s.width > a.width ? d = a.width / 2 : d = a.width - 8), ["top", "tl", "tr"]
				.includes(o) ? {
					left: `${d}px`,
					bottom: "0",
					transform: "translate(-50%,50%) rotate(45deg)",
					...l
				} : {
					left: `${d}px`,
					top: "0",
					transform: "translate(-50%,-50%) rotate(45deg)",
					...l
				}
		}
		let c = Math.abs(s.scrollTop + s.height / 2 - a.scrollTop);
		return c > a.height - 8 && (s.height > a.height ? c = a.height / 2 : c = a.height - 8), ["left", "lt", "lb"]
			.includes(o) ? {
				top: `${c}px`,
				right: "0",
				transform: "translate(50%,-50%) rotate(45deg)",
				...l
			} : {
				top: `${c}px`,
				left: "0",
				transform: "translate(-50%,-50%) rotate(45deg)",
				...l
			}
	},
	isScrollElement = o => o.scrollHeight > o.offsetHeight || o.scrollWidth > o.offsetWidth,
	getScrollElements = o => {
		var s;
		const a = [];
		let l = o;
		for (; l && l !== document.documentElement;) isScrollElement(l) && a.push(l), l = (s = l.parentElement) !=
			null ? s : void 0;
		return a
	},
	useFirstElement = () => {
		const o = {},
			s = ref(),
			a = () => {
				const l = getFirstElementFromChildren(o.value);
				l !== s.value && (s.value = l)
			};
		return onMounted(() => a()), onUpdated(() => a()), {
			children: o,
			firstElement: s
		}
	};
var ResizeObserver$1 = defineComponent({
	name: "ResizeObserver",
	props: {
		watchOnUpdated: Boolean
	},
	emits: ["resize"],
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			children: l,
			firstElement: c
		} = useFirstElement();
		let d;
		const f = g => {
				g && (d = new index$1(v => {
					const y = v[0];
					s("resize", y)
				}), d.observe(g))
			},
			m = () => {
				d && (d.disconnect(), d = null)
			};
		return watch(c, g => {
			d && m(), g && f(g)
		}), onBeforeUnmount(() => {
			d && m()
		}), () => {
			var g;
			return l.value = (g = a.default) == null ? void 0 : g.call(a), l.value
		}
	}
});

function usePickSlots(o, s) {
	const a = ref(o[s]);
	return onUpdated(() => {
		const l = o[s];
		a.value !== l && (a.value = l)
	}), a
}
const triggerInjectionKey = Symbol("ArcoTrigger"),
	POPUP_BASE_Z_INDEX = 1e3,
	MESSAGE_BASE_Z_INDEX = 5e3,
	Z_INDEX_STEP = 1;
class PopupManager {
	constructor() {
		this.popupStack = {
				popup: new Set,
				dialog: new Set,
				message: new Set
			}, this.getNextZIndex = s => (s === "message" ? Array.from(this.popupStack.message).pop() ||
				MESSAGE_BASE_Z_INDEX : Array.from(this.popupStack.popup).pop() || POPUP_BASE_Z_INDEX) +
			Z_INDEX_STEP, this.add = s => {
				const a = this.getNextZIndex(s);
				return this.popupStack[s].add(a), s === "dialog" && this.popupStack.popup.add(a), a
			}, this.delete = (s, a) => {
				this.popupStack[a].delete(s), a === "dialog" && this.popupStack.popup.delete(s)
			}, this.isLastDialog = s => this.popupStack.dialog.size > 1 ? s === Array.from(this.popupStack.dialog)
			.pop() : !0
	}
}
const popupManager = new PopupManager;

function usePopupManager(o, {
	visible: s,
	runOnMounted: a
} = {}) {
	const l = ref(0),
		c = () => {
			l.value = popupManager.add(o)
		},
		d = () => {
			popupManager.delete(l.value, o)
		},
		f = () => o === "dialog" ? popupManager.isLastDialog(l.value) : !1;
	return watch(() => s == null ? void 0 : s.value, m => {
		m ? c() : d()
	}, {
		immediate: !0
	}), a && (onMounted(() => {
		c()
	}), onBeforeUnmount(() => {
		d()
	})), {
		zIndex: readonly(l),
		open: c,
		close: d,
		isLastDialog: f
	}
}
const useResizeObserver = ({
	elementRef: o,
	onResize: s
}) => {
	let a;
	return {
		createResizeObserver: () => {
			o.value && (a = new index$1(d => {
				const f = d[0];
				isFunction$2(s) && s(f)
			}), a.observe(o.value))
		},
		destroyResizeObserver: () => {
			a && (a.disconnect(), a = null)
		}
	}
};
var ClientOnly = defineComponent({
	name: "ClientOnly",
	setup(o, {
		slots: s
	}) {
		const a = ref(!1);
		return onMounted(() => a.value = !0), () => {
			var l;
			return a.value ? (l = s.default) == null ? void 0 : l.call(s) : null
		}
	}
});
const useTeleportContainer = ({
		popupContainer: o,
		visible: s,
		defaultContainer: a = "body",
		documentContainer: l
	}) => {
		const c = ref(o.value),
			d = ref(),
			f = () => {
				const m = getElement(o.value),
					g = m ? o.value : a,
					v = m ?? (l ? document.documentElement : getElement(a));
				g !== c.value && (c.value = g), v !== d.value && (d.value = v)
			};
		return onMounted(() => f()), watch(s, m => {
			c.value !== o.value && m && f()
		}), {
			teleportContainer: c,
			containerRef: d
		}
	},
	TRIGGER_EVENTS = ["onClick", "onMouseenter", "onMouseleave", "onFocusin", "onFocusout", "onContextmenu"];
var _Trigger = defineComponent({
	name: "Trigger",
	inheritAttrs: !1,
	props: {
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean,
			default: !1
		},
		trigger: {
			type: [String, Array],
			default: "hover"
		},
		position: {
			type: String,
			default: "bottom"
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		popupOffset: {
			type: Number,
			default: 0
		},
		popupTranslate: {
			type: [Array, Object]
		},
		showArrow: {
			type: Boolean,
			default: !1
		},
		alignPoint: {
			type: Boolean,
			default: !1
		},
		popupHoverStay: {
			type: Boolean,
			default: !0
		},
		blurToClose: {
			type: Boolean,
			default: !0
		},
		clickToClose: {
			type: Boolean,
			default: !0
		},
		clickOutsideToClose: {
			type: Boolean,
			default: !0
		},
		unmountOnClose: {
			type: Boolean,
			default: !0
		},
		contentClass: {
			type: [String, Array, Object]
		},
		contentStyle: {
			type: Object
		},
		arrowClass: {
			type: [String, Array, Object]
		},
		arrowStyle: {
			type: Object
		},
		popupStyle: {
			type: Object
		},
		animationName: {
			type: String,
			default: "fade-in"
		},
		duration: {
			type: [Number, Object]
		},
		mouseEnterDelay: {
			type: Number,
			default: 100
		},
		mouseLeaveDelay: {
			type: Number,
			default: 100
		},
		focusDelay: {
			type: Number,
			default: 0
		},
		autoFitPopupWidth: {
			type: Boolean,
			default: !1
		},
		autoFitPopupMinWidth: {
			type: Boolean,
			default: !1
		},
		autoFixPosition: {
			type: Boolean,
			default: !0
		},
		popupContainer: {
			type: [String, Object]
		},
		updateAtScroll: {
			type: Boolean,
			default: !1
		},
		autoFitTransformOrigin: {
			type: Boolean,
			default: !1
		},
		hideEmpty: {
			type: Boolean,
			default: !1
		},
		openedClass: {
			type: [String, Array, Object]
		},
		autoFitPosition: {
			type: Boolean,
			default: !0
		},
		renderToBody: {
			type: Boolean,
			default: !0
		},
		preventFocus: {
			type: Boolean,
			default: !1
		},
		scrollToClose: {
			type: Boolean,
			default: !1
		},
		scrollToCloseDistance: {
			type: Number,
			default: 0
		}
	},
	emits: {
		"update:popupVisible": o => !0,
		popupVisibleChange: o => !0,
		show: () => !0,
		hide: () => !0,
		resize: () => !0
	},
	setup(o, {
		emit: s,
		slots: a,
		attrs: l
	}) {
		const {
			popupContainer: c
		} = toRefs(o), d = getPrefixCls("trigger"), f = computed(() => omit(l, TRIGGER_EVENTS)), m = inject(
				configProviderInjectionKey, void 0), g = computed(() => [].concat(o.trigger)), v = new Set, y =
			inject(triggerInjectionKey, void 0), {
				children: b,
				firstElement: C
			} = useFirstElement(), _ = ref(), S = ref(o.defaultPopupVisible), w = ref(o.position), T = ref({}),
			A = ref({}), k = ref({}), M = ref(), D = ref({
				top: 0,
				left: 0
			});
		let F = null,
			R = null;
		const O = computed(() => {
				var Oe;
				return (Oe = o.popupVisible) != null ? Oe : S.value
			}),
			{
				teleportContainer: U,
				containerRef: V
			} = useTeleportContainer({
				popupContainer: c,
				visible: O,
				documentContainer: !0
			}),
			{
				zIndex: z
			} = usePopupManager("popup", {
				visible: O
			});
		let j = 0,
			ge = !1,
			me = !1;
		const he = () => {
				j && (window.clearTimeout(j), j = 0)
			},
			ce = Oe => {
				if (o.alignPoint) {
					const {
						pageX: Xe,
						pageY: rt
					} = Oe;
					D.value = {
						top: rt,
						left: Xe
					}
				}
			},
			ae = () => {
				if (!C.value || !_.value || !V.value) return;
				const Oe = V.value.getBoundingClientRect(),
					Xe = o.alignPoint ? {
						top: D.value.top,
						bottom: D.value.top,
						left: D.value.left,
						right: D.value.left,
						scrollTop: D.value.top,
						scrollBottom: D.value.top,
						scrollLeft: D.value.left,
						scrollRight: D.value.left,
						width: 0,
						height: 0
					} : getElementScrollRect(C.value, Oe),
					rt = () => getElementScrollRect(_.value, Oe),
					ut = rt(),
					{
						style: gt,
						position: Et
					} = getPopupStyle(o.position, Oe, Xe, ut, {
						offset: o.popupOffset,
						translate: o.popupTranslate,
						customStyle: o.popupStyle,
						autoFitPosition: o.autoFitPosition
					});
				o.autoFitTransformOrigin && (A.value = {
						transformOrigin: getTransformOrigin(Et)
					}), o.autoFitPopupMinWidth ? gt.minWidth = `${Xe.width}px` : o.autoFitPopupWidth && (gt
						.width = `${Xe.width}px`), w.value !== Et && (w.value = Et), T.value = gt, o
					.showArrow && nextTick(() => {
						k.value = getArrowStyle(Et, Xe, rt(), {
							customStyle: o.arrowStyle
						})
					})
			},
			fe = (Oe, Xe) => {
				if (Oe === O.value && j === 0) return;
				const rt = () => {
					S.value = Oe, s("update:popupVisible", Oe), s("popupVisibleChange", Oe), Oe && nextTick(
						() => {
							ae()
						})
				};
				Oe || (F = null, R = null), Xe ? (he(), Oe !== O.value && (j = window.setTimeout(rt, Xe))) :
				rt()
			},
			q = Oe => {
				var Xe;
				(Xe = l.onClick) == null || Xe.call(l, Oe), !(o.disabled || O.value && !o.clickToClose) && (g
					.value.includes("click") ? (ce(Oe), fe(!O.value)) : g.value.includes("contextMenu") && O
					.value && fe(!1))
			},
			le = Oe => {
				var Xe;
				(Xe = l.onMouseenter) == null || Xe.call(l, Oe), !(o.disabled || !g.value.includes("hover")) &&
					(ce(Oe), fe(!0, o.mouseEnterDelay))
			},
			de = Oe => {
				y == null || y.onMouseenter(Oe), le(Oe)
			},
			_e = Oe => {
				var Xe;
				(Xe = l.onMouseleave) == null || Xe.call(l, Oe), !(o.disabled || !g.value.includes("hover")) &&
					fe(!1, o.mouseLeaveDelay)
			},
			ke = Oe => {
				y == null || y.onMouseleave(Oe), _e(Oe)
			},
			De = Oe => {
				var Xe;
				(Xe = l.onFocusin) == null || Xe.call(l, Oe), !(o.disabled || !g.value.includes("focus")) && fe(
					!0, o.focusDelay)
			},
			Se = Oe => {
				var Xe;
				(Xe = l.onFocusout) == null || Xe.call(l, Oe), !(o.disabled || !g.value.includes("focus")) && o
					.blurToClose && fe(!1)
			},
			be = Oe => {
				var Xe;
				(Xe = l.onContextmenu) == null || Xe.call(l, Oe), !(o.disabled || !g.value.includes(
					"contextMenu") || O.value && !o.clickToClose) && (ce(Oe), fe(!O.value), Oe
					.preventDefault())
			};
		provide(triggerInjectionKey, reactive({
			onMouseenter: de,
			onMouseleave: ke,
			addChildRef: Oe => {
				v.add(Oe), y == null || y.addChildRef(Oe)
			},
			removeChildRef: Oe => {
				v.delete(Oe), y == null || y.removeChildRef(Oe)
			}
		}));
		const it = () => {
				off(document.documentElement, "mousedown", He), ge = !1
			},
			pt = usePickSlots(a, "content"),
			dt = computed(() => {
				var Oe;
				return o.hideEmpty && isEmptyChildren((Oe = pt.value) == null ? void 0 : Oe.call(pt))
			}),
			He = Oe => {
				var Xe, rt, ut;
				if (!((Xe = C.value) != null && Xe.contains(Oe.target) || (rt = _.value) != null && rt.contains(
						Oe.target))) {
					for (const gt of v)
						if ((ut = gt.value) != null && ut.contains(Oe.target)) return;
					it(), fe(!1)
				}
			},
			Ae = (Oe, Xe) => {
				const [rt, ut] = Oe, {
					scrollTop: gt,
					scrollLeft: Et
				} = Xe;
				return Math.abs(gt - rt) >= o.scrollToCloseDistance || Math.abs(Et - ut) >= o
					.scrollToCloseDistance
			},
			xe = throttleByRaf(Oe => {
				if (O.value)
					if (o.scrollToClose || m != null && m.scrollToClose) {
						const Xe = Oe.target;
						F || (F = [Xe.scrollTop, Xe.scrollLeft]), Ae(F, Xe) ? fe(!1) : ae()
					} else ae()
			}),
			ye = () => {
				off(window, "scroll", Le), me = !1
			},
			Le = throttleByRaf(Oe => {
				const Xe = Oe.target.documentElement;
				R || (R = [Xe.scrollTop, Xe.scrollLeft]), Ae(R, Xe) && (fe(!1), ye())
			}),
			Ue = () => {
				O.value && ae()
			},
			nt = () => {
				Ue(), s("resize")
			},
			ot = Oe => {
				o.preventFocus && Oe.preventDefault()
			};
		y == null || y.addChildRef(_);
		const at = computed(() => O.value ? o.openedClass : void 0);
		let Je;
		watch(O, Oe => {
			if (o.clickOutsideToClose && (!Oe && ge ? it() : Oe && !ge && (on(document.documentElement,
					"mousedown", He), ge = !0)), (o.scrollToClose || m != null && m.scrollToClose) && (
					on(window, "scroll", Le), me = !0), o.updateAtScroll || m != null && m
				.updateAtScroll) {
				if (Oe) {
					Je = getScrollElements(C.value);
					for (const Xe of Je) Xe.addEventListener("scroll", xe)
				} else if (Je) {
					for (const Xe of Je) Xe.removeEventListener("scroll", xe);
					Je = void 0
				}
			}
			Oe && (Ce.value = !0)
		}), watch(() => [o.autoFitPopupWidth, o.autoFitPopupMinWidth], () => {
			O.value && ae()
		});
		const {
			createResizeObserver: Ne,
			destroyResizeObserver: we
		} = useResizeObserver({
			elementRef: V,
			onResize: Ue
		});
		onMounted(() => {
			if (Ne(), O.value && (ae(), o.clickOutsideToClose && !ge && (on(document.documentElement,
					"mousedown", He), ge = !0), o.updateAtScroll || m != null && m.updateAtScroll)) {
				Je = getScrollElements(C.value);
				for (const Oe of Je) Oe.addEventListener("scroll", xe)
			}
		}), onUpdated(() => {
			O.value && ae()
		}), onDeactivated(() => {
			fe(!1)
		}), onBeforeUnmount(() => {
			if (y == null || y.removeChildRef(_), we(), ge && it(), me && ye(), Je) {
				for (const Oe of Je) Oe.removeEventListener("scroll", xe);
				Je = void 0
			}
		});
		const Ce = ref(O.value),
			$e = ref(!1),
			Fe = () => {
				$e.value = !0
			},
			Ge = () => {
				$e.value = !1, O.value && s("show")
			},
			ze = () => {
				$e.value = !1, O.value || (Ce.value = !1, s("hide"))
			};
		return () => {
			var Oe, Xe;
			return b.value = (Xe = (Oe = a.default) == null ? void 0 : Oe.call(a)) != null ? Xe : [],
				mergeFirstChild(b.value, {
					class: at.value,
					onClick: q,
					onMouseenter: le,
					onMouseleave: _e,
					onFocusin: De,
					onFocusout: Se,
					onContextmenu: be
				}), createVNode(Fragment, null, [o.autoFixPosition ? createVNode(ResizeObserver$1, {
					onResize: nt
				}, {
					default: () => [b.value]
				}) : b.value, createVNode(ClientOnly, null, {
					default: () => [createVNode(Teleport, {
						to: U.value,
						disabled: !o.renderToBody
					}, {
						default: () => [(!o.unmountOnClose || O.value || Ce
							.value) && !dt.value && createVNode(
								ResizeObserver$1, {
									onResize: Ue
								}, {
									default: () => [createVNode("div",
										mergeProps({
											ref: _,
											class: [`${d}-popup`,
												`${d}-position-${w.value}`
											],
											style: {
												...T.value,
												zIndex: z.value,
												pointerEvents: $e
													.value ?
													"none" : "auto"
											},
											"trigger-placement": w
												.value,
											onMouseenter: de,
											onMouseleave: ke,
											onMousedown: ot
										}, f.value), [createVNode(
											Transition, {
												name: o
													.animationName,
												duration: o
													.duration,
												appear: !0,
												onBeforeEnter: Fe,
												onAfterEnter: Ge,
												onBeforeLeave: Fe,
												onAfterLeave: ze
											}, {
												default: () => {
													var rt;
													return [withDirectives(
														createVNode(
															"div", {
																class: `${d}-popup-wrapper`,
																style: A
																	.value
															},
															[createVNode(
																	"div", {
																		class: [`${d}-content`,
																			o
																			.contentClass
																		],
																		style: o
																			.contentStyle
																	},
																	[(rt = a
																			.content) ==
																		null ?
																		void 0 :
																		rt
																		.call(
																			a
																			)
																	]
																	),
																o
																.showArrow &&
																createVNode(
																	"div", {
																		ref: M,
																		class: [`${d}-arrow`,
																			o
																			.arrowClass
																		],
																		style: k
																			.value
																	},
																	null
																	)
															]
															),
														[
															[vShow,
																O
																.value
															]
														]
														)]
												}
											})])]
								})
						]
					})]
				})])
		}
	}
});
const Trigger = Object.assign(_Trigger, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Trigger.name, _Trigger)
		}
	}),
	_sfc_main$2_ = defineComponent({
		name: "IconEmpty",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-empty`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$19 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2I(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M24 5v6m7 1 4-4m-18 4-4-4m28.5 22H28s-1 3-4 3-4-3-4-3H6.5M40 41H8a2 2 0 0 1-2-2v-8.46a2 2 0 0 1 .272-1.007l6.15-10.54A2 2 0 0 1 14.148 18H33.85a2 2 0 0 1 1.728.992l6.149 10.541A2 2 0 0 1 42 30.541V39a2 2 0 0 1-2 2Z"
	}, null, -1)]), 14, _hoisted_1$19)
}
var _IconEmpty = _export_sfc$1(_sfc_main$2_, [
	["render", _sfc_render$2I]
]);
const IconEmpty = Object.assign(_IconEmpty, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconEmpty.name, _IconEmpty)
	}
});
var Empty$1 = defineComponent({
	name: "Empty",
	inheritAttrs: !1,
	props: {
		description: String,
		imgSrc: String,
		inConfigProvider: {
			type: Boolean,
			default: !1
		}
	},
	setup(o, {
		slots: s,
		attrs: a
	}) {
		const l = getPrefixCls("empty"),
			{
				t: c
			} = useI18n(),
			d = inject(configProviderInjectionKey, void 0);
		return () => {
			var f, m, g, v;
			return !o.inConfigProvider && (d != null && d.slots.empty) && !(s.image || o.imgSrc || o
				.description) ? d.slots.empty({
				component: "empty"
			}) : createVNode("div", mergeProps({
				class: l
			}, a), [createVNode("div", {
				class: `${l}-image`
			}, [(m = (f = s.image) == null ? void 0 : f.call(s)) != null ? m : o.imgSrc ?
				createVNode("img", {
					src: o.imgSrc,
					alt: o.description || "empty"
				}, null) : createVNode(IconEmpty, null, null)
			]), createVNode("div", {
				class: `${l}-description`
			}, [(v = (g = s.default) == null ? void 0 : g.call(s)) != null ? v : o
				.description || c("empty.description")
			])])
		}
	}
});
const Empty = Object.assign(Empty$1, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + Empty$1.name, Empty$1)
		}
	}),
	DOT_NUMBER = 5;
var DotLoading = defineComponent({
		name: "DotLoading",
		props: {
			size: {
				type: Number
			}
		},
		setup(o) {
			const s = getPrefixCls("dot-loading");
			return () => {
				const a = o.size ? {
					width: `${o.size}px`,
					height: `${o.size}px`
				} : {};
				return createVNode("div", {
					class: s,
					style: {
						width: o.size ? `${o.size*7}px` : void 0,
						height: o.size ? `${o.size}px` : void 0
					}
				}, [Array(DOT_NUMBER).fill(1).map((l, c) => createVNode("div", {
					class: `${s}-item`,
					key: c,
					style: a
				}, null))])
			}
		}
	}),
	_Spin = defineComponent({
		name: "Spin",
		props: {
			size: {
				type: Number
			},
			loading: Boolean,
			dot: Boolean,
			tip: String,
			hideIcon: {
				type: Boolean,
				default: !1
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("spin"),
				l = inject(configProviderInjectionKey, void 0),
				c = computed(() => [a, {
					[`${a}-loading`]: o.loading,
					[`${a}-with-tip`]: o.tip && !s.default
				}]),
				d = () => {
					if (s.icon) {
						const m = getFirstComponent(s.icon());
						if (m) return cloneVNode(m, {
							spin: !0
						})
					}
					return s.element ? s.element() : o.dot ? createVNode(DotLoading, {
						size: o.size
					}, null) : l != null && l.slots.loading ? l.slots.loading() : createVNode(IconLoading, {
						spin: !0,
						size: o.size
					}, null)
				},
				f = () => {
					var m, g, v;
					const y = o.size ? {
							fontSize: `${o.size}px`
						} : void 0,
						b = !!((m = s.tip) != null ? m : o.tip);
					return createVNode(Fragment, null, [!o.hideIcon && createVNode("div", {
						class: `${a}-icon`,
						style: y
					}, [d()]), b && createVNode("div", {
						class: `${a}-tip`
					}, [(v = (g = s.tip) == null ? void 0 : g.call(s)) != null ? v : o.tip])])
				};
			return () => createVNode("div", {
				class: c.value
			}, [s.default ? createVNode(Fragment, null, [s.default(), o.loading && createVNode("div", {
				class: `${a}-mask`
			}, [createVNode("div", {
				class: `${a}-mask-icon`
			}, [f()])])]) : f()])
		}
	});
const Spin = Object.assign(_Spin, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Spin.name, _Spin)
		}
	}),
	_sfc_main$2Z = defineComponent({
		name: "Thumb",
		props: {
			data: {
				type: Object
			},
			direction: {
				type: String,
				default: "horizontal"
			},
			alwaysShow: {
				type: Boolean,
				default: !1
			},
			both: {
				type: Boolean,
				default: !1
			}
		},
		emits: ["scroll"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("scrollbar"),
				l = ref(!1),
				c = ref(),
				d = ref(),
				f = computed(() => o.direction === "horizontal" ? {
					size: "width",
					direction: "left",
					offset: "offsetWidth",
					client: "clientX"
				} : {
					size: "height",
					direction: "top",
					offset: "offsetHeight",
					client: "clientY"
				}),
				m = ref(0),
				g = ref(!1),
				v = ref(0),
				y = computed(() => {
					var k, M;
					return {
						[f.value.size]: `${(M=(k=o.data)==null?void 0:k.thumbSize)!=null?M:0}px`,
						[f.value.direction]: `${m.value}px`
					}
				}),
				b = k => {
					k.preventDefault(), d.value && (v.value = k[f.value.client] - d.value.getBoundingClientRect()[f
						.value.direction], g.value = !0, on(window, "mousemove", S), on(window, "mouseup",
						w), on(window, "contextmenu", w))
				},
				C = k => {
					var M, D, F, R;
					if (k.preventDefault(), d.value) {
						const O = _(k[f.value.client] > d.value.getBoundingClientRect()[f.value.direction] ? m
							.value + ((D = (M = o.data) == null ? void 0 : M.thumbSize) != null ? D : 0) : m
							.value - ((R = (F = o.data) == null ? void 0 : F.thumbSize) != null ? R : 0));
						O !== m.value && (m.value = O, s("scroll", O))
					}
				},
				_ = k => k < 0 ? 0 : o.data && k > o.data.max ? o.data.max : k,
				S = k => {
					if (c.value && d.value) {
						const M = _(k[f.value.client] - c.value.getBoundingClientRect()[f.value.direction] - v
							.value);
						M !== m.value && (m.value = M, s("scroll", M))
					}
				},
				w = () => {
					g.value = !1, off(window, "mousemove", S), off(window, "mouseup", w)
				},
				T = k => {
					g.value || (k = _(k), k !== m.value && (m.value = k))
				},
				A = computed(() => [`${a}-thumb`, `${a}-thumb-direction-${o.direction}`, {
					[`${a}-thumb-dragging`]: g.value
				}]);
			return {
				visible: l,
				trackRef: c,
				thumbRef: d,
				prefixCls: a,
				thumbCls: A,
				thumbStyle: y,
				handleThumbMouseDown: b,
				handleTrackClick: C,
				setOffset: T
			}
		}
	});

function _sfc_render$2H(o, s, a, l, c, d) {
	return openBlock(), createBlock(Transition, null, {
		default: withCtx(() => [createBaseVNode("div", {
			ref: "trackRef",
			class: normalizeClass([`${o.prefixCls}-track`,
				`${o.prefixCls}-track-direction-${o.direction}`
			]),
			onMousedown: s[1] || (s[1] = withModifiers((...f) => o.handleTrackClick && o
				.handleTrackClick(...f), ["self"]))
		}, [createBaseVNode("div", {
			ref: "thumbRef",
			class: normalizeClass(o.thumbCls),
			style: normalizeStyle(o.thumbStyle),
			onMousedown: s[0] || (s[0] = (...f) => o.handleThumbMouseDown && o
				.handleThumbMouseDown(...f))
		}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-thumb-bar`)
		}, null, 2)], 38)], 34)]),
		_: 1
	})
}
var Thumb = _export_sfc$1(_sfc_main$2Z, [
	["render", _sfc_render$2H]
]);
const THUMB_MIN_SIZE = 20,
	TRACK_SIZE = 15,
	_sfc_main$2Y = defineComponent({
		name: "Scrollbar",
		components: {
			ResizeObserver: ResizeObserver$1,
			Thumb
		},
		inheritAttrs: !1,
		props: {
			type: {
				type: String,
				default: "embed"
			},
			outerClass: [String, Object, Array],
			outerStyle: {
				type: [String, Object, Array]
			},
			hide: {
				type: Boolean,
				default: !1
			},
			disableHorizontal: {
				type: Boolean,
				default: !1
			},
			disableVertical: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			scroll: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("scrollbar"),
				l = ref(),
				c = ref(),
				d = ref(),
				f = ref(),
				m = ref(),
				g = ref(!1),
				v = ref(!1),
				y = computed(() => g.value && !o.disableHorizontal),
				b = computed(() => v.value && !o.disableVertical),
				C = ref(!1),
				_ = () => {
					var D, F, R, O, U, V;
					if (l.value) {
						const {
							clientWidth: z,
							clientHeight: j,
							offsetWidth: ge,
							offsetHeight: me,
							scrollWidth: he,
							scrollHeight: ce,
							scrollTop: ae,
							scrollLeft: fe
						} = l.value;
						g.value = he > z, v.value = ce > j, C.value = y.value && b.value;
						const q = o.type === "embed" && C.value ? ge - TRACK_SIZE : ge,
							le = o.type === "embed" && C.value ? me - TRACK_SIZE : me,
							de = Math.round(q / Math.min(he / z, q / THUMB_MIN_SIZE)),
							_e = q - de,
							ke = (he - z) / _e,
							De = Math.round(le / Math.min(ce / j, le / THUMB_MIN_SIZE)),
							Se = le - De,
							be = (ce - j) / Se;
						if (c.value = {
								ratio: ke,
								thumbSize: de,
								max: _e
							}, d.value = {
								ratio: be,
								thumbSize: De,
								max: Se
							}, ae > 0) {
							const Me = Math.round(ae / ((F = (D = d.value) == null ? void 0 : D.ratio) != null ? F :
								1));
							(R = m.value) == null || R.setOffset(Me)
						}
						if (fe > 0) {
							const Me = Math.round(fe / ((U = (O = d.value) == null ? void 0 : O.ratio) != null ? U :
								1));
							(V = f.value) == null || V.setOffset(Me)
						}
					}
				};
			onMounted(() => {
				_()
			});
			const S = () => {
					_()
				},
				w = D => {
					var F, R, O, U, V, z;
					if (l.value) {
						if (y.value && !o.disableHorizontal) {
							const j = Math.round(l.value.scrollLeft / ((R = (F = c.value) == null ? void 0 : F
								.ratio) != null ? R : 1));
							(O = f.value) == null || O.setOffset(j)
						}
						if (b.value && !o.disableVertical) {
							const j = Math.round(l.value.scrollTop / ((V = (U = d.value) == null ? void 0 : U
								.ratio) != null ? V : 1));
							(z = m.value) == null || z.setOffset(j)
						}
					}
					s("scroll", D)
				},
				T = D => {
					var F, R;
					l.value && l.value.scrollTo({
						left: D * ((R = (F = c.value) == null ? void 0 : F.ratio) != null ? R : 1)
					})
				},
				A = D => {
					var F, R;
					l.value && l.value.scrollTo({
						top: D * ((R = (F = d.value) == null ? void 0 : F.ratio) != null ? R : 1)
					})
				},
				k = computed(() => {
					const D = {};
					return o.type === "track" && (y.value && (D.paddingBottom = `${TRACK_SIZE}px`), b.value && (
						D.paddingRight = `${TRACK_SIZE}px`)), [D, o.outerStyle]
				}),
				M = computed(() => [`${a}`, `${a}-type-${o.type}`, {
					[`${a}-both`]: C.value
				}, o.outerClass]);
			return {
				prefixCls: a,
				cls: M,
				style: k,
				containerRef: l,
				horizontalThumbRef: f,
				verticalThumbRef: m,
				horizontalData: c,
				verticalData: d,
				isBoth: C,
				hasHorizontalScrollbar: y,
				hasVerticalScrollbar: b,
				handleResize: S,
				handleScroll: w,
				handleHorizontalScroll: T,
				handleVerticalScroll: A
			}
		},
		methods: {
			scrollTo(o, s) {
				var a, l;
				isObject$2(o) ? (a = this.$refs.containerRef) == null || a.scrollTo(o) : (o || s) && ((l = this
					.$refs.containerRef) == null || l.scrollTo(o, s))
			},
			scrollTop(o) {
				var s;
				(s = this.$refs.containerRef) == null || s.scrollTo({
					top: o
				})
			},
			scrollLeft(o) {
				var s;
				(s = this.$refs.containerRef) == null || s.scrollTo({
					left: o
				})
			}
		}
	});

function _sfc_render$2G(o, s, a, l, c, d) {
	const f = resolveComponent("ResizeObserver"),
		m = resolveComponent("thumb");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.style)
	}, [createVNode(f, {
			onResize: o.handleResize
		}, {
			default: withCtx(() => [createBaseVNode("div", mergeProps({
				ref: "containerRef",
				class: `${o.prefixCls}-container`
			}, o.$attrs, {
				onScroll: s[0] || (s[0] = (...g) => o.handleScroll && o.handleScroll(...
					g))
			}), [createVNode(f, {
				onResize: o.handleResize
			}, {
				default: withCtx(() => [renderSlot(o.$slots, "default")]),
				_: 3
			}, 8, ["onResize"])], 16)]),
			_: 3
		}, 8, ["onResize"]), !o.hide && o.hasHorizontalScrollbar ? (openBlock(), createBlock(m, {
			key: 0,
			ref: "horizontalThumbRef",
			data: o.horizontalData,
			direction: "horizontal",
			both: o.isBoth,
			onScroll: o.handleHorizontalScroll
		}, null, 8, ["data", "both", "onScroll"])) : createCommentVNode("v-if", !0), !o.hide && o
		.hasVerticalScrollbar ? (openBlock(), createBlock(m, {
			key: 1,
			ref: "verticalThumbRef",
			data: o.verticalData,
			direction: "vertical",
			both: o.isBoth,
			onScroll: o.handleVerticalScroll
		}, null, 8, ["data", "both", "onScroll"])) : createCommentVNode("v-if", !0)
	], 6)
}
var _Scrollbar = _export_sfc$1(_sfc_main$2Y, [
	["render", _sfc_render$2G]
]);
const Scrollbar = Object.assign(_Scrollbar, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Scrollbar.name, _Scrollbar)
		}
	}),
	useComponentRef = o => {
		const s = ref(),
			a = () => isComponentInstance(s.value) ? s.value.$refs[o] : s.value,
			l = ref();
		return onMounted(() => {
			l.value = a()
		}), watch([s], () => {
			l.value = a()
		}), {
			componentRef: s,
			elementRef: l
		}
	},
	useScrollbar = o => {
		const s = computed(() => !!o.value),
			a = computed(() => {
				if (o.value) return {
					type: "embed",
					...isBoolean$2(o.value) ? void 0 : o.value
				}
			});
		return {
			displayScrollbar: s,
			scrollbarProps: a
		}
	},
	_sfc_main$2X = defineComponent({
		name: "SelectDropdown",
		components: {
			ScrollbarComponent: Scrollbar,
			Empty,
			Spin
		},
		props: {
			loading: Boolean,
			empty: Boolean,
			virtualList: Boolean,
			bottomOffset: {
				type: Number,
				default: 0
			},
			scrollbar: {
				type: [Boolean, Object],
				default: !0
			},
			onScroll: {
				type: [Function, Array]
			},
			onReachBottom: {
				type: [Function, Array]
			},
			showHeaderOnEmpty: {
				type: Boolean,
				default: !1
			},
			showFooterOnEmpty: {
				type: Boolean,
				default: !1
			}
		},
		emits: ["scroll", "reachBottom"],
		setup(o, {
			emit: s,
			slots: a
		}) {
			var l, c, d;
			const {
				scrollbar: f
			} = toRefs(o), m = getPrefixCls("select-dropdown"), g = inject(configProviderInjectionKey, void 0), v =
				(d = (c = g == null ? void 0 : (l = g.slots).empty) == null ? void 0 : c.call(l, {
					component: "select"
				})) == null ? void 0 : d[0], {
					componentRef: y,
					elementRef: b
				} = useComponentRef("containerRef"), {
					displayScrollbar: C,
					scrollbarProps: _
				} = useScrollbar(f), S = T => {
					const {
						scrollTop: A,
						scrollHeight: k,
						offsetHeight: M
					} = T.target;
					k - (A + M) <= o.bottomOffset && s("reachBottom", T), s("scroll", T)
				}, w = computed(() => [m, {
					[`${m}-has-header`]: !!a.header,
					[`${m}-has-footer`]: !!a.footer
				}]);
			return {
				prefixCls: m,
				SelectEmpty: v,
				cls: w,
				wrapperRef: b,
				wrapperComRef: y,
				handleScroll: S,
				displayScrollbar: C,
				scrollbarProps: _
			}
		}
	});

function _sfc_render$2F(o, s, a, l, c, d) {
	const f = resolveComponent("spin");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [o.$slots.header && (!o.empty || o.showHeaderOnEmpty) ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-header`)
		}, [renderSlot(o.$slots, "header")], 2)) : createCommentVNode("v-if", !0), o.loading ? (openBlock(),
			createBlock(f, {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-loading`)
			}, null, 8, ["class"])) : o.empty ? (openBlock(), createElementBlock("div", {
			key: 2,
			class: normalizeClass(`${o.prefixCls}-empty`)
		}, [renderSlot(o.$slots, "empty", {}, () => [(openBlock(), createBlock(resolveDynamicComponent(o
			.SelectEmpty ? o.SelectEmpty : "Empty")))])], 2)) : createCommentVNode("v-if", !0), o.virtualList &&
		!o.loading && !o.empty ? renderSlot(o.$slots, "virtual-list", {
			key: 3
		}) : createCommentVNode("v-if", !0), o.virtualList ? createCommentVNode("v-if", !0) : withDirectives((
			openBlock(), createBlock(resolveDynamicComponent(o.displayScrollbar ? "ScrollbarComponent" :
				"div"), mergeProps({
				key: 4,
				ref: "wrapperComRef",
				class: `${o.prefixCls}-list-wrapper`
			}, o.scrollbarProps, {
				onScroll: o.handleScroll
			}), {
				default: withCtx(() => [createBaseVNode("ul", {
					class: normalizeClass(`${o.prefixCls}-list`)
				}, [renderSlot(o.$slots, "default")], 2)]),
				_: 3
			}, 16, ["class", "onScroll"])), [
			[vShow, !o.loading && !o.empty]
		]), o.$slots.footer && (!o.empty || o.showFooterOnEmpty) ? (openBlock(), createElementBlock("div", {
			key: 5,
			class: normalizeClass(`${o.prefixCls}-footer`)
		}, [renderSlot(o.$slots, "footer")], 2)) : createCommentVNode("v-if", !0)
	], 2)
}
var SelectDropdown = _export_sfc$1(_sfc_main$2X, [
		["render", _sfc_render$2F]
	]),
	IconCheck$1 = defineComponent({
		name: "IconCheck",
		render() {
			return createVNode("svg", {
				"aria-hidden": "true",
				focusable: "false",
				viewBox: "0 0 1024 1024",
				width: "200",
				height: "200",
				fill: "currentColor"
			}, [createVNode("path", {
				d: "M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z",
				"p-id": "840"
			}, null)])
		}
	});
const checkboxGroupKey = Symbol("ArcoCheckboxGroup");
var _Checkbox = defineComponent({
		name: "Checkbox",
		components: {
			IconCheck: IconCheck$1,
			IconHover
		},
		props: {
			modelValue: {
				type: [Boolean, Array],
				default: void 0
			},
			defaultChecked: {
				type: Boolean,
				default: !1
			},
			value: {
				type: [String, Number, Boolean]
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			indeterminate: {
				type: Boolean,
				default: !1
			},
			uninjectGroupContext: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:modelValue": o => !0,
			change: (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				disabled: l,
				modelValue: c
			} = toRefs(o), d = getPrefixCls("checkbox"), f = ref(), m = o.uninjectGroupContext ? void 0 : inject(
				checkboxGroupKey, void 0), g = (m == null ? void 0 : m.name) === "ArcoCheckboxGroup", {
				mergedDisabled: v,
				eventHandlers: y
			} = useFormItem({
				disabled: l
			}), b = ref(o.defaultChecked), C = computed(() => {
				var D;
				return g ? m == null ? void 0 : m.computedValue : (D = o.modelValue) != null ? D : b.value
			}), _ = computed(() => {
				var D;
				return isArray$2(C.value) ? C.value.includes((D = o.value) != null ? D : !0) : C.value
			}), S = computed(() => (m == null ? void 0 : m.disabled) || (v == null ? void 0 : v.value) || !_
				.value && (m == null ? void 0 : m.isMaxed)), w = D => {
				D.stopPropagation()
			}, T = D => {
				var F, R, O, U;
				const {
					checked: V
				} = D.target;
				let z = V;
				if (isArray$2(C.value)) {
					const j = new Set(C.value);
					V ? j.add((F = o.value) != null ? F : !0) : j.delete((R = o.value) != null ? R : !0), z =
						Array.from(j)
				}
				b.value = V, g && isArray$2(z) ? m == null || m.handleChange(z, D) : (s("update:modelValue", z),
					s("change", z, D), (U = (O = y.value) == null ? void 0 : O.onChange) == null || U.call(
						O, D)), nextTick(() => {
					f.value && f.value.checked !== _.value && (f.value.checked = _.value)
				})
			}, A = computed(() => [d, {
				[`${d}-checked`]: _.value,
				[`${d}-indeterminate`]: o.indeterminate,
				[`${d}-disabled`]: S.value
			}]), k = D => {
				var F, R;
				(R = (F = y.value) == null ? void 0 : F.onFocus) == null || R.call(F, D)
			}, M = D => {
				var F, R;
				(R = (F = y.value) == null ? void 0 : F.onBlur) == null || R.call(F, D)
			};
			return watch(c, D => {
				(isUndefined$1(D) || isNull$1(D)) && (b.value = !1)
			}), watch(C, D => {
				var F;
				let R;
				isArray$2(D) ? R = D.includes((F = o.value) != null ? F : !0) : R = D, b.value !== R && (b
					.value = R), f.value && f.value.checked !== R && (f.value.checked = R)
			}), () => {
				var D, F, R, O;
				return createVNode("label", {
					"aria-disabled": S.value,
					class: A.value
				}, [createVNode("input", {
					ref: f,
					type: "checkbox",
					checked: _.value,
					value: o.value,
					class: `${d}-target`,
					disabled: S.value,
					onClick: w,
					onChange: T,
					onFocus: k,
					onBlur: M
				}, null), (O = (R = (F = a.checkbox) != null ? F : (D = m == null ? void 0 : m
					.slots) == null ? void 0 : D.checkbox) == null ? void 0 : R({
					checked: _.value,
					disabled: S.value
				})) != null ? O : createVNode(IconHover, {
					class: `${d}-icon-hover`,
					disabled: S.value || _.value
				}, {
					default: () => [createVNode("div", {
						class: `${d}-icon`
					}, [_.value && createVNode(IconCheck$1, {
						class: `${d}-icon-check`
					}, null)])]
				}), a.default && createVNode("span", {
					class: `${d}-label`
				}, [a.default()])])
			}
		}
	}),
	CheckboxGroup = defineComponent({
		name: "CheckboxGroup",
		props: {
			modelValue: {
				type: Array,
				default: void 0
			},
			defaultValue: {
				type: Array,
				default: () => []
			},
			max: {
				type: Number
			},
			options: {
				type: Array
			},
			direction: {
				type: String,
				default: "horizontal"
			},
			disabled: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:modelValue": o => !0,
			change: (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				disabled: l
			} = toRefs(o), c = getPrefixCls("checkbox-group"), {
					mergedDisabled: d,
					eventHandlers: f
				} = useFormItem({
					disabled: l
				}), m = ref(o.defaultValue), g = computed(() => isArray$2(o.modelValue) ? o.modelValue : m.value),
				v = computed(() => o.max === void 0 ? !1 : g.value.length >= o.max), y = computed(() => {
					var S;
					return ((S = o.options) != null ? S : []).map(w => isString$2(w) || isNumber$2(w) ? {
						label: w,
						value: w
					} : w)
				});
			provide(checkboxGroupKey, reactive({
				name: "ArcoCheckboxGroup",
				computedValue: g,
				disabled: d,
				isMaxed: v,
				slots: a,
				handleChange: (S, w) => {
					var T, A;
					m.value = S, s("update:modelValue", S), s("change", S, w), (A = (T = f.value) ==
						null ? void 0 : T.onChange) == null || A.call(T, w)
				}
			}));
			const C = computed(() => [c, `${c}-direction-${o.direction}`]);
			watch(() => o.modelValue, S => {
				isArray$2(S) ? m.value = [...S] : m.value = []
			});
			const _ = () => y.value.map(S => {
				const w = g.value.includes(S.value);
				return createVNode(_Checkbox, {
					key: S.value,
					value: S.value,
					disabled: S.disabled || !w && v.value,
					indeterminate: S.indeterminate,
					modelValue: w
				}, {
					default: () => [a.label ? a.label({
						data: S
					}) : isFunction$2(S.label) ? S.label() : S.label]
				})
			});
			return () => {
				var S;
				return createVNode("span", {
					class: C.value
				}, [y.value.length > 0 ? _() : (S = a.default) == null ? void 0 : S.call(a)])
			}
		}
	});
const Checkbox = Object.assign(_Checkbox, {
		Group: CheckboxGroup,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Checkbox.name, _Checkbox), o.component(a + CheckboxGroup.name, CheckboxGroup)
		}
	}),
	selectInjectionKey = Symbol("ArcoSelectContext"),
	isGroupOption = o => isObject$2(o) && "isGroup" in o,
	isGroupOptionInfo = o => isObject$2(o) && "isGroup" in o,
	getValueString = (o, s = "value") => String(isObject$2(o) ? o[s] : o),
	getKeyFromValue = (o, s = "value") => isObject$2(o) ? `__arco__option__object__${o[s]}` : o || isNumber$2(o) ||
	isString$2(o) || isBoolean$2(o) ? `__arco__option__${typeof o}-${o}` : "",
	hasEmptyStringKey = o => o.has("__arco__option__string-"),
	createOptionInfo = (o, {
		valueKey: s,
		fieldNames: a,
		origin: l,
		index: c = -1
	}) => {
		var d;
		if (isObject$2(o)) {
			const m = o[a.value];
			return {
				raw: o,
				index: c,
				key: getKeyFromValue(m, s),
				origin: l,
				value: m,
				label: (d = o[a.label]) != null ? d : getValueString(m, s),
				render: o[a.render],
				disabled: !!o[a.disabled],
				tagProps: o[a.tagProps]
			}
		}
		const f = {
			value: o,
			label: String(o),
			disabled: !1
		};
		return {
			raw: f,
			index: c,
			key: getKeyFromValue(o, s),
			origin: l,
			...f
		}
	},
	getOptionInfos$1 = (o, {
		valueKey: s,
		fieldNames: a,
		origin: l,
		optionInfoMap: c
	}) => {
		var d;
		const f = [];
		for (const m of o)
			if (isGroupOption(m)) {
				const g = getOptionInfos$1((d = m.options) != null ? d : [], {
					valueKey: s,
					fieldNames: a,
					origin: l,
					optionInfoMap: c
				});
				g.length > 0 && f.push({
					...m,
					key: `__arco__group__${m.label}`,
					options: g
				})
			} else {
				const g = createOptionInfo(m, {
					valueKey: s,
					fieldNames: a,
					origin: l
				});
				f.push(g), c.get(g.key) || c.set(g.key, g)
			} return f
	},
	getValidOptions = (o, {
		inputValue: s,
		filterOption: a
	}) => {
		const l = c => {
			var d;
			const f = [];
			for (const m of c)
				if (isGroupOptionInfo(m)) {
					const g = l((d = m.options) != null ? d : []);
					g.length > 0 && f.push({
						...m,
						options: g
					})
				} else isValidOption(m, {
					inputValue: s,
					filterOption: a
				}) && f.push(m);
			return f
		};
		return l(o)
	},
	isValidOption = (o, {
		inputValue: s,
		filterOption: a
	}) => isFunction$2(a) ? !s || a(s, o.raw) : a ? o.label.toLowerCase().includes((s ?? "").toLowerCase()) : !0,
	isEqualObject = (o, s) => {
		if (!o || !s || o.length !== s.length) return !1;
		for (const a of Object.keys(o))
			if (!isEqual$1(o[a], s[a])) return !1;
		return !0
	},
	isEqualArray = (o, s) => {
		if (!o || !s) return !1;
		const {
			length: a
		} = o;
		if (a !== s.length) return !1;
		for (let l = 0; l < a; l++)
			if (!isEqual$1(o[l], s[l])) return !1;
		return !0
	},
	isEqual$1 = (o, s) => {
		const a = Object.prototype.toString.call(o);
		return a !== Object.prototype.toString.call(s) ? !1 : a === "[object Object]" ? isEqualObject(o, s) : a ===
			"[object Array]" ? isEqualArray(o, s) : a === "[object Function]" ? o === s ? !0 : o.toString() === s
			.toString() : o === s
	},
	_sfc_main$2W = defineComponent({
		name: "Option",
		components: {
			Checkbox
		},
		props: {
			value: {
				type: [String, Number, Boolean, Object],
				default: void 0
			},
			label: String,
			disabled: Boolean,
			tagProps: {
				type: Object
			},
			extra: {
				type: Object
			},
			index: {
				type: Number
			},
			internal: Boolean
		},
		setup(o) {
			const {
				disabled: s,
				tagProps: a,
				index: l
			} = toRefs(o), c = getPrefixCls("select-option"), d = inject(selectInjectionKey, void 0), f =
				getCurrentInstance(), m = ref(), g = ref(a.value);
			watch(a, (R, O) => {
				isEqual$1(R, O) || (g.value = R)
			});
			const v = ref(""),
				y = computed(() => {
					var R, O;
					return (O = (R = o.value) != null ? R : o.label) != null ? O : v.value
				}),
				b = computed(() => {
					var R;
					return (R = o.label) != null ? R : v.value
				}),
				C = computed(() => getKeyFromValue(y.value, d == null ? void 0 : d.valueKey)),
				_ = computed(() => {
					var R;
					return (R = d == null ? void 0 : d.component) != null ? R : "li"
				}),
				S = () => {
					var R;
					if (!o.label && m.value) {
						const O = (R = m.value.textContent) != null ? R : "";
						v.value !== O && (v.value = O)
					}
				};
			onMounted(() => S()), onUpdated(() => S());
			const w = computed(() => {
					var R;
					return (R = d == null ? void 0 : d.valueKeys.includes(C.value)) != null ? R : !1
				}),
				T = computed(() => (d == null ? void 0 : d.activeKey) === C.value);
			let A = ref(!0);
			if (!o.internal) {
				const R = reactive({
					raw: {
						value: y,
						label: b,
						disabled: s,
						tagProps: g
					},
					ref: m,
					index: l,
					key: C,
					origin: "slot",
					value: y,
					label: b,
					disabled: s,
					tagProps: g
				});
				A = computed(() => isValidOption(R, {
					inputValue: d == null ? void 0 : d.inputValue,
					filterOption: d == null ? void 0 : d.filterOption
				})), f && (d == null || d.addSlotOptionInfo(f.uid, R)), onBeforeUnmount(() => {
					f && (d == null || d.removeSlotOptionInfo(f.uid))
				})
			}
			const k = R => {
					o.disabled || d == null || d.onSelect(C.value, R)
				},
				M = () => {
					o.disabled || d == null || d.setActiveKey(C.value)
				},
				D = () => {
					o.disabled || d == null || d.setActiveKey()
				},
				F = computed(() => [c, {
					[`${c}-disabled`]: o.disabled,
					[`${c}-selected`]: w.value,
					[`${c}-active`]: T.value,
					[`${c}-multiple`]: d == null ? void 0 : d.multiple
				}]);
			return {
				prefixCls: c,
				cls: F,
				selectCtx: d,
				itemRef: m,
				component: _,
				isSelected: w,
				isValid: A,
				handleClick: k,
				handleMouseEnter: M,
				handleMouseLeave: D
			}
		}
	});

function _sfc_render$2E(o, s, a, l, c, d) {
	const f = resolveComponent("checkbox");
	return withDirectives((openBlock(), createBlock(resolveDynamicComponent(o.component), {
		ref: "itemRef",
		class: normalizeClass([o.cls, {
			[`${o.prefixCls}-has-suffix`]: !!o.$slots.suffix
		}]),
		onClick: o.handleClick,
		onMouseenter: o.handleMouseEnter,
		onMouseleave: o.handleMouseLeave
	}, {
		default: withCtx(() => [o.$slots.icon ? (openBlock(), createElementBlock("span", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-icon`)
			}, [renderSlot(o.$slots, "icon")], 2)) : createCommentVNode("v-if", !0), o
			.selectCtx && o.selectCtx.multiple ? (openBlock(), createBlock(f, {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-checkbox`),
				"model-value": o.isSelected,
				disabled: o.disabled,
				"uninject-group-context": ""
			}, {
				default: withCtx(() => [renderSlot(o.$slots, "default", {}, () => [
					createTextVNode(toDisplayString(o.label), 1)
				])]),
				_: 3
			}, 8, ["class", "model-value", "disabled"])) : (openBlock(), createElementBlock(
				"span", {
					key: 2,
					class: normalizeClass(`${o.prefixCls}-content`)
				}, [renderSlot(o.$slots, "default", {}, () => [createTextVNode(
					toDisplayString(o.label), 1)])], 2)), o.$slots.suffix ? (openBlock(),
				createElementBlock("span", {
					key: 3,
					class: normalizeClass(`${o.prefixCls}-suffix`)
				}, [renderSlot(o.$slots, "suffix")], 2)) : createCommentVNode("v-if", !0)
		]),
		_: 3
	}, 40, ["class", "onClick", "onMouseenter", "onMouseleave"])), [
		[vShow, o.isValid]
	])
}
var Option = _export_sfc$1(_sfc_main$2W, [
	["render", _sfc_render$2E]
]);
const DEFAULT_FIELD_NAMES$2 = {
		value: "value",
		label: "label",
		disabled: "disabled",
		tagProps: "tagProps",
		render: "render"
	},
	useOptions = ({
		options: o,
		extraOptions: s,
		inputValue: a,
		filterOption: l,
		showExtraOptions: c,
		valueKey: d,
		fieldNames: f
	}) => {
		const m = computed(() => ({
				...DEFAULT_FIELD_NAMES$2,
				...f == null ? void 0 : f.value
			})),
			g = reactive(new Map),
			v = computed(() => Array.from(g.values()).sort((M, D) => isNumber$2(M.index) && isNumber$2(D.index) ? M
				.index - D.index : 0)),
			y = computed(() => {
				var M, D;
				const F = new Map;
				return {
					optionInfos: getOptionInfos$1((M = o == null ? void 0 : o.value) != null ? M : [], {
						valueKey: (D = d == null ? void 0 : d.value) != null ? D : "value",
						fieldNames: m.value,
						origin: "options",
						optionInfoMap: F
					}),
					optionInfoMap: F
				}
			}),
			b = computed(() => {
				var M, D;
				const F = new Map;
				return {
					optionInfos: getOptionInfos$1((M = s == null ? void 0 : s.value) != null ? M : [], {
						valueKey: (D = d == null ? void 0 : d.value) != null ? D : "value",
						fieldNames: m.value,
						origin: "extraOptions",
						optionInfoMap: F
					}),
					optionInfoMap: F
				}
			}),
			C = reactive(new Map);
		watch([v, o ?? ref([]), s ?? ref([]), d ?? ref("value")], () => {
			C.clear(), v.value.forEach((M, D) => {
				C.set(M.key, {
					...M,
					index: D
				})
			}), y.value.optionInfoMap.forEach(M => {
				C.has(M.key) || (M.index = C.size, C.set(M.key, M))
			}), b.value.optionInfoMap.forEach(M => {
				C.has(M.key) || (M.index = C.size, C.set(M.key, M))
			})
		}, {
			immediate: !0,
			deep: !0
		});
		const _ = computed(() => {
				var M;
				const D = getValidOptions(y.value.optionInfos, {
					inputValue: a == null ? void 0 : a.value,
					filterOption: l == null ? void 0 : l.value
				});
				return ((M = c == null ? void 0 : c.value) == null || M) && D.push(...getValidOptions(b.value
					.optionInfos, {
						inputValue: a == null ? void 0 : a.value,
						filterOption: l == null ? void 0 : l.value
					})), D
			}),
			S = computed(() => Array.from(C.values()).filter(M => M.origin === "extraOptions" && (c == null ? void 0 : c
				.value) === !1 ? !1 : isValidOption(M, {
				inputValue: a == null ? void 0 : a.value,
				filterOption: l == null ? void 0 : l.value
			}))),
			w = computed(() => S.value.filter(M => !M.disabled).map(M => M.key));
		return {
			validOptions: _,
			optionInfoMap: C,
			validOptionInfos: S,
			enabledOptionKeys: w,
			getNextSlotOptionIndex: () => g.size,
			addSlotOptionInfo: (M, D) => {
				g.set(M, D)
			},
			removeSlotOptionInfo: M => {
				g.delete(M)
			}
		}
	},
	KEYBOARD_KEY = {
		ENTER: "Enter",
		ESC: "Escape",
		SPACE: " ",
		ARROW_UP: "ArrowUp",
		ARROW_DOWN: "ArrowDown",
		ARROW_LEFT: "ArrowLeft",
		ARROW_RIGHT: "ArrowRight"
	},
	stringifyCodeKey = o => JSON.stringify({
		key: o.key,
		ctrl: !!o.ctrl,
		shift: !!o.shift,
		alt: !!o.alt,
		meta: !!o.meta
	}),
	getKeyDownHandler = o => {
		const s = {};
		return o.forEach((a, l) => {
			const c = isString$2(l) ? {
				key: l
			} : l;
			s[stringifyCodeKey(c)] = a
		}), a => {
			const l = stringifyCodeKey({
					key: a.key,
					ctrl: a.ctrlKey,
					shift: a.shiftKey,
					alt: a.altKey,
					meta: a.metaKey
				}),
				c = s[l];
			c && (a.stopPropagation(), c(a))
		}
	},
	useSelect = ({
		multiple: o,
		options: s,
		extraOptions: a,
		inputValue: l,
		filterOption: c,
		showExtraOptions: d,
		component: f,
		valueKey: m,
		fieldNames: g,
		loading: v,
		popupVisible: y,
		valueKeys: b,
		dropdownRef: C,
		optionRefs: _,
		virtualListRef: S,
		onSelect: w,
		onPopupVisibleChange: T,
		enterToOpen: A = !0,
		defaultActiveFirstOption: k
	}) => {
		const {
			validOptions: M,
			optionInfoMap: D,
			validOptionInfos: F,
			enabledOptionKeys: R,
			getNextSlotOptionIndex: O,
			addSlotOptionInfo: U,
			removeSlotOptionInfo: V
		} = useOptions({
			options: s,
			extraOptions: a,
			inputValue: l,
			filterOption: c,
			showExtraOptions: d,
			valueKey: m,
			fieldNames: g
		}), z = ref();
		watch(R, ce => {
			(!z.value || !ce.includes(z.value)) && (z.value = ce[0])
		});
		const j = ce => {
				z.value = ce
			},
			ge = ce => {
				const ae = R.value.length;
				if (ae === 0) return;
				if (!z.value) return ce === "down" ? R.value[0] : R.value[ae - 1];
				const fe = R.value.indexOf(z.value),
					q = (ae + fe + (ce === "up" ? -1 : 1)) % ae;
				return R.value[q]
			},
			me = ce => {
				var ae, fe;
				S != null && S.value && S.value.scrollTo({
					key: ce
				});
				const q = D.get(ce),
					le = (ae = C == null ? void 0 : C.value) == null ? void 0 : ae.wrapperRef,
					de = (fe = _ == null ? void 0 : _.value[ce]) != null ? fe : q == null ? void 0 : q.ref;
				if (!le || !de || le.scrollHeight === le.offsetHeight) return;
				const _e = getRelativeRect(de, le),
					ke = le.scrollTop;
				_e.top < 0 ? le.scrollTo(0, ke + _e.top) : _e.bottom < 0 && le.scrollTo(0, ke - _e.bottom)
			};
		watch(y, ce => {
			var ae;
			if (ce) {
				const fe = b.value[b.value.length - 1];
				let q = (ae = k == null ? void 0 : k.value) == null || ae ? R.value[0] : void 0;
				R.value.includes(fe) && (q = fe), q !== z.value && (z.value = q), nextTick(() => {
					z.value && me(z.value)
				})
			}
		});
		const he = getKeyDownHandler(new Map([
			[KEYBOARD_KEY.ENTER, ce => {
				!(v != null && v.value) && !ce.isComposing && (y.value ? z.value && (w(z.value, ce), ce
					.preventDefault()) : A && (T(!0), ce.preventDefault()))
			}],
			[KEYBOARD_KEY.ESC, ce => {
				y.value && (T(!1), ce.preventDefault())
			}],
			[KEYBOARD_KEY.ARROW_DOWN, ce => {
				if (y.value) {
					const ae = ge("down");
					ae && (z.value = ae, me(ae)), ce.preventDefault()
				}
			}],
			[KEYBOARD_KEY.ARROW_UP, ce => {
				if (y.value) {
					const ae = ge("up");
					ae && (z.value = ae, me(ae)), ce.preventDefault()
				}
			}]
		]));
		return provide(selectInjectionKey, reactive({
			multiple: o,
			valueKey: m,
			inputValue: l,
			filterOption: c,
			component: f,
			valueKeys: b,
			activeKey: z,
			setActiveKey: j,
			onSelect: w,
			getNextSlotOptionIndex: O,
			addSlotOptionInfo: U,
			removeSlotOptionInfo: V
		})), {
			validOptions: M,
			optionInfoMap: D,
			validOptionInfos: F,
			enabledOptionKeys: R,
			activeKey: z,
			setActiveKey: j,
			addSlotOptionInfo: U,
			removeSlotOptionInfo: V,
			getNextActiveKey: ge,
			scrollIntoView: me,
			handleKeyDown: he
		}
	},
	useSize = ({
		dataKeys: o,
		contentRef: s,
		fixedSize: a,
		estimatedSize: l,
		buffer: c
	}) => {
		const d = ref(0),
			f = new Map,
			m = computed(() => o.value.length),
			g = ref(0),
			v = computed(() => {
				const O = g.value + c.value * 3;
				return O > m.value ? m.value : O
			}),
			y = computed(() => {
				const O = m.value - c.value * 3;
				return O < 0 ? 0 : O
			}),
			b = O => {
				O < 0 ? g.value = 0 : O > y.value ? g.value = y.value : g.value = O
			},
			C = ref(a.value),
			_ = computed(() => l.value !== 30 ? l.value : d.value || l.value),
			S = (O, U) => {
				f.set(O, U)
			},
			w = O => {
				var U;
				if (C.value) return _.value;
				const V = o.value[O];
				return (U = f.get(V)) != null ? U : _.value
			},
			T = O => f.has(O);
		onMounted(() => {
			const O = Array.from(f.values()).reduce((U, V) => U + V, 0);
			O > 0 && (d.value = O / f.size)
		});
		const A = O => C.value ? _.value * O : k(0, O),
			k = (O, U) => {
				let V = 0;
				for (let z = O; z < U; z++) V += w(z);
				return V
			},
			M = computed(() => C.value ? _.value * g.value : k(0, g.value)),
			D = O => {
				const U = O >= M.value;
				let V = Math.abs(O - M.value);
				const z = U ? g.value : g.value - 1;
				let j = 0;
				for (; V > 0;) V -= w(z + j), U ? j++ : j--;
				return j
			},
			F = O => {
				const U = D(O),
					V = g.value + U - c.value;
				return V < 0 ? 0 : V > y.value ? y.value : V
			},
			R = computed(() => C.value ? _.value * (m.value - v.value) : k(v.value, m.value));
		return {
			frontPadding: M,
			behindPadding: R,
			start: g,
			end: v,
			getStartByScroll: F,
			setItemSize: S,
			hasItemSize: T,
			setStart: b,
			getScrollOffset: A
		}
	};
var VirtualListItem = defineComponent({
	name: "VirtualListItem",
	props: {
		hasItemSize: {
			type: Function,
			required: !0
		},
		setItemSize: {
			type: Function,
			required: !0
		}
	},
	setup(o, {
		slots: s
	}) {
		var a;
		const l = (a = getCurrentInstance()) == null ? void 0 : a.vnode.key,
			c = ref(),
			d = () => {
				var f, m, g, v;
				const y = (m = (f = c.value) == null ? void 0 : f.$el) != null ? m : c.value,
					b = (v = (g = y == null ? void 0 : y.getBoundingClientRect) == null ? void 0 : g.call(y)
						.height) != null ? v : y == null ? void 0 : y.offsetHeight;
				b && o.setItemSize(l, b)
			};
		return onMounted(() => d()), onBeforeUnmount(() => d()), () => {
			var f;
			const m = getFirstComponent((f = s.default) == null ? void 0 : f.call(s));
			return m ? cloneVNode(m, {
				ref: c
			}, !0) : null
		}
	}
});
const _sfc_main$2V = defineComponent({
	name: "VirtualList",
	components: {
		VirtualListItem
	},
	props: {
		height: {
			type: [Number, String],
			default: 200
		},
		data: {
			type: Array,
			default: () => []
		},
		threshold: {
			type: Number,
			default: 0
		},
		itemKey: {
			type: String,
			default: "key"
		},
		fixedSize: {
			type: Boolean,
			default: !1
		},
		estimatedSize: {
			type: Number,
			default: 30
		},
		buffer: {
			type: Number,
			default: 10
		},
		component: {
			type: [String, Object],
			default: "div"
		},
		listAttrs: {
			type: Object
		},
		contentAttrs: {
			type: Object
		},
		paddingPosition: {
			type: String,
			default: "content"
		}
	},
	emits: {
		scroll: o => !0,
		reachBottom: o => !0
	},
	setup(o, {
		emit: s
	}) {
		const {
			data: a,
			itemKey: l,
			fixedSize: c,
			estimatedSize: d,
			buffer: f,
			height: m
		} = toRefs(o), g = getPrefixCls("virtual-list"), v = computed(() => isObject$2(o.component) ? {
			container: "div",
			list: "div",
			content: "div",
			...o.component
		} : {
			container: o.component,
			list: "div",
			content: "div"
		}), y = ref(), b = ref(), C = computed(() => ({
			height: isNumber$2(m.value) ? `${m.value}px` : m.value,
			overflow: "auto"
		})), _ = computed(() => a.value.map((z, j) => {
			var ge;
			return (ge = z[l.value]) != null ? ge : j
		})), {
			frontPadding: S,
			behindPadding: w,
			start: T,
			end: A,
			getStartByScroll: k,
			setItemSize: M,
			hasItemSize: D,
			setStart: F,
			getScrollOffset: R
		} = useSize({
			dataKeys: _,
			contentRef: b,
			fixedSize: c,
			estimatedSize: d,
			buffer: f
		}), O = computed(() => o.threshold && a.value.length <= o.threshold ? a.value : a.value.slice(T
			.value, A.value)), U = z => {
			const {
				scrollTop: j,
				scrollHeight: ge,
				offsetHeight: me
			} = z.target, he = k(j);
			he !== T.value && (F(he), nextTick(() => {
				V(j)
			})), s("scroll", z), Math.floor(ge - (j + me)) <= 0 && s("reachBottom", z)
		}, V = z => {
			var j, ge;
			if (y.value)
				if (isNumber$2(z)) y.value.scrollTop = z;
				else {
					const me = (ge = z.index) != null ? ge : _.value.indexOf((j = z.key) != null ? j : "");
					F(me - f.value), y.value.scrollTop = R(me), nextTick(() => {
						if (y.value) {
							const he = R(me);
							he !== y.value.scrollTop && (y.value.scrollTop = he)
						}
					})
				}
		};
		return {
			prefixCls: g,
			containerRef: y,
			contentRef: b,
			frontPadding: S,
			currentList: O,
			behindPadding: w,
			onScroll: U,
			setItemSize: M,
			hasItemSize: D,
			start: T,
			scrollTo: V,
			style: C,
			mergedComponent: v
		}
	}
});

function _sfc_render$2D(o, s, a, l, c, d) {
	const f = resolveComponent("VirtualListItem");
	return openBlock(), createBlock(resolveDynamicComponent(o.mergedComponent.container), {
		ref: "containerRef",
		class: normalizeClass(o.prefixCls),
		style: normalizeStyle(o.style),
		onScroll: o.onScroll
	}, {
		default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(o.mergedComponent.list),
			mergeProps(o.listAttrs, {
				style: o.paddingPosition === "list" ? {
					paddingTop: `${o.frontPadding}px`,
					paddingBottom: `${o.behindPadding}px`
				} : {}
			}), {
				default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(o
					.mergedComponent.content), mergeProps({
					ref: "contentRef"
				}, o.contentAttrs, {
					style: o.paddingPosition === "content" ? {
						paddingTop: `${o.frontPadding}px`,
						paddingBottom: `${o.behindPadding}px`
					} : {}
				}), {
					default: withCtx(() => [(openBlock(!0),
						createElementBlock(Fragment, null,
							renderList(o.currentList, (m,
							g) => {
								var v;
								return openBlock(),
									createBlock(f, {
										key: (v = m[o
												.itemKey
												]) !=
											null ? v : o
											.start + g,
										"has-item-size": o
											.hasItemSize,
										"set-item-size": o
											.setItemSize
									}, {
										default: withCtx(
											() => [
												renderSlot(
													o
													.$slots,
													"item", {
														item: m,
														index: o
															.start +
															g
													}
													)
											]),
										_: 2
									}, 1032, [
										"has-item-size",
										"set-item-size"
									])
							}), 128))]),
					_: 3
				}, 16, ["style"]))]),
				_: 3
			}, 16, ["style"]))]),
		_: 3
	}, 40, ["class", "style", "onScroll"])
}
var VirtualList = _export_sfc$1(_sfc_main$2V, [
		["render", _sfc_render$2D]
	]),
	_AutoComplete = defineComponent({
		name: "AutoComplete",
		inheritAttrs: !1,
		props: {
			modelValue: {
				type: String,
				default: void 0
			},
			defaultValue: {
				type: String,
				default: ""
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			data: {
				type: Array,
				default: () => []
			},
			popupContainer: {
				type: [String, Object]
			},
			strict: {
				type: Boolean,
				default: !1
			},
			filterOption: {
				type: [Boolean, Function],
				default: !0
			},
			triggerProps: {
				type: Object
			},
			allowClear: {
				type: Boolean,
				default: !1
			},
			virtualListProps: {
				type: Object
			}
		},
		emits: {
			"update:modelValue": o => !0,
			change: o => !0,
			search: o => !0,
			select: o => !0,
			clear: o => !0,
			dropdownScroll: o => !0,
			dropdownReachBottom: o => !0
		},
		setup(o, {
			emit: s,
			attrs: a,
			slots: l
		}) {
			const {
				modelValue: c
			} = toRefs(o), d = getPrefixCls("auto-complete"), {
				mergedDisabled: f,
				eventHandlers: m
			} = useFormItem({
				disabled: toRef(o, "disabled")
			}), g = ref(o.defaultValue), v = ref(), y = computed(() => {
				var de;
				return (de = o.modelValue) != null ? de : g.value
			});
			watch(c, de => {
				(isUndefined$1(de) || isNull$1(de)) && (g.value = "")
			});
			const b = computed(() => y.value ? [getKeyFromValue(y.value)] : []),
				{
					data: C
				} = toRefs(o),
				_ = ref(),
				S = ref({}),
				w = ref(!1),
				T = computed(() => w.value && he.value.length > 0),
				A = ref(),
				k = computed(() => o.virtualListProps ? "div" : "li"),
				M = de => {
					w.value = de
				},
				D = (de, _e) => {
					var ke;
					return !!((ke = _e.label) != null && ke.includes(de))
				},
				F = computed(() => isFunction$2(o.filterOption) ? o.filterOption : o.filterOption && o.strict ? D :
					o.filterOption),
				R = de => {
					var _e, ke;
					g.value = de, s("update:modelValue", de), s("change", de), (ke = (_e = m.value) == null ?
						void 0 : _e.onChange) == null || ke.call(_e)
				},
				O = de => {
					var _e, ke;
					g.value = "", s("update:modelValue", ""), s("change", ""), (ke = (_e = m.value) == null ?
						void 0 : _e.onChange) == null || ke.call(_e), s("clear", de)
				},
				U = (de, _e) => {
					var ke, De;
					const Se = (ke = me.get(de)) == null ? void 0 : ke.value;
					s("select", Se), R(Se), (De = v.value) == null || De.blur()
				},
				V = de => {
					s("search", de), R(de)
				},
				z = de => {
					s("dropdownScroll", de)
				},
				j = de => {
					s("dropdownReachBottom", de)
				},
				{
					validOptions: ge,
					optionInfoMap: me,
					validOptionInfos: he,
					handleKeyDown: ce
				} = useSelect({
					options: C,
					inputValue: y,
					filterOption: F,
					popupVisible: T,
					valueKeys: b,
					component: k,
					dropdownRef: _,
					optionRefs: S,
					onSelect: U,
					onPopupVisibleChange: M
				}),
				ae = de => {
					if (isFunction$2(l.option) && de.value) {
						const _e = me.get(de.key),
							ke = l.option;
						return () => ke({
							data: _e
						})
					}
					return () => de.label
				},
				fe = de => createVNode(Option, {
					ref: _e => {
						_e != null && _e.$el && (S.value[de.key] = _e.$el)
					},
					key: de.key,
					value: de.value,
					disabled: de.disabled,
					internal: !0
				}, {
					default: ae(de)
				}),
				q = () => createVNode(SelectDropdown, {
					ref: _,
					class: `${d}-dropdown`,
					virtualList: !!o.virtualListProps,
					onScroll: z,
					onReachBottom: j
				}, {
					default: () => [...ge.value.map(de => fe(de))],
					"virtual-list": () => createVNode(VirtualList, mergeProps(o.virtualListProps, {
						ref: A,
						data: ge.value
					}), {
						item: ({
							item: de
						}) => fe(de)
					}),
					footer: l.footer
				});
			return {
				inputRef: v,
				render: () => createVNode(Trigger, mergeProps({
					trigger: "focus",
					position: "bl",
					animationName: "slide-dynamic-origin",
					autoFitTransformOrigin: !0,
					popupVisible: T.value,
					clickToClose: !1,
					preventFocus: !0,
					popupOffset: 4,
					disabled: f.value,
					autoFitPopupWidth: !0
				}, o.triggerProps, {
					onPopupVisibleChange: M
				}), {
					default: () => [createVNode(Input, mergeProps({
						ref: v
					}, a, {
						allowClear: o.allowClear,
						modelValue: y.value,
						disabled: f.value,
						onInput: V,
						onClear: O,
						onKeydown: ce
					}), l)],
					content: q
				})
			}
		},
		methods: {
			focus() {
				var o;
				(o = this.inputRef) == null || o.focus()
			},
			blur() {
				var o;
				(o = this.inputRef) == null || o.blur()
			}
		},
		render() {
			return this.render()
		}
	});
const AutoComplete = Object.assign(_AutoComplete, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _AutoComplete.name, _AutoComplete)
		}
	}),
	useIndex = ({
		itemRef: o,
		selector: s,
		index: a,
		parentClassName: l
	}) => {
		const c = ref(-1),
			d = computed(() => {
				var v;
				return (v = a == null ? void 0 : a.value) != null ? v : c.value
			}),
			f = ref(),
			m = () => {
				var v, y, b;
				let C = (y = (v = o.value) == null ? void 0 : v.parentElement) != null ? y : void 0;
				if (l)
					for (; C && !C.className.includes(l);) C = (b = C.parentElement) != null ? b : void 0;
				return C
			},
			g = () => {
				if (isUndefined$1(a == null ? void 0 : a.value) && f.value && o.value) {
					const v = Array.from(f.value.querySelectorAll(s)).indexOf(o.value);
					v !== c.value && (c.value = v)
				}
			};
		return watch(o, () => {
			o.value && !f.value && (f.value = m())
		}), onMounted(() => {
			o.value && (f.value = m()), g()
		}), onUpdated(() => g()), {
			computedIndex: d
		}
	},
	avatarGroupInjectionKey = Symbol("ArcoAvatarGroup"),
	_sfc_main$2U = defineComponent({
		name: "IconImageClose",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-image-close`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$18 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2C(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createStaticVNode(
		'<path d="M41 26V9a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v30a2 2 0 0 0 2 2h17"></path><path d="m24 33 9-8.5V27s-2 1-3.5 2.5C27.841 31.159 27 33 27 33h-3Zm0 0-3.5-4.5L17 33h7Z"></path><path d="M20.5 28.5 17 33h7l-3.5-4.5ZM33 24.5 24 33h3s.841-1.841 2.5-3.5C31 28 33 27 33 27v-2.5Z" fill="currentColor" stroke="none"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M46 38a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-4.95-4.782 1.74 1.74-3.045 3.046 3.046 3.046-1.74 1.74-3.047-3.045-3.046 3.046-1.74-1.74 3.046-3.047-3.046-3.046 1.74-1.74 3.046 3.046 3.046-3.046Z" fill="currentColor" stroke="none"></path><path d="M17 15h-2v2h2v-2Z"></path>',
		5)]), 14, _hoisted_1$18)
}
var _IconImageClose = _export_sfc$1(_sfc_main$2U, [
	["render", _sfc_render$2C]
]);
const IconImageClose = Object.assign(_IconImageClose, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconImageClose.name, _IconImageClose)
		}
	}),
	_sfc_main$2T = defineComponent({
		name: "Avatar",
		components: {
			ResizeObserver: ResizeObserver$1,
			IconImageClose,
			IconLoading
		},
		props: {
			shape: {
				type: String,
				default: "circle"
			},
			imageUrl: String,
			size: Number,
			autoFixFontSize: {
				type: Boolean,
				default: !0
			},
			triggerType: {
				type: String,
				default: "button"
			},
			triggerIconStyle: {
				type: Object
			},
			objectFit: {
				type: String
			}
		},
		emits: {
			click: o => !0,
			error: () => !0,
			load: () => !0
		},
		setup(o, {
			slots: s,
			emit: a,
			attrs: l
		}) {
			const {
				shape: c,
				size: d,
				autoFixFontSize: f,
				triggerType: m,
				triggerIconStyle: g
			} = toRefs(o), v = getPrefixCls("avatar"), y = inject(avatarGroupInjectionKey, void 0), b = ref(), C =
				ref(), _ = computed(() => {
					var he;
					return (he = y == null ? void 0 : y.shape) != null ? he : c.value
				}), S = computed(() => {
					var he;
					return (he = y == null ? void 0 : y.size) != null ? he : d.value
				}), w = computed(() => {
					var he;
					return (he = y == null ? void 0 : y.autoFixFontSize) != null ? he : f.value
				}), T = ref(!1), A = ref(!1), k = ref(!0), M = ref(!1), D = y ? useIndex({
					itemRef: b,
					selector: `.${v}`
				}).computedIndex : ref(-1), F = computed(() => {
					var he;
					const ce = isNumber$2(S.value) ? {
						width: `${S.value}px`,
						height: `${S.value}px`,
						fontSize: `${S.value/2}px`
					} : {};
					return y && (ce.zIndex = y.zIndexAscend ? D.value + 1 : y.total - D.value, ce.marginLeft = D
						.value !== 0 ? `-${((he=S.value)!=null?he:40)/4}px` : "0"), ce
				}), R = useTriggerIconStyle({
					triggerIconStyle: g == null ? void 0 : g.value,
					inlineStyle: l.style,
					triggerType: m.value
				}), O = () => {
					!T.value && !o.imageUrl && nextTick(() => {
						var he;
						if (!C.value || !b.value) return;
						const ce = C.value.clientWidth,
							ae = (he = S.value) != null ? he : b.value.offsetWidth,
							fe = ae / (ce + 8);
						ae && fe < 1 && (C.value.style.transform = `scale(${fe}) translateX(-50%)`), k
							.value = !0
					})
				};
			onMounted(() => {
				var he;
				(he = C.value) != null && he.firstElementChild && ["IMG", "PICTURE"].includes(C.value
					.firstElementChild.tagName) && (T.value = !0), w.value && O()
			}), watch(d, () => {
				w.value && O()
			});
			const U = computed(() => [v, `${v}-${_.value}`]),
				V = computed(() => T.value || o.imageUrl ? `${v}-image` : `${v}-text`);
			return {
				prefixCls: v,
				itemRef: b,
				cls: U,
				outerStyle: F,
				wrapperRef: C,
				wrapperCls: V,
				computedTriggerIconStyle: R,
				isImage: T,
				shouldLoad: k,
				isLoaded: M,
				hasError: A,
				onClick: he => {
					a("click", he)
				},
				handleResize: () => {
					w.value && O()
				},
				handleImgLoad: () => {
					M.value = !0, a("load")
				},
				handleImgError: () => {
					A.value = !0, a("error")
				}
			}
		}
	}),
	useTriggerIconStyle = ({
		triggerType: o,
		inlineStyle: s = {},
		triggerIconStyle: a = {}
	}) => {
		let l = {};
		return o === "button" && (!a || a && !a.color) && s && s.backgroundColor && (l = {
			color: s.backgroundColor
		}), {
			...a,
			...l
		}
	},
	_hoisted_1$17 = ["src"];

function _sfc_render$2B(o, s, a, l, c, d) {
	const f = resolveComponent("IconImageClose"),
		m = resolveComponent("IconLoading"),
		g = resolveComponent("resize-observer");
	return openBlock(), createElementBlock("div", {
		ref: "itemRef",
		style: normalizeStyle(o.outerStyle),
		class: normalizeClass([o.cls, {
			[`${o.prefixCls}-with-trigger-icon`]: !!o.$slots["trigger-icon"]
		}]),
		onClick: s[2] || (s[2] = (...v) => o.onClick && o.onClick(...v))
	}, [createVNode(g, {
		onResize: o.handleResize
	}, {
		default: withCtx(() => [createBaseVNode("span", {
			ref: "wrapperRef",
			class: normalizeClass(o.wrapperCls)
		}, [o.imageUrl ? (openBlock(), createElementBlock(Fragment, {
			key: 0
		}, [o.hasError ? renderSlot(o.$slots, "error", {
				key: 0
			}, () => [createBaseVNode("div", {
				class: normalizeClass(
					`${o.prefixCls}-image-icon`)
			}, [createVNode(f)], 2)]) : createCommentVNode("v-if", !0), !(o
				.hasError || !o.shouldLoad) && !o.isLoaded ? renderSlot(o
				.$slots, "default", {
					key: 1
				}, () => [createBaseVNode("div", {
					class: normalizeClass(
						`${o.prefixCls}-image-icon`)
				}, [createVNode(m)], 2)]) : createCommentVNode("v-if", !0),
			o.hasError || !o.shouldLoad ? createCommentVNode("v-if", !0) : (
				openBlock(), createElementBlock("img", {
					key: 2,
					src: o.imageUrl,
					style: normalizeStyle({
						width: o.size + "px",
						height: o.size + "px",
						objectFit: o.objectFit
					}),
					alt: "avatar",
					onLoad: s[0] || (s[0] = (...v) => o.handleImgLoad &&
						o.handleImgLoad(...v)),
					onError: s[1] || (s[1] = (...v) => o
						.handleImgError && o.handleImgError(...v))
				}, null, 44, _hoisted_1$17))
		], 64)) : renderSlot(o.$slots, "default", {
			key: 1
		})], 2)]),
		_: 3
	}, 8, ["onResize"]), o.$slots["trigger-icon"] ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-trigger-icon-${o.triggerType}`),
		style: normalizeStyle(o.computedTriggerIconStyle)
	}, [renderSlot(o.$slots, "trigger-icon")], 6)) : createCommentVNode("v-if", !0)], 6)
}
var _Avatar = _export_sfc$1(_sfc_main$2T, [
	["render", _sfc_render$2B]
]);
const _sfc_main$2S = defineComponent({
	name: "Popover",
	components: {
		Trigger
	},
	props: {
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean,
			default: !1
		},
		title: String,
		content: String,
		trigger: {
			type: [String, Array],
			default: "hover"
		},
		position: {
			type: String,
			default: "top"
		},
		contentClass: {
			type: [String, Array, Object]
		},
		contentStyle: {
			type: Object
		},
		arrowClass: {
			type: [String, Array, Object]
		},
		arrowStyle: {
			type: Object
		},
		popupContainer: {
			type: [String, Object]
		}
	},
	emits: {
		"update:popupVisible": o => !0,
		popupVisibleChange: o => !0
	},
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("popover"),
			l = ref(o.defaultPopupVisible),
			c = computed(() => {
				var g;
				return (g = o.popupVisible) != null ? g : l.value
			}),
			d = g => {
				l.value = g, s("update:popupVisible", g), s("popupVisibleChange", g)
			},
			f = computed(() => [`${a}-popup-content`, o.contentClass]),
			m = computed(() => [`${a}-popup-arrow`, o.arrowClass]);
		return {
			prefixCls: a,
			computedPopupVisible: c,
			contentCls: f,
			arrowCls: m,
			handlePopupVisibleChange: d
		}
	}
});

function _sfc_render$2A(o, s, a, l, c, d) {
	const f = resolveComponent("trigger");
	return openBlock(), createBlock(f, {
		class: normalizeClass(o.prefixCls),
		trigger: o.trigger,
		position: o.position,
		"popup-visible": o.computedPopupVisible,
		"popup-offset": 10,
		"content-class": o.contentCls,
		"content-style": o.contentStyle,
		"arrow-class": o.arrowCls,
		"arrow-style": o.arrowStyle,
		"show-arrow": "",
		"popup-container": o.popupContainer,
		"animation-name": "zoom-in-fade-out",
		"auto-fit-transform-origin": "",
		onPopupVisibleChange: o.handlePopupVisibleChange
	}, {
		content: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-title`)
		}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(o.title),
			1)])], 2), createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [renderSlot(o.$slots, "content", {}, () => [createTextVNode(toDisplayString(o
			.content), 1)])], 2)]),
		default: withCtx(() => [renderSlot(o.$slots, "default")]),
		_: 3
	}, 8, ["class", "trigger", "position", "popup-visible", "content-class", "content-style", "arrow-class",
		"arrow-style", "popup-container", "onPopupVisibleChange"
	])
}
var _Popover = _export_sfc$1(_sfc_main$2S, [
	["render", _sfc_render$2A]
]);
const Popover = Object.assign(_Popover, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Popover.name, _Popover)
		}
	}),
	AvatarGroup = defineComponent({
		name: "AvatarGroup",
		props: {
			shape: {
				type: String,
				default: "circle"
			},
			size: Number,
			autoFixFontSize: {
				type: Boolean,
				default: !0
			},
			maxCount: {
				type: Number,
				default: 0
			},
			zIndexAscend: {
				type: Boolean,
				default: !1
			},
			maxStyle: {
				type: Object
			},
			maxPopoverTriggerProps: {
				type: Object
			}
		},
		setup(o, {
			slots: s
		}) {
			const {
				shape: a,
				size: l,
				autoFixFontSize: c,
				zIndexAscend: d
			} = toRefs(o), f = getPrefixCls("avatar-group"), m = ref(0);
			return provide(avatarGroupInjectionKey, reactive({
				shape: a,
				size: l,
				autoFixFontSize: c,
				zIndexAscend: d,
				total: m
			})), () => {
				var g, v;
				const y = getAllElements((v = (g = s.default) == null ? void 0 : g.call(s)) != null ? v : []),
					b = o.maxCount > 0 ? y.slice(0, o.maxCount) : y,
					C = o.maxCount > 0 ? y.slice(o.maxCount) : [];
				return m.value !== y.length && (m.value = y.length), createVNode("div", {
					class: f
				}, [b, C.length > 0 && createVNode(Popover, o.maxPopoverTriggerProps, {
					default: () => [createVNode(_Avatar, {
						class: `${f}-max-count-avatar`,
						style: o.maxStyle
					}, {
						default: () => [createTextVNode("+"), C.length]
					})],
					content: () => createVNode("div", null, [C])
				})])
			}
		}
	}),
	Avatar = Object.assign(_Avatar, {
		Group: AvatarGroup,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Avatar.name, _Avatar), o.component(a + AvatarGroup.name, AvatarGroup)
		}
	}),
	_sfc_main$2R = defineComponent({
		name: "IconToTop",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-to-top`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$16 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2z(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M43 7H5M24 20v23M24 13.96 30.453 21H17.546L24 13.96Zm.736-.804Z"
	}, null, -1), createBaseVNode("path", {
		d: "m24 14-6 7h12l-6-7Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$16)
}
var _IconToTop = _export_sfc$1(_sfc_main$2R, [
	["render", _sfc_render$2z]
]);
const IconToTop = Object.assign(_IconToTop, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconToTop.name, _IconToTop)
		}
	}),
	_sfc_main$2Q = defineComponent({
		name: "BackTop",
		components: {
			IconToTop
		},
		props: {
			visibleHeight: {
				type: Number,
				default: 200
			},
			targetContainer: {
				type: [String, Object]
			},
			easing: {
				type: String,
				default: "quartOut"
			},
			duration: {
				type: Number,
				default: 200
			}
		},
		setup(o) {
			const s = getPrefixCls("back-top"),
				a = ref(!1),
				l = ref(),
				c = !o.targetContainer,
				d = throttleByRaf(() => {
					if (l.value) {
						const {
							visibleHeight: g
						} = o, {
							scrollTop: v
						} = l.value;
						a.value = v >= g
					}
				}),
				f = g => isString$2(g) ? document.querySelector(g) : g;
			return onMounted(() => {
				l.value = c ? document == null ? void 0 : document.documentElement : f(o.targetContainer), l
					.value && (on(c ? window : l.value, "scroll", d), d())
			}), onUnmounted(() => {
				d.cancel(), l.value && off(c ? window : l.value, "scroll", d)
			}), {
				prefixCls: s,
				visible: a,
				scrollToTop: () => {
					if (l.value) {
						const {
							scrollTop: g
						} = l.value;
						new Tween({
							from: {
								scrollTop: g
							},
							to: {
								scrollTop: 0
							},
							easing: o.easing,
							duration: o.duration,
							onUpdate: y => {
								l.value && (l.value.scrollTop = y.scrollTop)
							}
						}).start()
					}
				}
			}
		}
	});

function _sfc_render$2y(o, s, a, l, c, d) {
	const f = resolveComponent("icon-to-top");
	return openBlock(), createBlock(Transition, {
		name: "fade-in"
	}, {
		default: withCtx(() => [o.visible ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(o.prefixCls),
			onClick: s[0] || (s[0] = (...m) => o.scrollToTop && o.scrollToTop(...m))
		}, [renderSlot(o.$slots, "default", {}, () => [createBaseVNode("button", {
			class: normalizeClass(`${o.prefixCls}-btn`)
		}, [createVNode(f)], 2)])], 2)) : createCommentVNode("v-if", !0)]),
		_: 3
	})
}
var _BackTop = _export_sfc$1(_sfc_main$2Q, [
	["render", _sfc_render$2y]
]);
const BackTop = Object.assign(_BackTop, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _BackTop.name, _BackTop)
		}
	}),
	COLORS = ["red", "orangered", "orange", "gold", "lime", "green", "cyan", "arcoblue", "purple", "pinkpurple",
		"magenta", "gray"
	],
	BADGE_STATUSES = ["normal", "processing", "success", "warning", "danger"];
var _Badge = defineComponent({
	name: "Badge",
	props: {
		text: {
			type: String
		},
		dot: {
			type: Boolean
		},
		dotStyle: {
			type: Object
		},
		maxCount: {
			type: Number,
			default: 99
		},
		offset: {
			type: Array,
			default: () => []
		},
		color: {
			type: String
		},
		status: {
			type: String,
			validator: o => BADGE_STATUSES.includes(o)
		},
		count: {
			type: Number
		}
	},
	setup(o, {
		slots: s
	}) {
		const {
			status: a,
			color: l,
			dotStyle: c,
			offset: d,
			text: f,
			dot: m,
			maxCount: g,
			count: v
		} = toRefs(o), y = getPrefixCls("badge"), b = useWrapperClass(y, a == null ? void 0 : a.value, s ==
			null ? void 0 : s.default), C = computed(() => {
			const S = {
					...(c == null ? void 0 : c.value) || {}
				},
				[w, T] = (d == null ? void 0 : d.value) || [];
			w && (S.marginRight = `${-w}px`), T && (S.marginTop = `${T}px`);
			const A = !(l != null && l.value) || COLORS.includes(l == null ? void 0 : l.value) ? {} : {
				backgroundColor: l.value
			};
			return {
				mergedStyle: {
					...A,
					...S
				},
				computedDotStyle: S,
				computedColorStyle: A
			}
		}), _ = () => {
			const S = f == null ? void 0 : f.value,
				w = l == null ? void 0 : l.value,
				T = a == null ? void 0 : a.value,
				A = m == null ? void 0 : m.value,
				k = Number(v == null ? void 0 : v.value),
				M = (v == null ? void 0 : v.value) != null,
				{
					computedDotStyle: D,
					mergedStyle: F
				} = C.value;
			return s.content ? createVNode("span", {
				class: `${y}-custom-dot`,
				style: D
			}, [s.content()]) : S && !w && !T ? createVNode("span", {
				class: `${y}-text`,
				style: D
			}, [S]) : T || w && !M ? createVNode("span", {
				class: `${y}-status-wrapper`
			}, [createVNode("span", {
				class: [`${y}-status-dot`, {
					[`${y}-status-${T}`]: T,
					[`${y}-color-${w}`]: w
				}],
				style: F
			}, null), S && createVNode("span", {
				class: `${y}-status-text`
			}, [S])]) : (A || w) && k > 0 ? createVNode("span", {
				class: [`${y}-dot`, {
					[`${y}-color-${w}`]: w
				}],
				style: F
			}, null) : k === 0 ? null : createVNode("span", {
				class: `${y}-number`,
				style: F
			}, [createVNode("span", null, [g.value && k > g.value ? `${g.value}+` : k])])
		};
		return () => createVNode("span", {
			class: b.value
		}, [s.default && s.default(), _()])
	}
});
const useWrapperClass = (o, s, a) => computed(() => [o, {
		[`${o}-status`]: s,
		[`${o}-no-children`]: !a
	}]),
	Badge = Object.assign(_Badge, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Badge.name, _Badge)
		}
	}),
	breadcrumbInjectKey = Symbol("ArcoBreadcrumb"),
	_sfc_main$2P = defineComponent({
		name: "IconMore",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-more`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$15 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2x(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1), createBaseVNode("path", {
		d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z"
	}, null, -1)]), 14, _hoisted_1$15)
}
var _IconMore = _export_sfc$1(_sfc_main$2P, [
	["render", _sfc_render$2x]
]);
const IconMore = Object.assign(_IconMore, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconMore.name, _IconMore)
		}
	}),
	_sfc_main$2O = defineComponent({
		name: "IconDown",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-down`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$14 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2w(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M39.6 17.443 24.043 33 8.487 17.443"
	}, null, -1)]), 14, _hoisted_1$14)
}
var _IconDown = _export_sfc$1(_sfc_main$2O, [
	["render", _sfc_render$2w]
]);
const IconDown = Object.assign(_IconDown, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconDown.name, _IconDown)
		}
	}),
	_sfc_main$2N = defineComponent({
		name: "IconObliqueLine",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-oblique-line`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$13 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2v(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M29.506 6.502 18.493 41.498"
	}, null, -1)]), 14, _hoisted_1$13)
}
var _IconObliqueLine = _export_sfc$1(_sfc_main$2N, [
	["render", _sfc_render$2v]
]);
const IconObliqueLine = Object.assign(_IconObliqueLine, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconObliqueLine.name, _IconObliqueLine)
		}
	}),
	dropdownInjectionKey = Symbol("ArcoDropdown"),
	_sfc_main$2M = defineComponent({
		name: "DropdownPanel",
		components: {
			Scrollbar,
			Empty
		},
		props: {
			loading: {
				type: Boolean,
				default: !1
			},
			isEmpty: {
				type: Boolean,
				default: !1
			},
			bottomOffset: {
				type: Number,
				default: 0
			},
			onScroll: {
				type: [Function, Array]
			},
			onReachBottom: {
				type: [Function, Array]
			}
		},
		emits: ["scroll", "reachBottom"],
		setup(o, {
			emit: s,
			slots: a
		}) {
			const l = getPrefixCls("dropdown"),
				c = inject(dropdownInjectionKey, {}),
				d = ref(),
				f = v => {
					const {
						scrollTop: y,
						scrollHeight: b,
						offsetHeight: C
					} = v.target;
					b - (y + C) <= o.bottomOffset && s("reachBottom", v), s("scroll", v)
				},
				m = computed(() => {
					if (isNumber$2(c.popupMaxHeight)) return {
						maxHeight: `${c.popupMaxHeight}px`
					};
					if (!c.popupMaxHeight) return {
						maxHeight: "none",
						overflowY: "hidden"
					}
				}),
				g = computed(() => [l, {
					[`${l}-has-footer`]: !!a.footer
				}]);
			return {
				prefixCls: l,
				cls: g,
				style: m,
				wrapperRef: d,
				handleScroll: f
			}
		}
	});

function _sfc_render$2u(o, s, a, l, c, d) {
	const f = resolveComponent("empty"),
		m = resolveComponent("Scrollbar");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [o.isEmpty ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-empty`)
		}, [renderSlot(o.$slots, "empty", {}, () => [createVNode(f)])], 2)) : createCommentVNode("v-if", !0),
		createVNode(m, {
			ref: "wrapperRef",
			class: normalizeClass(`${o.prefixCls}-list-wrapper`),
			style: normalizeStyle(o.style),
			onScroll: o.handleScroll
		}, {
			default: withCtx(() => [createBaseVNode("ul", {
				class: normalizeClass(`${o.prefixCls}-list`)
			}, [renderSlot(o.$slots, "default")], 2)]),
			_: 3
		}, 8, ["class", "style", "onScroll"]), o.$slots.footer && !o.isEmpty ? (openBlock(), createElementBlock(
			"div", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-footer`)
			}, [renderSlot(o.$slots, "footer")], 2)) : createCommentVNode("v-if", !0)
	], 2)
}
var DropdownPanel = _export_sfc$1(_sfc_main$2M, [
	["render", _sfc_render$2u]
]);
const useTrigger = ({
		popupVisible: o,
		defaultPopupVisible: s,
		emit: a
	}) => {
		var l;
		const c = ref((l = s == null ? void 0 : s.value) != null ? l : !1),
			d = computed(() => {
				var m;
				return (m = o == null ? void 0 : o.value) != null ? m : c.value
			}),
			f = m => {
				m !== d.value && (c.value = m, a("update:popupVisible", m), a("popupVisibleChange", m))
			};
		return watch(d, m => {
			c.value !== m && (c.value = m)
		}), {
			computedPopupVisible: d,
			handlePopupVisibleChange: f
		}
	},
	_sfc_main$2L = defineComponent({
		name: "Dropdown",
		components: {
			Trigger,
			DropdownPanel
		},
		props: {
			popupVisible: {
				type: Boolean,
				default: void 0
			},
			defaultPopupVisible: {
				type: Boolean,
				default: !1
			},
			trigger: {
				type: [String, Array],
				default: "click"
			},
			position: {
				type: String,
				default: "bottom"
			},
			popupContainer: {
				type: [String, Object]
			},
			popupMaxHeight: {
				type: [Boolean, Number],
				default: !0
			},
			hideOnSelect: {
				type: Boolean,
				default: !0
			}
		},
		emits: {
			"update:popupVisible": o => !0,
			popupVisibleChange: o => !0,
			select: (o, s) => !0
		},
		setup(o, {
			emit: s
		}) {
			const {
				defaultPopupVisible: a,
				popupVisible: l,
				popupMaxHeight: c
			} = toRefs(o), d = getPrefixCls("dropdown"), {
				computedPopupVisible: f,
				handlePopupVisibleChange: m
			} = useTrigger({
				defaultPopupVisible: a,
				popupVisible: l,
				emit: s
			});
			return provide(dropdownInjectionKey, reactive({
				popupMaxHeight: c,
				onOptionClick: (v, y) => {
					s("select", v, y), o.hideOnSelect && m(!1)
				}
			})), {
				prefixCls: d,
				computedPopupVisible: f,
				handlePopupVisibleChange: m
			}
		}
	});

function _sfc_render$2t(o, s, a, l, c, d) {
	const f = resolveComponent("DropdownPanel"),
		m = resolveComponent("Trigger");
	return openBlock(), createBlock(m, {
		"popup-visible": o.computedPopupVisible,
		"animation-name": "slide-dynamic-origin",
		"auto-fit-transform-origin": "",
		trigger: o.trigger,
		position: o.position,
		"popup-offset": 4,
		"popup-container": o.popupContainer,
		"opened-class": `${o.prefixCls}-open`,
		onPopupVisibleChange: o.handlePopupVisibleChange
	}, {
		content: withCtx(() => [createVNode(f, null, createSlots({
			default: withCtx(() => [renderSlot(o.$slots, "content")]),
			_: 2
		}, [o.$slots.footer ? {
			name: "footer",
			fn: withCtx(() => [renderSlot(o.$slots, "footer")]),
			key: "0"
		} : void 0]), 1024)]),
		default: withCtx(() => [renderSlot(o.$slots, "default")]),
		_: 3
	}, 8, ["popup-visible", "trigger", "position", "popup-container", "opened-class", "onPopupVisibleChange"])
}
var _Dropdown = _export_sfc$1(_sfc_main$2L, [
	["render", _sfc_render$2t]
]);
const _sfc_main$2K = defineComponent({
	name: "Doption",
	props: {
		value: {
			type: [String, Number, Object]
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		active: Boolean,
		uninjectContext: Boolean
	},
	emits: {
		click: o => !0
	},
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("dropdown-option"),
			l = ref(),
			c = computed(() => {
				var g, v, y;
				return (y = (v = o.value) != null ? v : (g = l.value) == null ? void 0 : g.textContent) !=
					null ? y : void 0
			}),
			d = o.uninjectContext ? void 0 : inject(dropdownInjectionKey, void 0),
			f = g => {
				o.disabled || (s("click", g), d == null || d.onOptionClick(c.value, g))
			},
			m = computed(() => [a, {
				[`${a}-disabled`]: o.disabled,
				[`${a}-active`]: o.active
			}]);
		return {
			prefixCls: a,
			cls: m,
			liRef: l,
			handleClick: f
		}
	}
});

function _sfc_render$2s(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("li", {
		ref: "liRef",
		class: normalizeClass([o.cls, {
			[`${o.prefixCls}-has-suffix`]: !!o.$slots.suffix
		}]),
		onClick: s[0] || (s[0] = (...f) => o.handleClick && o.handleClick(...f))
	}, [o.$slots.icon ? (openBlock(), createElementBlock("span", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-icon`)
	}, [renderSlot(o.$slots, "icon")], 2)) : createCommentVNode("v-if", !0), createBaseVNode("span", {
		class: normalizeClass(`${o.prefixCls}-content`)
	}, [renderSlot(o.$slots, "default")], 2), o.$slots.suffix ? (openBlock(), createElementBlock("span", {
		key: 1,
		class: normalizeClass(`${o.prefixCls}-suffix`)
	}, [renderSlot(o.$slots, "suffix")], 2)) : createCommentVNode("v-if", !0)], 2)
}
var Doption = _export_sfc$1(_sfc_main$2K, [
	["render", _sfc_render$2s]
]);
const _sfc_main$2J = defineComponent({
	name: "Dgroup",
	props: {
		title: String
	},
	setup() {
		return {
			prefixCls: getPrefixCls("dropdown-group")
		}
	}
});

function _sfc_render$2r(o, s, a, l, c, d) {
	return openBlock(), createElementBlock(Fragment, null, [createBaseVNode("li", {
			class: normalizeClass(`${o.prefixCls}-title`)
		}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(o.title), 1)])], 2),
		renderSlot(o.$slots, "default")
	], 64)
}
var Dgroup = _export_sfc$1(_sfc_main$2J, [
	["render", _sfc_render$2r]
]);
const _sfc_main$2I = defineComponent({
		name: "IconRight",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-right`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$12 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2q(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "m16 39.513 15.556-15.557L16 8.4"
	}, null, -1)]), 14, _hoisted_1$12)
}
var _IconRight = _export_sfc$1(_sfc_main$2I, [
	["render", _sfc_render$2q]
]);
const IconRight = Object.assign(_IconRight, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconRight.name, _IconRight)
		}
	}),
	_sfc_main$2H = defineComponent({
		name: "Dsubmenu",
		components: {
			Trigger,
			DropdownPanel,
			DropdownOption: Doption,
			IconRight
		},
		props: {
			value: {
				type: [String, Number]
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			trigger: {
				type: [String, Array],
				default: "click"
			},
			position: {
				type: String,
				default: "rt"
			},
			popupVisible: {
				type: Boolean,
				default: void 0
			},
			defaultPopupVisible: {
				type: Boolean,
				default: !1
			},
			optionProps: {
				type: Object
			}
		},
		emits: {
			"update:popupVisible": o => !0,
			popupVisibleChange: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const {
				defaultPopupVisible: a,
				popupVisible: l
			} = toRefs(o), c = getPrefixCls("dropdown"), {
				computedPopupVisible: d,
				handlePopupVisibleChange: f
			} = useTrigger({
				defaultPopupVisible: a,
				popupVisible: l,
				emit: s
			});
			return {
				prefixCls: c,
				computedPopupVisible: d,
				handlePopupVisibleChange: f
			}
		}
	});

function _sfc_render$2p(o, s, a, l, c, d) {
	const f = resolveComponent("IconRight"),
		m = resolveComponent("dropdown-option"),
		g = resolveComponent("dropdown-panel"),
		v = resolveComponent("Trigger");
	return openBlock(), createBlock(v, {
		"popup-visible": o.computedPopupVisible,
		trigger: o.trigger,
		position: o.position,
		disabled: o.disabled,
		"popup-offset": 4,
		onPopupVisibleChange: o.handlePopupVisibleChange
	}, {
		content: withCtx(() => [createVNode(g, {
			class: normalizeClass(`${o.prefixCls}-submenu`)
		}, createSlots({
			default: withCtx(() => [renderSlot(o.$slots, "content")]),
			_: 2
		}, [o.$slots.footer ? {
			name: "footer",
			fn: withCtx(() => [renderSlot(o.$slots, "footer")]),
			key: "0"
		} : void 0]), 1032, ["class"])]),
		default: withCtx(() => [createVNode(m, mergeProps(o.optionProps, {
			active: o.computedPopupVisible,
			"uninject-context": ""
		}), createSlots({
			suffix: withCtx(() => [renderSlot(o.$slots, "suffix", {}, () => [createVNode(
				f)])]),
			default: withCtx(() => [renderSlot(o.$slots, "default")]),
			_: 2
		}, [o.$slots.icon ? {
			name: "icon",
			fn: withCtx(() => [renderSlot(o.$slots, "icon")]),
			key: "0"
		} : void 0]), 1040, ["active"])]),
		_: 3
	}, 8, ["popup-visible", "trigger", "position", "disabled", "onPopupVisibleChange"])
}
var Dsubmenu = _export_sfc$1(_sfc_main$2H, [
	["render", _sfc_render$2p]
]);
const _sfc_main$2G = defineComponent({
	name: "DropdownButton",
	components: {
		IconMore,
		Button,
		ButtonGroup,
		Dropdown: _Dropdown
	},
	props: {
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean,
			default: !1
		},
		trigger: {
			type: [String, Array],
			default: "click"
		},
		position: {
			type: String,
			default: "br"
		},
		popupContainer: {
			type: [String, Object]
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		type: {
			type: String
		},
		size: {
			type: String
		},
		buttonProps: {
			type: Object
		},
		hideOnSelect: {
			type: Boolean,
			default: !0
		}
	},
	emits: {
		"update:popupVisible": o => !0,
		popupVisibleChange: o => !0,
		click: o => !0,
		select: (o, s) => !0
	},
	setup(o, {
		emit: s
	}) {
		const {
			defaultPopupVisible: a,
			popupVisible: l
		} = toRefs(o), c = getPrefixCls("dropdown"), {
			computedPopupVisible: d,
			handlePopupVisibleChange: f
		} = useTrigger({
			defaultPopupVisible: a,
			popupVisible: l,
			emit: s
		});
		return {
			prefixCls: c,
			computedPopupVisible: d,
			handleClick: v => {
				s("click", v)
			},
			handleSelect: (v, y) => {
				s("select", v, y)
			},
			handlePopupVisibleChange: f
		}
	}
});

function _sfc_render$2o(o, s, a, l, c, d) {
	const f = resolveComponent("Button"),
		m = resolveComponent("IconMore"),
		g = resolveComponent("Dropdown"),
		v = resolveComponent("ButtonGroup");
	return openBlock(), createBlock(v, null, {
		default: withCtx(() => [createVNode(f, mergeProps({
			size: o.size,
			type: o.type,
			disabled: o.disabled
		}, o.buttonProps, {
			onClick: o.handleClick
		}), {
			default: withCtx(() => [renderSlot(o.$slots, "default")]),
			_: 3
		}, 16, ["size", "type", "disabled", "onClick"]), createVNode(g, {
			"popup-visible": o.computedPopupVisible,
			trigger: o.trigger,
			position: o.position,
			"popup-container": o.popupContainer,
			"hide-on-select": o.hideOnSelect,
			onSelect: o.handleSelect,
			onPopupVisibleChange: o.handlePopupVisibleChange
		}, {
			content: withCtx(() => [renderSlot(o.$slots, "content")]),
			default: withCtx(() => [createVNode(f, {
				size: o.size,
				type: o.type,
				disabled: o.disabled
			}, {
				icon: withCtx(() => [renderSlot(o.$slots, "icon", {
					popupVisible: o.computedPopupVisible
				}, () => [createVNode(m)])]),
				_: 3
			}, 8, ["size", "type", "disabled"])]),
			_: 3
		}, 8, ["popup-visible", "trigger", "position", "popup-container", "hide-on-select",
			"onSelect", "onPopupVisibleChange"
		])]),
		_: 3
	})
}
var DropdownButton = _export_sfc$1(_sfc_main$2G, [
	["render", _sfc_render$2o]
]);
const Dropdown = Object.assign(_Dropdown, {
	Option: Doption,
	Group: Dgroup,
	Submenu: Dsubmenu,
	Button: DropdownButton,
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Dropdown.name, _Dropdown), o.component(a + Doption.name, Doption), o.component(a +
			Dgroup.name, Dgroup), o.component(a + Dsubmenu.name, Dsubmenu), o.component(a +
			DropdownButton.name, DropdownButton)
	}
});
var BreadcrumbItem = defineComponent({
		name: "BreadcrumbItem",
		inheritAttrs: !1,
		props: {
			separator: {
				type: [String, Number]
			},
			droplist: {
				type: Array
			},
			dropdownProps: {
				type: Object
			},
			index: {
				type: Number,
				default: 0
			}
		},
		setup(o, {
			slots: s,
			attrs: a
		}) {
			const l = getPrefixCls("breadcrumb-item"),
				c = inject(breadcrumbInjectKey, void 0),
				d = ref(!1),
				f = computed(() => !(c && c.needHide && o.index > 1 && o.index <= c.total - c.maxCount)),
				m = computed(() => c && c.needHide ? o.index === 1 : !1),
				g = computed(() => c ? o.index < c.total - 1 : !0),
				v = S => {
					d.value = S
				},
				y = () => {
					var S, w, T, A, k, M, D;
					if (!g.value) return null;
					const F = (D = (M = (k = (w = (S = s.separator) == null ? void 0 : S.call(s)) != null ? w : o
								.separator) != null ? k : (A = c == null ? void 0 : (T = c.slots).separator) ==
							null ? void 0 : A.call(T)) != null ? M : c == null ? void 0 : c.separator) != null ? D :
						createVNode(IconObliqueLine, null, null);
					return createVNode("div", {
						"aria-hidden": "true",
						class: `${l}-separator`
					}, [F])
				},
				b = () => {
					var S, w, T, A;
					return createVNode("div", mergeProps({
						role: "listitem",
						class: [l, {
							[`${l}-with-dropdown`]: o.droplist || s.droplist
						}]
					}, m.value ? {
						"aria-label": "ellipses of breadcrumb items"
					} : void 0, a), [m.value ? (T = (w = c == null ? void 0 : (S = c.slots)["more-icon"]) ==
							null ? void 0 : w.call(S)) != null ? T : createVNode(IconMore, null, null) : (
							A = s.default) == null ? void 0 : A.call(s), (o.droplist || s.droplist) &&
						createVNode("span", {
							"aria-hidden": !0,
							class: [`${l}-dropdown-icon`, {
								[`${l}-dropdown-icon-active`]: d.value
							}]
						}, [createVNode(IconDown, null, null)])
					])
				},
				C = () => {
					var S, w, T;
					return (T = (S = s.droplist) == null ? void 0 : S.call(s)) != null ? T : (w = o.droplist) ==
						null ? void 0 : w.map(A => createVNode(Doption, {
							value: A.path
						}, {
							default: () => [A.label]
						}))
				},
				_ = () => createVNode(Dropdown, mergeProps({
					popupVisible: d.value,
					onPopupVisibleChange: v
				}, o.dropdownProps), {
					default: () => [b()],
					content: C
				});
			return () => f.value ? createVNode(Fragment, null, [s.droplist || o.droplist ? _() : b(), y()]) : null
		}
	}),
	_Breadcrumb = defineComponent({
		name: "Breadcrumb",
		props: {
			maxCount: {
				type: Number,
				default: 0
			},
			routes: {
				type: Array
			},
			separator: {
				type: [String, Number]
			},
			customUrl: {
				type: Function
			}
		},
		setup(o, {
			slots: s
		}) {
			const {
				maxCount: a,
				separator: l,
				routes: c
			} = toRefs(o), d = getPrefixCls("breadcrumb"), f = ref(0), m = computed(() => a.value > 0 && f.value > a
				.value + 1);
			provide(breadcrumbInjectKey, reactive({
				total: f,
				maxCount: a,
				separator: l,
				needHide: m,
				slots: s
			}));
			const g = (b, C, _) => {
					var S, w;
					if (C.indexOf(b) === C.length - 1) return createVNode("span", null, [b.label]);
					const T = (w = (S = o.customUrl) == null ? void 0 : S.call(o, _)) != null ? w :
						`#/${_.join("/").replace(/^\//,"")}`;
					return createVNode("a", {
						href: T
					}, [b.label])
				},
				v = () => {
					var b;
					if (!((b = c.value) != null && b.length)) return null;
					f.value !== c.value.length && (f.value = c.value.length);
					const C = [];
					return c.value.map((_, S, w) => {
						C.push((_.path || "").replace(/^\//, ""));
						const T = [...C];
						return createVNode(BreadcrumbItem, {
							key: _.path || _.label,
							index: S,
							droplist: _.children
						}, {
							default: () => {
								var A, k;
								return [(k = (A = s["item-render"]) == null ? void 0 : A.call(
								s, {
									route: _,
									routes: w,
									paths: T
								})) != null ? k : g(_, w, T)]
							}
						})
					})
				},
				y = () => {
					var b, C;
					const _ = getAllElements((C = (b = s.default) == null ? void 0 : b.call(s)) != null ? C : []);
					return f.value !== _.length && (f.value = _.length), _.map((S, w) => {
						var T;
						return S.props = mergeProps((T = S.props) != null ? T : {}, {
							index: w
						}), S
					})
				};
			return () => createVNode("div", {
				role: "list",
				class: d
			}, [s.default ? y() : v()])
		}
	});
const Breadcrumb = Object.assign(_Breadcrumb, {
	Item: BreadcrumbItem,
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Breadcrumb.name, _Breadcrumb), o.component(a + BreadcrumbItem.name, BreadcrumbItem)
	}
});
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ?
	global : typeof self < "u" ? self : {};

function getDefaultExportFromCjs(o) {
	return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o
}
var dayjs_min$1 = {
		exports: {}
	},
	dayjs_min = dayjs_min$1.exports,
	hasRequiredDayjs_min;

function requireDayjs_min() {
	return hasRequiredDayjs_min || (hasRequiredDayjs_min = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(dayjs_min, function() {
			var a = 1e3,
				l = 6e4,
				c = 36e5,
				d = "millisecond",
				f = "second",
				m = "minute",
				g = "hour",
				v = "day",
				y = "week",
				b = "month",
				C = "quarter",
				_ = "year",
				S = "date",
				w = "Invalid Date",
				T =
				/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
				A = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
				k = {
					name: "en",
					weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
					months: "January_February_March_April_May_June_July_August_September_October_November_December"
						.split("_"),
					ordinal: function(he) {
						var ce = ["th", "st", "nd", "rd"],
							ae = he % 100;
						return "[" + he + (ce[(ae - 20) % 10] || ce[ae] || ce[0]) + "]"
					}
				},
				M = function(he, ce, ae) {
					var fe = String(he);
					return !fe || fe.length >= ce ? he : "" + Array(ce + 1 - fe.length).join(ae) + he
				},
				D = {
					s: M,
					z: function(he) {
						var ce = -he.utcOffset(),
							ae = Math.abs(ce),
							fe = Math.floor(ae / 60),
							q = ae % 60;
						return (ce <= 0 ? "+" : "-") + M(fe, 2, "0") + ":" + M(q, 2, "0")
					},
					m: function he(ce, ae) {
						if (ce.date() < ae.date()) return -he(ae, ce);
						var fe = 12 * (ae.year() - ce.year()) + (ae.month() - ce.month()),
							q = ce.clone().add(fe, b),
							le = ae - q < 0,
							de = ce.clone().add(fe + (le ? -1 : 1), b);
						return +(-(fe + (ae - q) / (le ? q - de : de - q)) || 0)
					},
					a: function(he) {
						return he < 0 ? Math.ceil(he) || 0 : Math.floor(he)
					},
					p: function(he) {
						return {
							M: b,
							y: _,
							w: y,
							d: v,
							D: S,
							h: g,
							m,
							s: f,
							ms: d,
							Q: C
						} [he] || String(he || "").toLowerCase().replace(/s$/, "")
					},
					u: function(he) {
						return he === void 0
					}
				},
				F = "en",
				R = {};
			R[F] = k;
			var O = "$isDayjsObject",
				U = function(he) {
					return he instanceof ge || !(!he || !he[O])
				},
				V = function he(ce, ae, fe) {
					var q;
					if (!ce) return F;
					if (typeof ce == "string") {
						var le = ce.toLowerCase();
						R[le] && (q = le), ae && (R[le] = ae, q = le);
						var de = ce.split("-");
						if (!q && de.length > 1) return he(de[0])
					} else {
						var _e = ce.name;
						R[_e] = ce, q = _e
					}
					return !fe && q && (F = q), q || !fe && F
				},
				z = function(he, ce) {
					if (U(he)) return he.clone();
					var ae = typeof ce == "object" ? ce : {};
					return ae.date = he, ae.args = arguments, new ge(ae)
				},
				j = D;
			j.l = V, j.i = U, j.w = function(he, ce) {
				return z(he, {
					locale: ce.$L,
					utc: ce.$u,
					x: ce.$x,
					$offset: ce.$offset
				})
			};
			var ge = function() {
					function he(ae) {
						this.$L = V(ae.locale, null, !0), this.parse(ae), this.$x = this.$x || ae.x || {},
							this[O] = !0
					}
					var ce = he.prototype;
					return ce.parse = function(ae) {
						this.$d = function(fe) {
							var q = fe.date,
								le = fe.utc;
							if (q === null) return new Date(NaN);
							if (j.u(q)) return new Date;
							if (q instanceof Date) return new Date(q);
							if (typeof q == "string" && !/Z$/i.test(q)) {
								var de = q.match(T);
								if (de) {
									var _e = de[2] - 1 || 0,
										ke = (de[7] || "0").substring(0, 3);
									return le ? new Date(Date.UTC(de[1], _e, de[3] || 1, de[4] || 0,
										de[5] || 0, de[6] || 0, ke)) : new Date(de[1], _e, de[
										3] || 1, de[4] || 0, de[5] || 0, de[6] || 0, ke)
								}
							}
							return new Date(q)
						}(ae), this.init()
					}, ce.init = function() {
						var ae = this.$d;
						this.$y = ae.getFullYear(), this.$M = ae.getMonth(), this.$D = ae.getDate(),
							this.$W = ae.getDay(), this.$H = ae.getHours(), this.$m = ae.getMinutes(),
							this.$s = ae.getSeconds(), this.$ms = ae.getMilliseconds()
					}, ce.$utils = function() {
						return j
					}, ce.isValid = function() {
						return this.$d.toString() !== w
					}, ce.isSame = function(ae, fe) {
						var q = z(ae);
						return this.startOf(fe) <= q && q <= this.endOf(fe)
					}, ce.isAfter = function(ae, fe) {
						return z(ae) < this.startOf(fe)
					}, ce.isBefore = function(ae, fe) {
						return this.endOf(fe) < z(ae)
					}, ce.$g = function(ae, fe, q) {
						return j.u(ae) ? this[fe] : this.set(q, ae)
					}, ce.unix = function() {
						return Math.floor(this.valueOf() / 1e3)
					}, ce.valueOf = function() {
						return this.$d.getTime()
					}, ce.startOf = function(ae, fe) {
						var q = this,
							le = !!j.u(fe) || fe,
							de = j.p(ae),
							_e = function(pt, dt) {
								var He = j.w(q.$u ? Date.UTC(q.$y, dt, pt) : new Date(q.$y, dt, pt), q);
								return le ? He : He.endOf(v)
							},
							ke = function(pt, dt) {
								return j.w(q.toDate()[pt].apply(q.toDate("s"), (le ? [0, 0, 0, 0] : [23,
									59, 59, 999
								]).slice(dt)), q)
							},
							De = this.$W,
							Se = this.$M,
							be = this.$D,
							Me = "set" + (this.$u ? "UTC" : "");
						switch (de) {
							case _:
								return le ? _e(1, 0) : _e(31, 11);
							case b:
								return le ? _e(1, Se) : _e(0, Se + 1);
							case y:
								var Ve = this.$locale().weekStart || 0,
									it = (De < Ve ? De + 7 : De) - Ve;
								return _e(le ? be - it : be + (6 - it), Se);
							case v:
							case S:
								return ke(Me + "Hours", 0);
							case g:
								return ke(Me + "Minutes", 1);
							case m:
								return ke(Me + "Seconds", 2);
							case f:
								return ke(Me + "Milliseconds", 3);
							default:
								return this.clone()
						}
					}, ce.endOf = function(ae) {
						return this.startOf(ae, !1)
					}, ce.$set = function(ae, fe) {
						var q, le = j.p(ae),
							de = "set" + (this.$u ? "UTC" : ""),
							_e = (q = {}, q[v] = de + "Date", q[S] = de + "Date", q[b] = de + "Month",
								q[_] = de + "FullYear", q[g] = de + "Hours", q[m] = de + "Minutes", q[
								f] = de + "Seconds", q[d] = de + "Milliseconds", q)[le],
							ke = le === v ? this.$D + (fe - this.$W) : fe;
						if (le === b || le === _) {
							var De = this.clone().set(S, 1);
							De.$d[_e](ke), De.init(), this.$d = De.set(S, Math.min(this.$D, De
								.daysInMonth())).$d
						} else _e && this.$d[_e](ke);
						return this.init(), this
					}, ce.set = function(ae, fe) {
						return this.clone().$set(ae, fe)
					}, ce.get = function(ae) {
						return this[j.p(ae)]()
					}, ce.add = function(ae, fe) {
						var q, le = this;
						ae = Number(ae);
						var de = j.p(fe),
							_e = function(Se) {
								var be = z(le);
								return j.w(be.date(be.date() + Math.round(Se * ae)), le)
							};
						if (de === b) return this.set(b, this.$M + ae);
						if (de === _) return this.set(_, this.$y + ae);
						if (de === v) return _e(1);
						if (de === y) return _e(7);
						var ke = (q = {}, q[m] = l, q[g] = c, q[f] = a, q)[de] || 1,
							De = this.$d.getTime() + ae * ke;
						return j.w(De, this)
					}, ce.subtract = function(ae, fe) {
						return this.add(-1 * ae, fe)
					}, ce.format = function(ae) {
						var fe = this,
							q = this.$locale();
						if (!this.isValid()) return q.invalidDate || w;
						var le = ae || "YYYY-MM-DDTHH:mm:ssZ",
							de = j.z(this),
							_e = this.$H,
							ke = this.$m,
							De = this.$M,
							Se = q.weekdays,
							be = q.months,
							Me = q.meridiem,
							Ve = function(dt, He, Ae, xe) {
								return dt && (dt[He] || dt(fe, le)) || Ae[He].slice(0, xe)
							},
							it = function(dt) {
								return j.s(_e % 12 || 12, dt, "0")
							},
							pt = Me || function(dt, He, Ae) {
								var xe = dt < 12 ? "AM" : "PM";
								return Ae ? xe.toLowerCase() : xe
							};
						return le.replace(A, function(dt, He) {
							return He || function(Ae) {
								switch (Ae) {
									case "YY":
										return String(fe.$y).slice(-2);
									case "YYYY":
										return j.s(fe.$y, 4, "0");
									case "M":
										return De + 1;
									case "MM":
										return j.s(De + 1, 2, "0");
									case "MMM":
										return Ve(q.monthsShort, De, be, 3);
									case "MMMM":
										return Ve(be, De);
									case "D":
										return fe.$D;
									case "DD":
										return j.s(fe.$D, 2, "0");
									case "d":
										return String(fe.$W);
									case "dd":
										return Ve(q.weekdaysMin, fe.$W, Se, 2);
									case "ddd":
										return Ve(q.weekdaysShort, fe.$W, Se, 3);
									case "dddd":
										return Se[fe.$W];
									case "H":
										return String(_e);
									case "HH":
										return j.s(_e, 2, "0");
									case "h":
										return it(1);
									case "hh":
										return it(2);
									case "a":
										return pt(_e, ke, !0);
									case "A":
										return pt(_e, ke, !1);
									case "m":
										return String(ke);
									case "mm":
										return j.s(ke, 2, "0");
									case "s":
										return String(fe.$s);
									case "ss":
										return j.s(fe.$s, 2, "0");
									case "SSS":
										return j.s(fe.$ms, 3, "0");
									case "Z":
										return de
								}
								return null
							}(dt) || de.replace(":", "")
						})
					}, ce.utcOffset = function() {
						return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
					}, ce.diff = function(ae, fe, q) {
						var le, de = this,
							_e = j.p(fe),
							ke = z(ae),
							De = (ke.utcOffset() - this.utcOffset()) * l,
							Se = this - ke,
							be = function() {
								return j.m(de, ke)
							};
						switch (_e) {
							case _:
								le = be() / 12;
								break;
							case b:
								le = be();
								break;
							case C:
								le = be() / 3;
								break;
							case y:
								le = (Se - De) / 6048e5;
								break;
							case v:
								le = (Se - De) / 864e5;
								break;
							case g:
								le = Se / c;
								break;
							case m:
								le = Se / l;
								break;
							case f:
								le = Se / a;
								break;
							default:
								le = Se
						}
						return q ? le : j.a(le)
					}, ce.daysInMonth = function() {
						return this.endOf(b).$D
					}, ce.$locale = function() {
						return R[this.$L]
					}, ce.locale = function(ae, fe) {
						if (!ae) return this.$L;
						var q = this.clone(),
							le = V(ae, fe, !0);
						return le && (q.$L = le), q
					}, ce.clone = function() {
						return j.w(this.$d, this)
					}, ce.toDate = function() {
						return new Date(this.valueOf())
					}, ce.toJSON = function() {
						return this.isValid() ? this.toISOString() : null
					}, ce.toISOString = function() {
						return this.$d.toISOString()
					}, ce.toString = function() {
						return this.$d.toUTCString()
					}, he
				}(),
				me = ge.prototype;
			return z.prototype = me, [
				["$ms", d],
				["$s", f],
				["$m", m],
				["$H", g],
				["$W", v],
				["$M", b],
				["$y", _],
				["$D", S]
			].forEach(function(he) {
				me[he[1]] = function(ce) {
					return this.$g(ce, he[0], he[1])
				}
			}), z.extend = function(he, ce) {
				return he.$i || (he(ce, ge, z), he.$i = !0), z
			}, z.locale = V, z.isDayjs = U, z.unix = function(he) {
				return z(1e3 * he)
			}, z.en = R[F], z.Ls = R, z.p = {}, z
		})
	}(dayjs_min$1)), dayjs_min$1.exports
}
var dayjs_minExports = requireDayjs_min();
const originDayjs = getDefaultExportFromCjs(dayjs_minExports);
var customParseFormat$2 = {
		exports: {}
	},
	customParseFormat$1 = customParseFormat$2.exports,
	hasRequiredCustomParseFormat;

function requireCustomParseFormat() {
	return hasRequiredCustomParseFormat || (hasRequiredCustomParseFormat = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(customParseFormat$1, function() {
			var a = {
					LTS: "h:mm:ss A",
					LT: "h:mm A",
					L: "MM/DD/YYYY",
					LL: "MMMM D, YYYY",
					LLL: "MMMM D, YYYY h:mm A",
					LLLL: "dddd, MMMM D, YYYY h:mm A"
				},
				l =
				/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
				c = /\d/,
				d = /\d\d/,
				f = /\d\d?/,
				m = /\d*[^-_:/,()\s\d]+/,
				g = {},
				v = function(T) {
					return (T = +T) + (T > 68 ? 1900 : 2e3)
				},
				y = function(T) {
					return function(A) {
						this[T] = +A
					}
				},
				b = [/[+-]\d\d:?(\d\d)?|Z/, function(T) {
					(this.zone || (this.zone = {})).offset = function(A) {
						if (!A || A === "Z") return 0;
						var k = A.match(/([+-]|\d\d)/g),
							M = 60 * k[1] + (+k[2] || 0);
						return M === 0 ? 0 : k[0] === "+" ? -M : M
					}(T)
				}],
				C = function(T) {
					var A = g[T];
					return A && (A.indexOf ? A : A.s.concat(A.f))
				},
				_ = function(T, A) {
					var k, M = g.meridiem;
					if (M) {
						for (var D = 1; D <= 24; D += 1)
							if (T.indexOf(M(D, 0, A)) > -1) {
								k = D > 12;
								break
							}
					} else k = T === (A ? "pm" : "PM");
					return k
				},
				S = {
					A: [m, function(T) {
						this.afternoon = _(T, !1)
					}],
					a: [m, function(T) {
						this.afternoon = _(T, !0)
					}],
					Q: [c, function(T) {
						this.month = 3 * (T - 1) + 1
					}],
					S: [c, function(T) {
						this.milliseconds = 100 * +T
					}],
					SS: [d, function(T) {
						this.milliseconds = 10 * +T
					}],
					SSS: [/\d{3}/, function(T) {
						this.milliseconds = +T
					}],
					s: [f, y("seconds")],
					ss: [f, y("seconds")],
					m: [f, y("minutes")],
					mm: [f, y("minutes")],
					H: [f, y("hours")],
					h: [f, y("hours")],
					HH: [f, y("hours")],
					hh: [f, y("hours")],
					D: [f, y("day")],
					DD: [d, y("day")],
					Do: [m, function(T) {
						var A = g.ordinal,
							k = T.match(/\d+/);
						if (this.day = k[0], A)
							for (var M = 1; M <= 31; M += 1) A(M).replace(/\[|\]/g, "") === T && (
								this.day = M)
					}],
					w: [f, y("week")],
					ww: [d, y("week")],
					M: [f, y("month")],
					MM: [d, y("month")],
					MMM: [m, function(T) {
						var A = C("months"),
							k = (C("monthsShort") || A.map(function(M) {
								return M.slice(0, 3)
							})).indexOf(T) + 1;
						if (k < 1) throw new Error;
						this.month = k % 12 || k
					}],
					MMMM: [m, function(T) {
						var A = C("months").indexOf(T) + 1;
						if (A < 1) throw new Error;
						this.month = A % 12 || A
					}],
					Y: [/[+-]?\d+/, y("year")],
					YY: [d, function(T) {
						this.year = v(T)
					}],
					YYYY: [/\d{4}/, y("year")],
					Z: b,
					ZZ: b
				};

			function w(T) {
				var A, k;
				A = T, k = g && g.formats;
				for (var M = (T = A.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(z, j, ge) {
						var me = ge && ge.toUpperCase();
						return j || k[ge] || a[ge] || k[me].replace(
							/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
							function(he, ce, ae) {
								return ce || ae.slice(1)
							})
					})).match(l), D = M.length, F = 0; F < D; F += 1) {
					var R = M[F],
						O = S[R],
						U = O && O[0],
						V = O && O[1];
					M[F] = V ? {
						regex: U,
						parser: V
					} : R.replace(/^\[|\]$/g, "")
				}
				return function(z) {
					for (var j = {}, ge = 0, me = 0; ge < D; ge += 1) {
						var he = M[ge];
						if (typeof he == "string") me += he.length;
						else {
							var ce = he.regex,
								ae = he.parser,
								fe = z.slice(me),
								q = ce.exec(fe)[0];
							ae.call(j, q), z = z.replace(q, "")
						}
					}
					return function(le) {
						var de = le.afternoon;
						if (de !== void 0) {
							var _e = le.hours;
							de ? _e < 12 && (le.hours += 12) : _e === 12 && (le.hours = 0),
								delete le.afternoon
						}
					}(j), j
				}
			}
			return function(T, A, k) {
				k.p.customParseFormat = !0, T && T.parseTwoDigitYear && (v = T.parseTwoDigitYear);
				var M = A.prototype,
					D = M.parse;
				M.parse = function(F) {
					var R = F.date,
						O = F.utc,
						U = F.args;
					this.$u = O;
					var V = U[1];
					if (typeof V == "string") {
						var z = U[2] === !0,
							j = U[3] === !0,
							ge = z || j,
							me = U[2];
						j && (me = U[2]), g = this.$locale(), !z && me && (g = k.Ls[me]), this.$d =
							function(fe, q, le, de) {
								try {
									if (["x", "X"].indexOf(q) > -1) return new Date((q === "X" ?
										1e3 : 1) * fe);
									var _e = w(q)(fe),
										ke = _e.year,
										De = _e.month,
										Se = _e.day,
										be = _e.hours,
										Me = _e.minutes,
										Ve = _e.seconds,
										it = _e.milliseconds,
										pt = _e.zone,
										dt = _e.week,
										He = new Date,
										Ae = Se || (ke || De ? 1 : He.getDate()),
										xe = ke || He.getFullYear(),
										ye = 0;
									ke && !De || (ye = De > 0 ? De - 1 : He.getMonth());
									var Le, Ue = be || 0,
										nt = Me || 0,
										ot = Ve || 0,
										at = it || 0;
									return pt ? new Date(Date.UTC(xe, ye, Ae, Ue, nt, ot, at + 60 *
										pt.offset * 1e3)) : le ? new Date(Date.UTC(xe, ye, Ae,
										Ue, nt, ot, at)) : (Le = new Date(xe, ye, Ae, Ue, nt,
										ot, at), dt && (Le = de(Le).week(dt).toDate()), Le)
								} catch {
									return new Date("")
								}
							}(R, V, O, k), this.init(), me && me !== !0 && (this.$L = this.locale(
								me).$L), ge && R != this.format(V) && (this.$d = new Date("")),
							g = {}
					} else if (V instanceof Array)
						for (var he = V.length, ce = 1; ce <= he; ce += 1) {
							U[1] = V[ce - 1];
							var ae = k.apply(this, U);
							if (ae.isValid()) {
								this.$d = ae.$d, this.$L = ae.$L, this.init();
								break
							}
							ce === he && (this.$d = new Date(""))
						} else D.call(this, F)
				}
			}
		})
	}(customParseFormat$2)), customParseFormat$2.exports
}
var customParseFormatExports = requireCustomParseFormat();
const customParseFormat = getDefaultExportFromCjs(customParseFormatExports);
var isBetween$2 = {
		exports: {}
	},
	isBetween$1 = isBetween$2.exports,
	hasRequiredIsBetween;

function requireIsBetween() {
	return hasRequiredIsBetween || (hasRequiredIsBetween = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(isBetween$1, function() {
			return function(a, l, c) {
				l.prototype.isBetween = function(d, f, m, g) {
					var v = c(d),
						y = c(f),
						b = (g = g || "()")[0] === "(",
						C = g[1] === ")";
					return (b ? this.isAfter(v, m) : !this.isBefore(v, m)) && (C ? this.isBefore(y,
						m) : !this.isAfter(y, m)) || (b ? this.isBefore(v, m) : !this.isAfter(v,
						m)) && (C ? this.isAfter(y, m) : !this.isBefore(y, m))
				}
			}
		})
	}(isBetween$2)), isBetween$2.exports
}
var isBetweenExports = requireIsBetween();
const isBetween = getDefaultExportFromCjs(isBetweenExports);
var weekOfYear$2 = {
		exports: {}
	},
	weekOfYear$1 = weekOfYear$2.exports,
	hasRequiredWeekOfYear;

function requireWeekOfYear() {
	return hasRequiredWeekOfYear || (hasRequiredWeekOfYear = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(weekOfYear$1, function() {
			var a = "week",
				l = "year";
			return function(c, d, f) {
				var m = d.prototype;
				m.week = function(g) {
					if (g === void 0 && (g = null), g !== null) return this.add(7 * (g - this
					.week()), "day");
					var v = this.$locale().yearStart || 1;
					if (this.month() === 11 && this.date() > 25) {
						var y = f(this).startOf(l).add(1, l).date(v),
							b = f(this).endOf(a);
						if (y.isBefore(b)) return 1
					}
					var C = f(this).startOf(l).date(v).startOf(a).subtract(1, "millisecond"),
						_ = this.diff(C, a, !0);
					return _ < 0 ? f(this).startOf("week").week() : Math.ceil(_)
				}, m.weeks = function(g) {
					return g === void 0 && (g = null), this.week(g)
				}
			}
		})
	}(weekOfYear$2)), weekOfYear$2.exports
}
var weekOfYearExports = requireWeekOfYear();
const weekOfYear = getDefaultExportFromCjs(weekOfYearExports);
var advancedFormat$1 = {
		exports: {}
	},
	advancedFormat = advancedFormat$1.exports,
	hasRequiredAdvancedFormat;

function requireAdvancedFormat() {
	return hasRequiredAdvancedFormat || (hasRequiredAdvancedFormat = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(advancedFormat, function() {
			return function(a, l) {
				var c = l.prototype,
					d = c.format;
				c.format = function(f) {
					var m = this,
						g = this.$locale();
					if (!this.isValid()) return d.bind(this)(f);
					var v = this.$utils(),
						y = (f || "YYYY-MM-DDTHH:mm:ssZ").replace(
							/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,
							function(b) {
								switch (b) {
									case "Q":
										return Math.ceil((m.$M + 1) / 3);
									case "Do":
										return g.ordinal(m.$D);
									case "gggg":
										return m.weekYear();
									case "GGGG":
										return m.isoWeekYear();
									case "wo":
										return g.ordinal(m.week(), "W");
									case "w":
									case "ww":
										return v.s(m.week(), b === "w" ? 1 : 2, "0");
									case "W":
									case "WW":
										return v.s(m.isoWeek(), b === "W" ? 1 : 2, "0");
									case "k":
									case "kk":
										return v.s(String(m.$H === 0 ? 24 : m.$H), b === "k" ? 1 :
											2, "0");
									case "X":
										return Math.floor(m.$d.getTime() / 1e3);
									case "x":
										return m.$d.getTime();
									case "z":
										return "[" + m.offsetName() + "]";
									case "zzz":
										return "[" + m.offsetName("long") + "]";
									default:
										return b
								}
							});
					return d.bind(this)(y)
				}
			}
		})
	}(advancedFormat$1)), advancedFormat$1.exports
}
var advancedFormatExports = requireAdvancedFormat();
const AdvancedFormat = getDefaultExportFromCjs(advancedFormatExports);
var weekYear$2 = {
		exports: {}
	},
	weekYear$1 = weekYear$2.exports,
	hasRequiredWeekYear;

function requireWeekYear() {
	return hasRequiredWeekYear || (hasRequiredWeekYear = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(weekYear$1, function() {
			return function(a, l) {
				l.prototype.weekYear = function() {
					var c = this.month(),
						d = this.week(),
						f = this.year();
					return d === 1 && c === 11 ? f + 1 : c === 0 && d >= 52 ? f - 1 : f
				}
			}
		})
	}(weekYear$2)), weekYear$2.exports
}
var weekYearExports = requireWeekYear();
const weekYear = getDefaultExportFromCjs(weekYearExports);
var quarterOfYear$1 = {
		exports: {}
	},
	quarterOfYear = quarterOfYear$1.exports,
	hasRequiredQuarterOfYear;

function requireQuarterOfYear() {
	return hasRequiredQuarterOfYear || (hasRequiredQuarterOfYear = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(quarterOfYear, function() {
			var a = "month",
				l = "quarter";
			return function(c, d) {
				var f = d.prototype;
				f.quarter = function(v) {
					return this.$utils().u(v) ? Math.ceil((this.month() + 1) / 3) : this.month(this
						.month() % 3 + 3 * (v - 1))
				};
				var m = f.add;
				f.add = function(v, y) {
					return v = Number(v), this.$utils().p(y) === l ? this.add(3 * v, a) : m.bind(
						this)(v, y)
				};
				var g = f.startOf;
				f.startOf = function(v, y) {
					var b = this.$utils(),
						C = !!b.u(y) || y;
					if (b.p(v) === l) {
						var _ = this.quarter() - 1;
						return C ? this.month(3 * _).startOf(a).startOf("day") : this.month(3 * _ +
							2).endOf(a).endOf("day")
					}
					return g.bind(this)(v, y)
				}
			}
		})
	}(quarterOfYear$1)), quarterOfYear$1.exports
}
var quarterOfYearExports = requireQuarterOfYear();
const QuarterOfYear = getDefaultExportFromCjs(quarterOfYearExports);
var zhCn$1 = {
		exports: {}
	},
	zhCn = zhCn$1.exports,
	hasRequiredZhCn;

function requireZhCn() {
	return hasRequiredZhCn || (hasRequiredZhCn = 1, function(o, s) {
		(function(a, l) {
			o.exports = l(requireDayjs_min())
		})(zhCn, function(a) {
			function l(f) {
				return f && typeof f == "object" && "default" in f ? f : {
					default: f
				}
			}
			var c = l(a),
				d = {
					name: "zh-cn",
					weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
					weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
					weekdaysMin: "日_一_二_三_四_五_六".split("_"),
					months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
					monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
					ordinal: function(f, m) {
						return m === "W" ? f + "周" : f + "日"
					},
					weekStart: 1,
					yearStart: 4,
					formats: {
						LT: "HH:mm",
						LTS: "HH:mm:ss",
						L: "YYYY/MM/DD",
						LL: "YYYY年M月D日",
						LLL: "YYYY年M月D日Ah点mm分",
						LLLL: "YYYY年M月D日ddddAh点mm分",
						l: "YYYY/M/D",
						ll: "YYYY年M月D日",
						lll: "YYYY年M月D日 HH:mm",
						llll: "YYYY年M月D日dddd HH:mm"
					},
					relativeTime: {
						future: "%s内",
						past: "%s前",
						s: "几秒",
						m: "1 分钟",
						mm: "%d 分钟",
						h: "1 小时",
						hh: "%d 小时",
						d: "1 天",
						dd: "%d 天",
						M: "1 个月",
						MM: "%d 个月",
						y: "1 年",
						yy: "%d 年"
					},
					meridiem: function(f, m) {
						var g = 100 * f + m;
						return g < 600 ? "凌晨" : g < 900 ? "早上" : g < 1100 ? "上午" : g < 1300 ? "中午" : g <
							1800 ? "下午" : "晚上"
					}
				};
			return c.default.locale(d, null, !0), d
		})
	}(zhCn$1)), zhCn$1.exports
}
requireZhCn();
const overwriteIsDayjs = (o, s, a) => {
	a = function(d, f) {
		if (isDayjs(d)) return d.clone();
		const m = typeof f == "object" ? f : {};
		return m.date = d, m.args = arguments, new s(m)
	};
	const l = s.prototype,
		c = l.$utils;
	l.$utils = () => {
		const d = c();
		return d.i = isDayjs, d
	}, a.isDayjs = isDayjs
};
originDayjs.extend(overwriteIsDayjs);
originDayjs.extend(customParseFormat);
originDayjs.extend(isBetween);
originDayjs.extend(weekOfYear);
originDayjs.extend(AdvancedFormat);
originDayjs.extend(weekYear);
originDayjs.extend(QuarterOfYear);
const dayjs = originDayjs,
	methods = {
		add(o, s, a) {
			return o.add(s, a)
		},
		subtract(o, s, a) {
			return o.subtract(s, a)
		},
		startOf(o, s) {
			return o.startOf(s)
		},
		startOfWeek(o, s) {
			const a = o.day();
			let l = o.subtract(a - s, "day");
			return l.isAfter(o) && (l = l.subtract(7, "day")), l
		},
		endOf(o, s) {
			return o.endOf(s)
		},
		set(o, s, a) {
			return o.set(s, a)
		},
		isSameWeek(o, s, a) {
			const l = c => {
				const d = c.day(),
					f = d - a + (d < a ? 7 : 0);
				return c.subtract(f, "day").week()
			};
			return l(o) === l(s)
		}
	};

function getNow() {
	return dayjs()
}

function getSortedDayjsArray(o) {
	return [...o].sort((s, a) => s.valueOf() - a.valueOf())
}

function isValueChange(o, s) {
	const a = (l, c) => l === void 0 && c === void 0 ? !1 : l && !c || !l && c ? !0 : (l == null ? void 0 : l
	.valueOf()) !== (c == null ? void 0 : c.valueOf());
	return s === void 0 && o === void 0 ? !1 : isArray$2(s) && isArray$2(o) ? a(s[0], o[0]) || a(s[1], o[1]) : !
		isArray$2(s) && !isArray$2(o) ? a(s, o) : !0
}

function getDayjsValue(o, s) {
	const a = c => {
			const d = /(Q1)|(Q2)|(Q3)|(Q4)/,
				f = {
					Q1: "01",
					Q2: "04",
					Q3: "07",
					Q4: "10"
				},
				[m] = d.exec(c);
			return c.replace(d, f[m])
		},
		l = c => {
			if (c) {
				if (typeof c == "string") {
					if (isQuarter(s)) return dayjs(a(c), s.replace(/\[Q]Q/, "MM"));
					if (dayjs(c, s).isValid()) return dayjs(c, s)
				}
				return dayjs(c)
			}
		};
	return isArray$2(o) ? o.map(l) : l(o)
}

function getDateValue$1(o) {
	const s = a => a ? a.toDate() : void 0;
	return isArray$2(o) ? o.map(s) : s(o)
}

function initializeDateLocale(o, s) {
	dayjs.locale({
		...dayjs.Ls[o.toLocaleLowerCase()],
		weekStart: s
	})
}

function pickDataAttributes(o) {
	const s = {};
	return o && Object.keys(o).forEach(a => {
		const l = String(a);
		l.indexOf("data-") === 0 && (s[l] = o[l]), l.indexOf("aria-") === 0 && (s[l] = o[l])
	}), s
}

function padStart(o, s, a = " ") {
	const l = String(o),
		c = l.length < s ? `${a}${l}` : l;
	return c.length < s ? padStart(c, s, a) : c
}
var Week = defineComponent({
	name: "Week",
	props: {
		mode: {
			type: String
		},
		dayStartOfWeek: {
			type: Number
		},
		isWeek: {
			type: Boolean
		},
		panel: {
			type: Boolean
		},
		value: {
			type: Object,
			required: !0
		},
		selectHandler: {
			type: Function
		},
		pageShowData: {
			type: Object,
			required: !0
		},
		pageData: {
			type: Array
		}
	},
	setup(o) {
		const {
			dayStartOfWeek: s,
			isWeek: a,
			panel: l,
			mode: c
		} = toRefs(o), d = getPrefixCls("calendar-week-list"), {
			t: f
		} = useI18n(), m = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
		return s.value === 0 ? m.unshift("sunday") : m.push("sunday"), a.value && m.unshift("self"), () =>
			createVNode("div", {
				class: d
			}, [m.map(g => createVNode("div", {
				class: `${d}-item`,
				key: g
			}, [f(`calendar.week.${l.value||c.value==="year"?"short":"long"}.${g}`)]))])
	}
});

function getDateValue(o, s) {
	if (o && isArray$2(o)) return o[s]
}

function useClassName({
	prefixCls: o,
	mergedValue: s,
	rangeValues: a,
	hoverRangeValues: l,
	panel: c,
	isSameTime: d,
	innerMode: f
}) {
	return function(g, v) {
		const y = getDateValue(a, 0),
			b = getDateValue(a, 1),
			C = getDateValue(l, 0),
			_ = getDateValue(l, 1),
			S = !g.isPrev && !g.isNext,
			w = S && c,
			T = w,
			A = w;
		C && y && C.isBefore(y);
		const M = b && _ && _.isAfter(b) && A;
		let D = d(g.time, getNow());
		return f === "year" && (D = getNow().isSame(g.time, "date")), [`${o}-cell`, {
			[`${o}-cell-in-view`]: S,
			[`${o}-cell-today`]: D,
			[`${o}-cell-selected`]: s && d(g.time, s),
			[`${o}-cell-range-start`]: T,
			[`${o}-cell-range-end`]: A,
			[`${o}-cell-in-range`]: w,
			[`${o}-cell-in-range-near-hover`]: M,
			[`${o}-cell-hover-range-start`]: w,
			[`${o}-cell-hover-range-end`]: w,
			[`${o}-cell-hover-in-range`]: w,
			[`${o}-cell-disabled`]: v
		}]
	}
}
const allDaysInOnePage = 6 * 7,
	getReturn = o => ({
		year: o.year(),
		month: o.month() + 1,
		date: o.date(),
		day: o.day(),
		time: o
	}),
	getTimeObj = o => ({
		start: getReturn(methods.startOf(o, "month")),
		end: getReturn(methods.endOf(o, "month")),
		days: o.daysInMonth()
	});

function getAllDaysByTime(o, {
	dayStartOfWeek: s = 0,
	isWeek: a
}) {
	const l = getTimeObj(o),
		c = Array(allDaysInOnePage).fill(null).map(() => ({})),
		d = s === 0 ? l.start.day : (l.start.day || 7) - 1;
	c[d] = {
		...l.start,
		isCurrent: !0
	};
	for (let m = 0; m < d; m++) c[d - m - 1] = {
		...getReturn(methods.subtract(l.start.time, m + 1, "day")),
		isPrev: !0
	};
	for (let m = 0; m < allDaysInOnePage - d - 1; m++) c[d + m + 1] = {
		...getReturn(methods.add(l.start.time, m + 1, "day")),
		isCurrent: m < l.days,
		isNext: m >= l.days - 1
	};
	const f = Array(6).fill(null).map(() => []);
	for (let m = 0; m < 6; m++)
		if (f[m] = c.slice(m * 7, 7 * (m + 1)), a) {
			const g = f[m][0].time,
				v = [...f[m]];
			f[m].unshift({
				weekRows: v,
				weekOfYear: g.week()
			})
		} return f
}
var Month = defineComponent({
	name: "Month",
	props: {
		cell: {
			type: Boolean
		},
		pageData: {
			type: Array
		},
		current: {
			type: Number
		},
		value: {
			type: Object,
			required: !0
		},
		selectHandler: {
			type: Function,
			required: !0
		},
		mode: {
			type: String
		},
		pageShowDate: {
			type: Object,
			required: !0
		},
		panel: {
			type: Boolean
		},
		dayStartOfWeek: {
			type: Number,
			required: !0
		},
		isWeek: {
			type: Boolean,
			required: !0
		}
	},
	setup(o, {
		slots: s
	}) {
		const {
			pageData: a
		} = toRefs(o), l = getPrefixCls("calendar"), c = o.pageShowDate.year(), d = computed(() =>
	useClassName({
			prefixCls: l,
			mergedValue: o.value,
			panel: !1,
			innerMode: o.mode,
			rangeValues: [],
			hoverRangeValues: [],
			isSameTime: (g, v) => g.isSame(v, "day")
		}));

		function f(g) {
			return g.map((v, y) => {
				var b;
				if (v.time) {
					const C = () => o.selectHandler(v.time, !1),
						_ = o.isWeek ? {
							onClick: C
						} : {},
						S = o.isWeek ? {} : {
							onClick: C
						};
					return createVNode("div", mergeProps({
						key: y,
						class: d.value(v, !1)
					}, _), [s.default ? (b = s.default) == null ? void 0 : b.call(s, {
						year: v.year,
						month: v.month,
						date: v.date
					}) : createVNode("div", mergeProps({
						class: `${l}-date`
					}, S), [createVNode("div", {
						class: `${l}-date-value`
					}, [o.panel ? v.date : createVNode("div", {
						class: `${l}-date-circle`
					}, [v.date])])])])
				}
				if ("weekOfYear" in v) {
					const C = o.value.year(),
						_ = o.value.month() + 1,
						S = o.value.week(),
						w = o.value && v.weekRows.find(T => T.year === C && T.month === _) && S === v
						.weekOfYear;
					return createVNode("div", {
						key: y,
						class: [`${l}-cell`, `${l}-cell-week`, {
							[`${l}-cell-selected-week`]: w,
							[`${l}-cell-in-range`]: w
						}]
					}, [createVNode("div", {
						class: `${l}-date`
					}, [createVNode("div", {
						class: `${l}-date-value`
					}, [v.weekOfYear])])])
				}
				return null
			})
		}
		let m = a.value;
		return typeof o.current == "number" && (m = getAllDaysByTime(dayjs(
			`${c}-${padStart(o.current+1,2,"0")}-01`), {
			dayStartOfWeek: o.dayStartOfWeek,
			isWeek: o.isWeek
		})), () => createVNode("div", {
			class: o.cell ? `${l}-month-cell` : `${l}-month`
		}, [createVNode(Week, {
			value: o.value,
			selectHandler: o.selectHandler,
			dayStartOfWeek: o.dayStartOfWeek,
			isWeek: o.isWeek,
			panel: o.panel,
			mode: o.mode,
			pageShowData: o.pageShowDate,
			pageData: o.pageData
		}, null), createVNode("div", {
			class: `${l}-month-cell-body`
		}, [m == null ? void 0 : m.map((g, v) => createVNode("div", {
			key: v,
			class: [`${l}-month-row`, {
				[`${l}-row-week`]: o.isWeek
			}]
		}, [f(g)]))])])
	}
});
const MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October",
		"November", "December"
	].map((o, s) => ({
		name: o,
		value: s
	})),
	monthGroup = Array(3);
for (let o = 0; o < 3; o++) monthGroup[o] = MONTHS.slice(o * 4, 4 * (o + 1));
const monthGroupPanel = Array(4);
for (let o = 0; o < 4; o++) monthGroupPanel[o] = MONTHS.slice(o * 3, 3 * (o + 1));
var Year = defineComponent({
	name: "Year",
	props: {
		mode: {
			type: String,
			required: !0
		},
		dayStartOfWeek: {
			type: Number,
			required: !0
		},
		value: {
			type: Object,
			required: !0
		},
		isWeek: {
			type: Boolean
		},
		panel: {
			type: Boolean,
			default: !1
		},
		pageShowData: {
			type: Object,
			required: !0
		},
		pageData: {
			type: Array
		},
		selectHandler: {
			type: Function,
			required: !0
		}
	},
	setup(o) {
		const s = getPrefixCls("calendar"),
			a = computed(() => useClassName({
				prefixCls: s,
				mergedValue: o.value,
				panel: !1,
				innerMode: o.mode,
				rangeValues: [],
				hoverRangeValues: [],
				isSameTime: (f, m) => f.isSame(m, "month")
			})),
			{
				t: l
			} = useI18n(),
			c = computed(() => o.pageShowData.year()),
			d = o.panel ? monthGroupPanel : monthGroup;
		return () => createVNode("div", {
			class: `${s}-year`
		}, [d.map((f, m) => createVNode("div", {
			class: `${s}-year-row`,
			key: m
		}, [f.map(g => {
			const v = dayjs(`${c.value}-${padStart(g.value+1,2,"0")}-01`),
				y = o.panel ? {
					onClick: () => o.selectHandler(v, !1)
				} : {};
			return createVNode("div", {
				key: g.value,
				class: a.value({
					...g,
					time: v
				}, !1)
			}, [o.panel ? createVNode("div", mergeProps({
				class: `${s}-date`
			}, y), [createVNode("div", {
				class: `${s}-date-value`
			}, [l(`calendar.month.short.${g.name}`)])]) : createVNode(
				"div", {
					class: `${s}-month-with-days`
				}, [createVNode("div", {
						class: `${s}-month-title`
					}, [l(`calendar.month.long.${g.name}`)]),
					createVNode(Month, {
						pageShowDate: o.pageShowData,
						pageData: o.pageData,
						dayStartOfWeek: o.dayStartOfWeek,
						selectHandler: o.selectHandler,
						isWeek: o.isWeek,
						cell: !0,
						current: g.value,
						value: o.value,
						mode: o.mode
					}, null)
				])])
		})]))])
	}
});
const useInput = ({
	defaultValue: o,
	modelValue: s,
	emit: a,
	eventName: l = "input",
	updateEventName: c = "update:modelValue",
	eventHandlers: d
}) => {
	var f;
	const m = ref(),
		g = ref((f = o == null ? void 0 : o.value) != null ? f : ""),
		v = ref(!1),
		y = ref(!1),
		b = ref("");
	let C;
	const _ = computed(() => {
			var R;
			return (R = s == null ? void 0 : s.value) != null ? R : g.value
		}),
		S = (R, O) => {
			g.value = R, a(c, R), a(l, R, O)
		},
		w = R => {
			const {
				value: O
			} = R.target;
			y.value || (S(O, R), nextTick(() => {
				m.value && _.value !== m.value.value && (m.value.value = _.value)
			}))
		},
		T = R => {
			l === "input" && _.value !== C && (C = _.value, a("change", _.value, R))
		},
		A = R => {
			var O;
			const {
				value: U
			} = R.target;
			R.type === "compositionend" ? (y.value = !1, b.value = "", S(U, R), nextTick(() => {
				m.value && _.value !== m.value.value && (m.value.value = _.value)
			})) : (y.value = !0, b.value = _.value + ((O = R.data) != null ? O : ""))
		},
		k = R => {
			var O, U;
			v.value = !0, C = _.value, a("focus", R), (U = (O = d == null ? void 0 : d.value) == null ? void 0 : O
				.onFocus) == null || U.call(O, R)
		},
		M = R => {
			var O, U;
			v.value = !1, a("blur", R), (U = (O = d == null ? void 0 : d.value) == null ? void 0 : O.onBlur) ==
				null || U.call(O, R), T(R)
		},
		D = R => {
			const O = R.key || R.code;
			!y.value && O === Enter.key && (a("pressEnter", R), T(R))
		},
		F = R => {
			m.value && R.target !== m.value && (R.preventDefault(), m.value.focus())
		};
	return watch(_, R => {
		m.value && R !== m.value.value && (m.value.value = R)
	}), {
		inputRef: m,
		_value: g,
		_focused: v,
		isComposition: y,
		compositionValue: b,
		computedValue: _,
		handleInput: w,
		handleComposition: A,
		handleFocus: k,
		handleBlur: M,
		handleKeyDown: D,
		handleMousedown: F
	}
};
var InputLabel = defineComponent({
	name: "InputLabel",
	inheritAttrs: !1,
	props: {
		modelValue: Object,
		inputValue: {
			type: String,
			default: ""
		},
		enabledInput: Boolean,
		formatLabel: Function,
		placeholder: String,
		retainInputValue: Boolean,
		disabled: Boolean,
		baseCls: String,
		size: String,
		error: Boolean,
		focused: Boolean,
		uninjectFormItemContext: Boolean
	},
	emits: ["update:inputValue", "inputValueChange", "focus", "blur"],
	setup(o, {
		attrs: s,
		emit: a,
		slots: l
	}) {
		var c;
		const {
			size: d,
			disabled: f,
			error: m,
			inputValue: g,
			uninjectFormItemContext: v
		} = toRefs(o), y = (c = o.baseCls) != null ? c : getPrefixCls("input-label"), {
			mergedSize: b,
			mergedDisabled: C,
			mergedError: _,
			eventHandlers: S
		} = useFormItem({
			size: d,
			disabled: f,
			error: m,
			uninject: v == null ? void 0 : v.value
		}), {
			mergedSize: w
		} = useSize$1(b), {
			inputRef: T,
			_focused: A,
			computedValue: k,
			handleInput: M,
			handleComposition: D,
			handleFocus: F,
			handleBlur: R,
			handleMousedown: O
		} = useInput({
			modelValue: g,
			emit: a,
			eventName: "inputValueChange",
			updateEventName: "update:inputValue",
			eventHandlers: S
		}), U = computed(() => {
			var fe;
			return (fe = o.focused) != null ? fe : A.value
		}), V = computed(() => o.enabledInput && A.value || !o.modelValue), z = () => {
			var fe, q;
			return o.modelValue ? (q = (fe = o.formatLabel) == null ? void 0 : fe.call(o, o.modelValue)) !=
				null ? q : o.modelValue.label : ""
		}, j = computed(() => o.enabledInput && o.modelValue ? z() : o.placeholder), ge = () => {
			var fe, q;
			return o.modelValue ? (q = (fe = l.default) == null ? void 0 : fe.call(l, {
				data: o.modelValue
			})) != null ? q : z() : null
		}, me = computed(() => [y, `${y}-size-${w.value}`, {
			[`${y}-search`]: o.enabledInput,
			[`${y}-focus`]: U.value,
			[`${y}-disabled`]: C.value,
			[`${y}-error`]: _.value
		}]), he = computed(() => omit(s, INPUT_EVENTS)), ce = computed(() => pick(s, INPUT_EVENTS));
		return {
			inputRef: T,
			render: () => createVNode("span", mergeProps(he.value, {
				class: me.value,
				title: z(),
				onMousedown: O
			}), [l.prefix && createVNode("span", {
				class: `${y}-prefix`
			}, [l.prefix()]), createVNode("input", mergeProps(ce.value, {
				ref: T,
				class: [`${y}-input`, {
					[`${y}-input-hidden`]: !V.value
				}],
				value: k.value,
				readonly: !o.enabledInput,
				placeholder: j.value,
				disabled: C.value,
				onInput: M,
				onFocus: F,
				onBlur: R,
				onCompositionstart: D,
				onCompositionupdate: D,
				onCompositionend: D
			}), null), createVNode("span", {
				class: [`${y}-value`, {
					[`${y}-value-hidden`]: V.value
				}]
			}, [ge()]), l.suffix && createVNode("span", {
				class: `${y}-suffix`
			}, [l.suffix()])])
		}
	},
	methods: {
		focus() {
			var o;
			(o = this.inputRef) == null || o.focus()
		},
		blur() {
			var o;
			(o = this.inputRef) == null || o.blur()
		}
	},
	render() {
		return this.render()
	}
});
const getValueData = (o, s) => {
		const a = [];
		for (const l of o)
			if (isObject$2(l)) a.push({
				raw: l,
				value: l[s.value],
				label: l[s.label],
				closable: l[s.closable],
				tagProps: l[s.tagProps]
			});
			else if (o || isNumber$2(o)) {
			const c = {
				value: l,
				label: String(l),
				closable: !0
			};
			a.push({
				raw: c,
				...c
			})
		}
		return a
	},
	TAG_COLORS = ["red", "orangered", "orange", "gold", "lime", "green", "cyan", "blue", "arcoblue", "purple",
		"pinkpurple", "magenta", "gray"
	],
	_sfc_main$2F = defineComponent({
		name: "Tag",
		components: {
			IconHover,
			IconClose,
			IconLoading
		},
		props: {
			color: {
				type: String
			},
			size: {
				type: String
			},
			bordered: {
				type: Boolean,
				default: !1
			},
			visible: {
				type: Boolean,
				default: void 0
			},
			defaultVisible: {
				type: Boolean,
				default: !0
			},
			loading: {
				type: Boolean,
				default: !1
			},
			closable: {
				type: Boolean,
				default: !1
			},
			checkable: {
				type: Boolean,
				default: !1
			},
			checked: {
				type: Boolean,
				default: void 0
			},
			defaultChecked: {
				type: Boolean,
				default: !0
			},
			nowrap: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:visible": o => !0,
			"update:checked": o => !0,
			close: o => !0,
			check: (o, s) => !0
		},
		setup(o, {
			emit: s
		}) {
			const {
				size: a
			} = toRefs(o), l = getPrefixCls("tag"), c = computed(() => o.color && TAG_COLORS.includes(o.color)), d =
				computed(() => o.color && !TAG_COLORS.includes(o.color)), f = ref(o.defaultVisible), m = ref(o
					.defaultChecked), g = computed(() => {
					var T;
					return (T = o.visible) != null ? T : f.value
				}), v = computed(() => {
					var T;
					return o.checkable ? (T = o.checked) != null ? T : m.value : !0
				}), {
					mergedSize: y
				} = useSize$1(a), b = computed(() => y.value === "mini" ? "small" : y.value), C = T => {
					f.value = !1, s("update:visible", !1), s("close", T)
				}, _ = T => {
					if (o.checkable) {
						const A = !v.value;
						m.value = A, s("update:checked", A), s("check", A, T)
					}
				}, S = computed(() => [l, `${l}-size-${b.value}`, {
					[`${l}-loading`]: o.loading,
					[`${l}-hide`]: !g.value,
					[`${l}-${o.color}`]: c.value,
					[`${l}-bordered`]: o.bordered,
					[`${l}-checkable`]: o.checkable,
					[`${l}-checked`]: v.value,
					[`${l}-custom-color`]: d.value
				}]), w = computed(() => {
					if (d.value) return {
						backgroundColor: o.color
					}
				});
			return {
				prefixCls: l,
				cls: S,
				style: w,
				computedVisible: g,
				computedChecked: v,
				handleClick: _,
				handleClose: C
			}
		}
	});

function _sfc_render$2n(o, s, a, l, c, d) {
	const f = resolveComponent("icon-close"),
		m = resolveComponent("icon-hover"),
		g = resolveComponent("icon-loading");
	return o.computedVisible ? (openBlock(), createElementBlock("span", {
		key: 0,
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.style),
		onClick: s[0] || (s[0] = (...v) => o.handleClick && o.handleClick(...v))
	}, [o.$slots.icon ? (openBlock(), createElementBlock("span", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-icon`)
	}, [renderSlot(o.$slots, "icon")], 2)) : createCommentVNode("v-if", !0), o.nowrap ? (openBlock(),
		createElementBlock("span", {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-text`)
		}, [renderSlot(o.$slots, "default")], 2)) : renderSlot(o.$slots, "default", {
		key: 2
	}), o.closable ? (openBlock(), createBlock(m, {
		key: 3,
		role: "button",
		"aria-label": "Close",
		prefix: o.prefixCls,
		class: normalizeClass(`${o.prefixCls}-close-btn`),
		onClick: withModifiers(o.handleClose, ["stop"])
	}, {
		default: withCtx(() => [renderSlot(o.$slots, "close-icon", {}, () => [createVNode(
			f)])]),
		_: 3
	}, 8, ["prefix", "class", "onClick"])) : createCommentVNode("v-if", !0), o.loading ? (openBlock(),
		createElementBlock("span", {
			key: 4,
			class: normalizeClass(`${o.prefixCls}-loading-icon`)
		}, [createVNode(g)], 2)) : createCommentVNode("v-if", !0)], 6)) : createCommentVNode("v-if", !0)
}
var _Tag = _export_sfc$1(_sfc_main$2F, [
	["render", _sfc_render$2n]
]);
const Tag = Object.assign(_Tag, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Tag.name, _Tag)
		}
	}),
	DEFAULT_FIELD_NAMES$1 = {
		value: "value",
		label: "label",
		closable: "closable",
		tagProps: "tagProps"
	};
var _InputTag = defineComponent({
	name: "InputTag",
	inheritAttrs: !1,
	props: {
		modelValue: {
			type: Array
		},
		defaultValue: {
			type: Array,
			default: () => []
		},
		inputValue: String,
		defaultInputValue: {
			type: String,
			default: ""
		},
		placeholder: String,
		disabled: {
			type: Boolean,
			default: !1
		},
		error: {
			type: Boolean,
			default: !1
		},
		readonly: {
			type: Boolean,
			default: !1
		},
		allowClear: {
			type: Boolean,
			default: !1
		},
		size: {
			type: String
		},
		maxTagCount: {
			type: Number,
			default: 0
		},
		retainInputValue: {
			type: [Boolean, Object],
			default: !1
		},
		formatTag: {
			type: Function
		},
		uniqueValue: {
			type: Boolean,
			default: !1
		},
		fieldNames: {
			type: Object
		},
		tagNowrap: {
			type: Boolean,
			default: !1
		},
		baseCls: String,
		focused: Boolean,
		disabledInput: Boolean,
		uninjectFormItemContext: Boolean
	},
	emits: {
		"update:modelValue": o => !0,
		"update:inputValue": o => !0,
		change: (o, s) => !0,
		inputValueChange: (o, s) => !0,
		pressEnter: (o, s) => !0,
		remove: (o, s) => !0,
		clear: o => !0,
		focus: o => !0,
		blur: o => !0
	},
	setup(o, {
		emit: s,
		slots: a,
		attrs: l
	}) {
		const {
			size: c,
			disabled: d,
			error: f,
			uninjectFormItemContext: m,
			modelValue: g
		} = toRefs(o), v = o.baseCls || getPrefixCls("input-tag"), y = ref(), b = ref(), {
				mergedSize: C,
				mergedDisabled: _,
				mergedError: S,
				feedback: w,
				eventHandlers: T
			} = useFormItem({
				size: c,
				disabled: d,
				error: f,
				uninject: m == null ? void 0 : m.value
			}), {
				mergedSize: A
			} = useSize$1(C), k = computed(() => ({
				...DEFAULT_FIELD_NAMES$1,
				...o.fieldNames
			})), M = ref(!1), D = ref(o.defaultValue), F = ref(o.defaultInputValue), R = ref(!1), O = ref(""),
			U = computed(() => isObject$2(o.retainInputValue) ? {
				create: !1,
				blur: !1,
				...o.retainInputValue
			} : {
				create: o.retainInputValue,
				blur: o.retainInputValue
			}), V = reactive({
				width: "12px"
			}), z = computed(() => o.focused || M.value), j = (ye, Le) => {
				F.value = ye, s("update:inputValue", ye), s("inputValueChange", ye, Le)
			}, ge = ye => {
				var Le;
				const {
					value: Ue
				} = ye.target;
				ye.type === "compositionend" ? (R.value = !1, O.value = "", j(Ue, ye), nextTick(() => {
					y.value && he.value !== y.value.value && (y.value.value = he.value)
				})) : (R.value = !0, O.value = he.value + ((Le = ye.data) != null ? Le : ""))
			}, me = computed(() => {
				var ye;
				return (ye = o.modelValue) != null ? ye : D.value
			}), he = computed(() => {
				var ye;
				return (ye = o.inputValue) != null ? ye : F.value
			});
		watch(g, ye => {
			(isUndefined$1(ye) || isNull$1(ye)) && (D.value = [])
		});
		const ce = ye => {
				y.value && ye.target !== y.value && (ye.preventDefault(), y.value.focus())
			},
			ae = ye => {
				const {
					value: Le
				} = ye.target;
				R.value || (j(Le, ye), nextTick(() => {
					y.value && he.value !== y.value.value && (y.value.value = he.value)
				}))
			},
			fe = computed(() => getValueData(me.value, k.value)),
			q = computed(() => {
				if (o.maxTagCount > 0) {
					const ye = fe.value.length - o.maxTagCount;
					if (ye > 0) {
						const Le = fe.value.slice(0, o.maxTagCount),
							Ue = {
								value: "__arco__more",
								label: `+${ye}...`,
								closable: !1
							};
						return Le.push({
							raw: Ue,
							...Ue
						}), Le
					}
				}
				return fe.value
			}),
			le = (ye, Le) => {
				var Ue, nt;
				D.value = ye, s("update:modelValue", ye), s("change", ye, Le), (nt = (Ue = T.value) == null ?
					void 0 : Ue.onChange) == null || nt.call(Ue, Le)
			},
			de = (ye, Le, Ue) => {
				var nt;
				const ot = (nt = me.value) == null ? void 0 : nt.filter((at, Je) => Je !== Le);
				le(ot, Ue), s("remove", ye, Ue)
			},
			_e = ye => {
				le([], ye), s("clear", ye)
			},
			ke = computed(() => !_.value && !o.readonly && o.allowClear && !!me.value.length),
			De = ye => {
				var Le;
				if (he.value) {
					if (ye.preventDefault(), o.uniqueValue && ((Le = me.value) != null && Le.includes(he
						.value))) {
						s("pressEnter", he.value, ye);
						return
					}
					const Ue = me.value.concat(he.value);
					le(Ue, ye), s("pressEnter", he.value, ye), U.value.create || j("", ye)
				}
			},
			Se = ye => {
				var Le, Ue;
				M.value = !0, s("focus", ye), (Ue = (Le = T.value) == null ? void 0 : Le.onFocus) == null || Ue
					.call(Le, ye)
			},
			be = ye => {
				var Le, Ue;
				M.value = !1, !U.value.blur && he.value && j("", ye), s("blur", ye), (Ue = (Le = T.value) ==
					null ? void 0 : Le.onBlur) == null || Ue.call(Le, ye)
			},
			Me = () => {
				for (let ye = fe.value.length - 1; ye >= 0; ye--)
					if (fe.value[ye].closable) return ye;
				return -1
			},
			Ve = ye => {
				if (_.value || o.readonly) return;
				const Le = ye.key || ye.code;
				if (!R.value && he.value && Le === Enter.key && De(ye), !R.value && q.value.length > 0 && !he
					.value && Le === Backspace.key) {
					const Ue = Me();
					Ue >= 0 && de(fe.value[Ue].value, Ue, ye)
				}
			},
			it = ye => {
				ye > 12 ? V.width = `${ye}px` : V.width = "12px"
			};
		onMounted(() => {
			b.value && it(b.value.offsetWidth)
		});
		const pt = () => {
			b.value && it(b.value.offsetWidth)
		};
		watch(he, ye => {
			y.value && !R.value && ye !== y.value.value && (y.value.value = ye)
		});
		const dt = computed(() => [v, `${v}-size-${A.value}`, {
				[`${v}-disabled`]: _.value,
				[`${v}-disabled-input`]: o.disabledInput,
				[`${v}-error`]: S.value,
				[`${v}-focus`]: z.value,
				[`${v}-readonly`]: o.readonly,
				[`${v}-has-tag`]: q.value.length > 0,
				[`${v}-has-prefix`]: !!a.prefix,
				[`${v}-has-suffix`]: !!a.suffix || ke.value || w.value,
				[`${v}-has-placeholder`]: !me.value.length
			}]),
			He = computed(() => omit(l, INPUT_EVENTS)),
			Ae = computed(() => pick(l, INPUT_EVENTS));
		return {
			inputRef: y,
			render: () => {
				var ye;
				return createVNode("span", mergeProps({
					class: dt.value,
					onMousedown: ce
				}, He.value), [createVNode(ResizeObserver$2, {
					onResize: pt
				}, {
					default: () => [createVNode("span", {
						ref: b,
						class: `${v}-mirror`
					}, [q.value.length > 0 ? O.value || he.value : O.value || he
						.value || o.placeholder
					])]
				}), a.prefix && createVNode("span", {
					class: `${v}-prefix`
				}, [a.prefix()]), createVNode(TransitionGroup, {
					tag: "span",
					name: "input-tag-zoom",
					class: [`${v}-inner`, {
						[`${v}-nowrap`]: o.tagNowrap
					}]
				}, {
					default: () => [q.value.map((Le, Ue) => createVNode(Tag, mergeProps({
						key: `tag-${Le.value}`,
						class: `${v}-tag`,
						closable: !_.value && !o.readonly && Le
							.closable,
						visible: !0,
						nowrap: o.tagNowrap
					}, Le.tagProps, {
						onClose: nt => de(Le.value, Ue, nt)
					}), {
						default: () => {
							var nt, ot, at, Je;
							return [(Je = (at = (nt = a.tag) == null ?
										void 0 : nt.call(a, {
											data: Le.raw
										})) != null ? at : (ot = o
										.formatTag) == null ?
									void 0 : ot.call(o, Le.raw)) !=
								null ? Je : Le.label
							]
						}
					})), createVNode("input", mergeProps(Ae.value, {
						ref: y,
						key: "input-tag-input",
						class: `${v}-input`,
						style: V,
						placeholder: q.value.length === 0 ? o.placeholder :
							void 0,
						disabled: _.value,
						readonly: o.readonly || o.disabledInput,
						onInput: ae,
						onKeydown: Ve,
						onFocus: Se,
						onBlur: be,
						onCompositionstart: ge,
						onCompositionupdate: ge,
						onCompositionend: ge
					}), null)]
				}), ke.value && createVNode(IconHover, {
					class: `${v}-clear-btn`,
					onClick: _e,
					onMousedown: Le => Le.stopPropagation()
				}, {
					default: () => [createVNode(IconClose, null, null)]
				}), (a.suffix || !!w.value) && createVNode("span", {
					class: `${v}-suffix`
				}, [(ye = a.suffix) == null ? void 0 : ye.call(a), !!w.value && createVNode(
					FeedbackIcon, {
						type: w.value
					}, null)])])
			}
		}
	},
	methods: {
		focus() {
			var o;
			(o = this.inputRef) == null || o.focus()
		},
		blur() {
			var o;
			(o = this.inputRef) == null || o.blur()
		}
	},
	render() {
		return this.render()
	}
});
const InputTag = Object.assign(_InputTag, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _InputTag.name, _InputTag)
	}
});
var SelectView = defineComponent({
	name: "SelectView",
	props: {
		modelValue: {
			type: Array,
			required: !0
		},
		inputValue: String,
		placeholder: String,
		disabled: {
			type: Boolean,
			default: !1
		},
		error: {
			type: Boolean,
			default: !1
		},
		loading: {
			type: Boolean,
			default: !1
		},
		opened: {
			type: Boolean,
			default: !1
		},
		size: {
			type: String
		},
		bordered: {
			type: Boolean,
			default: !0
		},
		multiple: {
			type: Boolean,
			default: !1
		},
		allowClear: {
			type: Boolean,
			default: !1
		},
		allowCreate: {
			type: Boolean,
			default: !1
		},
		allowSearch: {
			type: Boolean,
			default: o => isArray$2(o.modelValue)
		},
		maxTagCount: {
			type: Number,
			default: 0
		},
		tagNowrap: {
			type: Boolean,
			default: !1
		},
		retainInputValue: {
			type: Boolean,
			default: !1
		}
	},
	emits: ["remove", "clear", "focus", "blur"],
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			size: l,
			disabled: c,
			error: d
		} = toRefs(o), f = getPrefixCls("select-view"), {
			feedback: m,
			eventHandlers: g,
			mergedDisabled: v,
			mergedSize: y,
			mergedError: b
		} = useFormItem({
			size: l,
			disabled: c,
			error: d
		}), {
			mergedSize: C
		} = useSize$1(y), {
			opened: _
		} = toRefs(o), S = ref(), w = computed(() => {
			var j;
			return (j = S.value) == null ? void 0 : j.inputRef
		}), T = computed(() => o.modelValue.length === 0), A = computed(() => o.allowSearch || o
			.allowCreate), k = computed(() => o.allowClear && !o.disabled && !T.value), M = j => {
			var ge, me;
			s("focus", j), (me = (ge = g.value) == null ? void 0 : ge.onFocus) == null || me.call(ge, j)
		}, D = j => {
			var ge, me;
			s("blur", j), (me = (ge = g.value) == null ? void 0 : ge.onBlur) == null || me.call(ge, j)
		}, F = j => {
			s("remove", j)
		}, R = j => {
			s("clear", j)
		}, O = () => {
			var j, ge, me, he;
			return o.loading ? (ge = (j = a["loading-icon"]) == null ? void 0 : j.call(a)) != null ? ge :
				createVNode(IconLoading, null, null) : o.allowSearch && o.opened ? (he = (me = a[
					"search-icon"]) == null ? void 0 : me.call(a)) != null ? he : createVNode(IconSearch,
					null, null) : a["arrow-icon"] ? a["arrow-icon"]() : createVNode(IconDown, {
					class: `${f}-arrow-icon`
				}, null)
		}, U = () => createVNode(Fragment, null, [k.value && createVNode(IconHover, {
			class: `${f}-clear-btn`,
			onClick: R,
			onMousedown: j => j.stopPropagation()
		}, {
			default: () => [createVNode(IconClose, null, null)]
		}), createVNode("span", {
			class: `${f}-icon`
		}, [O()]), !!m.value && createVNode(FeedbackIcon, {
			type: m.value
		}, null)]);
		watch(_, j => {
			!j && w.value && w.value.isSameNode(document.activeElement) && w.value.blur()
		});
		const V = computed(() => [`${f}-${o.multiple?"multiple":"single"}`, {
			[`${f}-opened`]: o.opened,
			[`${f}-borderless`]: !o.bordered
		}]);
		return {
			inputRef: w,
			handleFocus: M,
			handleBlur: D,
			render: () => o.multiple ? createVNode(InputTag, {
				ref: S,
				baseCls: f,
				class: V.value,
				modelValue: o.modelValue,
				inputValue: o.inputValue,
				focused: o.opened,
				placeholder: o.placeholder,
				disabled: v.value,
				size: C.value,
				error: b.value,
				maxTagCount: o.maxTagCount,
				disabledInput: !o.allowSearch && !o.allowCreate,
				tagNowrap: o.tagNowrap,
				retainInputValue: !0,
				uninjectFormItemContext: !0,
				onRemove: F,
				onFocus: M,
				onBlur: D
			}, {
				prefix: a.prefix,
				suffix: U,
				tag: a.label
			}) : createVNode(InputLabel, {
				ref: S,
				baseCls: f,
				class: V.value,
				modelValue: o.modelValue[0],
				inputValue: o.inputValue,
				focused: o.opened,
				placeholder: o.placeholder,
				disabled: v.value,
				size: C.value,
				error: b.value,
				enabledInput: A.value,
				uninjectFormItemContext: !0,
				onFocus: M,
				onBlur: D
			}, {
				default: a.label,
				prefix: a.prefix,
				suffix: U
			})
		}
	},
	methods: {
		focus() {
			this.inputRef && this.inputRef.focus()
		},
		blur() {
			this.inputRef && this.inputRef.blur()
		}
	},
	render() {
		return this.render()
	}
});
const _sfc_main$2E = defineComponent({
	name: "Optgroup",
	props: {
		label: {
			type: String
		}
	},
	setup() {
		return {
			prefixCls: getPrefixCls("select-group")
		}
	}
});

function _sfc_render$2m(o, s, a, l, c, d) {
	return openBlock(), createElementBlock(Fragment, null, [createBaseVNode("li", {
			class: normalizeClass(`${o.prefixCls}-title`)
		}, [renderSlot(o.$slots, "label", {}, () => [createTextVNode(toDisplayString(o.label), 1)])], 2),
		renderSlot(o.$slots, "default")
	], 64)
}
var Optgroup = _export_sfc$1(_sfc_main$2E, [
	["render", _sfc_render$2m]
]);
const target = typeof window > "u" ? global : window;

function debounce$1(o, s) {
	let a = 0;
	return (...l) => {
		a && target.clearTimeout(a), a = target.setTimeout(() => {
			a = 0, o(...l)
		}, s)
	}
}

function _isSlot$g(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
const DEFAULT_FIELD_NAMES = {
	value: "value",
	label: "label",
	disabled: "disabled",
	tagProps: "tagProps",
	render: "render"
};
var _Select = defineComponent({
	name: "Select",
	components: {
		Trigger,
		SelectView
	},
	inheritAttrs: !1,
	props: {
		multiple: {
			type: Boolean,
			default: !1
		},
		modelValue: {
			type: [String, Number, Boolean, Object, Array],
			default: void 0
		},
		defaultValue: {
			type: [String, Number, Boolean, Object, Array],
			default: o => isUndefined$1(o.multiple) ? "" : []
		},
		inputValue: {
			type: String
		},
		defaultInputValue: {
			type: String,
			default: ""
		},
		size: {
			type: String
		},
		placeholder: String,
		loading: {
			type: Boolean,
			default: !1
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		error: {
			type: Boolean,
			default: !1
		},
		allowClear: {
			type: Boolean,
			default: !1
		},
		allowSearch: {
			type: [Boolean, Object],
			default: o => !!o.multiple
		},
		allowCreate: {
			type: Boolean,
			default: !1
		},
		maxTagCount: {
			type: Number,
			default: 0
		},
		popupContainer: {
			type: [String, Object]
		},
		bordered: {
			type: Boolean,
			default: !0
		},
		defaultActiveFirstOption: {
			type: Boolean,
			default: !0
		},
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean,
			default: !1
		},
		unmountOnClose: {
			type: Boolean,
			default: !1
		},
		filterOption: {
			type: [Boolean, Function],
			default: !0
		},
		options: {
			type: Array,
			default: () => []
		},
		virtualListProps: {
			type: Object
		},
		triggerProps: {
			type: Object
		},
		formatLabel: {
			type: Function
		},
		fallbackOption: {
			type: [Boolean, Function],
			default: !0
		},
		showExtraOptions: {
			type: Boolean,
			default: !0
		},
		valueKey: {
			type: String,
			default: "value"
		},
		searchDelay: {
			type: Number,
			default: 500
		},
		limit: {
			type: Number,
			default: 0
		},
		fieldNames: {
			type: Object
		},
		scrollbar: {
			type: [Boolean, Object],
			default: !0
		},
		showHeaderOnEmpty: {
			type: Boolean,
			default: !1
		},
		showFooterOnEmpty: {
			type: Boolean,
			default: !1
		},
		tagNowrap: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		"update:modelValue": o => !0,
		"update:inputValue": o => !0,
		"update:popupVisible": o => !0,
		change: o => !0,
		inputValueChange: o => !0,
		popupVisibleChange: o => !0,
		clear: o => !0,
		remove: o => !0,
		search: o => !0,
		dropdownScroll: o => !0,
		dropdownReachBottom: o => !0,
		exceedLimit: (o, s) => !0
	},
	setup(o, {
		slots: s,
		emit: a,
		attrs: l
	}) {
		const {
			size: c,
			disabled: d,
			error: f,
			options: m,
			filterOption: g,
			valueKey: v,
			multiple: y,
			popupVisible: b,
			defaultPopupVisible: C,
			showExtraOptions: _,
			modelValue: S,
			fieldNames: w,
			loading: T,
			defaultActiveFirstOption: A
		} = toRefs(o), k = getPrefixCls("select"), {
			mergedSize: M,
			mergedDisabled: D,
			mergedError: F,
			eventHandlers: R
		} = useFormItem({
			size: c,
			disabled: d,
			error: f
		}), O = computed(() => o.virtualListProps ? "div" : "li"), U = computed(() => isObject$2(o
			.allowSearch) && !!o.allowSearch.retainInputValue);
		computed(() => {
			if (isFunction$2(o.formatLabel)) return ze => {
				const Oe = ot.get(ze.value);
				return o.formatLabel(Oe)
			}
		});
		const V = ref(),
			z = ref({}),
			j = ref(),
			{
				computedPopupVisible: ge,
				handlePopupVisibleChange: me
			} = useTrigger({
				popupVisible: b,
				defaultPopupVisible: C,
				emit: a
			}),
			he = ref(o.defaultValue),
			ce = computed(() => {
				var ze;
				const Oe = (ze = o.modelValue) != null ? ze : he.value;
				return (isArray$2(Oe) ? Oe : Oe || isNumber$2(Oe) || isString$2(Oe) || isBoolean$2(Oe) ? [
					Oe] : []).map(rt => ({
					value: rt,
					key: getKeyFromValue(rt, o.valueKey)
				}))
			});
		watch(S, ze => {
			(isUndefined$1(ze) || isNull$1(ze)) && (he.value = y.value ? [] : ze)
		});
		const ae = computed(() => ce.value.map(ze => ze.key)),
			fe = computed(() => ({
				...DEFAULT_FIELD_NAMES,
				...w == null ? void 0 : w.value
			})),
			q = ref(),
			le = ze => {
				const Oe = {};
				return ze.forEach(Xe => {
					Oe[Xe] = ot.get(Xe)
				}), Oe
			},
			de = ze => {
				q.value = le(ze)
			},
			_e = ze => isFunction$2(o.fallbackOption) ? o.fallbackOption(ze) : {
				[fe.value.value]: ze,
				[fe.value.label]: String(isObject$2(ze) ? ze[v == null ? void 0 : v.value] : ze)
			},
			ke = () => {
				const ze = [],
					Oe = [];
				if (o.allowCreate || o.fallbackOption) {
					for (const Xe of ce.value)
						if (!Oe.includes(Xe.key) && Xe.value !== "") {
							const rt = ot.get(Xe.key);
							(!rt || rt.origin === "extraOptions") && (ze.push(Xe), Oe.push(Xe.key))
						}
				}
				if (o.allowCreate && Me.value) {
					const Xe = getKeyFromValue(Me.value);
					if (!Oe.includes(Xe)) {
						const rt = ot.get(Xe);
						(!rt || rt.origin === "extraOptions") && ze.push({
							value: Me.value,
							key: Xe
						})
					}
				}
				return ze
			},
			De = ref([]),
			Se = computed(() => De.value.map(ze => {
				var Oe;
				let Xe = _e(ze.value);
				const rt = (Oe = q.value) == null ? void 0 : Oe[ze.key];
				return !isUndefined$1(rt) && !isEmptyObject$1(rt) && (Xe = {
					...Xe,
					...rt
				}), Xe
			}));
		nextTick(() => {
			watchEffect(() => {
				var ze;
				const Oe = ke();
				if (Oe.length !== De.value.length) De.value = Oe;
				else if (Oe.length > 0) {
					for (let Xe = 0; Xe < Oe.length; Xe++)
						if (Oe[Xe].key !== ((ze = De.value[Xe]) == null ? void 0 : ze.key)) {
							De.value = Oe;
							break
						}
				}
			})
		});
		const be = ref(""),
			Me = computed(() => {
				var ze;
				return (ze = o.inputValue) != null ? ze : be.value
			});
		watch(ge, ze => {
			!ze && !U.value && Me.value && pt("")
		});
		const Ve = ze => {
				var Oe, Xe;
				return o.multiple ? ze.map(rt => {
						var ut, gt;
						return (gt = (ut = ot.get(rt)) == null ? void 0 : ut.value) != null ? gt : ""
					}) : (Xe = (Oe = ot.get(ze[0])) == null ? void 0 : Oe.value) != null ? Xe :
					hasEmptyStringKey(ot) ? void 0 : ""
			},
			it = ze => {
				var Oe, Xe;
				const rt = Ve(ze);
				he.value = rt, a("update:modelValue", rt), a("change", rt), (Xe = (Oe = R.value) == null ?
					void 0 : Oe.onChange) == null || Xe.call(Oe), de(ze)
			},
			pt = ze => {
				be.value = ze, a("update:inputValue", ze), a("inputValueChange", ze)
			},
			dt = (ze, Oe) => {
				if (o.multiple) {
					if (ae.value.includes(ze)) {
						const Xe = ae.value.filter(rt => rt !== ze);
						it(Xe)
					} else if (Je.value.includes(ze))
						if (o.limit > 0 && ae.value.length >= o.limit) {
							const Xe = ot.get(ze);
							a("exceedLimit", Xe == null ? void 0 : Xe.value, Oe)
						} else {
							const Xe = ae.value.concat(ze);
							it(Xe)
						} U.value || pt("")
				} else {
					if (ze !== ae.value[0] && it([ze]), U.value) {
						const Xe = ot.get(ze);
						Xe && pt(Xe.label)
					}
					me(!1)
				}
			},
			He = debounce$1(ze => {
				a("search", ze)
			}, o.searchDelay),
			Ae = ze => {
				ze !== Me.value && (ge.value || me(!0), pt(ze), o.allowSearch && He(ze))
			},
			xe = ze => {
				const Oe = ot.get(ze),
					Xe = ae.value.filter(rt => rt !== ze);
				it(Xe), a("remove", Oe == null ? void 0 : Oe.value)
			},
			ye = ze => {
				ze == null || ze.stopPropagation();
				const Oe = ae.value.filter(Xe => {
					var rt;
					return (rt = ot.get(Xe)) == null ? void 0 : rt.disabled
				});
				it(Oe), pt(""), a("clear", ze)
			},
			Le = ze => {
				a("dropdownScroll", ze)
			},
			Ue = ze => {
				a("dropdownReachBottom", ze)
			},
			{
				validOptions: nt,
				optionInfoMap: ot,
				validOptionInfos: at,
				enabledOptionKeys: Je,
				handleKeyDown: Ne
			} = useSelect({
				multiple: y,
				options: m,
				extraOptions: Se,
				inputValue: Me,
				filterOption: g,
				showExtraOptions: _,
				component: O,
				valueKey: v,
				fieldNames: w,
				loading: T,
				popupVisible: ge,
				valueKeys: ae,
				dropdownRef: V,
				optionRefs: z,
				virtualListRef: j,
				defaultActiveFirstOption: A,
				onSelect: dt,
				onPopupVisibleChange: me
			}),
			we = computed(() => {
				var ze;
				const Oe = [];
				for (const Xe of ce.value) {
					const rt = ot.get(Xe.key);
					rt && Oe.push({
						...rt,
						value: Xe.key,
						label: (ze = rt == null ? void 0 : rt.label) != null ? ze : String(
							isObject$2(Xe.value) ? Xe.value[v == null ? void 0 : v.value] : Xe
							.value),
						closable: !(rt != null && rt.disabled),
						tagProps: rt == null ? void 0 : rt.tagProps
					})
				}
				return Oe
			}),
			Ce = ze => {
				if (isFunction$2(s.option)) {
					const Oe = s.option;
					return () => Oe({
						data: ze.raw
					})
				}
				return isFunction$2(ze.render) ? ze.render : () => ze.label
			},
			$e = ze => {
				if (isGroupOptionInfo(ze)) {
					let Oe;
					return createVNode(Optgroup, {
						key: ze.key,
						label: ze.label
					}, _isSlot$g(Oe = ze.options.map(Xe => $e(Xe))) ? Oe : {
						default: () => [Oe]
					})
				}
				return isValidOption(ze, {
					inputValue: Me.value,
					filterOption: g == null ? void 0 : g.value
				}) ? createVNode(Option, {
					ref: Oe => {
						Oe != null && Oe.$el && (z.value[ze.key] = Oe.$el)
					},
					key: ze.key,
					value: ze.value,
					label: ze.label,
					disabled: ze.disabled,
					internal: !0
				}, {
					default: Ce(ze)
				}) : null
			},
			Fe = () => createVNode(SelectDropdown, {
				ref: V,
				loading: o.loading,
				empty: at.value.length === 0,
				virtualList: !!o.virtualListProps,
				scrollbar: o.scrollbar,
				showHeaderOnEmpty: o.showHeaderOnEmpty,
				showFooterOnEmpty: o.showFooterOnEmpty,
				onScroll: Le,
				onReachBottom: Ue
			}, {
				default: () => {
					var ze, Oe;
					return [...(Oe = (ze = s.default) == null ? void 0 : ze.call(s)) != null ? Oe : [],
						...nt.value.map($e)
					]
				},
				"virtual-list": () => createVNode(VirtualList, mergeProps(o.virtualListProps, {
					ref: j,
					data: nt.value
				}), {
					item: ({
						item: ze
					}) => $e(ze)
				}),
				empty: s.empty,
				header: s.header,
				footer: s.footer
			}),
			Ge = ({
				data: ze
			}) => {
				var Oe, Xe, rt, ut;
				if ((s.label || isFunction$2(o.formatLabel)) && ze) {
					const gt = ot.get(ze.value);
					if (gt != null && gt.raw) return (rt = (Oe = s.label) == null ? void 0 : Oe.call(s, {
						data: gt.raw
					})) != null ? rt : (Xe = o.formatLabel) == null ? void 0 : Xe.call(o, gt.raw)
				}
				return (ut = ze == null ? void 0 : ze.label) != null ? ut : ""
			};
		return () => createVNode(Trigger, mergeProps({
			trigger: "click",
			position: "bl",
			popupOffset: 4,
			animationName: "slide-dynamic-origin",
			hideEmpty: !0,
			preventFocus: !0,
			autoFitPopupWidth: !0,
			autoFitTransformOrigin: !0,
			disabled: D.value,
			popupVisible: ge.value,
			unmountOnClose: o.unmountOnClose,
			clickToClose: !(o.allowSearch || o.allowCreate),
			popupContainer: o.popupContainer,
			onPopupVisibleChange: me
		}, o.triggerProps), {
			default: () => {
				var ze, Oe;
				return [(Oe = (ze = s.trigger) == null ? void 0 : ze.call(s)) != null ? Oe :
					createVNode(SelectView, mergeProps({
						class: k,
						modelValue: we.value,
						inputValue: Me.value,
						multiple: o.multiple,
						disabled: D.value,
						error: F.value,
						loading: o.loading,
						allowClear: o.allowClear,
						allowCreate: o.allowCreate,
						allowSearch: !!o.allowSearch,
						opened: ge.value,
						maxTagCount: o.maxTagCount,
						placeholder: o.placeholder,
						bordered: o.bordered,
						size: M.value,
						tagNowrap: o.tagNowrap,
						onInputValueChange: Ae,
						onRemove: xe,
						onClear: ye,
						onKeydown: Ne
					}, l), {
						label: Ge,
						prefix: s.prefix,
						"arrow-icon": s["arrow-icon"],
						"loading-icon": s["loading-icon"],
						"search-icon": s["search-icon"]
					})
				]
			},
			content: Fe
		})
	}
});
const Select = Object.assign(_Select, {
		Option,
		OptGroup: Optgroup,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Select.name, _Select), o.component(a + Option.name, Option), o.component(a +
				Optgroup.name, Optgroup)
		}
	}),
	radioGroupKey = Symbol("RadioGroup");
var _Radio = defineComponent({
		name: "Radio",
		components: {
			IconHover
		},
		props: {
			modelValue: {
				type: [String, Number, Boolean],
				default: void 0
			},
			defaultChecked: {
				type: Boolean,
				default: !1
			},
			value: {
				type: [String, Number, Boolean],
				default: !0
			},
			type: {
				type: String,
				default: "radio"
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			uninjectGroupContext: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:modelValue": o => !0,
			change: (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const l = getPrefixCls("radio"),
				{
					modelValue: c
				} = toRefs(o),
				d = o.uninjectGroupContext ? void 0 : inject(radioGroupKey, void 0),
				{
					mergedDisabled: f,
					eventHandlers: m
				} = useFormItem({
					disabled: toRef(o, "disabled")
				}),
				g = ref(null),
				v = ref(o.defaultChecked),
				y = computed(() => (d == null ? void 0 : d.name) === "ArcoRadioGroup"),
				b = computed(() => {
					var D;
					return (D = d == null ? void 0 : d.type) != null ? D : o.type
				}),
				C = computed(() => (d == null ? void 0 : d.disabled) || f.value),
				_ = computed(() => {
					var D, F;
					return y.value ? (d == null ? void 0 : d.value) === ((D = o.value) != null ? D : !0) :
						isUndefined$1(o.modelValue) ? v.value : o.modelValue === ((F = o.value) != null ? F : !
							0)
				});
			watch(c, D => {
				(isUndefined$1(D) || isNull$1(D)) && (v.value = !1)
			}), watch(_, (D, F) => {
				D !== F && (v.value = D, g.value && (g.value.checked = D))
			});
			const S = D => {
					var F, R;
					(R = (F = m.value) == null ? void 0 : F.onFocus) == null || R.call(F, D)
				},
				w = D => {
					var F, R;
					(R = (F = m.value) == null ? void 0 : F.onBlur) == null || R.call(F, D)
				},
				T = D => {
					D.stopPropagation()
				},
				A = D => {
					var F, R, O, U, V;
					v.value = !0, y.value ? d == null || d.handleChange((F = o.value) != null ? F : !0, D) : (s(
							"update:modelValue", (R = o.value) != null ? R : !0), s("change", (O = o.value) !=
							null ? O : !0, D), (V = (U = m.value) == null ? void 0 : U.onChange) == null || V
						.call(U, D)), nextTick(() => {
						g.value && g.value.checked !== _.value && (g.value.checked = _.value)
					})
				},
				k = computed(() => [`${b.value==="button"?`${l}-button`:l}`, {
					[`${l}-checked`]: _.value,
					[`${l}-disabled`]: C.value
				}]),
				M = () => createVNode(Fragment, null, [createVNode(resolveComponent("icon-hover"), {
					class: `${l}-icon-hover`,
					disabled: C.value || _.value
				}, {
					default: () => [createVNode("span", {
						class: `${l}-icon`
					}, null)]
				}), a.default && createVNode("span", {
					class: `${l}-label`
				}, [a.default()])]);
			return () => {
				var D, F, R, O;
				return createVNode("label", {
					class: k.value
				}, [createVNode("input", {
					ref: g,
					type: "radio",
					checked: _.value,
					value: o.value,
					class: `${l}-target`,
					disabled: C.value,
					onClick: T,
					onChange: A,
					onFocus: S,
					onBlur: w
				}, null), b.value === "radio" ? (O = (R = (F = a.radio) != null ? F : (D = d ==
					null ? void 0 : d.slots) == null ? void 0 : D.radio) == null ? void 0 : R({
					checked: _.value,
					disabled: C.value
				})) != null ? O : M() : createVNode("span", {
					class: `${l}-button-content`
				}, [a.default && a.default()])])
			}
		}
	}),
	RadioGroup = defineComponent({
		name: "RadioGroup",
		props: {
			modelValue: {
				type: [String, Number, Boolean],
				default: void 0
			},
			defaultValue: {
				type: [String, Number, Boolean],
				default: ""
			},
			type: {
				type: String,
				default: "radio"
			},
			size: {
				type: String
			},
			options: {
				type: Array
			},
			direction: {
				type: String,
				default: "horizontal"
			},
			disabled: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:modelValue": o => !0,
			change: (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const l = getPrefixCls("radio-group"),
				{
					size: c,
					type: d,
					disabled: f,
					modelValue: m
				} = toRefs(o),
				{
					mergedDisabled: g,
					mergedSize: v,
					eventHandlers: y
				} = useFormItem({
					size: c,
					disabled: f
				}),
				{
					mergedSize: b
				} = useSize$1(v),
				C = ref(o.defaultValue),
				_ = computed(() => {
					var k;
					return (k = o.modelValue) != null ? k : C.value
				}),
				S = computed(() => {
					var k;
					return ((k = o.options) != null ? k : []).map(M => isString$2(M) || isNumber$2(M) ? {
						label: M,
						value: M
					} : M)
				});
			provide(radioGroupKey, reactive({
				name: "ArcoRadioGroup",
				value: _,
				size: b,
				type: d,
				disabled: g,
				slots: a,
				handleChange: (k, M) => {
					var D, F;
					C.value = k, s("update:modelValue", k), s("change", k, M), (F = (D = y.value) ==
						null ? void 0 : D.onChange) == null || F.call(D, M)
				}
			})), watch(_, k => {
				C.value !== k && (C.value = k)
			}), watch(m, k => {
				(isUndefined$1(k) || isNull$1(k)) && (C.value = "")
			});
			const T = computed(() => [`${l}${o.type==="button"?"-button":""}`, `${l}-size-${b.value}`,
					`${l}-direction-${o.direction}`, {
						[`${l}-disabled`]: g.value
					}
				]),
				A = () => S.value.map(k => createVNode(_Radio, {
					key: k.value,
					value: k.value,
					disabled: k.disabled,
					modelValue: _.value === k.value
				}, {
					default: () => [a.label ? a.label({
						data: k
					}) : isFunction$2(k.label) ? k.label() : k.label]
				}));
			return () => {
				var k;
				return createVNode("span", {
					class: T.value
				}, [S.value.length > 0 ? A() : (k = a.default) == null ? void 0 : k.call(a)])
			}
		}
	});
const Radio = Object.assign(_Radio, {
		Group: RadioGroup,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Radio.name, _Radio), o.component(a + RadioGroup.name, RadioGroup)
		}
	}),
	_sfc_main$2D = defineComponent({
		name: "IconLeft",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-left`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$11 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2l(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M32 8.4 16.444 23.956 32 39.513"
	}, null, -1)]), 14, _hoisted_1$11)
}
var _IconLeft = _export_sfc$1(_sfc_main$2D, [
	["render", _sfc_render$2l]
]);
const IconLeft = Object.assign(_IconLeft, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconLeft.name, _IconLeft)
	}
});

function _isSlot$f(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}

function getPopupContainer(o) {
	return o.parentElement
}
var Header = defineComponent({
	name: "Header",
	props: {
		mode: {
			type: String
		},
		dayStartOfWeek: {
			type: Number
		},
		isWeek: {
			type: Boolean
		},
		panel: {
			type: Boolean
		},
		modes: {
			type: Array
		},
		headerType: {
			type: String
		},
		pageShowData: {
			type: Object,
			required: !0
		},
		move: {
			type: Function,
			required: !0
		},
		onYearChange: {
			type: Function,
			required: !0
		},
		onMonthChange: {
			type: Function,
			required: !0
		},
		changePageShowDate: {
			type: Function,
			required: !0
		},
		onModeChange: {
			type: Function,
			required: !0
		},
		headerValueFormat: {
			type: String,
			required: !0
		}
	},
	emits: ["yearChange", "monthChange"],
	setup(o, {
		slots: s
	}) {
		const a = getPrefixCls("calendar"),
			{
				t: l
			} = useI18n(),
			c = isArray$2(o.modes) ? o.modes.map(y => ({
				label: l(`datePicker.view.${y}`),
				value: y
			})) : [],
			d = o.headerType === "select",
			f = computed(() => o.pageShowData.year()),
			m = computed(() => o.pageShowData.month() + 1),
			g = computed(() => {
				const y = [f.value];
				for (let b = 1; b <= 10; b++) y.unshift(f.value - b);
				for (let b = 1; b < 10; b++) y.push(f.value + b);
				return y
			}),
			v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
		return () => {
			let y;
			return createVNode("div", {
				class: `${a}-header`
			}, [createVNode("div", {
				class: `${a}-header-left`
			}, [d ? createVNode(Fragment, null, [createVNode(Select, {
				size: "small",
				class: `${a}-header-value-year`,
				value: f,
				options: g.value,
				onChange: o.onYearChange,
				getPopupContainer
			}, null), o.mode === "month" && createVNode(Select, {
				size: "small",
				class: `${a}-header-value-month`,
				value: m,
				options: v,
				onChange: o.onMonthChange,
				getPopupContainer
			}, null)]) : createVNode(Fragment, null, [createVNode("div", {
				class: `${a}-header-icon`,
				role: "button",
				tabIndex: 0,
				onClick: () => o.changePageShowDate("prev", o.mode)
			}, [createVNode(IconLeft, null, null)]), createVNode("div", {
				class: `${a}-header-value`
			}, [s.default ? s.default({
				year: f,
				month: m
			}) : o.pageShowData.format(o.headerValueFormat)]), createVNode(
				"div", {
					role: "button",
					tabIndex: 0,
					class: `${a}-header-icon`,
					onClick: () => o.changePageShowDate("next", o.mode)
				}, [createVNode(IconRight, null, null)])]), createVNode(Button, {
				size: "small",
				onClick: () => o.move(getNow())
			}, _isSlot$f(y = l("datePicker.today")) ? y : {
				default: () => [y]
			})]), createVNode("div", {
				class: `${a}-header-right`
			}, [createVNode(Radio.Group, {
				size: "small",
				type: "button",
				options: c,
				onChange: o.onModeChange,
				modelValue: o.mode
			}, null)])])
		}
	}
});

function getFormat(o, s) {
	return o === "month" || o === "year" && !s ? "YYYY-MM-DD" : "YYYY-MM"
}
var _Calendar = defineComponent({
	name: "Calendar",
	props: {
		modelValue: {
			type: Date,
			default: void 0
		},
		defaultValue: {
			type: Date
		},
		mode: {
			type: String
		},
		defaultMode: {
			type: String,
			default: "month"
		},
		modes: {
			type: Array,
			default: () => ["month", "year"]
		},
		allowSelect: {
			type: Boolean,
			default: !0
		},
		panel: {
			type: Boolean,
			default: !1
		},
		panelWidth: {
			type: Number
		},
		panelTodayBtn: {
			type: Boolean,
			default: !1
		},
		dayStartOfWeek: {
			type: Number,
			default: 0
		},
		isWeek: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		"update:modelValue": o => !0,
		change: o => !0,
		panelChange: o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			dayStartOfWeek: l,
			isWeek: c
		} = toRefs(o), d = getPrefixCls("calendar"), f = ref(o.defaultMode), {
				t: m
			} = useI18n(), g = computed(() => o.mode ? o.mode : f.value), v = getFormat(g.value, o.panel), y =
			ref(getDayjsValue(o.defaultValue || Date.now(), v)), b = computed(() => o.modelValue ?
				getDayjsValue(o.modelValue, v) : y.value), C = ref(b.value || getNow()), _ = computed(() =>
				getAllDaysByTime(C.value, {
					dayStartOfWeek: l.value,
					isWeek: c.value
				}));

		function S(U) {
			C.value = U, s("panelChange", U.toDate())
		}

		function w(U) {
			y.value = U, s("change", U.toDate()), s("update:modelValue", U.toDate()), S(U)
		}

		function T(U, V = !1) {
			V || w(U)
		}
		let A = "";
		g.value === "month" ? A = m("calendar.formatMonth") : g.value === "year" && (A = m(
			"calendar.formatYear"));

		function k(U, V) {
			U === "prev" && (C.value = methods.subtract(C.value, 1, V)), U === "next" && (C.value = methods.add(
				C.value, 1, V)), s("panelChange", C.value.toDate())
		}

		function M(U) {
			const V = methods.set(C.value, "year", U);
			C.value = V, s("panelChange", V.toDate())
		}

		function D(U) {
			const V = methods.set(C.value, "month", U - 1);
			C.value = V, s("panelChange", V.toDate())
		}

		function F(U) {
			f.value = U
		}
		const R = computed(() => [d, g.value === "month" ? `${d}-mode-month` : `${d}-mode-year`, {
				[`${d}-panel`]: o.panel && (g.value === "month" || g.value === "year")
			}]),
			O = o.panel ? {
				width: o.panelWidth
			} : {};
		return () => createVNode("div", mergeProps({
			class: R.value,
			style: O
		}, pickDataAttributes(o)), [createVNode(Header, {
			move: w,
			headerValueFormat: A,
			modes: o.modes,
			mode: g.value,
			pageShowData: C.value,
			dayStartOfWeek: o.dayStartOfWeek,
			isWeek: o.isWeek,
			onModeChange: F,
			onYearChange: M,
			onMonthChange: D,
			changePageShowDate: k
		}, {
			default: a.header
		}), g.value === "month" && createVNode("div", {
			class: `${d}-body`
		}, [createVNode(Month, {
			key: C.value.month(),
			pageData: _.value,
			value: b.value,
			mode: g.value,
			selectHandler: T,
			isWeek: o.isWeek,
			dayStartOfWeek: o.dayStartOfWeek,
			pageShowDate: C.value
		}, {
			default: a.default
		})]), g.value === "year" && createVNode("div", {
			class: `${d}-body`
		}, [createVNode(Year, {
			key: C.value.year(),
			pageData: _.value,
			pageShowData: C.value,
			mode: g.value,
			isWeek: o.isWeek,
			value: b.value,
			dayStartOfWeek: o.dayStartOfWeek,
			selectHandler: T
		}, null)]), o.panel && o.panelTodayBtn && createVNode("div", {
			class: `${d}-footer-btn-wrapper`
		}, [m("today")])])
	}
});
const Calendar = Object.assign(_Calendar, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Calendar.name, _Calendar)
		}
	}),
	cardInjectionKey = Symbol("ArcoCard");
var _Card = defineComponent({
		name: "Card",
		components: {
			Spin
		},
		props: {
			bordered: {
				type: Boolean,
				default: !0
			},
			loading: {
				type: Boolean,
				default: !1
			},
			hoverable: {
				type: Boolean,
				default: !1
			},
			size: {
				type: String
			},
			headerStyle: {
				type: Object,
				default: () => ({})
			},
			bodyStyle: {
				type: Object,
				default: () => ({})
			},
			title: {
				type: String
			},
			extra: {
				type: String
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("card"),
				{
					size: l
				} = toRefs(o),
				{
					mergedSize: c
				} = useSize$1(l),
				d = computed(() => c.value === "small" || c.value === "mini" ? "small" : "medium"),
				f = v => {
					const y = getAllElements(v);
					return createVNode("div", {
						class: `${a}-actions`
					}, [createVNode("div", {
						class: `${a}-actions-right`
					}, [y.map((b, C) => createVNode("span", {
						key: `action-${C}`,
						class: `${a}-actions-item`
					}, [b]))])])
				},
				m = reactive({
					hasMeta: !1,
					hasGrid: !1,
					slots: s,
					renderActions: f
				});
			provide(cardInjectionKey, m);
			const g = computed(() => [a, `${a}-size-${d.value}`, {
				[`${a}-loading`]: o.loading,
				[`${a}-bordered`]: o.bordered,
				[`${a}-hoverable`]: o.hoverable,
				[`${a}-contain-grid`]: m.hasGrid
			}]);
			return () => {
				var v, y, b, C, _, S, w;
				const T = !!((v = s.title) != null ? v : o.title),
					A = !!((y = s.extra) != null ? y : o.extra);
				return createVNode("div", {
					class: g.value
				}, [(T || A) && createVNode("div", {
					class: [`${a}-header`, {
						[`${a}-header-no-title`]: !T
					}],
					style: o.headerStyle
				}, [T && createVNode("div", {
					class: `${a}-header-title`
				}, [(C = (b = s.title) == null ? void 0 : b.call(s)) != null ? C : o
					.title
				]), A && createVNode("div", {
					class: `${a}-header-extra`
				}, [(S = (_ = s.extra) == null ? void 0 : _.call(s)) != null ? S : o
					.extra
				])]), s.cover && createVNode("div", {
					class: `${a}-cover`
				}, [s.cover()]), createVNode("div", {
					class: `${a}-body`,
					style: o.bodyStyle
				}, [o.loading ? createVNode(Spin, null, null) : (w = s.default) == null ?
					void 0 : w.call(s), s.actions && !m.hasMeta && f(s.actions())
				])])
			}
		}
	}),
	CardMeta = defineComponent({
		name: "CardMeta",
		props: {
			title: {
				type: String
			},
			description: {
				type: String
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("card-meta"),
				l = inject(cardInjectionKey);
			return onMounted(() => {
				l && (l.hasMeta = !0)
			}), () => {
				var c, d, f, m, g, v;
				const y = !!((c = s.title) != null ? c : o.title),
					b = !!((d = s.description) != null ? d : o.description);
				return createVNode("div", {
					class: a
				}, [(y || b) && createVNode("div", {
					class: `${a}-content`
				}, [y && createVNode("div", {
					class: `${a}-title`
				}, [(m = (f = s.title) == null ? void 0 : f.call(s)) != null ? m : o
					.title
				]), b && createVNode("div", {
					class: `${a}-description`
				}, [(v = (g = s.description) == null ? void 0 : g.call(s)) != null ? v :
					o.description
				])]), (s.avatar || (l == null ? void 0 : l.slots.actions)) && createVNode("div", {
					class: [`${a}-footer `, {
						[`${a}-footer-only-actions`]: !s.avatar
					}]
				}, [s.avatar && createVNode("div", {
						class: `${a}-avatar`
					}, [s.avatar()]), l && l.slots.actions && l.renderActions(l.slots
				.actions())])])
			}
		}
	});
const _sfc_main$2C = defineComponent({
	name: "CardGrid",
	props: {
		hoverable: {
			type: Boolean,
			default: !1
		}
	},
	setup(o) {
		const s = getPrefixCls("card-grid"),
			a = inject(cardInjectionKey);
		return onMounted(() => {
			a && (a.hasGrid = !0)
		}), {
			cls: computed(() => [s, {
				[`${s}-hoverable`]: o.hoverable
			}])
		}
	}
});

function _sfc_render$2k(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [renderSlot(o.$slots, "default")], 2)
}
var CardGrid = _export_sfc$1(_sfc_main$2C, [
	["render", _sfc_render$2k]
]);
const Card = Object.assign(_Card, {
		Meta: CardMeta,
		Grid: CardGrid,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Card.name, _Card), o.component(a + CardMeta.name, CardMeta), o.component(a +
				CardGrid.name, CardGrid)
		}
	}),
	_sfc_main$2B = defineComponent({
		name: "Indicator",
		props: {
			count: {
				type: Number,
				default: 2
			},
			activeIndex: {
				type: Number,
				default: 0
			},
			type: {
				type: String,
				default: "line"
			},
			position: {
				type: String,
				default: "bottom"
			},
			trigger: {
				type: String,
				default: "click"
			}
		},
		emits: ["select"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("carousel-indicator"),
				l = m => {
					var g;
					if (m.preventDefault(), o.type === "slider") {
						const v = m.offsetX,
							y = m.currentTarget.clientWidth;
						if (m.target === m.currentTarget) {
							const b = Math.floor(v / y * o.count);
							b !== o.activeIndex && s("select", b)
						}
					} else {
						const v = Number.parseInt((g = m.target.getAttribute("data-index")) != null ? g : "", 10);
						!Number.isNaN(v) && v !== o.activeIndex && s("select", v)
					}
				},
				c = computed(() => o.trigger === "click" ? {
					onClick: l
				} : {
					onMouseover: l
				}),
				d = computed(() => [`${a}`, `${a}-${o.type}`, `${a}-${o.position}`]),
				f = computed(() => {
					const m = 100 / o.count;
					return {
						width: `${m}%`,
						left: `${o.activeIndex*m}%`
					}
				});
			return {
				prefixCls: a,
				eventHandlers: c,
				cls: d,
				sliderStyle: f
			}
		}
	}),
	_hoisted_1$10 = ["data-index"];

function _sfc_render$2j(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", mergeProps({
		class: o.cls
	}, o.eventHandlers), [o.type === "slider" ? (openBlock(), createElementBlock("span", {
		key: 0,
		style: normalizeStyle(o.sliderStyle),
		class: normalizeClass([`${o.prefixCls}-item`, `${o.prefixCls}-item-active`])
	}, null, 6)) : (openBlock(!0), createElementBlock(Fragment, {
		key: 1
	}, renderList(Array(o.count), (f, m) => (openBlock(), createElementBlock("span", {
		key: m,
		"data-index": m,
		class: normalizeClass([`${o.prefixCls}-item`, {
			[`${o.prefixCls}-item-active`]: m === o.activeIndex
		}])
	}, null, 10, _hoisted_1$10))), 128))], 16)
}
var CarouselIndicator = _export_sfc$1(_sfc_main$2B, [
	["render", _sfc_render$2j]
]);
const _sfc_main$2A = defineComponent({
		name: "IconUp",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-up`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$$ = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2i(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M39.6 30.557 24.043 15 8.487 30.557"
	}, null, -1)]), 14, _hoisted_1$$)
}
var _IconUp = _export_sfc$1(_sfc_main$2A, [
	["render", _sfc_render$2i]
]);
const IconUp = Object.assign(_IconUp, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconUp.name, _IconUp)
		}
	}),
	_sfc_main$2z = defineComponent({
		name: "Arrow",
		components: {
			IconUp,
			IconDown,
			IconLeft,
			IconRight
		},
		props: {
			direction: {
				type: String,
				default: "horizontal"
			},
			showArrow: {
				type: String,
				default: "always"
			}
		},
		emits: ["previousClick", "nextClick"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("carousel"),
				l = f => {
					s("previousClick", f)
				},
				c = f => {
					s("nextClick", f)
				},
				d = computed(() => [`${a}-arrow`, {
					[`${a}-arrow-hover`]: o.showArrow === "hover"
				}]);
			return {
				prefixCls: a,
				cls: d,
				onPreviousClick: l,
				onNextClick: c
			}
		}
	});

function _sfc_render$2h(o, s, a, l, c, d) {
	const f = resolveComponent("IconLeft"),
		m = resolveComponent("IconUp"),
		g = resolveComponent("IconRight"),
		v = resolveComponent("IconDown");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-arrow-${o.direction==="vertical"?"top":"left"}`),
		onClick: s[0] || (s[0] = (...y) => o.onPreviousClick && o.onPreviousClick(...y))
	}, [o.direction === "horizontal" ? (openBlock(), createBlock(f, {
		key: 0
	})) : (openBlock(), createBlock(m, {
		key: 1
	}))], 2), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-arrow-${o.direction==="vertical"?"bottom":"right"}`),
		onClick: s[1] || (s[1] = (...y) => o.onNextClick && o.onNextClick(...y))
	}, [o.direction === "horizontal" ? (openBlock(), createBlock(g, {
		key: 0
	})) : (openBlock(), createBlock(v, {
		key: 1
	}))], 2)], 2)
}
var CarouselArrow = _export_sfc$1(_sfc_main$2z, [
	["render", _sfc_render$2h]
]);
const carouselInjectionKey = Symbol("ArcoCarousel"),
	useChildrenComponents = o => {
		const s = {},
			a = ref([]),
			l = () => {
				if (s.value) {
					const c = getComponentsFromChildren(s.value, o);
					(c.length !== a.value.length || c.toString() !== a.value.toString()) && (a.value = c)
				}
			};
		return onMounted(() => l()), onUpdated(() => l()), {
			children: s,
			components: a
		}
	},
	DEFAULT_AUTO_PLAY = {
		interval: 3e3,
		hoverToPause: !0
	};

function getValidIndex(o, s) {
	const a = +o;
	return typeof a == "number" && !Number.isNaN(a) ? (a + s) % s : o
}
var _Carousel = defineComponent({
	name: "Carousel",
	props: {
		current: {
			type: Number
		},
		defaultCurrent: {
			type: Number,
			default: 1
		},
		autoPlay: {
			type: [Boolean, Object],
			default: !1
		},
		moveSpeed: {
			type: Number,
			default: 500
		},
		animationName: {
			type: String,
			default: "slide"
		},
		trigger: {
			type: String,
			default: "click"
		},
		direction: {
			type: String,
			default: "horizontal"
		},
		showArrow: {
			type: String,
			default: "always"
		},
		arrowClass: {
			type: String,
			default: ""
		},
		indicatorType: {
			type: String,
			default: "dot"
		},
		indicatorPosition: {
			type: String,
			default: "bottom"
		},
		indicatorClass: {
			type: String,
			default: ""
		},
		transitionTimingFunction: {
			type: String,
			default: "cubic-bezier(0.34, 0.69, 0.1, 1)"
		}
	},
	emits: {
		"update:current": o => !0,
		change: (o, s, a) => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			current: l,
			animationName: c,
			moveSpeed: d,
			transitionTimingFunction: f
		} = toRefs(o), m = getPrefixCls("carousel"), g = ref(!1), v = ref(), y = ref(), b = computed(() =>
			isObject$2(o.autoPlay) ? {
				...DEFAULT_AUTO_PLAY,
				...o.autoPlay
			} : o.autoPlay ? DEFAULT_AUTO_PLAY : {});
		let C = 0,
			_ = 0;
		const {
			children: S,
			components: w
		} = useChildrenComponents("CarouselItem"), T = ref(o.defaultCurrent - 1), A = computed(() => {
			const he = w.value.length,
				ce = isNumber$2(l.value) ? getValidIndex(l.value - 1, he) : T.value,
				ae = getValidIndex(ce - 1, he),
				fe = getValidIndex(ce + 1, he);
			return {
				mergedIndex: ce,
				mergedPrevIndex: ae,
				mergedNextIndex: fe
			}
		}), k = reactive({
			items: w,
			slideTo: D,
			mergedIndexes: A,
			previousIndex: v,
			animationName: c,
			slideDirection: y,
			transitionTimingFunction: f,
			moveSpeed: d
		});
		provide(carouselInjectionKey, k);
		const M = () => {
			C && window.clearInterval(C)
		};
		watchEffect(() => {
			var he;
			const {
				interval: ce
			} = b.value || {}, {
				mergedNextIndex: ae
			} = A.value, fe = ((he = w.value) == null ? void 0 : he.length) > 1 && !g.value && !!ce;
			M(), fe && (C = window.setInterval(() => {
				D({
					targetIndex: ae
				})
			}, ce))
		}), onBeforeUnmount(() => {
			M()
		});

		function D({
			targetIndex: he,
			isNegative: ce = !1,
			isManual: ae = !1
		}) {
			!_ && he !== A.value.mergedIndex && (v.value = T.value, T.value = he, y.value = ce ? "negative" :
				"positive", _ = window.setTimeout(() => {
					_ = 0
				}, d.value), s("update:current", T.value + 1), s("change", T.value + 1, v.value + 1, ae))
		}
		const F = () => D({
				targetIndex: A.value.mergedPrevIndex,
				isNegative: !0,
				isManual: !0
			}),
			R = () => D({
				targetIndex: A.value.mergedNextIndex,
				isManual: !0
			}),
			O = he => D({
				targetIndex: he,
				isNegative: he < A.value.mergedIndex,
				isManual: !0
			}),
			U = computed(() => b.value.hoverToPause ? {
				onMouseenter: () => {
					g.value = !0
				},
				onMouseleave: () => {
					g.value = !1
				}
			} : {}),
			V = computed(() => o.indicatorType !== "never" && w.value.length > 1),
			z = computed(() => o.showArrow !== "never" && w.value.length > 1),
			j = computed(() => [m, `${m}-indicator-position-${o.indicatorPosition}`]),
			ge = computed(() => [`${m}-${o.animationName}`, `${m}-${o.direction}`, {
				[`${m}-negative`]: y.value === "negative"
			}]),
			me = computed(() => [`${m}-indicator-wrapper`, `${m}-indicator-wrapper-${o.indicatorPosition}`]);
		return () => {
			var he;
			return S.value = (he = a.default) == null ? void 0 : he.call(a), createVNode("div", mergeProps({
				class: j.value
			}, U.value), [createVNode("div", {
				class: ge.value
			}, [S.value]), V.value && createVNode("div", {
				class: me.value
			}, [createVNode(CarouselIndicator, {
				class: o.indicatorClass,
				type: o.indicatorType,
				count: w.value.length,
				activeIndex: A.value.mergedIndex,
				position: o.indicatorPosition,
				trigger: o.trigger,
				onSelect: O
			}, null)]), z.value && createVNode(CarouselArrow, {
				class: o.arrowClass,
				direction: o.direction,
				showArrow: o.showArrow,
				onPreviousClick: F,
				onNextClick: R
			}, null)])
		}
	}
});
const _sfc_main$2y = defineComponent({
		name: "CarouselItem",
		setup() {
			const o = getPrefixCls("carousel-item"),
				s = getCurrentInstance(),
				a = inject(carouselInjectionKey, {}),
				l = computed(() => {
					var m, g, v;
					return (v = (g = a.items) == null ? void 0 : g.indexOf((m = s == null ? void 0 : s.uid) !=
						null ? m : -1)) != null ? v : -1
				}),
				c = computed(() => {
					var m;
					return ((m = a.mergedIndexes) == null ? void 0 : m.mergedIndex) === l.value
				}),
				d = computed(() => {
					const {
						previousIndex: m,
						animationName: g,
						slideDirection: v,
						mergedIndexes: y
					} = a;
					return {
						[`${o}-prev`]: l.value === (y == null ? void 0 : y.mergedPrevIndex),
						[`${o}-next`]: l.value === (y == null ? void 0 : y.mergedNextIndex),
						[`${o}-current`]: c.value,
						[`${o}-slide-in`]: g === "slide" && v && c.value,
						[`${o}-slide-out`]: g === "slide" && v && l.value === m
					}
				}),
				f = computed(() => {
					const {
						transitionTimingFunction: m,
						moveSpeed: g
					} = a;
					return {
						transitionTimingFunction: m,
						transitionDuration: `${g}ms`,
						animationTimingFunction: m,
						animationDuration: `${g}ms`
					}
				});
			return {
				cls: d,
				animationStyle: f,
				isCurrent: c
			}
		}
	}),
	_hoisted_1$_ = ["aria-hidden"];

function _sfc_render$2g(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		"aria-hidden": !o.isCurrent,
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.animationStyle)
	}, [renderSlot(o.$slots, "default")], 14, _hoisted_1$_)
}
var CarouselItem = _export_sfc$1(_sfc_main$2y, [
	["render", _sfc_render$2g]
]);
const Carousel = Object.assign(_Carousel, {
		Item: CarouselItem,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Carousel.name, _Carousel), o.component(a + CarouselItem.name, CarouselItem)
		}
	}),
	getOptionInfos = (o, {
		optionMap: s,
		leafOptionMap: a,
		leafOptionSet: l,
		leafOptionValueMap: c,
		totalLevel: d,
		checkStrictly: f,
		enabledLazyLoad: m,
		lazyLoadOptions: g,
		valueKey: v,
		fieldNames: y
	}) => {
		let b = 0;
		const C = (S, w, T) => {
				var A;
				const k = (A = w == null ? void 0 : w.path) != null ? A : [];
				return b = Math.max(b, T ?? 1), S.map((M, D) => {
					var F;
					const R = M[y.value],
						O = {
							raw: M,
							value: R,
							label: (F = M[y.label]) != null ? F : String(R),
							disabled: !!M[y.disabled],
							selectionDisabled: !1,
							render: M[y.render],
							tagProps: M[y.tagProps],
							isLeaf: M[y.isLeaf],
							level: k.length,
							index: D,
							key: "",
							valueKey: String(isObject$2(R) ? R[v.value] : R),
							parent: w,
							path: [],
							pathValue: []
						},
						U = k.concat(O),
						V = [],
						z = U.map(j => (V.push(j.value), j.valueKey)).join("-");
					return O.path = U, O.pathValue = V, O.key = z, M[y.children] ? (O.isLeaf = !1, O.children =
							C(M[y.children], O, (T ?? 1) + 1)) : m && !O.isLeaf ? (O.isLeaf = !1, g[z] && (O
							.children = C(g[z], O, (T ?? 1) + 1))) : O.isLeaf = !0, O.children && !O.disabled &&
						(O.totalLeafOptions = O.children.reduce((j, ge) => isNumber$2(ge.totalLeafOptions) ? j +
							ge.totalLeafOptions : ge.disabled || ge.selectionDisabled ? j : j + (ge.isLeaf ?
								1 : 0), 0), O.totalLeafOptions === 0 && !f.value && (O.selectionDisabled = !
							0)), s.set(O.key, O), (O.isLeaf || f.value) && (l.add(O), a.set(O.key, O), c.has(O
							.valueKey) || c.set(O.valueKey, O.key)), O
				})
			},
			_ = C(o);
		return d.value = b, _
	},
	getCheckedStatus = (o, s) => {
		var a, l;
		let c = !1,
			d = !1;
		if (o.isLeaf) s != null && s.has(o.key) && (c = !0);
		else {
			const f = new RegExp(`^${o.key}(-|$)`),
				m = Array.from((a = s == null ? void 0 : s.keys()) != null ? a : []).reduce((g, v) => f.test(v) ? g +
					1 : g, 0);
			m > 0 && m >= ((l = o.totalLeafOptions) != null ? l : 1) ? c = !0 : m > 0 && (d = !0)
		}
		return {
			checked: c,
			indeterminate: d
		}
	},
	getLeafOptionKeys = o => {
		const s = [];
		if (o.isLeaf) s.push(o.key);
		else if (o.children)
			for (const a of o.children) s.push(...getLeafOptionKeys(a));
		return s
	},
	getLeafOptionInfos = o => {
		const s = [];
		if (o.disabled || o.selectionDisabled) return s;
		if (o.isLeaf) s.push(o);
		else if (o.children)
			for (const a of o.children) s.push(...getLeafOptionInfos(a));
		return s
	},
	getValueKey = (o, {
		valueKey: s,
		leafOptionValueMap: a
	}) => {
		var l;
		if (isArray$2(o)) return o.map(d => isObject$2(d) ? d[s] : d).join("-");
		const c = isObject$2(o) ? o[s] : o;
		return (l = a.get(String(c))) != null ? l : String(c)
	},
	getValidValues = (o, {
		multiple: s,
		pathMode: a
	}) => isArray$2(o) ? a && !s && o.length > 0 && !isArray$2(o[0]) ? [o] : o : isUndefined$1(o) || isNull$1(o) ||
	o === "" ? [] : [o],
	getOptionLabel = o => o.path.map(s => s.label).join(" / "),
	cascaderInjectionKey = Symbol("ArcoCascader");
var CascaderOption = defineComponent({
		name: "CascaderOption",
		props: {
			option: {
				type: Object,
				required: !0
			},
			active: Boolean,
			multiple: Boolean,
			checkStrictly: Boolean,
			searchOption: Boolean,
			pathLabel: Boolean
		},
		setup(o) {
			const s = getPrefixCls("cascader-option"),
				a = inject(cascaderInjectionKey, {}),
				l = ref(!1),
				c = {},
				d = y => {
					var b;
					if (isFunction$2(a.loadMore) && !o.option.isLeaf) {
						const {
							isLeaf: C,
							children: _,
							key: S
						} = o.option;
						!C && !_ && (l.value = !0, new Promise(w => {
							var T;
							(T = a.loadMore) == null || T.call(a, o.option.raw, w)
						}).then(w => {
							var T;
							l.value = !1, w && ((T = a.addLazyLoadOptions) == null || T.call(a, w, S))
						}))
					}(b = a.setSelectedPath) == null || b.call(a, o.option.key)
				};
			o.option.disabled || (c.onMouseenter = [() => {
				var y;
				return (y = a.setActiveKey) == null ? void 0 : y.call(a, o.option.key)
			}], c.onMouseleave = () => {
				var y;
				return (y = a.setActiveKey) == null ? void 0 : y.call(a)
			}, c.onClick = [], a.expandTrigger === "hover" ? c.onMouseenter.push(y => d()) : c.onClick.push(
				y => d()), o.option.isLeaf && !o.multiple && c.onClick.push(y => {
				var b;
				d(), (b = a.onClickOption) == null || b.call(a, o.option)
			}));
			const f = computed(() => [s, {
					[`${s}-active`]: o.active,
					[`${s}-disabled`]: o.option.disabled
				}]),
				m = computed(() => {
					var y;
					return o.checkStrictly ? {
						checked: (y = a.valueMap) == null ? void 0 : y.has(o.option.key),
						indeterminate: !1
					} : getCheckedStatus(o.option, a.valueMap)
				}),
				g = () => {
					var y, b, C;
					return o.pathLabel ? (b = (y = a == null ? void 0 : a.formatLabel) == null ? void 0 : y.call(a,
							o.option.path.map(_ => _.raw))) != null ? b : getOptionLabel(o.option) : (C = a
						.slots) != null && C.option ? a.slots.option({
							data: o.option
						}) : isFunction$2(o.option.render) ? o.option.render() : o.option.label
				},
				v = () => l.value ? createVNode(IconLoading, null, null) : !o.searchOption && !o.option.isLeaf ?
				createVNode(IconRight, null, null) : null;
			return () => {
				var y;
				return createVNode("li", mergeProps({
					tabindex: "0",
					role: "menuitem",
					"aria-disabled": o.option.disabled,
					"aria-haspopup": !o.option.isLeaf,
					"aria-expanded": !o.option.isLeaf && o.active,
					title: o.option.label,
					class: f.value
				}, c), [o.multiple && createVNode(Checkbox, {
					modelValue: m.value.checked,
					indeterminate: m.value.indeterminate,
					disabled: o.option.disabled || o.option.selectionDisabled,
					uninjectGroupContext: !0,
					onChange: (b, C) => {
						var _;
						C.stopPropagation(), d(), (_ = a.onClickOption) == null || _.call(a,
							o.option, !m.value.checked)
					},
					onClick: b => b.stopPropagation()
				}, null), o.checkStrictly && !o.multiple && createVNode(Radio, {
					modelValue: (y = a.valueMap) == null ? void 0 : y.has(o.option.key),
					disabled: o.option.disabled,
					uninjectGroupContext: !0,
					onChange: (b, C) => {
						var _;
						C.stopPropagation(), d(), (_ = a.onClickOption) == null || _.call(a,
							o.option, !0)
					},
					onClick: b => b.stopPropagation()
				}, null), createVNode("div", {
					class: `${s}-label`
				}, [g(), v()])])
			}
		}
	}),
	CascaderColumn = defineComponent({
		name: "CascaderColumn",
		props: {
			column: {
				type: Array,
				required: !0
			},
			level: {
				type: Number,
				default: 0
			},
			selectedPath: {
				type: Array,
				required: !0
			},
			activeKey: String,
			totalLevel: {
				type: Number,
				required: !0
			},
			multiple: Boolean,
			checkStrictly: Boolean,
			virtualListProps: {
				type: Object
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("cascader"),
				l = inject(configProviderInjectionKey, void 0),
				c = ref(),
				d = ref(!!o.virtualListProps),
				f = () => {
					var m, g, v, y, b;
					return (b = (y = (m = s.empty) == null ? void 0 : m.call(s)) != null ? y : (v = l == null ?
						void 0 : (g = l.slots).empty) == null ? void 0 : v.call(g, {
						component: "cascader"
					})) != null ? b : createVNode(Empty, null, null)
				};
			return () => {
				var m;
				return createVNode("div", {
					class: `${a}-panel-column`,
					style: {
						zIndex: o.totalLevel - o.level
					}
				}, [o.column.length === 0 ? createVNode(Scrollbar, {
					class: `${a}-column-content`
				}, {
					default: () => [createVNode("div", {
						class: `${a}-list-empty`
					}, [f()])]
				}) : d.value ? createVNode(VirtualList, mergeProps({
					key: (m = o.column) == null ? void 0 : m.length
				}, o.virtualListProps, {
					ref: c,
					data: o.column
				}), {
					item: ({
						item: g
					}) => createVNode(CascaderOption, {
						key: g.key,
						option: g,
						active: o.selectedPath.includes(g.key) || g.key === o.activeKey,
						multiple: o.multiple,
						checkStrictly: o.checkStrictly
					}, null)
				}) : createVNode(Scrollbar, {
					class: `${a}-column-content`
				}, {
					default: () => [createVNode("ul", {
						role: "menu",
						class: [`${a}-list`, {
							[`${a}-list-multiple`]: !!(o != null && o
								.multiple),
							[`${a}-list-strictly`]: !!(o != null && o
								.checkStrictly)
						}]
					}, [o.column.map(g => createVNode(CascaderOption, {
						key: g.key,
						option: g,
						active: o.selectedPath.includes(g.key) || g
							.key === o.activeKey,
						multiple: o.multiple,
						checkStrictly: o.checkStrictly
					}, null))])]
				})])
			}
		}
	});

function _isSlot$e(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var BaseCascaderPanel = defineComponent({
	name: "BaseCascaderPanel",
	props: {
		displayColumns: {
			type: Array,
			required: !0
		},
		selectedPath: {
			type: Array,
			required: !0
		},
		activeKey: String,
		totalLevel: {
			type: Number,
			required: !0
		},
		multiple: Boolean,
		checkStrictly: Boolean,
		loading: Boolean,
		dropdown: Boolean,
		virtualListProps: {
			type: Object
		}
	},
	setup(o, {
		slots: s
	}) {
		const a = getPrefixCls("cascader"),
			l = inject(configProviderInjectionKey, void 0),
			c = () => {
				var f, m, g, v, y;
				return (y = (v = (f = s.empty) == null ? void 0 : f.call(s)) != null ? v : (g = l == null ?
					void 0 : (m = l.slots).empty) == null ? void 0 : g.call(m, {
					component: "cascader"
				})) != null ? y : createVNode(Empty, null, null)
			},
			d = () => o.loading ? createVNode("div", {
				key: "panel-column-loading",
				class: [`${a}-panel-column`, `${a}-panel-column-loading`]
			}, [createVNode(Spin, null, null)]) : o.displayColumns.length === 0 ? createVNode("div", {
				key: "panel-column-empty",
				class: `${a}-panel-column`
			}, [createVNode("div", {
				class: `${a}-list-empty`
			}, [c()])]) : o.displayColumns.map((f, m) => createVNode(CascaderColumn, {
				key: `column-${m}`,
				column: f,
				level: m,
				selectedPath: o.selectedPath,
				activeKey: o.activeKey,
				totalLevel: o.totalLevel,
				multiple: o.multiple,
				checkStrictly: o.checkStrictly,
				virtualListProps: o.virtualListProps
			}, {
				empty: s.empty
			}));
		return () => {
			let f;
			return createVNode(TransitionGroup, {
				tag: "div",
				name: "cascader-slide",
				class: [`${a}-panel`, {
					[`${a}-dropdown-panel`]: o.dropdown
				}]
			}, _isSlot$e(f = d()) ? f : {
				default: () => [f]
			})
		}
	}
});

function _isSlot$d(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var CascaderSearchPanel = defineComponent({
	name: "CascaderSearchPanel",
	props: {
		options: {
			type: Array,
			required: !0
		},
		loading: Boolean,
		activeKey: String,
		multiple: Boolean,
		checkStrictly: Boolean,
		pathLabel: Boolean
	},
	setup(o, {
		slots: s
	}) {
		const a = getPrefixCls("cascader"),
			l = inject(configProviderInjectionKey, void 0),
			c = () => {
				var d, f, m, g, v;
				return o.loading ? createVNode(Spin, null, null) : o.options.length === 0 ? createVNode("div", {
					class: `${a}-list-empty`
				}, [(v = (g = (d = s.empty) == null ? void 0 : d.call(s)) != null ? g : (m = l == null ?
					void 0 : (f = l.slots).empty) == null ? void 0 : m.call(f, {
					component: "cascader"
				})) != null ? v : createVNode(Empty, null, null)]) : createVNode("ul", {
					role: "menu",
					class: [`${a}-list`, `${a}-search-list`, {
						[`${a}-list-multiple`]: o.multiple
					}]
				}, [o.options.map(y => createVNode(CascaderOption, {
					key: y.key,
					class: `${a}-search-option`,
					option: y,
					active: y.key === o.activeKey,
					multiple: o.multiple,
					checkStrictly: o.checkStrictly,
					pathLabel: o.pathLabel,
					searchOption: !0
				}, null))])
			};
		return () => {
			let d;
			return createVNode(Scrollbar, {
				class: [`${a}-panel`, `${a}-search-panel`]
			}, _isSlot$d(d = c()) ? d : {
				default: () => [d]
			})
		}
	}
});
const useSelectedPath = (o, {
		optionMap: s,
		filteredLeafOptions: a,
		showSearchPanel: l,
		expandChild: c
	}) => {
		const d = ref(),
			f = computed(() => {
				if (d.value) return s.get(d.value)
			}),
			m = ref([]),
			g = computed(() => {
				const S = [o.value];
				for (const w of m.value) {
					const T = s.get(w);
					T != null && T.children && S.push(T.children)
				}
				return S
			}),
			v = S => {
				var w;
				const T = C(S);
				m.value = (w = T == null ? void 0 : T.path.map(A => A.key)) != null ? w : []
			},
			y = S => {
				d.value = S
			},
			b = computed(() => {
				var S;
				return l != null && l.value ? a.value.filter(w => !w.disabled) : f.value && f.value.parent ? (S = f
					.value.parent.children) == null ? void 0 : S.filter(w => !w.disabled) : o.value.filter(w =>
					!w.disabled)
			}),
			C = S => {
				let w = S ? s.get(S) : void 0;
				if (c.value)
					for (; w && w.children && w.children.length > 0;) w = w.children[0];
				return w
			};
		return {
			activeKey: d,
			activeOption: f,
			selectedPath: m,
			displayColumns: g,
			setActiveKey: y,
			setSelectedPath: v,
			getNextActiveNode: S => {
				var w, T, A, k, M, D, F;
				const R = (T = (w = b.value) == null ? void 0 : w.length) != null ? T : 0;
				if (d.value) {
					const O = (k = (A = b.value) == null ? void 0 : A.findIndex(U => U.key === d.value)) != null ?
						k : 0;
					return S === "next" ? (M = b.value) == null ? void 0 : M[(R + O + 1) % R] : (D = b.value) ==
						null ? void 0 : D[(R + O - 1) % R]
				}
				return (F = b.value) == null ? void 0 : F[0]
			}
		}
	},
	_sfc_main$2x = defineComponent({
		name: "Cascader",
		components: {
			Trigger,
			SelectView,
			BaseCascaderPanel,
			CascaderSearchPanel
		},
		inheritAttrs: !1,
		props: {
			pathMode: {
				type: Boolean,
				default: !1
			},
			multiple: {
				type: Boolean,
				default: !1
			},
			modelValue: {
				type: [String, Number, Object, Array]
			},
			defaultValue: {
				type: [String, Number, Object, Array],
				default: o => o.multiple ? [] : o.pathMode ? void 0 : ""
			},
			options: {
				type: Array,
				default: () => []
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			error: {
				type: Boolean,
				default: !1
			},
			size: {
				type: String
			},
			allowSearch: {
				type: Boolean,
				default: o => !!o.multiple
			},
			allowClear: {
				type: Boolean,
				default: !1
			},
			inputValue: {
				type: String,
				default: void 0
			},
			defaultInputValue: {
				type: String,
				default: ""
			},
			popupVisible: {
				type: Boolean,
				default: void 0
			},
			expandTrigger: {
				type: String,
				default: "click"
			},
			defaultPopupVisible: {
				type: Boolean,
				default: !1
			},
			placeholder: String,
			filterOption: {
				type: Function
			},
			popupContainer: {
				type: [String, Object]
			},
			maxTagCount: {
				type: Number,
				default: 0
			},
			formatLabel: {
				type: Function
			},
			triggerProps: {
				type: Object
			},
			checkStrictly: {
				type: Boolean,
				default: !1
			},
			loadMore: {
				type: Function
			},
			loading: {
				type: Boolean,
				default: !1
			},
			searchOptionOnlyLabel: {
				type: Boolean,
				default: !1
			},
			searchDelay: {
				type: Number,
				default: 500
			},
			fieldNames: {
				type: Object
			},
			valueKey: {
				type: String,
				default: "value"
			},
			fallback: {
				type: [Boolean, Function],
				default: !0
			},
			expandChild: {
				type: Boolean,
				default: !1
			},
			virtualListProps: {
				type: Object
			},
			tagNowrap: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:modelValue": o => !0,
			"update:popupVisible": o => !0,
			change: o => !0,
			inputValueChange: o => !0,
			clear: () => !0,
			search: o => !0,
			popupVisibleChange: o => !0,
			focus: o => !0,
			blur: o => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				options: l,
				checkStrictly: c,
				loadMore: d,
				formatLabel: f,
				modelValue: m,
				disabled: g,
				valueKey: v,
				expandTrigger: y,
				expandChild: b,
				pathMode: C,
				multiple: _
			} = toRefs(o), S = ref(o.defaultValue), w = ref(o.defaultInputValue), T = ref(o.defaultPopupVisible), {
				mergedDisabled: A,
				eventHandlers: k
			} = useFormItem({
				disabled: g
			});
			watch(m, at => {
				(isUndefined$1(at) || isNull$1(at)) && (S.value = o.multiple ? [] : void 0)
			});
			const M = ref([]),
				D = ref(1),
				F = reactive(new Map),
				R = reactive(new Map),
				O = reactive(new Map),
				U = reactive(new Set),
				V = reactive({}),
				z = (at, Je) => {
					V[Je] = at
				},
				j = {
					value: "value",
					label: "label",
					disabled: "disabled",
					children: "children",
					tagProps: "tagProps",
					render: "render",
					isLeaf: "isLeaf"
				},
				ge = computed(() => ({
					...j,
					...o.fieldNames
				}));
			watch([l, V, ge], ([at, Je, Ne]) => {
				F.clear(), R.clear(), O.clear(), U.clear(), M.value = getOptionInfos(at ?? [], {
					enabledLazyLoad: !!o.loadMore,
					lazyLoadOptions: V,
					optionMap: F,
					leafOptionSet: U,
					leafOptionMap: R,
					leafOptionValueMap: O,
					totalLevel: D,
					checkStrictly: c,
					valueKey: v,
					fieldNames: Ne
				})
			}, {
				immediate: !0,
				deep: !0
			});
			const me = computed(() => {
					var at;
					const Je = getValidValues((at = o.modelValue) != null ? at : S.value, {
						multiple: o.multiple,
						pathMode: o.pathMode
					});
					return new Map(Je.map(Ne => [getValueKey(Ne, {
						valueKey: o.valueKey,
						leafOptionValueMap: O
					}), Ne]))
				}),
				he = computed(() => {
					var at;
					return (at = o.inputValue) != null ? at : w.value
				}),
				ce = computed(() => {
					var at;
					return (at = o.popupVisible) != null ? at : T.value
				}),
				ae = at => {
					var Je;
					return at == null ? void 0 : at.toLocaleLowerCase().includes((Je = he.value) == null ? void 0 :
						Je.toLocaleLowerCase())
				},
				fe = computed(() => (o.checkStrictly ? Array.from(F.values()) : Array.from(U)).filter(Je => {
					var Ne;
					return isFunction$2(o.filterOption) ? o.filterOption(he.value, Je.raw) : o
						.checkStrictly ? ae(Je.label) : (Ne = Je.path) == null ? void 0 : Ne.find(we => ae(
							we.label))
				})),
				q = at => {
					var Je, Ne, we;
					const Ce = o.multiple ? at : (Je = at[0]) != null ? Je : "";
					at.length === 0 && (Le(), ye()), S.value = Ce, s("update:modelValue", Ce), s("change", Ce), (
						we = (Ne = k.value) == null ? void 0 : Ne.onChange) == null || we.call(Ne)
				};
			watch([_, C], () => {
				const at = [];
				me.value.forEach((Je, Ne) => {
					const we = R.get(Ne);
					we && at.push(C.value ? we.pathValue : we.value)
				}), q(at)
			});
			const le = at => {
					ce.value !== at && (T.value = at, s("popupVisibleChange", at))
				},
				de = at => {
					if (o.multiple) {
						const Je = R.get(at);
						if (Je) ke(Je, !1);
						else {
							const Ne = [];
							me.value.forEach((we, Ce) => {
								Ce !== at && Ne.push(we)
							}), q(Ne)
						}
					}
				},
				_e = at => {
					q([o.pathMode ? at.pathValue : at.value]), le(!1)
				},
				ke = (at, Je) => {
					if (Je) {
						const Ne = o.checkStrictly ? [at] : getLeafOptionInfos(at);
						q([...me.value.values(), ...Ne.filter(we => !me.value.has(we.key)).map(we => o.pathMode ? we
							.pathValue : we.value)])
					} else {
						const Ne = o.checkStrictly ? [at.key] : getLeafOptionKeys(at),
							we = [];
						me.value.forEach((Ce, $e) => {
							Ne.includes($e) || we.push(Ce)
						}), q(we)
					}
					be("", "optionChecked")
				},
				De = (at, Je) => {
					o.multiple ? ke(at, Je ?? !0) : _e(at)
				},
				Se = debounce$1(at => {
					s("search", at)
				}, o.searchDelay),
				be = (at, Je) => {
					at !== he.value && (Je === "manual" && !ce.value && (T.value = !0, s("popupVisibleChange", !0)),
						w.value = at, s("inputValueChange", at), o.allowSearch && Se(at))
				};
			watch(ce, at => {
				if (at) {
					if (me.value.size > 0) {
						const Je = Array.from(me.value.keys()),
							Ne = Je[Je.length - 1],
							we = R.get(Ne);
						we && we.key !== dt.value && (Le(we.key), ye(we.key))
					}
				} else me.value.size === 0 && (Le(), ye()), be("", "optionListHide")
			});
			const Me = at => {
					if (at.stopPropagation(), o.multiple) {
						const Je = [];
						me.value.forEach((Ne, we) => {
							const Ce = R.get(we);
							Ce != null && Ce.disabled && Je.push(o.pathMode ? Ce.pathValue : Ce.value)
						}), q(Je)
					} else q([]);
					be("", "manual"), s("clear")
				},
				Ve = computed(() => o.allowSearch && he.value.length > 0),
				it = at => {
					s("focus", at)
				},
				pt = at => {
					s("blur", at)
				},
				{
					activeKey: dt,
					activeOption: He,
					selectedPath: Ae,
					displayColumns: xe,
					setActiveKey: ye,
					setSelectedPath: Le,
					getNextActiveNode: Ue
				} = useSelectedPath(M, {
					optionMap: F,
					filteredLeafOptions: fe,
					showSearchPanel: Ve,
					expandChild: b
				});
			provide(cascaderInjectionKey, reactive({
				onClickOption: De,
				setActiveKey: ye,
				setSelectedPath: Le,
				loadMore: d,
				expandTrigger: y,
				addLazyLoadOptions: z,
				formatLabel: f,
				slots: a,
				valueMap: me
			}));
			const nt = getKeyDownHandler(new Map([
					[KEYBOARD_KEY.ENTER, at => {
						if (ce.value) {
							if (He.value) {
								let Je;
								o.checkStrictly || He.value.isLeaf ? Je = !me.value.has(He.value.key) :
									Je = !getCheckedStatus(He.value, me.value).checked, Le(He.value
									.key), De(He.value, Je)
							}
						} else le(!0)
					}],
					[KEYBOARD_KEY.ESC, at => {
						le(!1)
					}],
					[KEYBOARD_KEY.ARROW_DOWN, at => {
						at.preventDefault();
						const Je = Ue("next");
						ye(Je == null ? void 0 : Je.key)
					}],
					[KEYBOARD_KEY.ARROW_UP, at => {
						at.preventDefault();
						const Je = Ue("preview");
						ye(Je == null ? void 0 : Je.key)
					}],
					[KEYBOARD_KEY.ARROW_RIGHT, at => {
						var Je, Ne;
						Ve.value || (at.preventDefault(), (Je = He.value) != null && Je.children && (Le(
							He.value.key), ye((Ne = He.value.children[0]) == null ? void 0 :
							Ne.key)))
					}],
					[KEYBOARD_KEY.ARROW_LEFT, at => {
						var Je;
						Ve.value || (at.preventDefault(), (Je = He.value) != null && Je.parent && (Le(He
							.value.parent.key), ye(He.value.parent.key)))
					}]
				])),
				ot = computed(() => {
					const at = [];
					return me.value.forEach((Je, Ne) => {
						var we, Ce;
						const $e = R.get(Ne);
						if ($e) at.push({
							value: Ne,
							label: (Ce = (we = o.formatLabel) == null ? void 0 : we.call(o, $e
								.path.map(Fe => Fe.raw))) != null ? Ce : getOptionLabel($e),
							closable: !$e.disabled,
							tagProps: $e.tagProps
						});
						else if (o.fallback) {
							const Fe = isFunction$2(o.fallback) ? o.fallback(Je) : isArray$2(Je) ? Je
								.join(" / ") : String(Je);
							at.push({
								value: Ne,
								label: Fe,
								closable: !0
							})
						}
					}), at
				});
			return {
				optionInfos: M,
				filteredLeafOptions: fe,
				selectedPath: Ae,
				activeKey: dt,
				displayColumns: xe,
				computedInputValue: he,
				computedPopupVisible: ce,
				handleClear: Me,
				selectViewValue: ot,
				handleInputValueChange: be,
				showSearchPanel: Ve,
				handlePopupVisibleChange: le,
				handleFocus: it,
				handleBlur: pt,
				handleRemove: de,
				mergedDisabled: A,
				handleKeyDown: nt,
				totalLevel: D
			}
		}
	});

function _sfc_render$2f(o, s, a, l, c, d) {
	const f = resolveComponent("select-view"),
		m = resolveComponent("cascader-search-panel"),
		g = resolveComponent("base-cascader-panel"),
		v = resolveComponent("trigger");
	return openBlock(), createBlock(v, mergeProps(o.triggerProps, {
		trigger: "click",
		"animation-name": "slide-dynamic-origin",
		"auto-fit-transform-origin": "",
		"popup-visible": o.computedPopupVisible,
		position: "bl",
		disabled: o.mergedDisabled,
		"popup-offset": 4,
		"auto-fit-popup-width": o.showSearchPanel,
		"popup-container": o.popupContainer,
		"prevent-focus": !0,
		"click-to-close": !o.allowSearch,
		onPopupVisibleChange: o.handlePopupVisibleChange
	}), {
		content: withCtx(() => [o.showSearchPanel ? (openBlock(), createBlock(m, {
			key: 0,
			options: o.filteredLeafOptions,
			"active-key": o.activeKey,
			multiple: o.multiple,
			"check-strictly": o.checkStrictly,
			loading: o.loading,
			"path-label": !o.searchOptionOnlyLabel
		}, createSlots({
			_: 2
		}, [o.$slots.empty ? {
			name: "empty",
			fn: withCtx(() => [renderSlot(o.$slots, "empty")]),
			key: "0"
		} : void 0]), 1032, ["options", "active-key", "multiple", "check-strictly",
			"loading", "path-label"
		])) : (openBlock(), createBlock(g, {
			key: 1,
			"display-columns": o.displayColumns,
			"selected-path": o.selectedPath,
			"active-key": o.activeKey,
			multiple: o.multiple,
			"total-level": o.totalLevel,
			"check-strictly": o.checkStrictly,
			loading: o.loading,
			"virtual-list-props": o.virtualListProps,
			dropdown: ""
		}, createSlots({
			_: 2
		}, [o.$slots.empty ? {
			name: "empty",
			fn: withCtx(() => [renderSlot(o.$slots, "empty")]),
			key: "0"
		} : void 0]), 1032, ["display-columns", "selected-path", "active-key", "multiple",
			"total-level", "check-strictly", "loading", "virtual-list-props"
		]))]),
		default: withCtx(() => [createVNode(f, mergeProps({
			"model-value": o.selectViewValue,
			"input-value": o.computedInputValue,
			disabled: o.mergedDisabled,
			error: o.error,
			multiple: o.multiple,
			"allow-clear": o.allowClear,
			"allow-search": o.allowSearch,
			size: o.size,
			opened: o.computedPopupVisible,
			placeholder: o.placeholder,
			loading: o.loading,
			"max-tag-count": o.maxTagCount,
			"tag-nowrap": o.tagNowrap
		}, o.$attrs, {
			onInputValueChange: o.handleInputValueChange,
			onClear: o.handleClear,
			onFocus: o.handleFocus,
			onBlur: o.handleBlur,
			onRemove: o.handleRemove,
			onKeydown: o.handleKeyDown
		}), createSlots({
			_: 2
		}, [o.$slots.label ? {
			name: "label",
			fn: withCtx(y => [renderSlot(o.$slots, "label", normalizeProps(
				guardReactiveProps(y)))]),
			key: "0"
		} : void 0, o.$slots.prefix ? {
			name: "prefix",
			fn: withCtx(() => [renderSlot(o.$slots, "prefix")]),
			key: "1"
		} : void 0, o.$slots["arrow-icon"] ? {
			name: "arrow-icon",
			fn: withCtx(() => [renderSlot(o.$slots, "arrow-icon")]),
			key: "2"
		} : void 0, o.$slots["loading-icon"] ? {
			name: "loading-icon",
			fn: withCtx(() => [renderSlot(o.$slots, "loading-icon")]),
			key: "3"
		} : void 0, o.$slots["search-icon"] ? {
			name: "search-icon",
			fn: withCtx(() => [renderSlot(o.$slots, "search-icon")]),
			key: "4"
		} : void 0]), 1040, ["model-value", "input-value", "disabled", "error", "multiple",
			"allow-clear", "allow-search", "size", "opened", "placeholder", "loading",
			"max-tag-count", "tag-nowrap", "onInputValueChange", "onClear", "onFocus", "onBlur",
			"onRemove", "onKeydown"
		])]),
		_: 3
	}, 16, ["popup-visible", "disabled", "auto-fit-popup-width", "popup-container", "click-to-close",
		"onPopupVisibleChange"
	])
}
var _Cascader = _export_sfc$1(_sfc_main$2x, [
	["render", _sfc_render$2f]
]);
const _sfc_main$2w = defineComponent({
	name: "CascaderPanel",
	components: {
		BaseCascaderPanel
	},
	props: {
		pathMode: {
			type: Boolean,
			default: !1
		},
		multiple: {
			type: Boolean,
			default: !1
		},
		modelValue: {
			type: [String, Number, Array]
		},
		defaultValue: {
			type: [String, Number, Array],
			default: o => o.multiple ? [] : o.pathMode ? void 0 : ""
		},
		options: {
			type: Array,
			default: () => []
		},
		expandTrigger: {
			type: String,
			default: "click"
		},
		checkStrictly: {
			type: Boolean,
			default: !1
		},
		loadMore: {
			type: Function
		},
		fieldNames: {
			type: Object
		},
		valueKey: {
			type: String,
			default: "value"
		},
		expandChild: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		"update:modelValue": o => !0,
		change: o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			options: l,
			checkStrictly: c,
			loadMore: d,
			modelValue: f,
			valueKey: m,
			expandChild: g,
			expandTrigger: v
		} = toRefs(o), y = ref(o.defaultValue);
		watch(f, le => {
			(isUndefined$1(le) || isNull$1(le)) && (y.value = o.multiple ? [] : void 0)
		});
		const b = ref([]),
			C = ref(1),
			_ = reactive(new Map),
			S = reactive(new Map),
			w = reactive(new Map),
			T = reactive(new Set),
			A = reactive({}),
			k = (le, de) => {
				A[de] = le
			},
			M = {
				value: "value",
				label: "label",
				disabled: "disabled",
				children: "children",
				tagProps: "tagProps",
				render: "render",
				isLeaf: "isLeaf"
			},
			D = computed(() => ({
				...M,
				...o.fieldNames
			}));
		watch([l, A, D], ([le, de, _e]) => {
			_.clear(), S.clear(), w.clear(), T.clear(), b.value = getOptionInfos(le ?? [], {
				enabledLazyLoad: !!o.loadMore,
				lazyLoadOptions: de,
				optionMap: _,
				leafOptionSet: T,
				leafOptionMap: S,
				leafOptionValueMap: w,
				totalLevel: C,
				checkStrictly: c,
				fieldNames: _e,
				valueKey: m
			})
		}, {
			immediate: !0
		});
		const F = computed(() => {
				var le;
				const de = getValidValues((le = o.modelValue) != null ? le : y.value, {
					multiple: o.multiple,
					pathMode: o.pathMode
				});
				return new Map(de.map(_e => [getValueKey(_e, {
					valueKey: o.valueKey,
					leafOptionValueMap: w
				}), _e]))
			}),
			R = computed(() => o.checkStrictly ? Array.from(_.values()) : Array.from(T)),
			O = le => {
				var de;
				const _e = o.multiple ? le : (de = le[0]) != null ? de : "";
				le.length === 0 && (ae(), ce()), y.value = _e, s("update:modelValue", _e), s("change", _e)
			},
			U = le => {
				O([o.pathMode ? le.pathValue : le.value])
			},
			V = (le, de) => {
				if (de) {
					const _e = o.checkStrictly ? [le] : getLeafOptionInfos(le);
					O([...F.value.values(), ..._e.filter(ke => !F.value.has(ke.key)).map(ke => o.pathMode ? ke
						.pathValue : ke.value)])
				} else {
					const _e = o.checkStrictly ? [le.key] : getLeafOptionKeys(le),
						ke = [];
					F.value.forEach((De, Se) => {
						_e.includes(Se) || ke.push(De)
					}), O(ke)
				}
			},
			z = (le, de) => {
				o.multiple ? V(le, de ?? !0) : U(le)
			},
			{
				activeKey: j,
				activeOption: ge,
				selectedPath: me,
				displayColumns: he,
				setActiveKey: ce,
				setSelectedPath: ae,
				getNextActiveNode: fe
			} = useSelectedPath(b, {
				optionMap: _,
				filteredLeafOptions: R,
				expandChild: g
			});
		provide(cascaderInjectionKey, reactive({
			onClickOption: z,
			setActiveKey: ce,
			setSelectedPath: ae,
			loadMore: d,
			addLazyLoadOptions: k,
			slots: a,
			valueMap: F,
			expandTrigger: v
		}));
		const q = getKeyDownHandler(new Map([
			[KEYBOARD_KEY.ENTER, le => {
				if (ge.value) {
					let de;
					o.checkStrictly || ge.value.isLeaf ? de = !F.value.has(ge.value.key) :
						de = !getCheckedStatus(ge.value, F.value).checked, ae(ge.value.key), z(
							ge.value, de)
				}
			}],
			[KEYBOARD_KEY.ARROW_DOWN, le => {
				le.preventDefault();
				const de = fe("next");
				ce(de == null ? void 0 : de.key)
			}],
			[KEYBOARD_KEY.ARROW_UP, le => {
				le.preventDefault();
				const de = fe("preview");
				ce(de == null ? void 0 : de.key)
			}],
			[KEYBOARD_KEY.ARROW_RIGHT, le => {
				var de, _e;
				le.preventDefault(), (de = ge.value) != null && de.children && (ae(ge.value
					.key), ce((_e = ge.value.children[0]) == null ? void 0 : _e.key))
			}],
			[KEYBOARD_KEY.ARROW_LEFT, le => {
				var de;
				le.preventDefault(), (de = ge.value) != null && de.parent && (ae(ge.value.parent
					.key), ce(ge.value.parent.key))
			}]
		]));
		return {
			optionInfos: b,
			filteredLeafOptions: R,
			selectedPath: me,
			activeKey: j,
			displayColumns: he,
			handleKeyDown: q,
			totalLevel: C
		}
	}
});

function _sfc_render$2e(o, s, a, l, c, d) {
	const f = resolveComponent("base-cascader-panel");
	return openBlock(), createBlock(f, {
		"display-columns": o.displayColumns,
		"selected-path": o.selectedPath,
		"active-key": o.activeKey,
		multiple: o.multiple,
		"total-level": o.totalLevel,
		"check-strictly": o.checkStrictly,
		onKeydown: o.handleKeyDown
	}, createSlots({
		_: 2
	}, [o.$slots.empty ? {
		name: "empty",
		fn: withCtx(() => [renderSlot(o.$slots, "empty")]),
		key: "0"
	} : void 0]), 1032, ["display-columns", "selected-path", "active-key", "multiple", "total-level",
		"check-strictly", "onKeydown"
	])
}
var CascaderPanel = _export_sfc$1(_sfc_main$2w, [
	["render", _sfc_render$2e]
]);
const Cascader = Object.assign(_Cascader, {
		CascaderPanel,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Cascader.name, _Cascader), o.component(a + CascaderPanel.name, CascaderPanel)
		}
	}),
	collapseKey = Symbol("collapseCtx"),
	_sfc_main$2v = defineComponent({
		name: "Collapse",
		props: {
			activeKey: {
				type: Array,
				default: void 0
			},
			defaultActiveKey: {
				type: Array,
				default: () => []
			},
			accordion: {
				type: Boolean,
				default: !1
			},
			showExpandIcon: {
				type: Boolean,
				default: void 0
			},
			expandIconPosition: {
				type: String,
				default: "left"
			},
			bordered: {
				type: Boolean,
				default: !0
			},
			destroyOnHide: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:activeKey": o => !0,
			change: (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				expandIconPosition: l,
				destroyOnHide: c,
				showExpandIcon: d
			} = toRefs(o), f = getPrefixCls("collapse"), m = ref(o.defaultActiveKey), g = computed(() => {
				var b;
				const C = (b = o.activeKey) != null ? b : m.value;
				return isArray$2(C) ? C : [C]
			});
			provide(collapseKey, reactive({
				activeKeys: g,
				slots: a,
				showExpandIcon: d,
				expandIconPosition: l,
				destroyOnHide: c,
				handleClick: (b, C) => {
					let _ = [];
					if (o.accordion) g.value.includes(b) || (_ = [b]), m.value = _;
					else {
						_ = [...g.value];
						const S = _.indexOf(b);
						S > -1 ? _.splice(S, 1) : o.accordion ? _ = [b] : _.push(b), m.value = _
					}
					s("update:activeKey", _), s("change", _, C)
				}
			}));
			const y = computed(() => [f, {
				[`${f}-borderless`]: !o.bordered
			}]);
			return {
				prefixCls: f,
				cls: y
			}
		}
	});

function _sfc_render$2d(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [renderSlot(o.$slots, "default")], 2)
}
var _Collapse = _export_sfc$1(_sfc_main$2v, [
	["render", _sfc_render$2d]
]);
const _sfc_main$2u = defineComponent({
		name: "IconCaretRight",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-caret-right`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$Z = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2c(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M34.829 23.063c.6.48.6 1.394 0 1.874L17.949 38.44c-.785.629-1.949.07-1.949-.937V10.497c0-1.007 1.164-1.566 1.95-.937l16.879 13.503Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$Z)
}
var _IconCaretRight = _export_sfc$1(_sfc_main$2u, [
	["render", _sfc_render$2c]
]);
const IconCaretRight = Object.assign(_IconCaretRight, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconCaretRight.name, _IconCaretRight)
		}
	}),
	_sfc_main$2t = defineComponent({
		name: "IconCaretLeft",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-caret-left`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$Y = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2b(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M13.171 24.937a1.2 1.2 0 0 1 0-1.874L30.051 9.56c.785-.629 1.949-.07 1.949.937v27.006c0 1.006-1.164 1.566-1.95.937L13.171 24.937Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$Y)
}
var _IconCaretLeft = _export_sfc$1(_sfc_main$2t, [
	["render", _sfc_render$2b]
]);
const IconCaretLeft = Object.assign(_IconCaretLeft, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconCaretLeft.name, _IconCaretLeft)
	}
});
var CollapseItem = defineComponent({
	name: "CollapseItem",
	components: {
		IconHover,
		IconCaretRight,
		IconCaretLeft
	},
	props: {
		header: String,
		disabled: {
			type: Boolean,
			default: !1
		},
		showExpandIcon: {
			type: Boolean,
			default: !0
		},
		destroyOnHide: {
			type: Boolean,
			default: !1
		}
	},
	setup(o, {
		slots: s
	}) {
		var a;
		const l = getCurrentInstance(),
			c = getPrefixCls("collapse-item"),
			d = inject(collapseKey, {}),
			f = l && isNumber$2(l == null ? void 0 : l.vnode.key) ? l.vnode.key : String((a = l == null ?
				void 0 : l.vnode.key) != null ? a : ""),
			m = computed(() => {
				var D;
				return (D = d.activeKeys) == null ? void 0 : D.includes(f)
			}),
			g = computed(() => d.destroyOnHide || o.destroyOnHide),
			v = computed(() => {
				var D;
				return (D = d == null ? void 0 : d.showExpandIcon) != null ? D : o.showExpandIcon
			}),
			y = ref(g.value ? m.value : !0),
			b = computed(() => {
				var D;
				return (D = d == null ? void 0 : d.expandIconPosition) != null ? D : "left"
			}),
			C = D => {
				var F;
				o.disabled || (F = d.handleClick) == null || F.call(d, f, D)
			};
		watch(m, D => {
			D && !y.value && (y.value = !0)
		});
		const _ = {
				onEnter: D => {
					D.style.height = `${D.scrollHeight}px`
				},
				onAfterEnter: D => {
					D.style.height = "auto"
				},
				onBeforeLeave: D => {
					D.style.height = `${D.scrollHeight}px`
				},
				onLeave: D => {
					D.style.height = "0"
				},
				onAfterLeave: () => {
					g.value && (y.value = !1)
				}
			},
			S = computed(() => [c, {
				[`${c}-active`]: m.value
			}]),
			w = computed(() => [`${c}-header`, `${c}-header-${d==null?void 0:d.expandIconPosition}`, {
				[`${c}-header-disabled`]: o.disabled
			}]),
			T = computed(() => [{
				[`${c}-icon-right`]: (d == null ? void 0 : d.expandIconPosition) === "right"
			}]),
			A = computed(() => [`${c}-content`, {
				[`${c}-content-expend`]: m.value
			}]),
			k = () => b.value === "right" ? createVNode(resolveComponent("icon-caret-left"), {
				class: `${c}-expand-icon`
			}, null) : createVNode(resolveComponent("icon-caret-right"), {
				class: `${c}-expand-icon`
			}, null),
			M = () => v.value && createVNode(resolveComponent("icon-hover"), {
				prefix: c,
				class: T.value,
				disabled: o.disabled
			}, {
				default: () => {
					var D, F, R, O;
					return [(O = (R = (F = s["expand-icon"]) != null ? F : (D = d == null ? void 0 : d
						.slots) == null ? void 0 : D["expand-icon"]) == null ? void 0 : R({
						active: m.value,
						disabled: o.disabled,
						position: b.value
					})) != null ? O : k()]
				}
			});
		return () => {
			var D, F, R;
			return createVNode("div", {
				class: S.value
			}, [createVNode("div", {
				role: "button",
				"aria-disabled": o.disabled,
				"aria-expanded": m.value,
				tabindex: "0",
				class: w.value,
				onClick: C
			}, [M(), createVNode("div", {
				class: `${c}-header-title`
			}, [(F = (D = s.header) == null ? void 0 : D.call(s)) != null ? F : o
				.header
			]), s.extra && createVNode("div", {
				class: `${c}-header-extra`
			}, [(R = s.extra) == null ? void 0 : R.call(s)])]), createVNode(Transition,
				mergeProps({
					name: "collapse-slider"
				}, _), {
					default: () => {
						var O;
						return [withDirectives(createVNode("div", {
							role: "region",
							class: A.value
						}, [y.value && createVNode("div", {
							ref: "contentBoxRef",
							class: `${c}-content-box`
						}, [(O = s.default) == null ? void 0 : O
							.call(s)
						])]), [
							[vShow, m.value]
						])]
					}
				})])
		}
	}
});
const Collapse = Object.assign(_Collapse, {
		Item: CollapseItem,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Collapse.name, _Collapse), o.component(a + CollapseItem.name, CollapseItem)
		}
	}),
	colors = ["#00B42A", "#3C7EFF", "#FF7D00", "#F76965", "#F7BA1E", "#F5319D", "#D91AD9", "#9FDB1D", "#FADC19",
		"#722ED1", "#3491FA", "#7BE188", "#93BEFF", "#FFCF8B", "#FBB0A7", "#FCE996", "#FB9DC7", "#F08EE6", "#DCF190",
		"#FDFA94", "#C396ED", "#9FD4FD"
	],
	hsvToRgb = (o, s, a) => {
		const l = Math.floor(o * 6),
			c = o * 6 - l,
			d = a * (1 - s),
			f = a * (1 - c * s),
			m = a * (1 - (1 - c) * s),
			g = l % 6,
			v = [a, f, d, d, m, a][g],
			y = [m, a, a, f, d, d][g],
			b = [d, d, m, a, a, f][g];
		return {
			r: Math.round(v * 255),
			g: Math.round(y * 255),
			b: Math.round(b * 255)
		}
	},
	rgbToHsv = (o, s, a) => {
		o /= 255, s /= 255, a /= 255;
		const l = Math.max(o, s, a),
			c = Math.min(o, s, a);
		let d = 0;
		const f = l,
			m = l - c,
			g = l === 0 ? 0 : m / l;
		if (l === c) d = 0;
		else {
			switch (l) {
				case o:
					d = (s - a) / m + (s < a ? 6 : 0);
					break;
				case s:
					d = (a - o) / m + 2;
					break;
				case a:
					d = (o - s) / m + 4;
					break
			}
			d /= 6
		}
		return {
			h: d,
			s: g,
			v: f
		}
	},
	CSS_INTEGER = "[-\\+]?\\d+%?",
	CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?",
	CSS_UNIT = `(?:${CSS_NUMBER})|(?:${CSS_INTEGER})`,
	PERMISSIVE_MATCH3 = `[\\s|\\(]+(${CSS_UNIT})[,|\\s]+(${CSS_UNIT})[,|\\s]+(${CSS_UNIT})\\s*\\)?`,
	PERMISSIVE_MATCH4 =
	`[\\s|\\(]+(${CSS_UNIT})[,|\\s]+(${CSS_UNIT})[,|\\s]+(${CSS_UNIT})[,|\\s]+(${CSS_UNIT})\\s*\\)?`,
	matchers = {
		rgb: new RegExp(`rgb${PERMISSIVE_MATCH3}`),
		rgba: new RegExp(`rgba${PERMISSIVE_MATCH4}`),
		hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
		hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	},
	parseIntFromHex = o => parseInt(o, 16),
	convertHexToDecimal = o => parseIntFromHex(o) / 255,
	formatInputToRgb = o => {
		let s = matchers.rgb.exec(o);
		return s ? {
			r: parseInt(s[1], 10),
			g: parseInt(s[2], 10),
			b: parseInt(s[3], 10)
		} : (s = matchers.rgba.exec(o), s ? {
			r: parseInt(s[1], 10),
			g: parseInt(s[2], 10),
			b: parseInt(s[3], 10),
			a: parseFloat(s[4])
		} : (s = matchers.hex8.exec(o), s ? {
			r: parseIntFromHex(s[1]),
			g: parseIntFromHex(s[2]),
			b: parseIntFromHex(s[3]),
			a: convertHexToDecimal(s[4])
		} : (s = matchers.hex6.exec(o), s ? {
			r: parseIntFromHex(s[1]),
			g: parseIntFromHex(s[2]),
			b: parseIntFromHex(s[3])
		} : (s = matchers.hex4.exec(o), s ? {
			r: parseIntFromHex(s[1] + s[1]),
			g: parseIntFromHex(s[2] + s[2]),
			b: parseIntFromHex(s[3] + s[3]),
			a: convertHexToDecimal(s[4] + s[4])
		} : (s = matchers.hex3.exec(o), s ? {
			r: parseIntFromHex(s[1] + s[1]),
			g: parseIntFromHex(s[2] + s[2]),
			b: parseIntFromHex(s[3] + s[3])
		} : !1)))))
	},
	formatInputToHSVA = o => {
		var s;
		const a = formatInputToRgb(o);
		return a ? {
			...rgbToHsv(a.r, a.g, a.b),
			a: (s = a.a) != null ? s : 1
		} : {
			h: 0,
			s: 1,
			v: 1,
			a: 1
		}
	},
	hexToRgb = o => {
		if (o = o.trim().toLowerCase(), o.length === 0) return !1;
		let s = matchers.hex6.exec(o);
		return s ? {
			r: parseIntFromHex(s[1]),
			g: parseIntFromHex(s[2]),
			b: parseIntFromHex(s[3])
		} : (s = matchers.hex3.exec(o), s ? {
			r: parseIntFromHex(s[1] + s[1]),
			g: parseIntFromHex(s[2] + s[2]),
			b: parseIntFromHex(s[3] + s[3])
		} : !1)
	},
	rgbToHex = (o, s, a) => [Math.round(o).toString(16).padStart(2, "0"), Math.round(s).toString(16).padStart(2, "0"),
		Math.round(a).toString(16).padStart(2, "0")
	].join("").toUpperCase(),
	rgbaToHex = (o, s, a, l) => [Math.round(o).toString(16).padStart(2, "0"), Math.round(s).toString(16).padStart(2,
		"0"), Math.round(a).toString(16).padStart(2, "0"), Math.round(l * 255).toString(16).padStart(2, "0")].join("")
	.toUpperCase(),
	useControlBlock = ({
		value: o,
		onChange: s
	}) => {
		const a = ref(!1),
			l = ref(),
			c = ref(),
			d = (y, b) => y < 0 ? 0 : y > b ? 1 : y / b,
			f = y => {
				if (!l.value) return;
				const {
					clientX: b,
					clientY: C
				} = y, _ = l.value.getBoundingClientRect(), S = [d(b - _.x, _.width), d(C - _.y, _.height)];
				(S[0] !== o[0] || S[1] !== o[1]) && (s == null || s(S))
			},
			m = () => {
				a.value = !1, window.removeEventListener("mousemove", v), window.removeEventListener("mouseup", m),
					window.removeEventListener("contextmenu", m)
			},
			g = y => {
				a.value = !0, f(y), window.addEventListener("mousemove", v), window.addEventListener("mouseup", m),
					window.addEventListener("contextmenu", m)
			};

		function v(y) {
			y.preventDefault(), y.buttons > 0 ? f(y) : m()
		}
		return {
			active: a,
			blockRef: l,
			handlerRef: c,
			onMouseDown: g
		}
	};
var ControlBar = defineComponent({
		name: "ControlBar",
		props: {
			x: {
				type: Number,
				required: !0
			},
			color: {
				type: Object,
				required: !0
			},
			colorString: String,
			type: String,
			onChange: Function
		},
		setup(o) {
			const s = getPrefixCls("color-picker"),
				a = computed(() => o.color.rgb),
				{
					blockRef: l,
					handlerRef: c,
					onMouseDown: d
				} = useControlBlock({
					value: [o.x, 0],
					onChange: m => {
						var g;
						return (g = o.onChange) == null ? void 0 : g.call(o, m[0])
					}
				}),
				f = () => createVNode("div", {
					ref: c,
					class: `${s}-handler`,
					style: {
						left: `${o.x*100}%`,
						color: o.colorString
					}
				}, null);
			return () => o.type === "alpha" ? createVNode("div", {
				class: `${s}-control-bar-bg`
			}, [createVNode("div", {
				ref: l,
				class: [`${s}-control-bar`, `${s}-control-bar-alpha`],
				style: {
					background: `linear-gradient(to right, rgba(0, 0, 0, 0), rgb(${a.value.r}, ${a.value.g}, ${a.value.b}))`
				},
				onMousedown: d
			}, [f()])]) : createVNode("div", {
				ref: l,
				class: [`${s}-control-bar`, `${s}-control-bar-hue`],
				onMousedown: d
			}, [f()])
		}
	}),
	Palette = defineComponent({
		name: "Palette",
		props: {
			color: {
				type: Object,
				required: !0
			},
			onChange: Function
		},
		setup(o) {
			const s = getPrefixCls("color-picker"),
				a = computed(() => o.color.hsv),
				{
					blockRef: l,
					handlerRef: c,
					onMouseDown: d
				} = useControlBlock({
					value: [a.value.s, 1 - a.value.v],
					onChange: m => {
						var g;
						return (g = o.onChange) == null ? void 0 : g.call(o, m[0], 1 - m[1])
					}
				}),
				f = computed(() => {
					const m = hsvToRgb(a.value.h, 1, 1);
					return `rgb(${m.r}, ${m.g}, ${m.b})`
				});
			return () => createVNode("div", {
				ref: l,
				class: `${s}-palette`,
				style: {
					backgroundColor: f.value
				},
				onMousedown: d
			}, [createVNode("div", {
				ref: c,
				class: `${s}-handler`,
				style: {
					top: `${(1-a.value.v)*100}%`,
					left: `${a.value.s*100}%`
				}
			}, null)])
		}
	});

function strip(o, s) {
	return s === void 0 && (s = 15), +parseFloat(Number(o).toPrecision(s))
}

function digitLength(o) {
	var s = o.toString().split(/[eE]/),
		a = (s[0].split(".")[1] || "").length - +(s[1] || 0);
	return a > 0 ? a : 0
}

function float2Fixed(o) {
	if (o.toString().indexOf("e") === -1) return Number(o.toString().replace(".", ""));
	var s = digitLength(o);
	return s > 0 ? strip(Number(o) * Math.pow(10, s)) : Number(o)
}

function checkBoundary(o) {
	_boundaryCheckingState && (o > Number.MAX_SAFE_INTEGER || o < Number.MIN_SAFE_INTEGER) && console.warn(o +
		" is beyond boundary when transfer to integer, the results may not be accurate")
}

function createOperation(o) {
	return function() {
		for (var s = [], a = 0; a < arguments.length; a++) s[a] = arguments[a];
		var l = s[0],
			c = s.slice(1);
		return c.reduce(function(d, f) {
			return o(d, f)
		}, l)
	}
}
var times = createOperation(function(o, s) {
		var a = float2Fixed(o),
			l = float2Fixed(s),
			c = digitLength(o) + digitLength(s),
			d = a * l;
		return checkBoundary(d), d / Math.pow(10, c)
	}),
	plus = createOperation(function(o, s) {
		var a = Math.pow(10, Math.max(digitLength(o), digitLength(s)));
		return (times(o, a) + times(s, a)) / a
	}),
	minus = createOperation(function(o, s) {
		var a = Math.pow(10, Math.max(digitLength(o), digitLength(s)));
		return (times(o, a) - times(s, a)) / a
	}),
	divide$1 = createOperation(function(o, s) {
		var a = float2Fixed(o),
			l = float2Fixed(s);
		return checkBoundary(a), checkBoundary(l), times(a / l, strip(Math.pow(10, digitLength(s) - digitLength(
			o))))
	});

function round$1(o, s) {
	var a = Math.pow(10, s),
		l = divide$1(Math.round(Math.abs(times(o, a))), a);
	return o < 0 && l !== 0 && (l = times(l, -1)), l
}
var _boundaryCheckingState = !0;

function enableBoundaryChecking(o) {
	o === void 0 && (o = !0), _boundaryCheckingState = o
}
var index = {
	strip,
	plus,
	minus,
	times,
	divide: divide$1,
	round: round$1,
	digitLength,
	float2Fixed,
	enableBoundaryChecking
};
const _sfc_main$2s = defineComponent({
		name: "IconPlus",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-plus`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$X = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2a(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M5 24h38M24 5v38"
	}, null, -1)]), 14, _hoisted_1$X)
}
var _IconPlus = _export_sfc$1(_sfc_main$2s, [
	["render", _sfc_render$2a]
]);
const IconPlus = Object.assign(_IconPlus, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconPlus.name, _IconPlus)
		}
	}),
	_sfc_main$2r = defineComponent({
		name: "IconMinus",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-minus`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$W = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$29(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M5 24h38"
	}, null, -1)]), 14, _hoisted_1$W)
}
var _IconMinus = _export_sfc$1(_sfc_main$2r, [
	["render", _sfc_render$29]
]);
const IconMinus = Object.assign(_IconMinus, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconMinus.name, _IconMinus)
		}
	}),
	FIRST_DELAY = 800,
	SPEED = 150;
index.enableBoundaryChecking(!1);
var _InputNumber = defineComponent({
	name: "InputNumber",
	props: {
		modelValue: Number,
		defaultValue: Number,
		mode: {
			type: String,
			default: "embed"
		},
		precision: Number,
		step: {
			type: Number,
			default: 1
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		error: {
			type: Boolean,
			default: !1
		},
		max: {
			type: Number,
			default: 1 / 0
		},
		min: {
			type: Number,
			default: -1 / 0
		},
		formatter: {
			type: Function
		},
		parser: {
			type: Function
		},
		placeholder: String,
		hideButton: {
			type: Boolean,
			default: !1
		},
		size: {
			type: String
		},
		allowClear: {
			type: Boolean,
			default: !1
		},
		modelEvent: {
			type: String,
			default: "change"
		},
		readOnly: {
			type: Boolean,
			default: !1
		},
		inputAttrs: {
			type: Object
		}
	},
	emits: {
		"update:modelValue": o => !0,
		change: (o, s) => !0,
		focus: o => !0,
		blur: o => !0,
		clear: o => !0,
		input: (o, s, a) => !0,
		keydown: o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		var l;
		const {
			size: c,
			disabled: d
		} = toRefs(o), f = getPrefixCls("input-number"), m = ref(), {
			mergedSize: g,
			mergedDisabled: v,
			eventHandlers: y
		} = useFormItem({
			size: c,
			disabled: d
		}), {
			mergedSize: b
		} = useSize$1(g), C = computed(() => {
			if (isNumber$2(o.precision)) {
				const _e = `${o.step}`.split(".")[1],
					ke = _e && _e.length || 0;
				return Math.max(ke, o.precision)
			}
		}), _ = _e => {
			var ke, De;
			if (!isNumber$2(_e)) return "";
			const Se = C.value ? _e.toFixed(C.value) : String(_e);
			return (De = (ke = o.formatter) == null ? void 0 : ke.call(o, Se)) != null ? De : Se
		}, S = ref(_((l = o.modelValue) != null ? l : o.defaultValue)), w = computed(() => {
			var _e, ke;
			if (!S.value) return;
			const De = Number((ke = (_e = o.parser) == null ? void 0 : _e.call(o, S.value)) != null ?
				ke : S.value);
			return Number.isNaN(De) ? void 0 : De
		}), T = ref(isNumber$2(w.value) && w.value <= o.min), A = ref(isNumber$2(w.value) && w.value >= o
			.max);
		let k = 0;
		const M = () => {
				k && (window.clearTimeout(k), k = 0)
			},
			D = _e => {
				if (!isUndefined$1(_e)) return isNumber$2(o.min) && _e < o.min && (_e = o.min), isNumber$2(o
						.max) && _e > o.max && (_e = o.max), isNumber$2(C.value) ? index.round(_e, C
					.value) : _e
			},
			F = _e => {
				let ke = !1,
					De = !1;
				isNumber$2(_e) && (_e <= o.min && (ke = !0), _e >= o.max && (De = !0)), A.value !== De && (A
					.value = De), T.value !== ke && (T.value = ke)
			},
			R = () => {
				const _e = D(w.value),
					ke = _(_e);
				(_e !== w.value || S.value !== ke) && (S.value = ke), s("update:modelValue", _e)
			};
		watch(() => [o.max, o.min], () => {
			R(), F(w.value)
		});
		const O = (_e, ke) => {
				if (v.value || _e === "plus" && A.value || _e === "minus" && T.value) return;
				let De;
				isNumber$2(w.value) ? De = D(index[_e](w.value, o.step)) : De = o.min === -1 / 0 ? 0 : o.min, S
					.value = _(De), F(De), s("update:modelValue", De), s("change", De, ke)
			},
			U = (_e, ke, De = !1) => {
				var Se;
				_e.preventDefault(), !o.readOnly && ((Se = m.value) == null || Se.focus(), O(ke, _e), De && (k =
					window.setTimeout(() => _e.target.dispatchEvent(_e), k ? SPEED : FIRST_DELAY)))
			},
			V = (_e, ke) => {
				var De, Se, be, Me;
				_e = _e.trim().replace(/。/g, "."), _e = (Se = (De = o.parser) == null ? void 0 : De.call(o,
					_e)) != null ? Se : _e, (isNumber$2(Number(_e)) || /^(\.|-)$/.test(_e)) && (S.value = (Me =
							(be = o.formatter) == null ? void 0 : be.call(o, _e)) != null ? Me : _e, F(w.value),
						s("input", w.value, S.value, ke), o.modelEvent === "input" && (s("update:modelValue", w
							.value), s("change", w.value, ke)))
			},
			z = _e => {
				s("focus", _e)
			},
			j = (_e, ke) => {
				ke instanceof MouseEvent && !_e || (R(), s("change", w.value, ke))
			},
			ge = _e => {
				s("blur", _e)
			},
			me = _e => {
				var ke, De;
				S.value = "", s("update:modelValue", void 0), s("change", void 0, _e), (De = (ke = y.value) ==
					null ? void 0 : ke.onChange) == null || De.call(ke, _e), s("clear", _e)
			},
			he = getKeyDownHandler(new Map([
				[KEYBOARD_KEY.ARROW_UP, _e => {
					_e.preventDefault(), !o.readOnly && O("plus", _e)
				}],
				[KEYBOARD_KEY.ARROW_DOWN, _e => {
					_e.preventDefault(), !o.readOnly && O("minus", _e)
				}]
			])),
			ce = _e => {
				s("keydown", _e), _e.defaultPrevented || he(_e)
			};
		watch(() => o.modelValue, _e => {
			_e !== w.value && (S.value = _(_e), F(_e))
		});
		const ae = () => {
				var _e, ke, De;
				return o.readOnly ? null : createVNode(Fragment, null, [a.suffix && createVNode("div", {
					class: `${f}-suffix`
				}, [(_e = a.suffix) == null ? void 0 : _e.call(a)]), createVNode("div", {
					class: `${f}-step`
				}, [createVNode("button", {
					class: [`${f}-step-button`, {
						[`${f}-step-button-disabled`]: v.value || A.value
					}],
					type: "button",
					tabindex: "-1",
					disabled: v.value || A.value,
					onMousedown: Se => U(Se, "plus", !0),
					onMouseup: M,
					onMouseleave: M
				}, [a.plus ? (ke = a.plus) == null ? void 0 : ke.call(a) : createVNode(
					IconUp, null, null)]), createVNode("button", {
					class: [`${f}-step-button`, {
						[`${f}-step-button-disabled`]: v.value || T.value
					}],
					type: "button",
					tabindex: "-1",
					disabled: v.value || T.value,
					onMousedown: Se => U(Se, "minus", !0),
					onMouseup: M,
					onMouseleave: M
				}, [a.minus ? (De = a.minus) == null ? void 0 : De.call(a) :
					createVNode(IconDown, null, null)
				])])])
			},
			fe = computed(() => [f, `${f}-mode-${o.mode}`, `${f}-size-${b.value}`, {
				[`${f}-readonly`]: o.readOnly
			}]),
			q = () => createVNode(Button, {
				size: b.value,
				tabindex: "-1",
				class: `${f}-step-button`,
				disabled: v.value || T.value,
				onMousedown: _e => U(_e, "minus", !0),
				onMouseup: M,
				onMouseleave: M
			}, {
				icon: () => createVNode(IconMinus, null, null)
			}),
			le = () => createVNode(Button, {
				size: b.value,
				tabindex: "-1",
				class: `${f}-step-button`,
				disabled: v.value || A.value,
				onMousedown: _e => U(_e, "plus", !0),
				onMouseup: M,
				onMouseleave: M
			}, {
				icon: () => createVNode(IconPlus, null, null)
			});
		return {
			inputRef: m,
			render: () => {
				const _e = o.mode === "embed" ? {
					prepend: a.prepend,
					prefix: a.prefix,
					suffix: o.hideButton ? a.suffix : ae,
					append: a.append
				} : {
					prepend: o.hideButton ? a.prepend : q,
					prefix: a.prefix,
					suffix: a.suffix,
					append: o.hideButton ? a.append : le
				};
				return createVNode(Input, {
					key: `__arco__${o.mode}`,
					ref: m,
					class: fe.value,
					type: "text",
					allowClear: o.allowClear,
					size: b.value,
					modelValue: S.value,
					placeholder: o.placeholder,
					disabled: v.value,
					readonly: o.readOnly,
					error: o.error,
					inputAttrs: {
						role: "spinbutton",
						"aria-valuemax": o.max,
						"aria-valuemin": o.min,
						"aria-valuenow": S.value,
						...o.inputAttrs
					},
					onInput: V,
					onFocus: z,
					onBlur: ge,
					onClear: me,
					onChange: j,
					onKeydown: ce
				}, _e)
			}
		}
	},
	methods: {
		focus() {
			var o;
			(o = this.inputRef) == null || o.focus()
		},
		blur() {
			var o;
			(o = this.inputRef) == null || o.blur()
		}
	},
	render() {
		return this.render()
	}
});
const InputNumber = Object.assign(_InputNumber, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _InputNumber.name, _InputNumber)
	}
});
var InputAlpha = defineComponent({
		name: "InputAlpha",
		props: {
			value: {
				type: Number,
				required: !0
			},
			disabled: Boolean,
			onChange: Function
		},
		setup(o) {
			const s = getPrefixCls("color-picker");
			return () => createVNode(InputNumber, {
				class: `${s}-input-alpha`,
				size: "mini",
				min: 0,
				max: 100,
				disabled: o.disabled,
				modelValue: Math.round(o.value * 100),
				onChange: (a = 100) => {
					var l;
					return (l = o.onChange) == null ? void 0 : l.call(o, a / 100)
				}
			}, {
				suffix: () => "%"
			})
		}
	}),
	InputRgb = defineComponent({
		name: "InputRgb",
		props: {
			color: {
				type: Object,
				required: !0
			},
			alpha: {
				type: Number,
				required: !0
			},
			disabled: Boolean,
			disabledAlpha: Boolean,
			onHsvChange: Function,
			onAlphaChange: Function
		},
		setup(o) {
			const s = getPrefixCls("color-picker"),
				{
					color: a
				} = toRefs(o),
				l = c => {
					var d;
					const f = {
							...a.value.rgb,
							...c
						},
						m = rgbToHsv(f.r, f.g, f.b);
					(d = o.onHsvChange) == null || d.call(o, m)
				};
			return () => createVNode(InputGroup, {
				class: `${s}-input-group`
			}, {
				default: () => [
					["r", "g", "b"].map(c => createVNode(InputNumber, {
						key: c,
						size: "mini",
						min: 0,
						max: 255,
						disabled: o.disabled,
						modelValue: a.value.rgb[c],
						hideButton: !0,
						onChange: (d = 0) => l({
							[c]: d
						})
					}, null)), !o.disabledAlpha && createVNode(InputAlpha, {
						disabled: o.disabled,
						value: o.alpha,
						onChange: o.onAlphaChange
					}, null)
				]
			})
		}
	}),
	InputHex = defineComponent({
		name: "InputHex",
		props: {
			color: {
				type: Object,
				required: !0
			},
			alpha: {
				type: Number,
				required: !0
			},
			disabled: Boolean,
			disabledAlpha: Boolean,
			onHsvChange: Function,
			onAlphaChange: Function
		},
		setup(o) {
			const s = getPrefixCls("color-picker"),
				{
					color: a
				} = toRefs(o),
				[l, c] = useState(a.value.hex),
				d = g => {
					var v;
					const y = hexToRgb(g) || {
							r: 255,
							g: 0,
							b: 0
						},
						b = rgbToHsv(y.r, y.g, y.b);
					(v = o.onHsvChange) == null || v.call(o, b)
				},
				f = g => {
					var v, y;
					const b = (y = (v = g.match(/[a-fA-F0-9]*/g)) == null ? void 0 : v.join("")) != null ? y : "";
					b !== a.value.hex && d(b.toUpperCase())
				},
				m = g => {
					if (!g.clipboardData) return;
					let v = g.clipboardData.getData("Text");
					v.startsWith("#") && (v = v.slice(1)), f(v), g.preventDefault()
				};
			return watch(a, () => {
				a.value.hex !== l.value && c(a.value.hex)
			}), () => createVNode(InputGroup, {
				class: `${s}-input-group`
			}, {
				default: () => [createVNode(Input, {
					class: `${s}-input-hex`,
					size: "mini",
					maxLength: 6,
					disabled: o.disabled,
					modelValue: l.value,
					onInput: c,
					onChange: f,
					onBlur: () => d,
					onPressEnter: () => d,
					onPaste: m
				}, {
					prefix: () => "#"
				}), !o.disabledAlpha && createVNode(InputAlpha, {
					disabled: o.disabled,
					value: o.alpha,
					onChange: o.onAlphaChange
				}, null)]
			})
		}
	}),
	Panel$2 = defineComponent({
		name: "Panel",
		props: {
			color: {
				type: Object,
				required: !0
			},
			alpha: {
				type: Number,
				required: !0
			},
			colorString: String,
			disabled: Boolean,
			disabledAlpha: Boolean,
			showHistory: Boolean,
			showPreset: Boolean,
			format: String,
			historyColors: Array,
			presetColors: Array,
			onAlphaChange: Function,
			onHsvChange: Function
		},
		setup(o) {
			const {
				t: s
			} = useI18n(), a = getPrefixCls("color-picker"), l = computed(() => o.color.hsv), [c, d] = useState(o
				.format || "hex"), f = C => {
				d(C)
			};
			ref(!1);
			const m = C => {
					var _;
					const S = hexToRgb(C) || {
							r: 255,
							g: 0,
							b: 0
						},
						w = rgbToHsv(S.r, S.g, S.b);
					(_ = o.onHsvChange) == null || _.call(o, w)
				},
				g = () => {
					const C = {
						color: o.color,
						alpha: o.alpha,
						disabled: o.disabled,
						disabledAlpha: o.disabledAlpha,
						onHsvChange: o.onHsvChange,
						onAlphaChange: o.onAlphaChange
					};
					return c.value === "rgb" ? createVNode(InputRgb, C, null) : createVNode(InputHex, C, null)
				},
				v = C => createVNode("div", {
					key: C,
					class: `${a}-color-block`,
					style: {
						backgroundColor: C
					},
					onClick: () => m(C)
				}, [createVNode("div", {
					class: `${a}-block`,
					style: {
						backgroundColor: C
					}
				}, null)]),
				y = (C, _) => createVNode("div", {
					class: `${a}-colors-section`
				}, [createVNode("div", {
					class: `${a}-colors-text`
				}, [C]), createVNode("div", {
					class: `${a}-colors-wrapper`
				}, [_ != null && _.length ? createVNode("div", {
					class: `${a}-colors-list`
				}, [_.map(v)]) : createVNode("span", {
					class: `${a}-colors-empty`
				}, [s("colorPicker.empty")])])]),
				b = () => o.showHistory || o.showPreset ? createVNode("div", {
					class: `${a}-panel-colors`
				}, [o.showHistory && y(s("colorPicker.history"), o.historyColors), o.showPreset && y(s(
					"colorPicker.preset"), o.presetColors)]) : null;
			return () => createVNode("div", {
				class: {
					[`${a}-panel`]: !0,
					[`${a}-panel-disabled`]: o.disabled
				}
			}, [createVNode(Palette, {
				color: o.color,
				onChange: (C, _) => {
					var S;
					return (S = o.onHsvChange) == null ? void 0 : S.call(o, {
						h: l.value.h,
						s: C,
						v: _
					})
				}
			}, null), createVNode("div", {
				class: `${a}-panel-control`
			}, [createVNode("div", {
				class: `${a}-control-wrapper`
			}, [createVNode("div", null, [createVNode(ControlBar, {
				type: "hue",
				x: l.value.h,
				color: o.color,
				colorString: o.colorString,
				onChange: C => {
					var _;
					return (_ = o.onHsvChange) == null ? void 0 : _
						.call(o, {
							h: C,
							s: l.value.s,
							v: l.value.v
						})
				}
			}, null), !o.disabledAlpha && createVNode(ControlBar, {
				type: "alpha",
				x: o.alpha,
				color: o.color,
				colorString: o.colorString,
				onChange: o.onAlphaChange
			}, null)]), createVNode("div", {
				class: `${a}-preview`,
				style: {
					backgroundColor: o.colorString
				}
			}, null)]), createVNode("div", {
				class: `${a}-input-wrapper`
			}, [createVNode(Select, {
				class: `${a}-select`,
				size: "mini",
				"trigger-props": {
					class: `${a}-select-popup`
				},
				options: [{
					value: "hex",
					label: "Hex"
				}, {
					value: "rgb",
					label: "RGB"
				}],
				modelValue: c.value,
				onChange: f
			}, null), createVNode("div", {
				class: `${a}-group-wrapper`
			}, [g()])])]), b()])
		}
	}),
	_ColorPicker = defineComponent({
		name: "ColorPicker",
		props: {
			modelValue: String,
			defaultValue: {
				type: String
			},
			format: {
				type: String
			},
			size: {
				type: String,
				default: "medium"
			},
			showText: {
				type: Boolean,
				default: !1
			},
			showHistory: {
				type: Boolean,
				default: !1
			},
			showPreset: {
				type: Boolean,
				default: !1
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			disabledAlpha: {
				type: Boolean,
				default: !1
			},
			hideTrigger: {
				type: Boolean
			},
			triggerProps: {
				type: Object
			},
			historyColors: {
				type: Array
			},
			presetColors: {
				type: Array,
				default: () => colors
			}
		},
		emits: {
			"update:modelValue": o => !0,
			change: o => !0,
			"popup-visible-change": (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const l = getPrefixCls("color-picker"),
				c = computed(() => {
					var k;
					return (k = o.modelValue) != null ? k : o.defaultValue
				}),
				d = computed(() => formatInputToHSVA(c.value || "")),
				[f, m] = useState(d.value.a),
				[g, v] = useState({
					h: d.value.h,
					s: d.value.s,
					v: d.value.v
				});
			watch(() => d.value, k => {
				c.value !== C.value && (m(k.a), v({
					h: k.h,
					s: k.s,
					v: k.v
				}))
			});
			const y = computed(() => {
					const k = hsvToRgb(g.value.h, g.value.s, g.value.v),
						M = rgbToHex(k.r, k.g, k.b);
					return {
						hsv: g.value,
						rgb: k,
						hex: M
					}
				}),
				b = computed(() => {
					const {
						r: k,
						g: M,
						b: D
					} = y.value.rgb;
					return `rgba(${k}, ${M}, ${D}, ${f.value.toFixed(2)})`
				}),
				C = computed(() => {
					const {
						r: k,
						g: M,
						b: D
					} = y.value.rgb;
					return o.format === "rgb" ? f.value < 1 && !o.disabledAlpha ?
						`rgba(${k}, ${M}, ${D}, ${f.value.toFixed(2)})` : `rgb(${k}, ${M}, ${D})` : f.value <
						1 && !o.disabledAlpha ? `#${rgbaToHex(k,M,D,f.value)}` : `#${rgbToHex(k,M,D)}`
				});
			watch(C, k => {
				s("update:modelValue", k), s("change", k)
			});
			const _ = k => {
					!o.disabled && v(k)
				},
				S = k => {
					!o.disabled && m(k)
				},
				w = k => {
					s("popup-visible-change", k, C.value)
				},
				T = () => createVNode("div", {
					class: {
						[l]: !0,
						[`${l}-size-${o.size}`]: o.size,
						[`${l}-disabled`]: o.disabled
					}
				}, [createVNode("div", {
					class: `${l}-preview`,
					style: {
						backgroundColor: C.value
					}
				}, null), o.showText && createVNode("div", {
					class: `${l}-value`
				}, [C.value]), createVNode("input", {
					class: `${l}-input`,
					value: C.value,
					disabled: o.disabled
				}, null)]),
				A = () => createVNode(Panel$2, {
					color: y.value,
					alpha: f.value,
					colorString: b.value,
					historyColors: o.historyColors,
					presetColors: o.presetColors,
					showHistory: o.showHistory,
					showPreset: o.showPreset,
					disabled: o.disabled,
					disabledAlpha: o.disabledAlpha,
					format: o.format,
					onHsvChange: _,
					onAlphaChange: S
				}, null);
			return () => o.hideTrigger ? A() : createVNode(Trigger, mergeProps({
				trigger: "click",
				position: "bl",
				animationName: "slide-dynamic-origin",
				popupOffset: 4,
				disabled: o.disabled,
				onPopupVisibleChange: w
			}, o.triggerProps), {
				default: () => [a.default ? a.default() : T()],
				content: A
			})
		}
	});
const ColorPicker = Object.assign(_ColorPicker, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _ColorPicker.name, _ColorPicker)
	}
});

function hasPropOrSlot(o, s, a) {
	return computed(() => !!(o[a] || s[a]))
}
const _sfc_main$2q = defineComponent({
		name: "Comment",
		props: {
			author: {
				type: String
			},
			avatar: {
				type: String
			},
			content: {
				type: String
			},
			datetime: {
				type: String
			},
			align: {
				type: [String, Object],
				default: "left"
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("comment"),
				[l, c, d, f] = ["author", "avatar", "content", "datetime"].map(g => hasPropOrSlot(o, s, g)),
				m = computed(() => {
					const {
						align: g
					} = o;
					return {
						...isString$2(g) ? {
							datetime: g,
							actions: g
						} : g
					}
				});
			return {
				prefixCls: a,
				hasAuthor: l,
				hasAvatar: c,
				hasContent: d,
				hasDatetime: f,
				computedAlign: m
			}
		}
	}),
	_hoisted_1$V = ["src"],
	_hoisted_2$6 = {
		key: 0
	},
	_hoisted_3$2 = {
		key: 0
	},
	_hoisted_4$2 = {
		key: 0
	};

function _sfc_render$28(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [o.hasAvatar ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-avatar`)
	}, [o.avatar ? (openBlock(), createElementBlock("img", {
		key: 0,
		src: o.avatar,
		alt: "comment-avatar"
	}, null, 8, _hoisted_1$V)) : renderSlot(o.$slots, "avatar", {
		key: 1
	})], 2)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-inner`)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-inner-content`)
	}, [o.hasAuthor || o.hasDatetime ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(
				`${o.prefixCls}-title ${o.prefixCls}-title-align-${o.computedAlign.datetime}`
				)
		}, [o.hasAuthor ? (openBlock(), createElementBlock("span", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-author`)
		}, [o.author ? (openBlock(), createElementBlock("span",
			_hoisted_2$6, toDisplayString(o.author), 1)) : renderSlot(o
			.$slots, "author", {
				key: 1
			})], 2)) : createCommentVNode("v-if", !0), o.hasDatetime ? (openBlock(),
			createElementBlock("span", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-datetime`)
			}, [o.datetime ? (openBlock(), createElementBlock("span",
				_hoisted_3$2, toDisplayString(o.datetime), 1)) : renderSlot(
				o.$slots, "datetime", {
					key: 1
				})], 2)) : createCommentVNode("v-if", !0)], 2)) : createCommentVNode("v-if", !
		0), o.hasContent ? (openBlock(), createElementBlock("div", {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [o.content ? (openBlock(), createElementBlock("span", _hoisted_4$2,
			toDisplayString(o.content), 1)) : renderSlot(o.$slots, "content", {
			key: 1
		})], 2)) : createCommentVNode("v-if", !0), o.$slots.actions ? (openBlock(),
			createElementBlock("div", {
				key: 2,
				class: normalizeClass(
					`${o.prefixCls}-actions ${o.prefixCls}-actions-align-${o.computedAlign.actions}`
					)
			}, [renderSlot(o.$slots, "actions")], 2)) : createCommentVNode("v-if", !0)
	], 2), o.$slots.default ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-inner-comment`)
	}, [renderSlot(o.$slots, "default")], 2)) : createCommentVNode("v-if", !0)], 2)], 2)
}
var _Comment = _export_sfc$1(_sfc_main$2q, [
	["render", _sfc_render$28]
]);
const Comment = Object.assign(_Comment, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Comment.name, _Comment)
		}
	}),
	_sfc_main$2p = defineComponent({
		name: "ConfigProvider",
		props: {
			prefixCls: {
				type: String,
				default: "arco"
			},
			locale: {
				type: Object
			},
			size: {
				type: String
			},
			global: {
				type: Boolean,
				default: !1
			},
			updateAtScroll: {
				type: Boolean,
				default: !1
			},
			scrollToClose: {
				type: Boolean,
				default: !1
			},
			exchangeTime: {
				type: Boolean,
				default: !0
			}
		},
		setup(o, {
			slots: s
		}) {
			const {
				prefixCls: a,
				locale: l,
				size: c,
				updateAtScroll: d,
				scrollToClose: f,
				exchangeTime: m
			} = toRefs(o), g = reactive({
				slots: s,
				prefixCls: a,
				locale: l,
				size: c,
				updateAtScroll: d,
				scrollToClose: f,
				exchangeTime: m
			});
			if (o.global) {
				const v = getCurrentInstance();
				v && v.appContext.app.provide(configProviderInjectionKey, g)
			} else provide(configProviderInjectionKey, g)
		}
	});

function _sfc_render$27(o, s, a, l, c, d) {
	return renderSlot(o.$slots, "default")
}
var _ConfigProvider = _export_sfc$1(_sfc_main$2p, [
	["render", _sfc_render$27]
]);
const ConfigProvider = Object.assign(_ConfigProvider, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _ConfigProvider.name, _ConfigProvider)
	}
});

function usePickerState(o) {
	const {
		modelValue: s,
		defaultValue: a,
		format: l
	} = toRefs(o), c = computed(() => getDayjsValue(s.value, l.value)), d = computed(() => getDayjsValue(a.value, l
		.value)), [f, m] = useState(isUndefined$1(c.value) ? isUndefined$1(d.value) ? void 0 : d.value : c.value);
	return watch(c, () => {
		isUndefined$1(c.value) && m(void 0)
	}), {
		value: computed(() => c.value || f.value),
		setValue: m
	}
}
const _sfc_main$2o = defineComponent({
		name: "DateInput",
		components: {
			IconHover,
			IconClose,
			FeedbackIcon
		},
		props: {
			size: {
				type: String
			},
			focused: {
				type: Boolean
			},
			disabled: {
				type: Boolean
			},
			readonly: {
				type: Boolean
			},
			error: {
				type: Boolean
			},
			allowClear: {
				type: Boolean
			},
			placeholder: {
				type: String
			},
			inputValue: {
				type: String
			},
			value: {
				type: Object
			},
			format: {
				type: [String, Function],
				required: !0
			}
		},
		emits: ["clear", "press-enter", "change", "blur"],
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				error: l,
				focused: c,
				disabled: d,
				size: f,
				value: m,
				format: g,
				inputValue: v
			} = toRefs(o), {
				mergedSize: y,
				mergedDisabled: b,
				mergedError: C,
				feedback: _
			} = useFormItem({
				size: f,
				disabled: d,
				error: l
			}), {
				mergedSize: S
			} = useSize$1(y), w = getPrefixCls("picker"), T = computed(() => [w, `${w}-size-${S.value}`, {
				[`${w}-focused`]: c.value,
				[`${w}-disabled`]: b.value,
				[`${w}-error`]: C.value,
				[`${w}-has-prefix`]: a.prefix
			}]), A = computed(() => {
				if (v != null && v.value) return v == null ? void 0 : v.value;
				if (m != null && m.value && isDayjs(m.value)) return isFunction$2(g.value) ? g.value(m
					.value) : m.value.format(g.value)
			}), k = ref();
			return {
				feedback: _,
				prefixCls: w,
				classNames: T,
				displayValue: A,
				mergedDisabled: b,
				refInput: k,
				onPressEnter() {
					s("press-enter")
				},
				onChange(M) {
					s("change", M)
				},
				onClear(M) {
					s("clear", M)
				},
				onBlur(M) {
					s("blur", M)
				}
			}
		},
		methods: {
			focus() {
				this.refInput && this.refInput.focus && this.refInput.focus()
			},
			blur() {
				this.refInput && this.refInput.blur && this.refInput.blur()
			}
		}
	}),
	_hoisted_1$U = ["disabled", "placeholder", "value"];

function _sfc_render$26(o, s, a, l, c, d) {
	const f = resolveComponent("IconClose"),
		m = resolveComponent("IconHover"),
		g = resolveComponent("FeedbackIcon");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [o.$slots.prefix ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-prefix`)
	}, [renderSlot(o.$slots, "prefix")], 2)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-input`)
	}, [createBaseVNode("input", mergeProps({
		ref: "refInput",
		disabled: o.mergedDisabled,
		placeholder: o.placeholder,
		class: `${o.prefixCls}-start-time`,
		value: o.displayValue
	}, o.readonly ? {
		readonly: !0
	} : {}, {
		onKeydown: s[0] || (s[0] = withKeys((...v) => o.onPressEnter && o.onPressEnter(...
			v), ["enter"])),
		onInput: s[1] || (s[1] = (...v) => o.onChange && o.onChange(...v)),
		onBlur: s[2] || (s[2] = (...v) => o.onBlur && o.onBlur(...v))
	}), null, 16, _hoisted_1$U)], 2), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-suffix`)
	}, [o.allowClear && !o.mergedDisabled && o.displayValue ? (openBlock(), createBlock(m, {
		key: 0,
		prefix: o.prefixCls,
		class: normalizeClass(`${o.prefixCls}-clear-icon`),
		onClick: o.onClear
	}, {
		default: withCtx(() => [createVNode(f)]),
		_: 1
	}, 8, ["prefix", "class", "onClick"])) : createCommentVNode("v-if", !0), createBaseVNode(
	"span", {
		class: normalizeClass(`${o.prefixCls}-suffix-icon`)
	}, [renderSlot(o.$slots, "suffix-icon")], 2), o.feedback ? (openBlock(), createBlock(g, {
		key: 1,
		type: o.feedback
	}, null, 8, ["type"])) : createCommentVNode("v-if", !0)], 2)], 2)
}
var DateInput = _export_sfc$1(_sfc_main$2o, [
	["render", _sfc_render$26]
]);

function getColumnsFromFormat(o) {
	const s = ["H", "h", "m", "s", "a", "A"],
		a = [];
	let l = !1;
	return s.forEach(c => {
		o.indexOf(c) !== -1 && (a.push(c), (c === "a" || c === "A") && (l = !0))
	}), {
		list: a,
		use12Hours: l
	}
}
const scrollIds = new Map;

function scrollTo(o, s, a) {
	const l = scrollIds.get(o);
	isUndefined$1(l) || cancelAnimationFrame(l), a <= 0 && (o.scrollTop = s), scrollIds.set(o, requestAnimationFrame(
	() => {
			new Tween({
				from: {
					scrollTop: o.scrollTop
				},
				to: {
					scrollTop: s
				},
				duration: a,
				onUpdate: d => {
					o.scrollTop = d.scrollTop
				}
			}).start()
		}))
}

function getFormattedValue(o, s) {
	const a = l => {
		if (isArray$2(l)) return l.map(c => a(c));
		if (!isUndefined$1(l)) return l.format(s)
	};
	return a(o)
}

function isValidRangeValue$1(o) {
	return isUndefined$1(o) ? !0 : isArray$2(o) ? o.length === 0 || o.length === 2 && isDayjs(o[0]) && isDayjs(o[1]) : !
		1
}

function isValidInputValue(o, s) {
	return o ? typeof o == "string" && dayjs(o, s).format(s) === o : !1
}

function isDisabledTime(o, {
	disabledHours: s,
	disabledMinutes: a,
	disabledSeconds: l
}) {
	if (!o) return !1;
	const c = o.hour(),
		d = o.minute(),
		f = o.second(),
		m = (s == null ? void 0 : s()) || [],
		g = (a == null ? void 0 : a(c)) || [],
		v = (l == null ? void 0 : l(c, d)) || [],
		y = (b, C) => !isUndefined$1(b) && C.includes(b);
	return y(c, m) || y(d, g) || y(f, v)
}
var RenderFunction = defineComponent({
	name: "RenderFunction",
	props: {
		renderFunc: {
			type: Function,
			required: !0
		}
	},
	render() {
		return this.renderFunc(this.$attrs)
	}
});
const PickerInjectionKey = Symbol("PickerInjectionKey");

function useDatePickerTransform$1() {
	const {
		datePickerT: o
	} = inject(PickerInjectionKey) || {};
	return o || ((s, ...a) => s)
}
const _sfc_main$2n = defineComponent({
	name: "PanelShortcuts",
	components: {
		Button,
		RenderFunction
	},
	props: {
		prefixCls: {
			type: String,
			required: !0
		},
		shortcuts: {
			type: Array,
			default: () => []
		},
		showNowBtn: {
			type: Boolean
		}
	},
	emits: ["item-click", "item-mouse-enter", "item-mouse-leave", "now-click"],
	setup(o, {
		emit: s
	}) {
		return {
			datePickerT: useDatePickerTransform$1(),
			onItemClick: l => {
				s("item-click", l)
			},
			onItemMouseEnter: l => {
				s("item-mouse-enter", l)
			},
			onItemMouseLeave: l => {
				s("item-mouse-leave", l)
			},
			onNowClick: () => {
				s("now-click")
			},
			isFunction: isFunction$2
		}
	}
});

function _sfc_render$25(o, s, a, l, c, d) {
	const f = resolveComponent("Button"),
		m = resolveComponent("RenderFunction");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-shortcuts`)
	}, [o.showNowBtn ? (openBlock(), createBlock(f, {
		key: 0,
		size: "mini",
		onClick: s[0] || (s[0] = () => o.onNowClick())
	}, {
		default: withCtx(() => [createTextVNode(toDisplayString(o.datePickerT("datePicker.now")),
			1)]),
		_: 1
	})) : createCommentVNode("v-if", !0), (openBlock(!0), createElementBlock(Fragment, null, renderList(o
		.shortcuts, (g, v) => (openBlock(), createBlock(f, {
			key: v,
			size: "mini",
			onClick: () => o.onItemClick(g),
			onMouseenter: () => o.onItemMouseEnter(g),
			onMouseleave: () => o.onItemMouseLeave(g)
		}, {
			default: withCtx(() => [o.isFunction(g.label) ? (openBlock(), createBlock(m, {
				key: 0,
				"render-func": g.label
			}, null, 8, ["render-func"])) : (openBlock(), createElementBlock(
				Fragment, {
					key: 1
				}, [createTextVNode(toDisplayString(g.label), 1)], 64))]),
			_: 2
		}, 1032, ["onClick", "onMouseenter", "onMouseleave"]))), 128))], 2)
}
var PanelShortcuts = _export_sfc$1(_sfc_main$2n, [
	["render", _sfc_render$25]
]);

function newArray(o) {
	return [...Array(o)]
}

function normalizeRangeValue(o) {
	if (!isUndefined$1(o)) return isArray$2(o) ? o : [o, void 0]
}

function isCompleteRangeValue(o) {
	return !!o && isDayjs(o[0]) && isDayjs(o[1])
}

function isValidRangeValue(o) {
	return isUndefined$1(o) || o.length === 0 || isCompleteRangeValue(o)
}

function mergeValueWithTime(o, s, a) {
	const l = s || o;
	return (a || o).set("year", l.year()).set("month", l.month()).set("date", l.date())
}
const _sfc_main$2m = defineComponent({
		name: "IconDoubleLeft",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-double-left`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$T = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$24(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M36.857 9.9 22.715 24.042l14.142 14.142M25.544 9.9 11.402 24.042l14.142 14.142"
	}, null, -1)]), 14, _hoisted_1$T)
}
var _IconDoubleLeft = _export_sfc$1(_sfc_main$2m, [
	["render", _sfc_render$24]
]);
const IconDoubleLeft = Object.assign(_IconDoubleLeft, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconDoubleLeft.name, _IconDoubleLeft)
		}
	}),
	_sfc_main$2l = defineComponent({
		name: "IconDoubleRight",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-double-right`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$S = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$23(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "m11.143 38.1 14.142-14.142L11.143 9.816M22.456 38.1l14.142-14.142L22.456 9.816"
	}, null, -1)]), 14, _hoisted_1$S)
}
var _IconDoubleRight = _export_sfc$1(_sfc_main$2l, [
	["render", _sfc_render$23]
]);
const IconDoubleRight = Object.assign(_IconDoubleRight, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconDoubleRight.name, _IconDoubleRight)
		}
	}),
	_sfc_main$2k = defineComponent({
		name: "PanelHeader",
		components: {
			IconLeft,
			IconRight,
			IconDoubleLeft,
			IconDoubleRight,
			RenderFunction
		},
		props: {
			prefixCls: {
				type: String,
				required: !0
			},
			title: {
				type: String,
				required: !0
			},
			mode: {
				type: String,
				default: "date"
			},
			value: {
				type: Object
			},
			icons: {
				type: Object
			},
			onPrev: {
				type: Function
			},
			onSuperPrev: {
				type: Function
			},
			onNext: {
				type: Function
			},
			onSuperNext: {
				type: Function
			},
			onLabelClick: {
				type: Function
			}
		},
		emits: ["label-click"],
		setup(o) {
			return {
				showPrev: computed(() => isFunction$2(o.onPrev)),
				showSuperPrev: computed(() => isFunction$2(o.onSuperPrev)),
				showNext: computed(() => isFunction$2(o.onNext)),
				showSuperNext: computed(() => isFunction$2(o.onSuperNext)),
				year: computed(() => ["date", "quarter", "month", "week"].includes(o.mode) && o.value ? o.value
					.format("YYYY") : ""),
				month: computed(() => ["date", "week"].includes(o.mode) && o.value ? o.value.format("MM") : ""),
				getIconClassName: s => [`${o.prefixCls}-header-icon`, {
					[`${o.prefixCls}-header-icon-hidden`]: !s
				}]
			}
		}
	}),
	_hoisted_1$R = {
		key: 1
	};

function _sfc_render$22(o, s, a, l, c, d) {
	const f = resolveComponent("RenderFunction"),
		m = resolveComponent("IconDoubleLeft"),
		g = resolveComponent("IconLeft"),
		v = resolveComponent("IconRight"),
		y = resolveComponent("IconDoubleRight");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-header`)
	}, [createBaseVNode("div", {
		class: normalizeClass(o.getIconClassName(o.showSuperPrev)),
		onClick: s[0] || (s[0] = (...b) => o.onSuperPrev && o.onSuperPrev(...b))
	}, [o.showSuperPrev ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [o.icons && o.icons.prevDouble ? (openBlock(), createBlock(f, {
		key: 0,
		"render-func": o.icons && o.icons.prevDouble
	}, null, 8, ["render-func"])) : (openBlock(), createBlock(m, {
		key: 1
	}))], 64)) : createCommentVNode("v-if", !0)], 2), createBaseVNode("div", {
		class: normalizeClass(o.getIconClassName(o.showPrev)),
		onClick: s[1] || (s[1] = (...b) => o.onPrev && o.onPrev(...b))
	}, [o.showPrev ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [o.icons && o.icons.prev ? (openBlock(), createBlock(f, {
		key: 0,
		"render-func": o.icons && o.icons.prev
	}, null, 8, ["render-func"])) : (openBlock(), createBlock(g, {
		key: 1
	}))], 64)) : createCommentVNode("v-if", !0)], 2), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-header-title`)
	}, [o.onLabelClick && (o.year || o.month) ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [o.year ? (openBlock(), createElementBlock("span", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-header-label`),
			onClick: s[2] || (s[2] = () => o.onLabelClick && o.onLabelClick("year"))
		}, toDisplayString(o.year), 3)) : createCommentVNode("v-if", !0), o.year && o
		.month ? (openBlock(), createElementBlock("span", _hoisted_1$R, "-")) :
		createCommentVNode("v-if", !0), o.month ? (openBlock(), createElementBlock("span", {
			key: 2,
			class: normalizeClass(`${o.prefixCls}-header-label`),
			onClick: s[3] || (s[3] = () => o.onLabelClick && o.onLabelClick(
				"month"))
		}, toDisplayString(o.month), 3)) : createCommentVNode("v-if", !0)
	], 64)) : (openBlock(), createElementBlock(Fragment, {
		key: 1
	}, [createTextVNode(toDisplayString(o.title), 1)], 64))], 2), createBaseVNode("div", {
		class: normalizeClass(o.getIconClassName(o.showNext)),
		onClick: s[4] || (s[4] = (...b) => o.onNext && o.onNext(...b))
	}, [o.showNext ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [o.icons && o.icons.next ? (openBlock(), createBlock(f, {
		key: 0,
		"render-func": o.icons && o.icons.next
	}, null, 8, ["render-func"])) : (openBlock(), createBlock(v, {
		key: 1
	}))], 64)) : createCommentVNode("v-if", !0)], 2), createBaseVNode("div", {
		class: normalizeClass(o.getIconClassName(o.showSuperNext)),
		onClick: s[5] || (s[5] = (...b) => o.onSuperNext && o.onSuperNext(...b))
	}, [o.showSuperNext ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [o.icons && o.icons.nextDouble ? (openBlock(), createBlock(f, {
		key: 0,
		"render-func": o.icons && o.icons.nextDouble
	}, null, 8, ["render-func"])) : (openBlock(), createBlock(y, {
		key: 1
	}))], 64)) : createCommentVNode("v-if", !0)], 2)], 2)
}
var PanelHeader = _export_sfc$1(_sfc_main$2k, [
	["render", _sfc_render$22]
]);

function useCellClassName(o) {
	const {
		rangeValues: s
	} = toRefs(o), a = computed(() => s != null && s.value && s.value.every(isDayjs) ? getSortedDayjsArray(s.value) :
		s == null ? void 0 : s.value), l = computed(() => {
		var d;
		return (d = a.value) == null ? void 0 : d[0]
	}), c = computed(() => {
		var d;
		return (d = a.value) == null ? void 0 : d[1]
	});
	return {
		getCellClassName: (d, f) => {
			const {
				value: m,
				isSameTime: g,
				mode: v,
				prefixCls: y
			} = o, b = !d.isPrev && !d.isNext, C = m && g(d.value, m);
			let _ = g(d.value, getNow());
			v === "week" && (_ = getNow().isSame(d.value, "date"));
			const S = b && l.value && g(d.value, l.value),
				w = b && c.value && g(d.value, c.value),
				T = b && l.value && c.value && (S || w || d.value.isBetween(l.value, c.value, null, "[]"));
			return [`${y}-cell`, {
				[`${y}-cell-in-view`]: b,
				[`${y}-cell-today`]: _,
				[`${y}-cell-selected`]: C,
				[`${y}-cell-range-start`]: S,
				[`${y}-cell-range-end`]: w,
				[`${y}-cell-in-range`]: T,
				[`${y}-cell-disabled`]: f
			}, d.classNames]
		}
	}
}
const _sfc_main$2j = defineComponent({
		name: "PanelBody",
		components: {
			RenderFunction
		},
		props: {
			prefixCls: {
				type: String,
				required: !0
			},
			rows: {
				type: Array,
				default: () => []
			},
			value: {
				type: Object
			},
			disabledDate: {
				type: Function
			},
			isSameTime: {
				type: Function,
				required: !0
			},
			mode: {
				type: String
			},
			rangeValues: {
				type: Array
			},
			dateRender: {
				type: Function
			}
		},
		emits: ["cell-click", "cell-mouse-enter"],
		setup(o, {
			emit: s
		}) {
			const {
				prefixCls: a,
				value: l,
				disabledDate: c,
				isSameTime: d,
				mode: f,
				rangeValues: m
			} = toRefs(o), {
				getCellClassName: g
			} = useCellClassName(reactive({
				prefixCls: a,
				value: l,
				isSameTime: d,
				mode: f,
				rangeValues: m
			})), v = y => !!(isFunction$2(c == null ? void 0 : c.value) && (c != null && c.value(getDateValue$1(
				y.value))));
			return {
				isWeek: computed(() => (f == null ? void 0 : f.value) === "week"),
				getCellClassName: y => {
					const b = v(y);
					return g(y, b)
				},
				onCellClick: y => {
					v(y) || s("cell-click", y)
				},
				onCellMouseEnter: y => {
					v(y) || s("cell-mouse-enter", y)
				},
				onCellMouseLeave: y => {
					v(y) || s("cell-mouse-enter", y)
				},
				getDateValue: getDateValue$1
			}
		}
	}),
	_hoisted_1$Q = ["onMouseenter", "onMouseleave", "onClick"];

function _sfc_render$21(o, s, a, l, c, d) {
	const f = resolveComponent("RenderFunction");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-body`)
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.rows, (m, g) => (openBlock(),
		createElementBlock("div", {
			key: g,
			class: normalizeClass([`${o.prefixCls}-row`, {
				[`${o.prefixCls}-row-week`]: o.isWeek
			}])
		}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(m, (v, y) => (
			openBlock(), createElementBlock(Fragment, null, [
				createCommentVNode(" 一年中的第几周，只在 week 模式下显示 "), o
				.isWeek && y === 0 ? (openBlock(), createElementBlock(
					"div", {
						key: y,
						class: normalizeClass([
							`${o.prefixCls}-cell`,
							`${o.prefixCls}-cell-week`
						])
					}, [createBaseVNode("div", {
						class: normalizeClass(
							`${o.prefixCls}-date`)
					}, [createBaseVNode("div", {
						class: normalizeClass(
							`${o.prefixCls}-date-value`
							)
					}, toDisplayString(v.label), 3)], 2)], 2)) : (
					openBlock(), createElementBlock("div", {
						key: y,
						class: normalizeClass(o.getCellClassName(
							v)),
						onMouseenter: () => {
							o.onCellMouseEnter(v)
						},
						onMouseleave: () => {
							o.onCellMouseLeave(v)
						},
						onClick: () => {
							o.onCellClick(v)
						}
					}, [o.dateRender ? (openBlock(), createBlock(
					f, {
						key: 0,
						"render-func": o.dateRender,
						date: o.getDateValue(v.value)
					}, null, 8, ["render-func", "date"])) : (
						openBlock(), createElementBlock("div", {
							key: 1,
							class: normalizeClass(
								`${o.prefixCls}-date`)
						}, [createBaseVNode("div", {
								class: normalizeClass(
									`${o.prefixCls}-date-value`
									)
							}, toDisplayString(v.label),
							3)], 2))], 42, _hoisted_1$Q))
			], 64))), 256))], 2))), 128))], 2)
}
var PanelBody = _export_sfc$1(_sfc_main$2j, [
	["render", _sfc_render$21]
]);
const _sfc_main$2i = defineComponent({
	name: "PanelWeekList",
	props: {
		prefixCls: {
			type: String,
			required: !0
		},
		weekList: {
			type: Array,
			required: !0
		}
	},
	setup() {
		const o = useDatePickerTransform$1();
		return {
			labelList: computed(() => ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday",
				"saturday"
			].map(a => o(`datePicker.week.short.${a}`)))
		}
	}
});

function _sfc_render$20(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-week-list`)
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.weekList, f => (openBlock(),
		createElementBlock("div", {
			key: f,
			class: normalizeClass(`${o.prefixCls}-week-list-item`)
		}, toDisplayString(o.labelList[f] || ""), 3))), 128))], 2)
}
var PanelWeekList = _export_sfc$1(_sfc_main$2i, [
	["render", _sfc_render$20]
]);
const _sfc_main$2h = defineComponent({
		name: "TimePickerColumn",
		props: {
			prefixCls: {
				type: String,
				required: !0
			},
			list: {
				type: Array,
				required: !0
			},
			value: {
				type: [Number, String]
			},
			visible: {
				type: Boolean
			}
		},
		emits: ["select"],
		setup(o, {
			emit: s
		}) {
			const {
				visible: a,
				value: l
			} = toRefs(o), c = ref(new Map), d = ref();

			function f(m = !1) {
				if (!d.value || isUndefined$1(l == null ? void 0 : l.value) || !(a != null && a.value)) return;
				const g = c.value.get(l.value);
				g && scrollTo(d.value, g.offsetTop, m ? 100 : 0)
			}
			return watch([l, a], (m, [, g]) => {
				a.value !== g ? nextTick(() => {
					f()
				}) : f(!0)
			}), onMounted(() => {
				f()
			}), {
				refWrapper: d,
				refMap: c,
				onItemRef(m, g) {
					c.value.set(g.value, m)
				},
				onItemClick(m) {
					m.disabled || s("select", m.value)
				}
			}
		}
	}),
	_hoisted_1$P = ["onClick"];

function _sfc_render$1$(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		ref: "refWrapper",
		class: normalizeClass(`${o.prefixCls}-column`)
	}, [createBaseVNode("ul", null, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.list, f =>
		(openBlock(), createElementBlock("li", {
			key: f.value,
			ref_for: !0,
			ref: m => {
				o.onItemRef(m, f)
			},
			class: normalizeClass([`${o.prefixCls}-cell`, {
				[`${o.prefixCls}-cell-disabled`]: f.disabled,
				[`${o.prefixCls}-cell-selected`]: f.selected
			}]),
			onClick: () => {
				o.onItemClick(f)
			}
		}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-cell-inner`)
		}, toDisplayString(f.label), 3)], 10, _hoisted_1$P))), 128))])], 2)
}
var TimeColumn = _export_sfc$1(_sfc_main$2h, [
	["render", _sfc_render$1$]
]);

function useTimeList(o) {
	const {
		format: s,
		step: a,
		use12Hours: l,
		hideDisabledOptions: c,
		disabledHours: d,
		disabledMinutes: f,
		disabledSeconds: m,
		selectedHour: g,
		selectedMinute: v,
		selectedSecond: y,
		selectedAmpm: b,
		disabled: C
	} = toRefs(o), _ = computed(() => {
		var k;
		const {
			hour: M = 1
		} = (a == null ? void 0 : a.value) || {}, D = ((k = d == null ? void 0 : d.value) == null ? void 0 : k
			.call(d)) || [];
		let F = [];
		for (let R = 0; R < (l.value ? 12 : 24); R += M) F.push(R);
		return l.value && (F[0] = 12), c.value && D.length && (F = F.filter(R => D.indexOf(R) < 0)), F.map(R =>
			({
				label: padStart(R, 2, "0"),
				value: R,
				selected: g.value === R,
				disabled: (C == null ? void 0 : C.value) || D.includes(R)
			}))
	}), S = computed(() => {
		var k;
		const {
			minute: M = 1
		} = (a == null ? void 0 : a.value) || {}, D = ((k = f == null ? void 0 : f.value) == null ? void 0 : k
			.call(f, g.value)) || [];
		let F = [];
		for (let R = 0; R < 60; R += M) F.push(R);
		return c.value && D.length && (F = F.filter(R => D.indexOf(R) < 0)), F.map(R => ({
			label: padStart(R, 2, "0"),
			value: R,
			selected: v.value === R,
			disabled: (C == null ? void 0 : C.value) || D.includes(R)
		}))
	}), w = computed(() => {
		var k;
		const {
			second: M = 1
		} = (a == null ? void 0 : a.value) || {}, D = ((k = m == null ? void 0 : m.value) == null ? void 0 : k
			.call(m, g.value, v.value)) || [];
		let F = [];
		for (let R = 0; R < 60; R += M) F.push(R);
		return c.value && D.length && (F = F.filter(R => D.indexOf(R) < 0)), F.map(R => ({
			label: padStart(R, 2, "0"),
			value: R,
			selected: y.value === R,
			disabled: (C == null ? void 0 : C.value) || D.includes(R)
		}))
	}), T = ["am", "pm"], A = computed(() => {
		const k = getColumnsFromFormat(s.value).list.includes("A");
		return T.map(M => ({
			label: k ? M.toUpperCase() : M,
			value: M,
			selected: b.value === M,
			disabled: C == null ? void 0 : C.value
		}))
	});
	return {
		hours: _,
		minutes: S,
		seconds: w,
		ampmList: A
	}
}

function useTimeFormat(o) {
	const {
		format: s,
		use12Hours: a,
		defaultFormat: l
	} = toRefs(o), c = computed(() => {
		let v = (s == null ? void 0 : s.value) || (l == null ? void 0 : l.value);
		return (!v || !getColumnsFromFormat(v).list.length) && (v = a != null && a.value ? "hh:mm:ss a" :
			"HH:mm:ss"), v
	}), d = computed(() => getColumnsFromFormat(c.value)), f = computed(() => d.value.list), m = computed(() => d
		.value.use12Hours), g = computed(() => !!(a != null && a.value || m.value));
	return {
		columns: f,
		use12Hours: g,
		format: c
	}
}

function useIsDisabledTime(o) {
	const s = a => isDisabledTime(a, {
		disabledHours: o.disabledHours,
		disabledMinutes: o.disabledMinutes,
		disabledSeconds: o.disabledSeconds
	});
	return a => isArray$2(a) ? a.some(l => s(l)) : s(a)
}
const _sfc_main$2g = defineComponent({
	name: "TimePickerPanel",
	components: {
		TimeColumn,
		Button
	},
	props: {
		value: {
			type: Object
		},
		visible: {
			type: Boolean
		},
		format: {
			type: String,
			default: "HH:mm:ss"
		},
		use12Hours: {
			type: Boolean
		},
		step: {
			type: Object
		},
		disabledHours: {
			type: Function
		},
		disabledMinutes: {
			type: Function
		},
		disabledSeconds: {
			type: Function
		},
		hideDisabledOptions: {
			type: Boolean
		},
		hideFooter: {
			type: Boolean
		},
		isRange: {
			type: Boolean
		},
		disabled: {
			type: Boolean
		}
	},
	emits: {
		select: o => isDayjs(o),
		confirm: o => isDayjs(o)
	},
	setup(o, {
		emit: s
	}) {
		const {
			value: a,
			visible: l,
			format: c,
			step: d,
			use12Hours: f,
			hideDisabledOptions: m,
			disabledHours: g,
			disabledMinutes: v,
			disabledSeconds: y,
			disabled: b
		} = toRefs(o), C = getPrefixCls("timepicker"), {
			t: _
		} = useI18n(), {
			columns: S,
			use12Hours: w,
			format: T
		} = useTimeFormat(reactive({
			format: c,
			use12Hours: f
		})), A = ref(a == null ? void 0 : a.value), k = ae => {
			A.value = ae
		};
		watch([l, a], () => {
			l.value && k(a == null ? void 0 : a.value)
		});
		const M = computed(() => {
				var ae;
				const fe = (ae = A.value) == null ? void 0 : ae.hour();
				return isUndefined$1(fe) || !w.value ? fe : fe > 12 ? fe - 12 : fe === 0 ? 12 : fe
			}),
			D = computed(() => {
				var ae;
				return (ae = A.value) == null ? void 0 : ae.minute()
			}),
			F = computed(() => {
				var ae;
				return (ae = A.value) == null ? void 0 : ae.second()
			}),
			R = computed(() => {
				var ae;
				const fe = (ae = A.value) == null ? void 0 : ae.hour();
				return !isUndefined$1(fe) && fe >= 12 ? "pm" : "am"
			}),
			{
				hours: O,
				minutes: U,
				seconds: V,
				ampmList: z
			} = useTimeList(reactive({
				format: T,
				step: d,
				use12Hours: w,
				hideDisabledOptions: m,
				disabledHours: g,
				disabledMinutes: v,
				disabledSeconds: y,
				selectedHour: M,
				selectedMinute: D,
				selectedSecond: F,
				selectedAmpm: R,
				disabled: b
			})),
			j = useIsDisabledTime(reactive({
				disabledHours: g,
				disabledMinutes: v,
				disabledSeconds: y
			})),
			ge = computed(() => j(A.value));

		function me(ae) {
			isUndefined$1(ae) || s("confirm", ae)
		}

		function he(ae) {
			k(ae), s("select", ae)
		}

		function ce(ae, fe = "hour") {
			let q;
			const le = M.value || "00",
				de = D.value || "00",
				_e = F.value || "00",
				ke = R.value || "am";
			switch (fe) {
				case "hour":
					q = `${ae}:${de}:${_e}`;
					break;
				case "minute":
					q = `${le}:${ae}:${_e}`;
					break;
				case "second":
					q = `${le}:${de}:${ae}`;
					break;
				case "ampm":
					q = `${le}:${de}:${_e} ${ae}`;
					break;
				default:
					q = "00:00:00"
			}
			let De = "HH:mm:ss";
			w.value && (De = "HH:mm:ss a", fe !== "ampm" && (q = `${q} ${ke}`)), q = dayjs(q, De), he(q)
		}
		return {
			prefixCls: C,
			t: _,
			hours: O,
			minutes: U,
			seconds: V,
			ampmList: z,
			selectedValue: A,
			selectedHour: M,
			selectedMinute: D,
			selectedSecond: F,
			selectedAmpm: R,
			computedUse12Hours: w,
			confirmBtnDisabled: ge,
			columns: S,
			onSelect: ce,
			onSelectNow() {
				const ae = dayjs(new Date);
				he(ae)
			},
			onConfirm() {
				me(A.value)
			}
		}
	}
});

function _sfc_render$1_(o, s, a, l, c, d) {
	const f = resolveComponent("TimeColumn"),
		m = resolveComponent("Button");
	return openBlock(), createElementBlock(Fragment, null, [createBaseVNode("div", {
			class: normalizeClass(o.prefixCls)
		}, [o.columns.includes("H") || o.columns.includes("h") ? (openBlock(), createBlock(f, {
				key: 0,
				value: o.selectedHour,
				list: o.hours,
				"prefix-cls": o.prefixCls,
				visible: o.visible,
				onSelect: s[0] || (s[0] = g => {
					o.onSelect(g, "hour")
				})
			}, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", !0), o
			.columns.includes("m") ? (openBlock(), createBlock(f, {
				key: 1,
				value: o.selectedMinute,
				list: o.minutes,
				"prefix-cls": o.prefixCls,
				visible: o.visible,
				onSelect: s[1] || (s[1] = g => {
					o.onSelect(g, "minute")
				})
			}, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", !0), o
			.columns.includes("s") ? (openBlock(), createBlock(f, {
				key: 2,
				value: o.selectedSecond,
				list: o.seconds,
				"prefix-cls": o.prefixCls,
				visible: o.visible,
				onSelect: s[2] || (s[2] = g => {
					o.onSelect(g, "second")
				})
			}, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", !0), o
			.computedUse12Hours ? (openBlock(), createBlock(f, {
				key: 3,
				value: o.selectedAmpm,
				list: o.ampmList,
				"prefix-cls": o.prefixCls,
				visible: o.visible,
				onSelect: s[3] || (s[3] = g => {
					o.onSelect(g, "ampm")
				})
			}, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", !0)
		], 2), o.$slots["extra-footer"] ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-footer-extra-wrapper`)
		}, [renderSlot(o.$slots, "extra-footer")], 2)) : createCommentVNode("v-if", !0), o.hideFooter ?
		createCommentVNode("v-if", !0) : (openBlock(), createElementBlock("div", {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-footer-btn-wrapper`)
		}, [o.isRange ? createCommentVNode("v-if", !0) : (openBlock(), createBlock(m, {
			key: 0,
			size: "mini",
			onClick: o.onSelectNow
		}, {
			default: withCtx(() => [createTextVNode(toDisplayString(o.t("datePicker.now")),
				1)]),
			_: 1
		}, 8, ["onClick"])), createVNode(m, {
			type: "primary",
			size: "mini",
			disabled: o.confirmBtnDisabled || !o.selectedValue,
			onClick: o.onConfirm
		}, {
			default: withCtx(() => [createTextVNode(toDisplayString(o.t("datePicker.ok")), 1)]),
			_: 1
		}, 8, ["disabled", "onClick"])], 2))
	], 64)
}
var Panel$1 = _export_sfc$1(_sfc_main$2g, [
	["render", _sfc_render$1_]
]);
const _sfc_main$2f = defineComponent({
		name: "IconCalendar",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-calendar`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$O = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1Z(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M7 22h34M14 5v8m20-8v8M8 41h32a1 1 0 0 0 1-1V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1Z"
	}, null, -1)]), 14, _hoisted_1$O)
}
var _IconCalendar = _export_sfc$1(_sfc_main$2f, [
	["render", _sfc_render$1Z]
]);
const IconCalendar = Object.assign(_IconCalendar, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconCalendar.name, _IconCalendar)
		}
	}),
	_sfc_main$2e = defineComponent({
		name: "IconClockCircle",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-clock-circle`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$N = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1Y(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M24 14v10h9.5m8.5 0c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z"
	}, null, -1)]), 14, _hoisted_1$N)
}
var _IconClockCircle = _export_sfc$1(_sfc_main$2e, [
	["render", _sfc_render$1Y]
]);
const IconClockCircle = Object.assign(_IconClockCircle, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconClockCircle.name, _IconClockCircle)
		}
	}),
	ROW_COUNT$2 = 6,
	COL_COUNT$2 = 7,
	CELL_COUNT$2 = ROW_COUNT$2 * COL_COUNT$2;

function getCellData(o) {
	return {
		label: o.date(),
		value: o
	}
}
const _sfc_main$2d = defineComponent({
	name: "DatePanel",
	components: {
		PanelHeader,
		PanelBody,
		PanelWeekList,
		TimePanel: Panel$1,
		IconCalendar,
		IconClockCircle
	},
	props: {
		isRange: {
			type: Boolean
		},
		value: {
			type: Object
		},
		rangeValues: {
			type: Array
		},
		headerValue: {
			type: Object,
			required: !0
		},
		footerValue: {
			type: Object
		},
		timePickerValue: {
			type: Object
		},
		headerOperations: {
			type: Object,
			default: () => ({})
		},
		headerIcons: {
			type: Object,
			default: () => ({})
		},
		dayStartOfWeek: {
			type: Number,
			default: 0
		},
		disabledDate: {
			type: Function
		},
		disabledTime: {
			type: Function
		},
		isSameTime: {
			type: Function
		},
		mode: {
			type: String,
			default: "date"
		},
		showTime: {
			type: Boolean
		},
		timePickerProps: {
			type: Object
		},
		currentView: {
			type: String
		},
		dateRender: {
			type: Function
		},
		disabled: {
			type: Boolean
		},
		onHeaderLabelClick: {
			type: Function
		}
	},
	emits: ["select", "time-picker-select", "cell-mouse-enter", "current-view-change", "update:currentView"],
	setup(o, {
		emit: s
	}) {
		const {
			isRange: a,
			headerValue: l,
			footerValue: c,
			dayStartOfWeek: d,
			isSameTime: f,
			mode: m,
			showTime: g,
			currentView: v,
			disabledTime: y
		} = toRefs(o), b = useDatePickerTransform$1(), C = computed(() => (m == null ? void 0 : m.value) ===
				"week"), _ = computed(() => getPrefixCls(C.value ? "panel-week" : "panel-date")), S =
			getPrefixCls("picker"), [w, T] = useMergeState("date", reactive({
				value: v
			})), A = computed(() => g.value && a.value), k = computed(() => !g.value || !A.value || w.value ===
				"date"), M = computed(() => g.value && (!A.value || w.value === "time")), D = computed(() => [_
				.value, {
					[`${_.value}-with-view-tabs`]: A.value
				}
			]), F = computed(() => l.value.format("YYYY-MM")), R = computed(() => {
				var me;
				return g.value && ((me = y == null ? void 0 : y.value) == null ? void 0 : me.call(y,
					getDateValue$1((c == null ? void 0 : c.value) || getNow()))) || {}
			}), O = computed(() => {
				const me = [0, 1, 2, 3, 4, 5, 6],
					he = Math.max(d.value % 7, 0);
				return [...me.slice(he), ...me.slice(0, he)]
			}), U = computed(() => {
				const me = methods.startOf(l.value, "month"),
					he = me.day(),
					ce = me.daysInMonth(),
					ae = O.value.indexOf(he),
					fe = newArray(CELL_COUNT$2);
				for (let le = 0; le < fe.length; le++) fe[le] = {
					...getCellData(methods.add(me, le - ae, "day")),
					isPrev: le < ae,
					isNext: le > ae + ce - 1
				};
				return newArray(ROW_COUNT$2).map((le, de) => {
					const _e = fe.slice(de * COL_COUNT$2, (de + 1) * COL_COUNT$2);
					if (C.value) {
						const ke = _e[0].value;
						_e.unshift({
							label: ke.week(),
							value: ke
						})
					}
					return _e
				})
			}), V = computed(() => (f == null ? void 0 : f.value) || ((me, he) => me.isSame(he, "day")));

		function z(me) {
			s("select", me.value)
		}

		function j(me) {
			s("time-picker-select", me)
		}

		function ge(me) {
			s("cell-mouse-enter", me.value)
		}
		return {
			prefixCls: _,
			classNames: D,
			pickerPrefixCls: S,
			headerTitle: F,
			rows: U,
			weekList: computed(() => C.value ? [-1, ...O.value] : O.value),
			mergedIsSameTime: V,
			disabledTimeProps: R,
			onCellClick: z,
			onCellMouseEnter: ge,
			onTimePanelSelect: j,
			showViewTabs: A,
			showDateView: k,
			showTimeView: M,
			changeViewTo: me => {
				s("current-view-change", me), s("update:currentView", me), T(me)
			},
			datePickerT: b
		}
	}
});

function _sfc_render$1X(o, s, a, l, c, d) {
	const f = resolveComponent("PanelHeader"),
		m = resolveComponent("PanelWeekList"),
		g = resolveComponent("PanelBody"),
		v = resolveComponent("TimePanel"),
		y = resolveComponent("IconCalendar"),
		b = resolveComponent("IconClockCircle");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [o.showDateView ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-inner`)
		}, [createVNode(f, mergeProps({
			...o.headerOperations,
			icons: o.headerIcons
		}, {
			"prefix-cls": o.pickerPrefixCls,
			title: o.headerTitle,
			mode: o.mode,
			value: o.headerValue,
			"on-label-click": o.onHeaderLabelClick
		}), null, 16, ["prefix-cls", "title", "mode", "value", "on-label-click"]), createVNode(m, {
			"prefix-cls": o.pickerPrefixCls,
			"week-list": o.weekList
		}, null, 8, ["prefix-cls", "week-list"]), createVNode(g, {
			mode: o.mode,
			"prefix-cls": o.pickerPrefixCls,
			rows: o.rows,
			value: o.isRange ? void 0 : o.value,
			"range-values": o.rangeValues,
			"disabled-date": o.disabledDate,
			"is-same-time": o.mergedIsSameTime,
			"date-render": o.dateRender,
			onCellClick: o.onCellClick,
			onCellMouseEnter: o.onCellMouseEnter
		}, null, 8, ["mode", "prefix-cls", "rows", "value", "range-values", "disabled-date",
			"is-same-time", "date-render", "onCellClick", "onCellMouseEnter"
		])], 2)) : createCommentVNode("v-if", !0), o.showTimeView ? (openBlock(), createElementBlock("div", {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-timepicker`)
		}, [createBaseVNode("header", {
			class: normalizeClass(`${o.prefixCls}-timepicker-title`)
		}, toDisplayString(o.datePickerT("datePicker.selectTime")), 3), createVNode(v, mergeProps({
			...o.timePickerProps,
			...o.disabledTimeProps
		}, {
			"hide-footer": "",
			value: o.value || o.isRange ? o.timePickerValue : void 0,
			disabled: o.disabled,
			onSelect: o.onTimePanelSelect
		}), null, 16, ["value", "disabled", "onSelect"])], 2)) : createCommentVNode("v-if", !0), o
		.showViewTabs ? (openBlock(), createElementBlock("div", {
			key: 2,
			class: normalizeClass(`${o.prefixCls}-footer`)
		}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-view-tabs`)
		}, [createBaseVNode("div", {
			class: normalizeClass([`${o.prefixCls}-view-tab-pane`, {
				[`${o.prefixCls}-view-tab-pane-active`]: o.showDateView
			}]),
			onClick: s[0] || (s[0] = () => o.changeViewTo("date"))
		}, [createVNode(y), createBaseVNode("span", {
				class: normalizeClass(`${o.prefixCls}-view-tab-pane-text`)
			}, toDisplayString(o.footerValue && o.footerValue.format("YYYY-MM-DD")),
			3)], 2), createBaseVNode("div", {
			class: normalizeClass([`${o.prefixCls}-view-tab-pane`, {
				[`${o.prefixCls}-view-tab-pane-active`]: o.showTimeView
			}]),
			onClick: s[1] || (s[1] = () => o.changeViewTo("time"))
		}, [createVNode(b), createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-view-tab-pane-text`)
		}, toDisplayString(o.timePickerValue && o.timePickerValue.format(
			"HH:mm:ss")), 3)], 2)], 2)], 2)) : createCommentVNode("v-if", !0)
	], 2)
}
var DatePanel = _export_sfc$1(_sfc_main$2d, [
	["render", _sfc_render$1X]
]);
const _sfc_main$2c = defineComponent({
	name: "WeekPanel",
	components: {
		DatePanel
	},
	props: {
		dayStartOfWeek: {
			type: Number,
			default: 0
		}
	},
	emits: ["select", "cell-mouse-enter"],
	setup(o, {
		emit: s
	}) {
		return useI18n(), {
			isSameTime: (l, c) => methods.isSameWeek(l, c, o.dayStartOfWeek),
			onSelect: l => {
				const c = methods.startOfWeek(l, o.dayStartOfWeek);
				s("select", c)
			},
			onCellMouseEnter: l => {
				const c = methods.startOfWeek(l, o.dayStartOfWeek);
				s("cell-mouse-enter", c)
			}
		}
	}
});

function _sfc_render$1W(o, s, a, l, c, d) {
	const f = resolveComponent("DatePanel");
	return openBlock(), createBlock(f, mergeProps(o.$attrs, {
		mode: "week",
		"is-week": "",
		"day-start-of-week": o.dayStartOfWeek,
		"is-same-time": o.isSameTime,
		onSelect: o.onSelect,
		onCellMouseEnter: o.onCellMouseEnter
	}), null, 16, ["day-start-of-week", "is-same-time", "onSelect", "onCellMouseEnter"])
}
var WeekPanel = _export_sfc$1(_sfc_main$2c, [
	["render", _sfc_render$1W]
]);
const MONTH_LIST = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October",
		"November", "December"
	],
	CELL_COUNT$1 = 12,
	ROW_COUNT$1 = 4,
	COL_COUNT$1 = 3,
	_sfc_main$2b = defineComponent({
		name: "MonthPanel",
		components: {
			PanelHeader,
			PanelBody
		},
		props: {
			headerValue: {
				type: Object,
				required: !0
			},
			headerOperations: {
				type: Object,
				default: () => ({})
			},
			headerIcons: {
				type: Object,
				default: () => ({})
			},
			value: {
				type: Object
			},
			disabledDate: {
				type: Function
			},
			rangeValues: {
				type: Array
			},
			dateRender: {
				type: Function
			},
			onHeaderLabelClick: {
				type: Function
			},
			abbreviation: {
				type: Boolean,
				default: !0
			}
		},
		emits: ["select", "cell-mouse-enter"],
		setup(o, {
			emit: s
		}) {
			const a = useDatePickerTransform$1(),
				{
					headerValue: l
				} = toRefs(o),
				c = computed(() => getPrefixCls("panel-month")),
				d = getPrefixCls("picker"),
				f = computed(() => l.value.format("YYYY")),
				m = computed(() => {
					const b = l.value.year(),
						C = o.abbreviation ? "short" : "long",
						_ = newArray(CELL_COUNT$1).map((w, T) => ({
							label: a(`datePicker.month.${C}.${MONTH_LIST[T]}`),
							value: dayjs(`${b}-${T+1}`, "YYYY-M")
						}));
					return newArray(ROW_COUNT$1).map((w, T) => _.slice(T * COL_COUNT$1, (T + 1) * COL_COUNT$1))
				}),
				g = (b, C) => b.isSame(C, "month");

			function v(b) {
				s("select", b.value)
			}

			function y(b) {
				s("cell-mouse-enter", b.value)
			}
			return {
				prefixCls: c,
				pickerPrefixCls: d,
				headerTitle: f,
				rows: m,
				isSameTime: g,
				onCellClick: v,
				onCellMouseEnter: y
			}
		}
	});

function _sfc_render$1V(o, s, a, l, c, d) {
	const f = resolveComponent("PanelHeader"),
		m = resolveComponent("PanelBody");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-inner`)
	}, [createVNode(f, mergeProps({
		...o.headerOperations,
		icons: o.headerIcons
	}, {
		"prefix-cls": o.pickerPrefixCls,
		title: o.headerTitle,
		mode: "month",
		value: o.headerValue,
		"on-label-click": o.onHeaderLabelClick
	}), null, 16, ["prefix-cls", "title", "value", "on-label-click"]), createVNode(m, {
		mode: "month",
		"prefix-cls": o.pickerPrefixCls,
		rows: o.rows,
		value: o.value,
		"range-values": o.rangeValues,
		"disabled-date": o.disabledDate,
		"is-same-time": o.isSameTime,
		"date-render": o.dateRender,
		onCellClick: o.onCellClick,
		onCellMouseEnter: o.onCellMouseEnter
	}, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time",
		"date-render", "onCellClick", "onCellMouseEnter"
	])], 2)], 2)
}
var MonthPanel = _export_sfc$1(_sfc_main$2b, [
	["render", _sfc_render$1V]
]);
const ROW_COUNT = 4,
	COL_COUNT = 3,
	CELL_COUNT = ROW_COUNT * COL_COUNT,
	SPAN = 10,
	_sfc_main$2a = defineComponent({
		name: "YearPanel",
		components: {
			PanelHeader,
			PanelBody
		},
		props: {
			headerValue: {
				type: Object,
				required: !0
			},
			headerOperations: {
				type: Object,
				default: () => ({})
			},
			headerIcons: {
				type: Object,
				default: () => ({})
			},
			value: {
				type: Object
			},
			disabledDate: {
				type: Function
			},
			rangeValues: {
				type: Array
			},
			dateRender: {
				type: Function
			}
		},
		emits: ["select", "cell-mouse-enter"],
		setup(o, {
			emit: s
		}) {
			const {
				headerValue: a
			} = toRefs(o), l = computed(() => getPrefixCls("panel-year")), c = getPrefixCls("picker"), d = computed(
					() => {
						const y = Math.floor(a.value.year() / SPAN) * SPAN - 1,
							b = newArray(CELL_COUNT).map((_, S) => ({
								label: y + S,
								value: dayjs(`${y+S}`, "YYYY"),
								isPrev: S < 1,
								isNext: S > SPAN
							}));
						return newArray(ROW_COUNT).map((_, S) => b.slice(S * COL_COUNT, (S + 1) * COL_COUNT))
					}), f = computed(() => `${d.value[0][1].label}-${d.value[ROW_COUNT-1][COL_COUNT-1].label}`), m =
				(y, b) => y.isSame(b, "year");

			function g(y) {
				s("select", y.value)
			}

			function v(y) {
				s("cell-mouse-enter", y.value)
			}
			return {
				prefixCls: l,
				pickerPrefixCls: c,
				headerTitle: f,
				rows: d,
				isSameTime: m,
				onCellClick: g,
				onCellMouseEnter: v
			}
		}
	});

function _sfc_render$1U(o, s, a, l, c, d) {
	const f = resolveComponent("PanelHeader"),
		m = resolveComponent("PanelBody");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-inner`)
	}, [createVNode(f, mergeProps({
		...o.headerOperations,
		icons: o.headerIcons
	}, {
		"prefix-cls": o.pickerPrefixCls,
		title: o.headerTitle
	}), null, 16, ["prefix-cls", "title"]), createVNode(m, {
		mode: "year",
		"prefix-cls": o.pickerPrefixCls,
		rows: o.rows,
		value: o.value,
		"range-values": o.rangeValues,
		"disabled-date": o.disabledDate,
		"is-same-time": o.isSameTime,
		"date-render": o.dateRender,
		onCellClick: o.onCellClick,
		onCellMouseEnter: o.onCellMouseEnter
	}, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time",
		"date-render", "onCellClick", "onCellMouseEnter"
	])], 2)], 2)
}
var YearPanel = _export_sfc$1(_sfc_main$2a, [
	["render", _sfc_render$1U]
]);
const _sfc_main$29 = defineComponent({
	name: "QuarterPanel",
	components: {
		PanelHeader,
		PanelBody
	},
	props: {
		headerValue: {
			type: Object,
			required: !0
		},
		headerOperations: {
			type: Object,
			default: () => ({})
		},
		headerIcons: {
			type: Object,
			default: () => ({})
		},
		value: {
			type: Object
		},
		disabledDate: {
			type: Function
		},
		rangeValues: {
			type: Array
		},
		dateRender: {
			type: Function
		},
		onHeaderLabelClick: {
			type: Function
		}
	},
	emits: ["select", "cell-mouse-enter"],
	setup(o, {
		emit: s
	}) {
		const {
			headerValue: a
		} = toRefs(o), l = computed(() => getPrefixCls("panel-quarter")), c = getPrefixCls("picker"), d =
			computed(() => a.value.format("YYYY")), f = computed(() => {
				const y = a.value.year();
				return [
					[1, 2, 3, 4].map(b => ({
						label: `Q${b}`,
						value: dayjs(`${y}-${padStart((b-1)*3+1,2,"0")}-01`)
					}))
				]
			}), m = (y, b) => y.isSame(b, "month") || y.isSame(b, "year") && Math.floor(y.month() / 3) === Math
			.floor(b.month() / 3);

		function g(y) {
			s("select", y.value)
		}

		function v(y) {
			s("cell-mouse-enter", y.value)
		}
		return {
			prefixCls: l,
			pickerPrefixCls: c,
			headerTitle: d,
			rows: f,
			isSameTime: m,
			onCellClick: g,
			onCellMouseEnter: v
		}
	}
});

function _sfc_render$1T(o, s, a, l, c, d) {
	const f = resolveComponent("PanelHeader"),
		m = resolveComponent("PanelBody");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-inner`)
	}, [createVNode(f, mergeProps({
		...o.headerOperations,
		icons: o.headerIcons
	}, {
		"prefix-cls": o.pickerPrefixCls,
		title: o.headerTitle,
		mode: "quarter",
		value: o.headerValue,
		"on-label-click": o.onHeaderLabelClick
	}), null, 16, ["prefix-cls", "title", "value", "on-label-click"]), createVNode(m, {
		mode: "quarter",
		"prefix-cls": o.pickerPrefixCls,
		rows: o.rows,
		value: o.value,
		"range-values": o.rangeValues,
		"disabled-date": o.disabledDate,
		"is-same-time": o.isSameTime,
		"date-render": o.dateRender,
		onCellClick: o.onCellClick,
		onCellMouseEnter: o.onCellMouseEnter
	}, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time",
		"date-render", "onCellClick", "onCellMouseEnter"
	])], 2)], 2)
}
var QuarterPanel = _export_sfc$1(_sfc_main$29, [
	["render", _sfc_render$1T]
]);
const _sfc_main$28 = defineComponent({
		name: "IconLink",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-link`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$M = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1S(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "m14.1 25.414-4.95 4.95a6 6 0 0 0 8.486 8.485l8.485-8.485a6 6 0 0 0 0-8.485m7.779.707 4.95-4.95a6 6 0 1 0-8.486-8.485l-8.485 8.485a6 6 0 0 0 0 8.485"
	}, null, -1)]), 14, _hoisted_1$M)
}
var _IconLink = _export_sfc$1(_sfc_main$28, [
	["render", _sfc_render$1S]
]);
const IconLink = Object.assign(_IconLink, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconLink.name, _IconLink)
		}
	}),
	_sfc_main$27 = defineComponent({
		name: "Link",
		components: {
			IconLink,
			IconLoading
		},
		props: {
			href: String,
			status: {
				type: String,
				default: "normal"
			},
			hoverable: {
				type: Boolean,
				default: !0
			},
			icon: Boolean,
			loading: Boolean,
			disabled: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			slots: s,
			emit: a
		}) {
			const l = getPrefixCls("link"),
				c = hasPropOrSlot(o, s, "icon"),
				d = m => {
					if (o.disabled || o.loading) {
						m.preventDefault();
						return
					}
					a("click", m)
				};
			return {
				cls: computed(() => [l, `${l}-status-${o.status}`, {
					[`${l}-disabled`]: o.disabled,
					[`${l}-loading`]: o.loading,
					[`${l}-hoverless`]: !o.hoverable,
					[`${l}-with-icon`]: o.loading || c.value
				}]),
				prefixCls: l,
				showIcon: c,
				handleClick: d
			}
		}
	}),
	_hoisted_1$L = ["href"];

function _sfc_render$1R(o, s, a, l, c, d) {
	const f = resolveComponent("icon-loading"),
		m = resolveComponent("icon-link");
	return openBlock(), createElementBlock("a", {
			href: o.disabled ? void 0 : o.href,
			class: normalizeClass(o.cls),
			onClick: s[0] || (s[0] = (...g) => o.handleClick && o.handleClick(...g))
		}, [o.loading || o.showIcon ? (openBlock(), createElementBlock("span", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-icon`)
		}, [o.loading ? (openBlock(), createBlock(f, {
			key: 0
		})) : renderSlot(o.$slots, "icon", {
			key: 1
		}, () => [createVNode(m)])], 2)) : createCommentVNode("v-if", !0), renderSlot(o.$slots, "default")], 10,
		_hoisted_1$L)
}
var _Link = _export_sfc$1(_sfc_main$27, [
	["render", _sfc_render$1R]
]);
const Link = Object.assign(_Link, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Link.name, _Link)
		}
	}),
	_sfc_main$26 = defineComponent({
		name: "PanelFooter",
		components: {
			Link,
			Button
		},
		props: {
			prefixCls: {
				type: String,
				required: !0
			},
			showTodayBtn: {
				type: Boolean
			},
			showConfirmBtn: {
				type: Boolean
			},
			confirmBtnDisabled: {
				type: Boolean
			}
		},
		emits: ["today-btn-click", "confirm-btn-click"],
		setup(o, {
			emit: s
		}) {
			return {
				datePickerT: useDatePickerTransform$1(),
				onTodayClick: () => {
					s("today-btn-click")
				},
				onConfirmBtnClick: () => {
					s("confirm-btn-click")
				}
			}
		}
	});

function _sfc_render$1Q(o, s, a, l, c, d) {
	const f = resolveComponent("Link"),
		m = resolveComponent("Button");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-footer`)
	}, [o.$slots.extra ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-footer-extra-wrapper`)
		}, [renderSlot(o.$slots, "extra")], 2)) : createCommentVNode("v-if", !0), o.showTodayBtn ? (openBlock(),
			createElementBlock("div", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-footer-now-wrapper`)
			}, [createVNode(f, {
				onClick: o.onTodayClick
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(o.datePickerT(
					"datePicker.today")), 1)]),
				_: 1
			}, 8, ["onClick"])], 2)) : createCommentVNode("v-if", !0), o.$slots.btn || o.showConfirmBtn ? (
			openBlock(), createElementBlock("div", {
				key: 2,
				class: normalizeClass(`${o.prefixCls}-footer-btn-wrapper`)
			}, [renderSlot(o.$slots, "btn"), o.showConfirmBtn ? (openBlock(), createBlock(m, {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-btn-confirm`),
				type: "primary",
				size: "mini",
				disabled: o.confirmBtnDisabled,
				onClick: o.onConfirmBtnClick
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(o.datePickerT(
					"datePicker.ok")), 1)]),
				_: 1
			}, 8, ["class", "disabled", "onClick"])) : createCommentVNode("v-if", !0)], 2)) :
		createCommentVNode("v-if", !0)
	], 2)
}
var PanelFooter = _export_sfc$1(_sfc_main$26, [
	["render", _sfc_render$1Q]
]);

function usePanelSpan(o) {
	const {
		mode: s
	} = toRefs(o), a = computed(() => ({
		date: 1,
		week: 1,
		year: 10 * 12,
		quarter: 12,
		month: 12
	})[s.value]), l = computed(() => ["year"].includes(s.value) ? 10 * 12 : 12);
	return {
		span: a,
		superSpan: l
	}
}

function useHeaderValue(o) {
	const {
		mode: s,
		value: a,
		defaultValue: l,
		selectedValue: c,
		format: d,
		onChange: f
	} = toRefs(o), m = computed(() => (s == null ? void 0 : s.value) || "date"), {
		span: g,
		superSpan: v
	} = usePanelSpan(reactive({
		mode: m
	})), y = (F, R) => {
		const O = m.value === "date" || m.value === "week" ? "M" : "y";
		return F.isSame(R, O)
	}, b = computed(() => getDayjsValue(a == null ? void 0 : a.value, d.value)), C = computed(() => getDayjsValue(
		l == null ? void 0 : l.value, d.value)), _ = ref(C.value || getNow()), S = computed(() => b.value || _
		.value), w = F => {
		F && (_.value = F)
	}, T = (F, R = !0) => {
		var O;
		F && (R && !y(S.value, F) && ((O = f == null ? void 0 : f.value) == null || O.call(f, F)), w(F))
	};
	c != null && c.value && w(c.value), watch(() => c == null ? void 0 : c.value, F => {
		T(F)
	});

	function A() {
		return (c == null ? void 0 : c.value) || C.value || getNow()
	}

	function k(F = !0) {
		const R = A();
		F ? T(R) : w(R)
	}
	const M = computed(() => g.value !== v.value),
		D = computed(() => ({
			onSuperPrev: () => {
				T(methods.subtract(S.value, v.value, "M"))
			},
			onPrev: M.value ? () => {
				T(methods.subtract(S.value, g.value, "M"))
			} : void 0,
			onNext: M.value ? () => {
				T(methods.add(S.value, g.value, "M"))
			} : void 0,
			onSuperNext: () => {
				T(methods.add(S.value, v.value, "M"))
			}
		}));
	return {
		headerValue: S,
		setHeaderValue: T,
		headerOperations: D,
		resetHeaderValue: k,
		getDefaultLocalValue: A
	}
}
const _sfc_main$25 = defineComponent({
	name: "DatePikerPanel",
	components: {
		DatePanel,
		PanelShortcuts,
		PanelFooter,
		WeekPanel,
		MonthPanel,
		YearPanel,
		QuarterPanel,
		RenderFunction
	},
	props: {
		mode: {
			type: String
		},
		headerMode: {
			type: String
		},
		prefixCls: {
			type: String,
			required: !0
		},
		value: {
			type: Object
		},
		headerValue: {
			type: Object,
			required: !0
		},
		timePickerValue: {
			type: Object
		},
		showTime: {
			type: Boolean
		},
		showConfirmBtn: {
			type: Boolean
		},
		shortcuts: {
			type: Array,
			default: () => []
		},
		shortcutsPosition: {
			type: String,
			default: "bottom"
		},
		format: {
			type: String,
			required: !0
		},
		dayStartOfWeek: {
			type: Number,
			default: 0
		},
		disabledDate: {
			type: Function
		},
		disabledTime: {
			type: Function
		},
		timePickerProps: {
			type: Object
		},
		extra: {
			type: Function
		},
		dateRender: {
			type: Function
		},
		hideTrigger: {
			type: Boolean
		},
		confirmBtnDisabled: {
			type: Boolean
		},
		showNowBtn: {
			type: Boolean
		},
		headerIcons: {
			type: Object,
			default: () => ({})
		},
		headerOperations: {
			type: Object
		},
		abbreviation: {
			type: Boolean
		}
	},
	emits: ["cell-click", "time-picker-select", "shortcut-click", "shortcut-mouse-enter",
		"shortcut-mouse-leave", "confirm", "today-btn-click", "header-label-click", "header-select",
		"month-header-click"
	],
	setup(o, {
		emit: s
	}) {
		const {
			prefixCls: a,
			shortcuts: l,
			shortcutsPosition: c,
			format: d,
			value: f,
			disabledDate: m,
			hideTrigger: g,
			showNowBtn: v,
			dateRender: y,
			showConfirmBtn: b,
			headerValue: C,
			headerIcons: _,
			headerOperations: S,
			headerMode: w
		} = toRefs(o), T = computed(() => !!(l.value && l.value.length)), A = computed(() => v.value && b
			.value && !T.value), k = computed(() => A.value || T.value), M = computed(() => k.value && c
			.value === "left"), D = computed(() => k.value && c.value === "right"), F = computed(() => k
			.value && c.value === "bottom"), R = computed(() => [`${a.value}-container`, {
			[`${a.value}-container-panel-only`]: g.value,
			[`${a.value}-container-shortcuts-placement-left`]: M.value,
			[`${a.value}-container-shortcuts-placement-right`]: D.value
		}]), O = computed(() => (f == null ? void 0 : f.value) || getNow()), {
			headerValue: U,
			setHeaderValue: V,
			headerOperations: z
		} = useHeaderValue(reactive({
			mode: w,
			format: d
		}));
		watch(C, Se => {
			V(Se)
		});

		function j(Se) {
			const {
				value: be
			} = Se;
			return getDayjsValue(isFunction$2(be) ? be() : be, Se.format || d.value)
		}

		function ge(Se) {
			s("shortcut-click", j(Se), Se)
		}

		function me(Se) {
			s("shortcut-mouse-enter", j(Se))
		}

		function he(Se) {
			s("shortcut-mouse-leave", j(Se))
		}

		function ce(Se) {
			s("cell-click", Se)
		}

		function ae(Se) {
			s("time-picker-select", Se)
		}

		function fe() {
			s("today-btn-click", getNow())
		}

		function q() {
			s("confirm")
		}

		function le(Se) {
			s("header-label-click", Se)
		}

		function de(Se) {
			s("header-select", Se)
		}

		function _e() {
			s("month-header-click")
		}
		const ke = reactive({
				prefixCls: a,
				shortcuts: l,
				showNowBtn: A,
				onItemClick: ge,
				onItemMouseEnter: me,
				onItemMouseLeave: he,
				onNowClick: fe
			}),
			De = reactive({
				value: f,
				headerValue: C,
				headerIcons: _,
				headerOperations: S,
				disabledDate: m,
				dateRender: y,
				onSelect: ce,
				onHeaderLabelClick: le
			});
		return {
			classNames: R,
			showShortcutsInLeft: M,
			showShortcutsInRight: D,
			showShortcutsInBottom: F,
			shortcutsProps: ke,
			commonPanelProps: De,
			footerValue: O,
			onTodayBtnClick: fe,
			onConfirmBtnClick: q,
			onTimePickerSelect: ae,
			onHeaderPanelSelect: de,
			headerPanelHeaderValue: U,
			headerPanelHeaderOperations: z,
			onMonthHeaderLabelClick: _e
		}
	}
});

function _sfc_render$1P(o, s, a, l, c, d) {
	const f = resolveComponent("PanelShortcuts"),
		m = resolveComponent("YearPanel"),
		g = resolveComponent("MonthPanel"),
		v = resolveComponent("WeekPanel"),
		y = resolveComponent("QuarterPanel"),
		b = resolveComponent("DatePanel"),
		C = resolveComponent("RenderFunction"),
		_ = resolveComponent("PanelFooter");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [o.showShortcutsInLeft ? (openBlock(), createBlock(f, normalizeProps(mergeProps({
		key: 0
	}, o.shortcutsProps)), null, 16)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-panel-wrapper`)
	}, [o.headerMode ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [o.headerMode === "year" ? (openBlock(), createBlock(m, {
		key: 0,
		"header-value": o.headerPanelHeaderValue,
		"header-icons": o.headerIcons,
		"header-operations": o.headerPanelHeaderOperations,
		onSelect: o.onHeaderPanelSelect
	}, null, 8, ["header-value", "header-icons", "header-operations",
		"onSelect"])) : o.headerMode === "month" ? (openBlock(), createBlock(g, {
		key: 1,
		"header-value": o.headerPanelHeaderValue,
		"header-icons": o.headerIcons,
		"header-operations": o.headerPanelHeaderOperations,
		abbreviation: o.abbreviation,
		onSelect: o.onHeaderPanelSelect,
		onHeaderLabelClick: o.onMonthHeaderLabelClick
	}, null, 8, ["header-value", "header-icons", "header-operations",
		"abbreviation", "onSelect", "onHeaderLabelClick"
	])) : createCommentVNode("v-if", !0)], 64)) : (openBlock(), createElementBlock(Fragment, {
		key: 1
	}, [o.mode === "week" ? (openBlock(), createBlock(v, mergeProps({
		key: 0
	}, o.commonPanelProps, {
		"day-start-of-week": o.dayStartOfWeek
	}), null, 16, ["day-start-of-week"])) : o.mode === "month" ? (openBlock(),
		createBlock(g, mergeProps({
			key: 1,
			abbreviation: o.abbreviation
		}, o.commonPanelProps), null, 16, ["abbreviation"])) : o.mode === "year" ? (
		openBlock(), createBlock(m, normalizeProps(mergeProps({
			key: 2
		}, o.commonPanelProps)), null, 16)) : o.mode === "quarter" ? (openBlock(),
		createBlock(y, normalizeProps(mergeProps({
			key: 3
		}, o.commonPanelProps)), null, 16)) : (openBlock(), createBlock(b, mergeProps({
		key: 4
	}, o.commonPanelProps, {
		mode: "date",
		"show-time": o.showTime,
		"time-picker-props": o.timePickerProps,
		"day-start-of-week": o.dayStartOfWeek,
		"footer-value": o.footerValue,
		"time-picker-value": o.timePickerValue,
		"disabled-time": o.disabledTime,
		onTimePickerSelect: o.onTimePickerSelect
	}), null, 16, ["show-time", "time-picker-props", "day-start-of-week",
		"footer-value", "time-picker-value", "disabled-time",
		"onTimePickerSelect"
	])), createVNode(_, {
		"prefix-cls": o.prefixCls,
		"show-today-btn": o.showNowBtn && !(o.showConfirmBtn || o
			.showShortcutsInBottom),
		"show-confirm-btn": o.showConfirmBtn,
		"confirm-btn-disabled": o.confirmBtnDisabled,
		onTodayBtnClick: o.onTodayBtnClick,
		onConfirmBtnClick: o.onConfirmBtnClick
	}, createSlots({
		_: 2
	}, [o.extra ? {
		name: "extra",
		fn: withCtx(() => [o.extra ? (openBlock(), createBlock(C, {
			key: 0,
			"render-func": o.extra
		}, null, 8, ["render-func"])) : createCommentVNode(
			"v-if", !0)]),
		key: "0"
	} : void 0, o.showShortcutsInBottom ? {
		name: "btn",
		fn: withCtx(() => [createVNode(f, normalizeProps(guardReactiveProps(
			o.shortcutsProps)), null, 16)]),
		key: "1"
	} : void 0]), 1032, ["prefix-cls", "show-today-btn", "show-confirm-btn",
		"confirm-btn-disabled", "onTodayBtnClick", "onConfirmBtnClick"
	])], 64))], 2), o.showShortcutsInRight ? (openBlock(), createBlock(f, normalizeProps(mergeProps({
		key: 1
	}, o.shortcutsProps)), null, 16)) : createCommentVNode("v-if", !0)], 2)
}
var PickerPanel = _export_sfc$1(_sfc_main$25, [
	["render", _sfc_render$1P]
]);

function getDefaultFormat(o = "date", s = !1) {
	switch (o) {
		case "date":
			return s ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
		case "month":
			return "YYYY-MM";
		case "year":
			return "YYYY";
		case "week":
			return "gggg-wo";
		case "quarter":
			return "YYYY-[Q]Q";
		default:
			return "YYYY-MM-DD"
	}
}

function getDefaultValueFormat(o = "date", s = !1) {
	switch (o) {
		case "date":
			return s ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
		case "month":
			return "YYYY-MM";
		case "year":
			return "YYYY";
		case "week":
			return "YYYY-MM-DD";
		case "quarter":
			return "YYYY-MM";
		default:
			return "YYYY-MM-DD"
	}
}

function useFormat(o) {
	const {
		format: s,
		mode: a,
		showTime: l,
		valueFormat: c
	} = toRefs(o), d = computed(() => !isFunction$2(s == null ? void 0 : s.value) && (s == null ? void 0 : s.value) ||
		getDefaultFormat(a == null ? void 0 : a.value, l == null ? void 0 : l.value)), f = computed(() => (c ==
		null ? void 0 : c.value) || getDefaultValueFormat(a == null ? void 0 : a.value, l == null ? void 0 : l
		.value)), m = computed(() => ["timestamp", "Date"].includes(f.value) ? d.value : f.value);
	return {
		format: d,
		valueFormat: f,
		parseValueFormat: m
	}
}

function useIsDisabledDate(o) {
	const {
		mode: s,
		showTime: a,
		disabledDate: l,
		disabledTime: c,
		isRange: d
	} = toRefs(o), f = computed(() => (s == null ? void 0 : s.value) === "date" && (a == null ? void 0 : a.value)), m =
		computed(() => (y, b) => {
			if (!(l != null && l.value)) return !1;
			const C = getDateValue$1(y);
			return d != null && d.value ? l.value(C, b) : l.value(C)
		}), g = (y, b) => ((b == null ? void 0 : b()) || []).includes(y), v = computed(() => (y, b) => {
			if (!f.value || !(c != null && c.value)) return !1;
			const C = getDateValue$1(y),
				_ = d != null && d.value ? c.value(C, b) : c.value(C);
			return g(y.hour(), _.disabledHours) || g(y.minute(), _.disabledMinutes) || g(y.second(), _
				.disabledSeconds)
		});
	return function(b, C) {
		return b && (m.value(b, C || "start") || v.value(b, C || "start"))
	}
}
const getValueByPath = (o, s) => {
		if (!o || !s) return;
		s = s.replace(/\[(\w+)\]/g, ".$1");
		const a = s.split(".");
		if (a.length === 0) return;
		let l = o;
		for (let c = 0; c < a.length; c++) {
			if (!isObject$2(l) && !isArray$2(l) || !a[c]) return;
			if (c !== a.length - 1) l = l[a[c]];
			else return l[a[c]]
		}
	},
	setValueByPath = (o, s, a, {
		addPath: l
	} = {}) => {
		if (!o || !s) return;
		s = s.replace(/\[(\w+)\]/g, ".$1");
		const c = s.split(".");
		if (c.length === 0) return;
		let d = o;
		for (let f = 0; f < c.length; f++) {
			if (!isObject$2(d) && !isArray$2(d) || !c[f]) return;
			f !== c.length - 1 ? (l && isUndefined$1(d[c[f]]) && (d[c[f]] = {}), d = d[c[f]]) : d[c[f]] = a
		}
	};

function useDatePickerTransform(o) {
	const {
		locale: s
	} = toRefs(o), {
		locale: a,
		t: l
	} = useI18n();
	dayjs.locale(a.value.toLowerCase());
	const c = (d, ...f) => {
		const m = d.startsWith("datePicker.") ? d.split(".").slice(1).join(".") : d;
		return getValueByPath((s == null ? void 0 : s.value) || {}, m) || l(d, ...f)
	};
	return provide(PickerInjectionKey, {
		datePickerT: c
	}), c
}

function useTimePickerValue(o) {
	const {
		timePickerProps: s,
		selectedValue: a
	} = toRefs(o), l = computed(() => {
		var b;
		return (b = s == null ? void 0 : s.value) == null ? void 0 : b.format
	}), c = computed(() => {
		var b;
		return !!((b = s == null ? void 0 : s.value) != null && b.use12Hours)
	}), {
		format: d
	} = useTimeFormat(reactive({
		format: l,
		use12Hours: c
	})), f = computed(() => {
		var b;
		return getDayjsValue((b = s == null ? void 0 : s.value) == null ? void 0 : b.defaultValue, d.value)
	}), m = () => (a == null ? void 0 : a.value) || f.value || getNow(), g = ref(m());

	function v(b) {
		b && (g.value = b)
	}

	function y() {
		g.value = m()
	}
	return watch(a, b => {
		v(b)
	}), [g, v, y]
}

function getReturnValue(o, s) {
	return s === "timestamp" ? o.toDate().getTime() : s === "Date" ? o.toDate() : o.format(s)
}

function useReturnValue(o) {
	const {
		format: s
	} = toRefs(o);
	return a => getReturnValue(a, s.value)
}

function getReturnRangeValue(o, s) {
	return o.map(a => a ? getReturnValue(a, s) : void 0)
}
const _sfc_main$24 = defineComponent({
	name: "Picker",
	components: {
		DateInput,
		Trigger,
		PickerPanel,
		IconCalendar
	},
	inheritAttrs: !1,
	props: {
		locale: {
			type: Object
		},
		hideTrigger: {
			type: Boolean
		},
		allowClear: {
			type: Boolean,
			default: !0
		},
		readonly: {
			type: Boolean
		},
		error: {
			type: Boolean
		},
		size: {
			type: String
		},
		shortcuts: {
			type: Array,
			default: () => []
		},
		shortcutsPosition: {
			type: String,
			default: "bottom"
		},
		position: {
			type: String,
			default: "bl"
		},
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean,
			default: !1
		},
		triggerProps: {
			type: Object
		},
		unmountOnClose: {
			type: Boolean
		},
		placeholder: {
			type: String
		},
		disabled: {
			type: Boolean
		},
		disabledDate: {
			type: Function
		},
		disabledTime: {
			type: Function
		},
		pickerValue: {
			type: [Object, String, Number]
		},
		defaultPickerValue: {
			type: [Object, String, Number]
		},
		popupContainer: {
			type: [String, Object]
		},
		mode: {
			type: String,
			default: "date"
		},
		format: {
			type: [String, Function]
		},
		valueFormat: {
			type: String
		},
		previewShortcut: {
			type: Boolean,
			default: !0
		},
		showConfirmBtn: {
			type: Boolean
		},
		showTime: {
			type: Boolean
		},
		timePickerProps: {
			type: Object
		},
		showNowBtn: {
			type: Boolean,
			default: !0
		},
		dayStartOfWeek: {
			type: Number,
			default: 0
		},
		modelValue: {
			type: [Object, String, Number]
		},
		defaultValue: {
			type: [Object, String, Number]
		},
		disabledInput: {
			type: Boolean,
			default: !1
		},
		abbreviation: {
			type: Boolean,
			default: !0
		}
	},
	emits: {
		change: (o, s, a) => !0,
		"update:modelValue": o => !0,
		select: (o, s, a) => !0,
		"popup-visible-change": o => !0,
		"update:popupVisible": o => !0,
		ok: (o, s, a) => !0,
		clear: () => !0,
		"select-shortcut": o => !0,
		"picker-value-change": (o, s, a) => !0,
		"update:pickerValue": o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			mode: l,
			modelValue: c,
			defaultValue: d,
			format: f,
			valueFormat: m,
			placeholder: g,
			popupVisible: v,
			defaultPopupVisible: y,
			disabled: b,
			showTime: C,
			timePickerProps: _,
			disabledDate: S,
			disabledTime: w,
			readonly: T,
			locale: A,
			pickerValue: k,
			defaultPickerValue: M,
			dayStartOfWeek: D,
			previewShortcut: F,
			showConfirmBtn: R
		} = toRefs(o), {
			locale: O
		} = useI18n();
		watchEffect(() => {
			initializeDateLocale(O.value, D.value)
		});
		const {
			mergedDisabled: U,
			eventHandlers: V
		} = useFormItem({
			disabled: b
		}), z = useDatePickerTransform(reactive({
			locale: A
		})), j = getPrefixCls("picker"), ge = ref(), me = computed(() => (g == null ? void 0 : g.value) || {
			date: z("datePicker.placeholder.date"),
			month: z("datePicker.placeholder.month"),
			year: z("datePicker.placeholder.year"),
			week: z("datePicker.placeholder.week"),
			quarter: z("datePicker.placeholder.quarter")
		} [l.value] || z("datePicker.placeholder.date")), {
			format: he,
			valueFormat: ce,
			parseValueFormat: ae
		} = useFormat(reactive({
			format: f,
			mode: l,
			showTime: C,
			valueFormat: m
		})), fe = computed(() => f && isFunction$2(f.value) ? Mt => {
			var qt;
			return (qt = f.value) == null ? void 0 : qt.call(f, getDateValue$1(Mt))
		} : he.value), q = useReturnValue(reactive({
			format: ce
		})), le = useIsDisabledDate(reactive({
			mode: l,
			disabledDate: S,
			disabledTime: w,
			showTime: C
		})), de = computed(() => C.value || R.value), _e = computed(() => de.value && (!pt.value || le(pt
			.value))), ke = computed(() => l.value === "date" && C.value), {
			value: De,
			setValue: Se
		} = usePickerState(reactive({
			modelValue: c,
			defaultValue: d,
			format: ae
		})), [be, Me] = useState(), [Ve, it] = useState(), pt = computed(() => {
			var Mt;
			return (Mt = be.value) != null ? Mt : De.value
		}), dt = computed(() => {
			var Mt, qt;
			return (qt = (Mt = Ve.value) != null ? Mt : be.value) != null ? qt : De.value
		}), [He, Ae] = useState(), [xe, ye] = useMergeState(y.value, reactive({
			value: v
		})), Le = Mt => {
			xe.value !== Mt && (ye(Mt), s("popup-visible-change", Mt), s("update:popupVisible", Mt))
		}, {
			headerValue: Ue,
			setHeaderValue: nt,
			headerOperations: ot,
			resetHeaderValue: at
		} = useHeaderValue(reactive({
			mode: l,
			value: k,
			defaultValue: M,
			selectedValue: dt,
			format: ae,
			onChange: Mt => {
				const qt = q(Mt),
					pn = getFormattedValue(Mt, ae.value),
					Te = getDateValue$1(Mt);
				s("picker-value-change", qt, Te, pn), s("update:pickerValue", qt)
			}
		})), [Je, , Ne] = useTimePickerValue(reactive({
			timePickerProps: _,
			selectedValue: dt
		})), we = computed(() => !T.value && !isFunction$2(fe.value)), Ce = ref();
		watch(xe, Mt => {
			Me(void 0), it(void 0), Ce.value = void 0, Mt && (at(), Ne()), Mt || Ae(void 0)
		});

		function $e(Mt, qt) {
			var pn, Te;
			const Pe = Mt ? q(Mt) : void 0,
				lt = getFormattedValue(Mt, ae.value),
				bt = getDateValue$1(Mt);
			isValueChange(Mt, De.value) && (s("update:modelValue", Pe), s("change", Pe, bt, lt), (Te = (pn = V
				.value) == null ? void 0 : pn.onChange) == null || Te.call(pn)), qt && s("ok", Pe, bt, lt)
		}

		function Fe(Mt, qt, pn) {
			le(Mt) || ($e(Mt, pn), Se(Mt), Me(void 0), it(void 0), Ae(void 0), Ce.value = void 0, isBoolean$2(
				qt) && Le(qt))
		}

		function Ge(Mt, qt) {
			if (Me(Mt), it(void 0), Ae(void 0), Ce.value = void 0, qt) {
				const pn = Mt ? q(Mt) : void 0,
					Te = getFormattedValue(Mt, ae.value),
					Pe = getDateValue$1(Mt);
				s("select", pn, Pe, Te)
			}
		}

		function ze(Mt) {
			ge.value && ge.value.focus && ge.value.focus(Mt)
		}

		function Oe(Mt, qt) {
			return !ke.value && !_.value ? Mt : mergeValueWithTime(getNow(), Mt, qt)
		}

		function Xe(Mt) {
			U.value || Le(Mt)
		}

		function rt(Mt) {
			Mt.stopPropagation(), Fe(void 0), s("clear")
		}

		function ut() {
			var Mt, qt;
			(qt = (Mt = V.value) == null ? void 0 : Mt.onBlur) == null || qt.call(Mt)
		}

		function gt(Mt) {
			Le(!0);
			const qt = Mt.target.value;
			if (Ae(qt), !isValidInputValue(qt, he.value)) return;
			const pn = dayjs(qt, he.value);
			le(pn) || (de.value ? Ge(pn) : Fe(pn, !0))
		}

		function Et() {
			Fe(dt.value, !1)
		}

		function Ze(Mt) {
			de.value ? Ge(Mt, !0) : Fe(Mt, !1)
		}

		function Ye(Mt) {
			const qt = Oe(Mt, Je.value);
			Ze(qt)
		}

		function ct(Mt) {
			const qt = Oe(dt.value || getNow(), Mt);
			Ze(qt)
		}

		function yt() {
			Fe(dt.value, !1, !0)
		}

		function wt() {
			o.disabledInput && ze()
		}
		let Qe;
		onUnmounted(() => {
			clearTimeout(Qe)
		});

		function At(Mt) {
			clearTimeout(Qe), it(Mt), Ae(void 0)
		}

		function Ct() {
			clearTimeout(Qe), Qe = setTimeout(() => {
				it(void 0)
			}, 100)
		}

		function xt(Mt, qt) {
			s("select-shortcut", qt), Fe(Mt, !1)
		}

		function Rt(Mt) {
			Ce.value = Mt
		}

		function $t() {
			Ce.value = "year"
		}

		function zt(Mt) {
			let qt = Ue.value;
			if (qt = qt.set("year", Mt.year()), Ce.value === "month" && (qt = qt.set("month", Mt.month())), nt(
					qt), l.value === "quarter" || l.value === "month") {
				Ce.value = void 0;
				return
			}
			Ce.value = Ce.value === "year" ? "month" : void 0
		}
		const sn = computed(() => ({
				format: he.value,
				...omit((_ == null ? void 0 : _.value) || {}, ["defaultValue"]),
				visible: xe.value
			})),
			dn = computed(() => ({
				...pick(o, ["mode", "shortcuts", "shortcutsPosition", "dayStartOfWeek", "disabledDate",
					"disabledTime", "showTime", "hideTrigger", "abbreviation"
				]),
				showNowBtn: o.showNowBtn && l.value === "date",
				prefixCls: j,
				format: ae.value,
				value: dt.value,
				visible: xe.value,
				showConfirmBtn: de.value,
				confirmBtnDisabled: _e.value,
				timePickerProps: sn.value,
				extra: a.extra,
				dateRender: a.cell,
				headerValue: Ue.value,
				headerIcons: {
					prev: a["icon-prev"],
					prevDouble: a["icon-prev-double"],
					next: a["icon-next"],
					nextDouble: a["icon-next-double"]
				},
				headerOperations: ot.value,
				timePickerValue: Je.value,
				headerMode: Ce.value,
				onCellClick: Ye,
				onTimePickerSelect: ct,
				onConfirm: yt,
				onShortcutClick: xt,
				onShortcutMouseEnter: F.value ? At : void 0,
				onShortcutMouseLeave: F.value ? Ct : void 0,
				onTodayBtnClick: Ze,
				onHeaderLabelClick: Rt,
				onHeaderSelect: zt,
				onMonthHeaderClick: $t
			}));
		return {
			prefixCls: j,
			refInput: ge,
			panelProps: dn,
			panelValue: dt,
			inputValue: He,
			selectedValue: De,
			inputFormat: fe,
			computedPlaceholder: me,
			panelVisible: xe,
			inputEditable: we,
			needConfirm: de,
			mergedDisabled: U,
			onPanelVisibleChange: Xe,
			onInputClear: rt,
			onInputChange: gt,
			onInputPressEnter: Et,
			onInputBlur: ut,
			onPanelClick: wt
		}
	}
});

function _sfc_render$1O(o, s, a, l, c, d) {
	const f = resolveComponent("IconCalendar"),
		m = resolveComponent("DateInput"),
		g = resolveComponent("PickerPanel"),
		v = resolveComponent("Trigger");
	return o.hideTrigger ? (openBlock(), createBlock(g, normalizeProps(mergeProps({
		key: 1
	}, {
		...o.$attrs,
		...o.panelProps
	})), null, 16)) : (openBlock(), createBlock(v, mergeProps({
		key: 0,
		trigger: "click",
		"animation-name": "slide-dynamic-origin",
		"auto-fit-transform-origin": "",
		"click-to-close": !1,
		"popup-offset": 4
	}, o.triggerProps, {
		position: o.position,
		disabled: o.mergedDisabled || o.readonly,
		"prevent-focus": !0,
		"popup-visible": o.panelVisible,
		"unmount-on-close": o.unmountOnClose,
		"popup-container": o.popupContainer,
		onPopupVisibleChange: o.onPanelVisibleChange
	}), {
		content: withCtx(() => [createVNode(g, mergeProps(o.panelProps, {
			onClick: o.onPanelClick
		}), null, 16, ["onClick"])]),
		default: withCtx(() => [renderSlot(o.$slots, "default", {}, () => [createVNode(m, mergeProps(o
			.$attrs, {
				ref: "refInput",
				size: o.size,
				focused: o.panelVisible,
				visible: o.panelVisible,
				error: o.error,
				disabled: o.mergedDisabled,
				readonly: !o.inputEditable || o.disabledInput,
				"allow-clear": o.allowClear && !o.readonly,
				placeholder: o.computedPlaceholder,
				"input-value": o.inputValue,
				value: o.needConfirm ? o.panelValue : o.selectedValue,
				format: o.inputFormat,
				onClear: o.onInputClear,
				onChange: o.onInputChange,
				onPressEnter: o.onInputPressEnter,
				onBlur: o.onInputBlur
			}), createSlots({
			"suffix-icon": withCtx(() => [renderSlot(o.$slots,
				"suffix-icon", {}, () => [createVNode(f)])]),
			_: 2
		}, [o.$slots.prefix ? {
			name: "prefix",
			fn: withCtx(() => [renderSlot(o.$slots, "prefix")]),
			key: "0"
		} : void 0]), 1040, ["size", "focused", "visible", "error", "disabled",
			"readonly", "allow-clear", "placeholder", "input-value", "value",
			"format", "onClear", "onChange", "onPressEnter", "onBlur"
		])])]),
		_: 3
	}, 16, ["position", "disabled", "popup-visible", "unmount-on-close", "popup-container",
		"onPopupVisibleChange"
	]))
}
var Picker = _export_sfc$1(_sfc_main$24, [
		["render", _sfc_render$1O]
	]),
	_DatePicker = defineComponent({
		name: "DatePicker",
		props: {
			modelValue: {
				type: [Object, String, Number]
			},
			defaultValue: {
				type: [Object, String, Number]
			},
			format: {
				type: [String, Function]
			},
			dayStartOfWeek: {
				type: Number,
				default: 0
			},
			showTime: {
				type: Boolean
			},
			timePickerProps: {
				type: Object
			},
			disabled: {
				type: Boolean
			},
			disabledDate: {
				type: Function
			},
			disabledTime: {
				type: Function
			},
			showNowBtn: {
				type: Boolean,
				default: !0
			}
		},
		setup(o, {
			attrs: s,
			slots: a
		}) {
			return () => createVNode(Picker, mergeProps(o, s, {
				mode: "date"
			}), a)
		}
	}),
	WeekPicker = defineComponent({
		name: "WeekPicker",
		props: {
			modelValue: {
				type: [Object, String, Number]
			},
			defaultValue: {
				type: [Object, String, Number]
			},
			format: {
				type: String,
				default: "gggg-wo"
			},
			valueFormat: {
				type: String,
				default: "YYYY-MM-DD"
			},
			dayStartOfWeek: {
				type: Number,
				default: 0
			}
		},
		setup(o, {
			attrs: s,
			slots: a
		}) {
			return () => createVNode(Picker, mergeProps(o, s, {
				mode: "week"
			}), a)
		}
	}),
	MonthPicker = defineComponent({
		name: "MonthPicker",
		props: {
			modelValue: {
				type: [Object, String, Number]
			},
			defaultValue: {
				type: [Object, String, Number]
			},
			format: {
				type: String,
				default: "YYYY-MM"
			}
		},
		setup(o, {
			attrs: s,
			slots: a
		}) {
			return () => createVNode(Picker, mergeProps(o, s, {
				mode: "month"
			}), a)
		}
	}),
	YearPicker = defineComponent({
		name: "YearPicker",
		props: {
			modelValue: {
				type: [Object, String, Number]
			},
			defaultValue: {
				type: [Object, String, Number]
			},
			format: {
				type: String,
				default: "YYYY"
			}
		},
		setup(o, {
			attrs: s,
			slots: a
		}) {
			return () => createVNode(Picker, mergeProps(o, s, {
				mode: "year"
			}), a)
		}
	}),
	QuarterPicker = defineComponent({
		name: "QuarterPicker",
		props: {
			modelValue: {
				type: [Object, String, Number]
			},
			defaultValue: {
				type: [Object, String, Number]
			},
			format: {
				type: String,
				default: "YYYY-[Q]Q"
			},
			valueFormat: {
				type: String,
				default: "YYYY-MM"
			}
		},
		setup(o, {
			attrs: s,
			slots: a
		}) {
			return () => createVNode(Picker, mergeProps(o, s, {
				mode: "quarter"
			}), a)
		}
	});

function useRangePickerState(o) {
	const {
		modelValue: s,
		defaultValue: a,
		format: l
	} = toRefs(o), c = computed(() => getDayjsValue(normalizeRangeValue(s.value), l.value)), d = computed(() =>
		getDayjsValue(normalizeRangeValue(a.value), l.value)), [f, m] = useState(isUndefined$1(c.value) ?
		isUndefined$1(d.value) ? [] : d.value : c.value);
	return watch(c, () => {
		isUndefined$1(c.value) && m([])
	}), {
		value: computed(() => c.value || f.value),
		setValue: m
	}
}

function useRangeHeaderValue(o) {
	const {
		startHeaderMode: s,
		endHeaderMode: a,
		mode: l,
		value: c,
		defaultValue: d,
		selectedValue: f,
		format: m,
		onChange: g
	} = toRefs(o), v = computed(() => ["date", "week"].includes(l.value)), y = computed(() => v.value ? "M" : "y"), b =
		(be, Me) => be.isSame(Me, y.value), {
			span: C,
			superSpan: _
		} = usePanelSpan(reactive({
			mode: l
		})), S = computed(() => (s == null ? void 0 : s.value) || l.value), w = computed(() => (a == null ? void 0 : a
			.value) || l.value), T = computed(() => {
			var be;
			return (be = c.value) == null ? void 0 : be[0]
		}), A = computed(() => {
			var be;
			return (be = c.value) == null ? void 0 : be[1]
		}), k = computed(() => {
			var be;
			return (be = d.value) == null ? void 0 : be[0]
		}), M = computed(() => {
			var be;
			return (be = d.value) == null ? void 0 : be[1]
		}), D = be => {
			g != null && g.value && g.value(be)
		}, {
			headerValue: F,
			setHeaderValue: R,
			headerOperations: O,
			getDefaultLocalValue: U
		} = useHeaderValue(reactive({
			mode: S,
			value: T,
			defaultValue: k,
			selectedValue: void 0,
			format: m,
			onChange: be => {
				D([be, V.value])
			}
		})), {
			headerValue: V,
			setHeaderValue: z,
			headerOperations: j,
			getDefaultLocalValue: ge
		} = useHeaderValue(reactive({
			mode: w,
			value: A,
			defaultValue: M,
			selectedValue: void 0,
			format: m,
			onChange: be => {
				D([F.value, be])
			}
		})), me = be => {
			const Me = b(F.value, be[0]),
				Ve = b(V.value, be[1]);
			R(be[0], !1), z(be[1], !1), (!Me || !Ve) && g != null && g.value && (g == null || g.value(be))
		};

	function he(be) {
		let [Me, Ve] = getSortedDayjsArray(be);
		const it = methods.add(Me, C.value, "M");
		return Ve.isBefore(it, y.value) && (Ve = it), [Me, Ve]
	}

	function ce() {
		var be, Me;
		let Ve = (be = f.value) == null ? void 0 : be[0],
			it = (Me = f.value) == null ? void 0 : Me[1];
		return Ve && it && ([Ve, it] = getSortedDayjsArray([Ve, it])), [Ve, it]
	}
	const [ae, fe] = ce(), [q, le] = he([ae || F.value, fe || V.value]);
	R(q, !1), z(le, !1);
	const de = () => {
			const be = U(),
				Me = ge();
			nextTick(() => {
				const [Ve, it] = ce(), [pt, dt] = he([Ve || be, it || Me]);
				me([pt, dt])
			})
		},
		_e = computed(() => methods.add(F.value, C.value, "M").isBefore(V.value, y.value)),
		ke = computed(() => methods.add(F.value, _.value, "M").isBefore(V.value, y.value)),
		De = computed(() => {
			const be = ["onSuperPrev"];
			return v.value && be.push("onPrev"), _e.value && v && be.push("onNext"), ke.value && be.push(
				"onSuperNext"), pick(O.value, be)
		}),
		Se = computed(() => {
			const be = ["onSuperNext"];
			return v.value && be.push("onNext"), _e.value && v.value && be.push("onPrev"), ke.value && be.push(
				"onSuperPrev"), pick(j.value, be)
		});
	return {
		startHeaderValue: F,
		endHeaderValue: V,
		startHeaderOperations: De,
		endHeaderOperations: Se,
		setHeaderValue: me,
		resetHeaderValue: de
	}
}
const _sfc_main$23 = defineComponent({
		name: "DateInputRange",
		components: {
			IconHover,
			IconClose,
			FeedbackIcon
		},
		props: {
			size: {
				type: String
			},
			focused: {
				type: Boolean
			},
			focusedIndex: {
				type: Number
			},
			error: {
				type: Boolean
			},
			disabled: {
				type: [Boolean, Array],
				default: !1
			},
			readonly: {
				type: Boolean
			},
			allowClear: {
				type: Boolean
			},
			placeholder: {
				type: Array,
				default: () => []
			},
			inputValue: {
				type: Array
			},
			value: {
				type: Array,
				default: () => []
			},
			format: {
				type: [String, Function],
				required: !0
			}
		},
		emits: ["focused-index-change", "update:focusedIndex", "change", "clear", "press-enter"],
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				error: l,
				focused: c,
				disabled: d,
				size: f,
				value: m,
				format: g,
				focusedIndex: v,
				inputValue: y
			} = toRefs(o), {
					mergedSize: b,
					mergedDisabled: C,
					mergedError: _,
					feedback: S
				} = useFormItem({
					size: f,
					error: l
				}), {
					mergedSize: w
				} = useSize$1(b), T = ref(), A = ref(), k = ae => C.value ? C.value : isArray$2(d.value) ? d.value[
					ae] : d.value, M = computed(() => k(0)), D = computed(() => k(1)), F = getPrefixCls("picker"),
				R = computed(() => [F, `${F}-range`, `${F}-size-${w.value}`, {
					[`${F}-focused`]: c.value,
					[`${F}-disabled`]: M.value && D.value,
					[`${F}-error`]: _.value,
					[`${F}-has-prefix`]: a.prefix
				}]);

			function O(ae) {
				return [`${F}-input`, {
					[`${F}-input-active`]: ae === (v == null ? void 0 : v.value)
				}]
			}

			function U(ae) {
				var fe, q;
				if (y != null && y.value) return (fe = y == null ? void 0 : y.value) == null ? void 0 : fe[ae];
				const le = (q = m == null ? void 0 : m.value) == null ? void 0 : q[ae];
				if (le && isDayjs(le)) return isFunction$2(g.value) ? g.value(le) : le.format(g.value)
			}
			const V = computed(() => U(0)),
				z = computed(() => U(1));

			function j(ae) {
				s("focused-index-change", ae), s("update:focusedIndex", ae)
			}

			function ge(ae) {
				ae.stopPropagation(), s("change", ae)
			}

			function me() {
				s("press-enter")
			}

			function he(ae) {
				ae.preventDefault()
			}

			function ce(ae) {
				s("clear", ae)
			}
			return {
				prefixCls: F,
				classNames: R,
				refInput0: T,
				refInput1: A,
				disabled0: M,
				disabled1: D,
				mergedDisabled: C,
				getDisabled: k,
				getInputWrapClassName: O,
				displayValue0: V,
				displayValue1: z,
				changeFocusedInput: j,
				onChange: ge,
				onPressEnter: me,
				onPressTab: he,
				onClear: ce,
				feedback: S
			}
		},
		methods: {
			focus(o) {
				const s = isNumber$2(o) ? o : this.focusedIndex,
					a = s === 0 ? this.refInput0 : this.refInput1;
				!isUndefined$1(s) && !this.getDisabled(s) && a && a.focus && a.focus()
			},
			blur() {
				const o = this.focusedIndex === 0 ? this.refInput0 : this.refInput1;
				o && o.blur && o.blur()
			}
		}
	}),
	_hoisted_1$K = ["disabled", "placeholder", "value"],
	_hoisted_2$5 = ["disabled", "placeholder", "value"];

function _sfc_render$1N(o, s, a, l, c, d) {
	const f = resolveComponent("IconClose"),
		m = resolveComponent("IconHover"),
		g = resolveComponent("FeedbackIcon");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [o.$slots.prefix ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-prefix`)
		}, [renderSlot(o.$slots, "prefix")], 2)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
			class: normalizeClass(o.getInputWrapClassName(0))
		}, [createBaseVNode("input", mergeProps({
			ref: "refInput0",
			disabled: o.disabled0,
			placeholder: o.placeholder[0],
			value: o.displayValue0
		}, o.readonly ? {
			readonly: !0
		} : {}, {
			onInput: s[0] || (s[0] = (...v) => o.onChange && o.onChange(...v)),
			onKeydown: [s[1] || (s[1] = withKeys((...v) => o.onPressEnter && o.onPressEnter(...
				v), ["enter"])), s[2] || (s[2] = withKeys((...v) => o.onPressTab && o
				.onPressTab(...v), ["tab"]))],
			onClick: s[3] || (s[3] = () => o.changeFocusedInput(0))
		}), null, 16, _hoisted_1$K)], 2), createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-separator`)
		}, [renderSlot(o.$slots, "separator", {}, () => [s[8] || (s[8] = createTextVNode(" - "))])], 2),
		createBaseVNode("div", {
			class: normalizeClass(o.getInputWrapClassName(1))
		}, [createBaseVNode("input", mergeProps({
			ref: "refInput1",
			disabled: o.disabled1,
			placeholder: o.placeholder[1],
			value: o.displayValue1
		}, o.readonly ? {
			readonly: !0
		} : {}, {
			onInput: s[4] || (s[4] = (...v) => o.onChange && o.onChange(...v)),
			onKeydown: [s[5] || (s[5] = withKeys((...v) => o.onPressEnter && o.onPressEnter(...
				v), ["enter"])), s[6] || (s[6] = withKeys((...v) => o.onPressTab && o
				.onPressTab(...v), ["tab"]))],
			onClick: s[7] || (s[7] = () => o.changeFocusedInput(1))
		}), null, 16, _hoisted_2$5)], 2), createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-suffix`)
		}, [o.allowClear && !o.mergedDisabled && o.value.length === 2 ? (openBlock(), createBlock(m, {
			key: 0,
			prefix: o.prefixCls,
			class: normalizeClass(`${o.prefixCls}-clear-icon`),
			onClick: o.onClear
		}, {
			default: withCtx(() => [createVNode(f)]),
			_: 1
		}, 8, ["prefix", "class", "onClick"])) : createCommentVNode("v-if", !0), createBaseVNode(
		"span", {
			class: normalizeClass(`${o.prefixCls}-suffix-icon`)
		}, [renderSlot(o.$slots, "suffix-icon")], 2), o.feedback ? (openBlock(), createBlock(g, {
			key: 1,
			type: o.feedback
		}, null, 8, ["type"])) : createCommentVNode("v-if", !0)], 2)
	], 2)
}
var DateRangeInput = _export_sfc$1(_sfc_main$23, [
	["render", _sfc_render$1N]
]);
const _sfc_main$22 = defineComponent({
	name: "DateRangePikerPanel",
	components: {
		PanelShortcuts,
		PanelFooter,
		RenderFunction,
		DatePanel,
		WeekPanel,
		MonthPanel,
		YearPanel,
		QuarterPanel
	},
	props: {
		mode: {
			type: String,
			default: "date"
		},
		value: {
			type: Array,
			default: () => []
		},
		footerValue: {
			type: Array
		},
		timePickerValue: {
			type: Array
		},
		showTime: {
			type: Boolean
		},
		showConfirmBtn: {
			type: Boolean
		},
		prefixCls: {
			type: String,
			required: !0
		},
		shortcuts: {
			type: Array,
			default: () => []
		},
		shortcutsPosition: {
			type: String,
			default: "bottom"
		},
		format: {
			type: String,
			required: !0
		},
		dayStartOfWeek: {
			type: Number,
			default: 0
		},
		disabledDate: {
			type: Function
		},
		disabledTime: {
			type: Function
		},
		timePickerProps: {
			type: Object
		},
		extra: {
			type: Function
		},
		dateRender: {
			type: Function
		},
		hideTrigger: {
			type: Boolean
		},
		startHeaderProps: {
			type: Object,
			default: () => ({})
		},
		endHeaderProps: {
			type: Object,
			default: () => ({})
		},
		confirmBtnDisabled: {
			type: Boolean
		},
		disabled: {
			type: Array,
			default: () => [!1, !1]
		},
		visible: {
			type: Boolean
		},
		startHeaderMode: {
			type: String
		},
		endHeaderMode: {
			type: String
		},
		abbreviation: {
			type: Boolean
		}
	},
	emits: ["cell-click", "cell-mouse-enter", "time-picker-select", "shortcut-click", "shortcut-mouse-enter",
		"shortcut-mouse-leave", "confirm", "start-header-label-click", "end-header-label-click",
		"start-header-select", "end-header-select"
	],
	setup(o, {
		emit: s
	}) {
		const {
			prefixCls: a,
			shortcuts: l,
			shortcutsPosition: c,
			format: d,
			hideTrigger: f,
			value: m,
			disabledDate: g,
			disabledTime: v,
			startHeaderProps: y,
			endHeaderProps: b,
			dateRender: C,
			visible: _,
			startHeaderMode: S,
			endHeaderMode: w
		} = toRefs(o), T = computed(() => isArray$2(l.value) && l.value.length), A = computed(() => [
			`${a.value}-range-container`, {
				[`${a.value}-range-container-panel-only`]: f.value,
				[`${a.value}-range-container-shortcuts-placement-left`]: T.value && c.value === "left",
				[`${a.value}-range-container-shortcuts-placement-right`]: T.value && c.value === "right"
			}
		]), k = ref("date");
		watch(_, (ke, De) => {
			ke && !De && (k.value = "date")
		});

		function M(ke) {
			return getDayjsValue(normalizeRangeValue(isFunction$2(ke.value) ? ke.value() : ke.value), ke
				.format || d.value)
		}

		function D(ke) {
			s("shortcut-click", M(ke), ke)
		}

		function F(ke) {
			s("shortcut-mouse-enter", M(ke))
		}

		function R(ke) {
			s("shortcut-mouse-leave", M(ke))
		}

		function O(ke) {
			s("cell-click", ke)
		}

		function U(ke) {
			s("cell-mouse-enter", ke)
		}

		function V() {
			s("confirm")
		}

		function z(ke) {
			s("time-picker-select", ke, "start")
		}

		function j(ke) {
			s("time-picker-select", ke, "end")
		}

		function ge(ke) {
			s("start-header-label-click", ke)
		}

		function me(ke) {
			s("end-header-label-click", ke)
		}

		function he(ke) {
			s("start-header-select", ke)
		}

		function ce(ke) {
			s("end-header-select", ke)
		}

		function ae(ke) {
			return isFunction$2(g == null ? void 0 : g.value) ? De => {
				var Se;
				return ((Se = g == null ? void 0 : g.value) == null ? void 0 : Se.call(g, De, ke === 0 ?
					"start" : "end")) || !1
			} : void 0
		}

		function fe(ke) {
			return isFunction$2(v == null ? void 0 : v.value) ? De => {
				var Se;
				return ((Se = v == null ? void 0 : v.value) == null ? void 0 : Se.call(v, De, ke === 0 ?
					"start" : "end")) || !1
			} : void 0
		}

		function q(ke) {
			return isFunction$2(C == null ? void 0 : C.value) ? De => {
				var Se;
				const be = {
					...De,
					type: ke === 0 ? "start" : "end"
				};
				return (Se = C == null ? void 0 : C.value) == null ? void 0 : Se.call(C, be)
			} : void 0
		}
		const le = reactive({
				prefixCls: a,
				shortcuts: l,
				onItemClick: D,
				onItemMouseEnter: F,
				onItemMouseLeave: R
			}),
			de = computed(() => ({
				...y.value,
				rangeValues: m.value,
				disabledDate: ae(0),
				dateRender: q(0),
				onSelect: S.value ? he : O,
				onCellMouseEnter: U,
				onHeaderLabelClick: ge
			})),
			_e = computed(() => ({
				...b.value,
				rangeValues: m.value,
				disabledDate: ae(1),
				dateRender: q(1),
				onSelect: w.value ? ce : O,
				onCellMouseEnter: U,
				onHeaderLabelClick: me
			}));
		return {
			pick,
			classNames: A,
			showShortcuts: T,
			shortcutsProps: le,
			startPanelProps: de,
			endPanelProps: _e,
			getDisabledTimeFunc: fe,
			onConfirmBtnClick: V,
			currentDateView: k,
			onStartTimePickerSelect: z,
			onEndTimePickerSelect: j,
			onStartHeaderPanelSelect: he,
			onEndHeaderPanelSelect: ce
		}
	}
});

function _sfc_render$1M(o, s, a, l, c, d) {
	const f = resolveComponent("PanelShortcuts"),
		m = resolveComponent("YearPanel"),
		g = resolveComponent("MonthPanel"),
		v = resolveComponent("WeekPanel"),
		y = resolveComponent("QuarterPanel"),
		b = resolveComponent("DatePanel"),
		C = resolveComponent("RenderFunction"),
		_ = resolveComponent("PanelFooter");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [o.showShortcuts && o.shortcutsPosition === "left" ? (openBlock(), createBlock(f, normalizeProps(
		mergeProps({
			key: 0
		}, o.shortcutsProps)), null, 16)) : createCommentVNode("v-if", !0), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-range-panel-wrapper`)
	}, [createCommentVNode(" panel "), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-range`)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-range-wrapper`)
	}, [o.startHeaderMode || o.endHeaderMode ? (openBlock(), createElementBlock(
		Fragment, {
			key: 0
		}, [o.startHeaderMode === "year" ? (openBlock(), createBlock(m,
				normalizeProps(mergeProps({
					key: 0
				}, o.startPanelProps)), null, 16)) : createCommentVNode("v-if",
				!0), o.endHeaderMode === "year" ? (openBlock(), createBlock(m,
				normalizeProps(mergeProps({
					key: 1
				}, o.endPanelProps)), null, 16)) : o.startHeaderMode ===
			"month" ? (openBlock(), createBlock(g, mergeProps({
				key: 2
			}, o.startPanelProps, {
				abbreviation: o.abbreviation
			}), null, 16, ["abbreviation"])) : o.endHeaderMode === "month" ? (
				openBlock(), createBlock(g, mergeProps({
					key: 3
				}, o.endPanelProps, {
					abbreviation: o.abbreviation
				}), null, 16, ["abbreviation"])) : createCommentVNode("v-if", !
				0)
		], 64)) : (openBlock(), createElementBlock(Fragment, {
		key: 1
	}, [createCommentVNode(" week "), o.mode === "week" ? (openBlock(),
			createElementBlock(Fragment, {
				key: 0
			}, [createVNode(v, mergeProps(o.startPanelProps, {
				"day-start-of-week": o.dayStartOfWeek
			}), null, 16, ["day-start-of-week"]), createVNode(v,
				mergeProps(o.endPanelProps, {
					"day-start-of-week": o.dayStartOfWeek
				}), null, 16, ["day-start-of-week"])], 64)) : o.mode ===
		"month" ? (openBlock(), createElementBlock(Fragment, {
			key: 1
		}, [createCommentVNode(" month "), createVNode(g,
			mergeProps(o.startPanelProps, {
				abbreviation: o.abbreviation
			}), null, 16, ["abbreviation"]), createVNode(g,
			mergeProps(o.endPanelProps, {
				abbreviation: o.abbreviation
			}), null, 16, ["abbreviation"])], 64)) : o.mode === "year" ? (
			openBlock(), createElementBlock(Fragment, {
				key: 2
			}, [createCommentVNode(" year "), createVNode(m,
				normalizeProps(guardReactiveProps(o
					.startPanelProps)), null, 16), createVNode(m,
				normalizeProps(guardReactiveProps(o.endPanelProps)),
				null, 16)], 64)) : o.mode === "quarter" ? (openBlock(),
			createElementBlock(Fragment, {
				key: 3
			}, [createCommentVNode(" quarter "), createVNode(y,
				normalizeProps(guardReactiveProps(o
					.startPanelProps)), null, 16), createVNode(y,
				normalizeProps(guardReactiveProps(o.endPanelProps)),
				null, 16)], 64)) : (openBlock(), createElementBlock(
			Fragment, {
				key: 4
			}, [createCommentVNode(" date "), createVNode(b,
		mergeProps({
				currentView: o.currentDateView,
				"onUpdate:currentView": s[0] || (s[0] = S =>
					o.currentDateView = S)
			}, o.startPanelProps, {
				"is-range": "",
				value: o.value && o.value[0],
				"footer-value": o.footerValue && o
					.footerValue[0],
				"time-picker-value": o.timePickerValue && o
					.timePickerValue[0],
				"day-start-of-week": o.dayStartOfWeek,
				"show-time": o.showTime,
				"time-picker-props": o.timePickerProps,
				"disabled-time": o.getDisabledTimeFunc(0),
				disabled: o.disabled[0],
				onTimePickerSelect: o
					.onStartTimePickerSelect
			}), null, 16, ["currentView", "value",
				"footer-value", "time-picker-value",
				"day-start-of-week", "show-time",
				"time-picker-props", "disabled-time",
				"disabled", "onTimePickerSelect"
			]), createVNode(b, mergeProps({
				currentView: o.currentDateView,
				"onUpdate:currentView": s[1] || (s[1] = S =>
					o.currentDateView = S)
			}, o.endPanelProps, {
				"is-range": "",
				value: o.value && o.value[1],
				"footer-value": o.footerValue && o
					.footerValue[1],
				"time-picker-value": o.timePickerValue && o
					.timePickerValue[1],
				"day-start-of-week": o.dayStartOfWeek,
				"show-time": o.showTime,
				"time-picker-props": o.timePickerProps,
				"disabled-time": o.getDisabledTimeFunc(1),
				disabled: o.disabled[1],
				onTimePickerSelect: o.onEndTimePickerSelect
			}), null, 16, ["currentView", "value",
				"footer-value", "time-picker-value",
				"day-start-of-week", "show-time",
				"time-picker-props", "disabled-time",
				"disabled", "onTimePickerSelect"
			])], 64))
	], 64))], 2)], 2), createCommentVNode(" footer "), createVNode(_, {
		"prefix-cls": o.prefixCls,
		"show-today-btn": !1,
		"show-confirm-btn": o.showConfirmBtn,
		"confirm-btn-disabled": o.confirmBtnDisabled,
		onConfirmBtnClick: o.onConfirmBtnClick
	}, createSlots({
		_: 2
	}, [o.extra || o.$slots.extra ? {
		name: "extra",
		fn: withCtx(() => [o.$slots.extra ? renderSlot(o.$slots, "extra", {
			key: 0
		}) : (openBlock(), createBlock(C, {
			key: 1,
			"render-func": o.extra
		}, null, 8, ["render-func"]))]),
		key: "0"
	} : void 0, o.showShortcuts && o.shortcutsPosition === "bottom" ? {
		name: "btn",
		fn: withCtx(() => [createVNode(f, normalizeProps(guardReactiveProps(o
			.shortcutsProps)), null, 16)]),
		key: "1"
	} : void 0]), 1032, ["prefix-cls", "show-confirm-btn", "confirm-btn-disabled",
		"onConfirmBtnClick"
	])], 2), o.showShortcuts && o.shortcutsPosition === "right" ? (openBlock(), createBlock(f,
		normalizeProps(mergeProps({
			key: 1
		}, o.shortcutsProps)), null, 16)) : createCommentVNode("v-if", !0)], 2)
}
var RangePickerPanel = _export_sfc$1(_sfc_main$22, [
	["render", _sfc_render$1M]
]);

function useRangeTimePickerValue(o) {
	const {
		timePickerProps: s,
		selectedValue: a
	} = toRefs(o), l = computed(() => {
		var A;
		return (A = a == null ? void 0 : a.value) == null ? void 0 : A[0]
	}), c = computed(() => {
		var A;
		return (A = a == null ? void 0 : a.value) == null ? void 0 : A[1]
	}), d = computed(() => {
		var A;
		return (A = s == null ? void 0 : s.value) == null ? void 0 : A.defaultValue
	}), f = computed(() => isArray$2(d.value) ? {
		...s == null ? void 0 : s.value,
		defaultValue: d.value[0]
	} : s == null ? void 0 : s.value), m = computed(() => isArray$2(d.value) ? {
		...s == null ? void 0 : s.value,
		defaultValue: d.value[1]
	} : s == null ? void 0 : s.value), [g, v, y] = useTimePickerValue(reactive({
		timePickerProps: f,
		selectedValue: l
	})), [b, C, _] = useTimePickerValue(reactive({
		timePickerProps: m,
		selectedValue: c
	})), S = computed(() => [g.value, b.value]);

	function w(A) {
		A && (v(A[0]), C(A[1]))
	}

	function T() {
		y(), _()
	}
	return [S, w, T]
}
const _sfc_main$21 = defineComponent({
	name: "RangePicker",
	components: {
		RangePickerPanel,
		DateRangeInput,
		Trigger,
		IconCalendar
	},
	inheritAttrs: !1,
	props: {
		mode: {
			type: String,
			default: "date"
		},
		modelValue: {
			type: Array
		},
		defaultValue: {
			type: Array
		},
		pickerValue: {
			type: Array
		},
		defaultPickerValue: {
			type: Array
		},
		disabled: {
			type: [Boolean, Array],
			default: !1
		},
		dayStartOfWeek: {
			type: Number,
			default: 0
		},
		format: {
			type: String
		},
		valueFormat: {
			type: String
		},
		showTime: {
			type: Boolean
		},
		timePickerProps: {
			type: Object
		},
		placeholder: {
			type: Array
		},
		disabledDate: {
			type: Function
		},
		disabledTime: {
			type: Function
		},
		separator: {
			type: String
		},
		exchangeTime: {
			type: Boolean,
			default: !0
		},
		popupContainer: {
			type: [String, Object]
		},
		locale: {
			type: Object
		},
		hideTrigger: {
			type: Boolean
		},
		allowClear: {
			type: Boolean,
			default: !0
		},
		readonly: {
			type: Boolean
		},
		error: {
			type: Boolean
		},
		size: {
			type: String
		},
		shortcuts: {
			type: Array,
			default: () => []
		},
		shortcutsPosition: {
			type: String,
			default: "bottom"
		},
		position: {
			type: String,
			default: "bl"
		},
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean
		},
		triggerProps: {
			type: Object
		},
		unmountOnClose: {
			type: Boolean
		},
		previewShortcut: {
			type: Boolean,
			default: !0
		},
		showConfirmBtn: {
			type: Boolean
		},
		disabledInput: {
			type: Boolean,
			default: !1
		},
		abbreviation: {
			type: Boolean,
			default: !0
		}
	},
	emits: {
		change: (o, s, a) => !0,
		"update:modelValue": o => !0,
		select: (o, s, a) => !0,
		"popup-visible-change": o => !0,
		"update:popupVisible": o => !0,
		ok: (o, s, a) => !0,
		clear: () => !0,
		"select-shortcut": o => !0,
		"picker-value-change": (o, s, a) => !0,
		"update:pickerValue": o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			mode: l,
			showTime: c,
			format: d,
			modelValue: f,
			defaultValue: m,
			popupVisible: g,
			defaultPopupVisible: v,
			placeholder: y,
			timePickerProps: b,
			disabled: C,
			disabledDate: _,
			disabledTime: S,
			locale: w,
			pickerValue: T,
			defaultPickerValue: A,
			valueFormat: k,
			size: M,
			error: D,
			dayStartOfWeek: F,
			exchangeTime: R,
			previewShortcut: O,
			showConfirmBtn: U
		} = toRefs(o), {
			locale: V
		} = useI18n(), z = inject(configProviderInjectionKey, void 0);
		watchEffect(() => {
			initializeDateLocale(V.value, F.value)
		});
		const j = computed(() => {
				var et;
				return !(!R.value || !((et = z == null ? void 0 : z.exchangeTime) == null || et))
			}),
			{
				mergedSize: ge,
				mergedDisabled: me,
				mergedError: he,
				eventHandlers: ce
			} = useFormItem({
				size: M,
				error: D
			}),
			ae = useDatePickerTransform(reactive({
				locale: w
			})),
			fe = getPrefixCls("picker"),
			q = computed(() => (y == null ? void 0 : y.value) || {
				date: ae("datePicker.rangePlaceholder.date"),
				month: ae("datePicker.rangePlaceholder.month"),
				year: ae("datePicker.rangePlaceholder.year"),
				week: ae("datePicker.rangePlaceholder.week"),
				quarter: ae("datePicker.rangePlaceholder.quarter")
			} [l.value] || ae("datePicker.rangePlaceholder.date")),
			{
				format: le,
				valueFormat: de,
				parseValueFormat: _e
			} = useFormat(reactive({
				mode: l,
				format: d,
				showTime: c,
				valueFormat: k
			})),
			ke = computed(() => {
				const et = C.value === !0 || me.value || isArray$2(C.value) && C.value[0] === !0,
					ft = C.value === !0 || me.value || isArray$2(C.value) && C.value[1] === !0;
				return [et, ft]
			}),
			De = computed(() => ke.value[0] && ke.value[1]);

		function Se(et = 0) {
			return ke.value[et] ? et ^ 1 : et
		}
		const be = ref(),
			Me = ref(Se()),
			Ve = computed(() => {
				const et = Me.value,
					ft = et ^ 1;
				return ke.value[ft] ? et : ft
			}),
			it = computed(() => ke.value[Me.value ^ 1]),
			{
				value: pt,
				setValue: dt
			} = useRangePickerState(reactive({
				modelValue: f,
				defaultValue: m,
				format: _e
			})),
			[He, Ae] = useState(),
			[xe, ye] = useState(),
			Le = computed(() => {
				var et;
				return (et = He.value) != null ? et : pt.value
			}),
			Ue = computed(() => {
				var et, ft;
				return (ft = (et = xe.value) != null ? et : He.value) != null ? ft : pt.value
			}),
			[nt, ot] = useState(),
			at = ref(),
			Je = ref(),
			[Ne, we] = useMergeState(v.value, reactive({
				value: g
			})),
			Ce = et => {
				Ne.value !== et && (we(et), s("popup-visible-change", et), s("update:popupVisible", et))
			},
			{
				startHeaderValue: $e,
				endHeaderValue: Fe,
				startHeaderOperations: Ge,
				endHeaderOperations: ze,
				resetHeaderValue: Oe,
				setHeaderValue: Xe
			} = useRangeHeaderValue(reactive({
				mode: l,
				startHeaderMode: at,
				endHeaderMode: Je,
				value: T,
				defaultValue: A,
				selectedValue: Ue,
				format: _e,
				onChange: et => {
					const ft = getReturnRangeValue(et, de.value),
						vt = getFormattedValue(et, _e.value),
						mt = getDateValue$1(et);
					s("picker-value-change", ft, mt, vt), s("update:pickerValue", ft)
				}
			}));

		function rt(et) {
			at.value = et
		}

		function ut(et) {
			Je.value = et
		}

		function gt(et) {
			let ft = $e.value;
			ft = ft.set("year", et.year()), at.value === "month" && (ft = ft.set("month", et.month())), Xe([ft,
				Fe.value
			]), at.value = void 0
		}

		function Et(et) {
			let ft = Fe.value;
			ft = ft.set("year", et.year()), Je.value === "month" && (ft = ft.set("month", et.month())), Xe([$e
				.value, ft
			]), Je.value = void 0
		}
		const Ze = ref([Ue.value[0] || getNow(), Ue.value[1] || getNow()]);
		watch(Ue, () => {
			const [et, ft] = Ue.value;
			Ze.value[0] = et || Ze.value[0], Ze.value[1] = ft || Ze.value[1]
		});
		const [Ye, ct, yt] = useRangeTimePickerValue(reactive({
				timePickerProps: b,
				selectedValue: Ue
			})), wt = computed(() => l.value === "date" && c.value), Qe = computed(() => wt.value || b.value),
			At = useIsDisabledDate(reactive({
				mode: l,
				isRange: !0,
				showTime: c,
				disabledDate: _,
				disabledTime: S
			})), Ct = computed(() => wt.value || U.value), xt = computed(() => Ct.value && (!
				isCompleteRangeValue(Le.value) || At(Le.value[0], "start") || At(Le.value[1], "end")));
		watch(Ne, et => {
			at.value = void 0, Je.value = void 0, Ae(void 0), ye(void 0), et && (Oe(), yt(), Me.value =
				Se(Me.value), nextTick(() => qt(Me.value))), et || ot(void 0)
		}), watch(Me, () => {
			o.disabledInput && (qt(Me.value), ot(void 0))
		});

		function Rt(et, ft) {
			var vt, mt;
			const Dt = et ? getReturnRangeValue(et, de.value) : void 0,
				Pt = getFormattedValue(et, _e.value),
				Lt = getDateValue$1(et);
			isValueChange(et, pt.value) && (s("update:modelValue", Dt), s("change", Dt, Lt, Pt), (mt = (vt = ce
				.value) == null ? void 0 : vt.onChange) == null || mt.call(vt)), ft && s("ok", Dt, Lt, Pt)
		}

		function $t(et) {
			let ft = getSortedDayjsArray(et);
			return Qe.value && !j.value && (ft = [pn(ft[0], et[0]), pn(ft[1], et[1])]), ft
		}

		function zt(et, ft, vt) {
			if (At(et == null ? void 0 : et[0], "start") || At(et == null ? void 0 : et[1], "end")) return;
			let mt = et ? [...et] : void 0;
			isCompleteRangeValue(mt) && (mt = $t(mt)), Rt(mt, vt), dt(mt || []), Ae(void 0), ye(void 0), ot(
				void 0), at.value = void 0, Je.value = void 0, isBoolean$2(ft) && Ce(ft)
		}

		function sn(et) {
			const ft = getReturnRangeValue(et, de.value),
				vt = getFormattedValue(et, _e.value),
				mt = getDateValue$1(et);
			s("select", ft, mt, vt)
		}

		function dn(et, ft) {
			const {
				emitSelect: vt = !1,
				updateHeader: mt = !1
			} = ft || {};
			let Dt = [...et];
			isCompleteRangeValue(Dt) && (Dt = $t(Dt)), Ae(Dt), ye(void 0), ot(void 0), at.value = void 0, Je
				.value = void 0, vt && sn(Dt), mt && Oe()
		}

		function Mt(et, ft) {
			const {
				updateHeader: vt = !1
			} = ft || {};
			ye(et), ot(void 0), vt && Oe()
		}

		function qt(et) {
			be.value && be.value.focus && be.value.focus(et)
		}

		function pn(et, ft) {
			return Qe.value ? mergeValueWithTime(getNow(), et, ft) : et
		}

		function Te(et) {
			Ce(et)
		}

		function Pe(et) {
			if (He.value && Ue.value[Ve.value] && (!Ct.value || !isCompleteRangeValue(He.value))) {
				const ft = [...Ue.value],
					vt = pn(et, Ye.value[Me.value]);
				ft[Me.value] = vt, Mt(ft)
			}
		}

		function lt(et = !1) {
			return it.value ? [...pt.value] : He.value ? et || !isCompleteRangeValue(He.value) ? [...He.value] :
				[] : et ? [...pt.value] : []
		}

		function bt(et) {
			const ft = lt(),
				vt = pn(et, Ye.value[Me.value]);
			ft[Me.value] = vt, sn(ft), !Ct.value && isCompleteRangeValue(ft) ? zt(ft, !1) : (dn(ft),
				isCompleteRangeValue(ft) ? Me.value = 0 : Me.value = Ve.value)
		}

		function Nt(et, ft) {
			const vt = ft === "start" ? 0 : 1,
				mt = pn(Ye.value[vt], et),
				Dt = [...Ye.value];
			Dt[vt] = mt, ct(Dt);
			const Pt = lt(!0);
			Pt[vt] && (Pt[vt] = mt, dn(Pt, {
				emitSelect: !0
			}))
		}
		let Ot;
		onUnmounted(() => {
			clearTimeout(Ot)
		});

		function nn(et) {
			clearTimeout(Ot), Mt(et, {
				updateHeader: !0
			})
		}

		function Cn() {
			clearTimeout(Ot), Ot = setTimeout(() => {
				ye(void 0), ot(void 0), Oe()
			}, 100)
		}

		function wn(et, ft) {
			s("select-shortcut", ft), zt(et, !1)
		}

		function Mn() {
			zt(Ue.value, !1, !0)
		}

		function fn(et) {
			et.stopPropagation(), zt(void 0), s("clear")
		}

		function zn(et) {
			Ce(!0);
			const ft = et.target.value;
			if (!ft) {
				ot(void 0);
				return
			}
			const vt = getFormattedValue(Ue.value, le.value),
				mt = isArray$2(nt.value) ? [...nt.value] : vt || [];
			if (mt[Me.value] = ft, ot(mt), !isValidInputValue(ft, le.value)) return;
			const Dt = dayjs(ft, le.value);
			if (At(Dt, Me.value === 0 ? "start" : "end")) return;
			const Pt = isArray$2(Ue.value) ? [...Ue.value] : [];
			Pt[Me.value] = Dt, dn(Pt, {
				updateHeader: !0
			})
		}

		function On() {
			isValidRangeValue(Ue.value) ? zt(Ue.value, !1) : Me.value = Ve.value
		}
		const Nn = computed(() => ({
				format: le.value,
				...omit((b == null ? void 0 : b.value) || {}, ["defaultValue"]),
				visible: Ne.value
			})),
			An = computed(() => ({
				prev: a["icon-prev"],
				prevDouble: a["icon-prev-double"],
				next: a["icon-next"],
				nextDouble: a["icon-next-double"]
			})),
			$n = reactive({
				headerValue: $e,
				headerOperations: Ge,
				headerIcons: An
			}),
			Rn = reactive({
				headerValue: Fe,
				headerOperations: ze,
				headerIcons: An
			}),
			We = computed(() => ({
				...pick(o, ["mode", "showTime", "shortcuts", "shortcutsPosition", "dayStartOfWeek",
					"disabledDate", "disabledTime", "hideTrigger", "abbreviation"
				]),
				prefixCls: fe,
				format: _e.value,
				value: Ue.value,
				showConfirmBtn: Ct.value,
				confirmBtnDisabled: xt.value,
				timePickerValue: Ye.value,
				timePickerProps: Nn.value,
				extra: a.extra,
				dateRender: a.cell,
				startHeaderProps: $n,
				endHeaderProps: Rn,
				footerValue: Ze.value,
				disabled: ke.value,
				visible: Ne.value,
				onCellClick: bt,
				onCellMouseEnter: Pe,
				onShortcutClick: wn,
				onShortcutMouseEnter: O.value ? nn : void 0,
				onShortcutMouseLeave: O.value ? Cn : void 0,
				onConfirm: Mn,
				onTimePickerSelect: Nt,
				startHeaderMode: at.value,
				endHeaderMode: Je.value,
				onStartHeaderLabelClick: rt,
				onEndHeaderLabelClick: ut,
				onStartHeaderSelect: gt,
				onEndHeaderSelect: Et
			}));
		return {
			prefixCls: fe,
			refInput: be,
			computedFormat: le,
			computedPlaceholder: q,
			panelVisible: Ne,
			panelValue: Ue,
			inputValue: nt,
			focusedIndex: Me,
			triggerDisabled: De,
			mergedSize: ge,
			mergedError: he,
			onPanelVisibleChange: Te,
			onInputClear: fn,
			onInputChange: zn,
			onInputPressEnter: On,
			rangePanelProps: We
		}
	}
});

function _sfc_render$1L(o, s, a, l, c, d) {
	const f = resolveComponent("IconCalendar"),
		m = resolveComponent("DateRangeInput"),
		g = resolveComponent("RangePickerPanel"),
		v = resolveComponent("Trigger");
	return o.hideTrigger ? (openBlock(), createBlock(g, normalizeProps(mergeProps({
		key: 1
	}, {
		...o.$attrs,
		...o.rangePanelProps
	})), null, 16)) : (openBlock(), createBlock(v, mergeProps({
		key: 0,
		trigger: "click",
		"animation-name": "slide-dynamic-origin",
		"auto-fit-transform-origin": "",
		"click-to-close": !1,
		"popup-offset": 4
	}, o.triggerProps, {
		"unmount-on-close": o.unmountOnClose,
		position: o.position,
		disabled: o.triggerDisabled || o.readonly,
		"popup-visible": o.panelVisible,
		"popup-container": o.popupContainer,
		onPopupVisibleChange: o.onPanelVisibleChange
	}), {
		content: withCtx(() => [createVNode(g, normalizeProps(guardReactiveProps(o.rangePanelProps)), null,
			16)]),
		default: withCtx(() => [renderSlot(o.$slots, "default", {}, () => [createVNode(m, mergeProps({
			ref: "refInput"
		}, o.$attrs, {
			focusedIndex: o.focusedIndex,
			"onUpdate:focusedIndex": s[0] || (s[0] = y => o.focusedIndex = y),
			size: o.size,
			focused: o.panelVisible,
			visible: o.panelVisible,
			error: o.error,
			disabled: o.disabled,
			readonly: o.readonly || o.disabledInput,
			"allow-clear": o.allowClear && !o.readonly,
			placeholder: o.computedPlaceholder,
			"input-value": o.inputValue,
			value: o.panelValue,
			format: o.computedFormat,
			onClear: o.onInputClear,
			onChange: o.onInputChange,
			onPressEnter: o.onInputPressEnter
		}), createSlots({
			"suffix-icon": withCtx(() => [renderSlot(o.$slots,
				"suffix-icon", {}, () => [createVNode(f)])]),
			separator: withCtx(() => [renderSlot(o.$slots, "separator", {},
			() => [createTextVNode(toDisplayString(o.separator ||
					"-"), 1)])]),
			_: 2
		}, [o.$slots.prefix ? {
			name: "prefix",
			fn: withCtx(() => [renderSlot(o.$slots, "prefix")]),
			key: "0"
		} : void 0]), 1040, ["focusedIndex", "size", "focused", "visible", "error",
			"disabled", "readonly", "allow-clear", "placeholder", "input-value",
			"value", "format", "onClear", "onChange", "onPressEnter"
		])])]),
		_: 3
	}, 16, ["unmount-on-close", "position", "disabled", "popup-visible", "popup-container",
		"onPopupVisibleChange"
	]))
}
var RangePicker = _export_sfc$1(_sfc_main$21, [
	["render", _sfc_render$1L]
]);
const DatePicker = Object.assign(_DatePicker, {
		WeekPicker,
		MonthPicker,
		YearPicker,
		QuarterPicker,
		RangePicker,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _DatePicker.name, _DatePicker), o.component(a + YearPicker.name, YearPicker), o
				.component(a + QuarterPicker.name, QuarterPicker), o.component(a + MonthPicker.name,
					MonthPicker), o.component(a + WeekPicker.name, WeekPicker), o.component(a + RangePicker
					.name, RangePicker)
		}
	}),
	responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"],
	responsiveMap = {
		xs: "(max-width: 575px)",
		sm: "(min-width: 576px)",
		md: "(min-width: 768px)",
		lg: "(min-width: 992px)",
		xl: "(min-width: 1200px)",
		xxl: "(min-width: 1600px)"
	};
let subscribers = [],
	subUid = -1,
	screens = {};
const responsiveObserve = {
	matchHandlers: {},
	dispatch(o, s) {
		return screens = o, subscribers.length < 1 ? !1 : (subscribers.forEach(a => {
			a.func(screens, s)
		}), !0)
	},
	subscribe(o) {
		subscribers.length === 0 && this.register();
		const s = (++subUid).toString();
		return subscribers.push({
			token: s,
			func: o
		}), o(screens, null), s
	},
	unsubscribe(o) {
		subscribers = subscribers.filter(s => s.token !== o), subscribers.length === 0 && this.unregister()
	},
	unregister() {
		Object.keys(responsiveMap).forEach(o => {
			const s = responsiveMap[o];
			if (!s) return;
			const a = this.matchHandlers[s];
			a && a.mql && a.listener && (a.mql.removeEventListener ? a.mql.removeEventListener("change", a
				.listener) : a.mql.removeListener(a.listener))
		})
	},
	register() {
		Object.keys(responsiveMap).forEach(o => {
			const s = responsiveMap[o];
			if (!s) return;
			const a = ({
					matches: c
				}) => {
					this.dispatch({
						...screens,
						[o]: c
					}, o)
				},
				l = window.matchMedia(s);
			l.addEventListener ? l.addEventListener("change", a) : l.addListener(a), this.matchHandlers[
			s] = {
				mql: l,
				listener: a
			}, a(l)
		})
	}
};

function isResponsiveValue(o) {
	return isObject$2(o)
}

function useResponsiveState(o, s, a = !1) {
	const l = ref({
			xs: !0,
			sm: !0,
			md: !0,
			lg: !0,
			xl: !0,
			xxl: !0
		}),
		c = computed(() => {
			let f = s;
			if (isResponsiveValue(o.value))
				for (let m = 0; m < responsiveArray.length; m++) {
					const g = responsiveArray[m];
					if ((l.value[g] || g === "xs" && a) && o.value[g] !== void 0) {
						f = o.value[g];
						break
					}
				} else f = o.value;
			return f
		});
	let d = "";
	return onMounted(() => {
		d = responsiveObserve.subscribe(f => {
			isResponsiveValue(o.value) && (l.value = f)
		})
	}), onUnmounted(() => {
		d && responsiveObserve.unsubscribe(d)
	}), c
}
var _Descriptions = defineComponent({
	name: "Descriptions",
	props: {
		data: {
			type: Array,
			default: () => []
		},
		column: {
			type: [Number, Object],
			default: 3
		},
		title: String,
		layout: {
			type: String,
			default: "horizontal"
		},
		align: {
			type: [String, Object],
			default: "left"
		},
		size: {
			type: String
		},
		bordered: {
			type: Boolean,
			default: !1
		},
		labelStyle: {
			type: Object
		},
		valueStyle: {
			type: Object
		},
		tableLayout: {
			type: String,
			default: "auto"
		}
	},
	setup(o, {
		slots: s
	}) {
		const {
			column: a,
			size: l
		} = toRefs(o), c = getPrefixCls("descriptions"), {
				mergedSize: d
			} = useSize$1(l), f = useResponsiveState(a, 3, !0), m = computed(() => {
				var F;
				return (F = isObject$2(o.align) ? o.align.label : o.align) != null ? F : "left"
			}), g = computed(() => {
				var F;
				return (F = isObject$2(o.align) ? o.align.value : o.align) != null ? F : "left"
			}), v = computed(() => ({
				textAlign: m.value,
				...o.labelStyle
			})), y = computed(() => ({
				textAlign: g.value,
				...o.valueStyle
			})), b = F => {
				const R = [];
				let O = [],
					U = 0;
				const V = () => {
					if (O.length) {
						const z = f.value - U;
						O[O.length - 1].span += z, R.push(O)
					}
				};
				return F.forEach(z => {
					var j, ge;
					const me = Math.min((ge = isVNode(z) ? (j = z.props) == null ? void 0 : j.span : z
						.span) != null ? ge : 1, f.value);
					U + me > f.value && (V(), O = [], U = 0), O.push({
						data: z,
						span: me
					}), U += me
				}), V(), R
			}, C = computed(() => {
				var F;
				return b((F = o.data) != null ? F : [])
			}), _ = (F, R) => {
				var O, U, V, z, j;
				return isVNode(F) ? isSlotsChildren(F, F.children) && ((U = (O = F.children).label) == null ?
					void 0 : U.call(O)) || ((V = F.props) == null ? void 0 : V.label) : (j = (z = s
					.label) == null ? void 0 : z.call(s, {
						label: F.label,
						index: R,
						data: F
					})) != null ? j : isFunction$2(F.label) ? F.label() : F.label
			}, S = (F, R) => {
				var O, U;
				return isVNode(F) ? F : (U = (O = s.value) == null ? void 0 : O.call(s, {
					value: F.value,
					index: R,
					data: F
				})) != null ? U : isFunction$2(F.value) ? F.value() : F.value
			}, w = F => createVNode(Fragment, null, [createVNode("tr", {
				class: `${c}-row`
			}, [F.map((R, O) => createVNode("td", {
				key: `label-${O}`,
				class: [`${c}-item-label`, `${c}-item-label-block`],
				style: v.value,
				colspan: R.span
			}, [_(R.data, O)]))]), createVNode("tr", {
				class: `${c}-row`
			}, [F.map((R, O) => createVNode("td", {
				key: `value-${O}`,
				class: [`${c}-item-value`, `${c}-item-value-block`],
				style: y.value,
				colspan: R.span
			}, [S(R.data, O)]))])]), T = (F, R) => createVNode("tr", {
				class: `${c}-row`,
				key: `tr-${R}`
			}, [F.map(O => createVNode(Fragment, null, [createVNode("td", {
				class: [`${c}-item-label`, `${c}-item-label-block`],
				style: v.value
			}, [_(O.data, R)]), createVNode("td", {
				class: [`${c}-item-value`, `${c}-item-value-block`],
				style: y.value,
				colspan: O.span * 2 - 1
			}, [S(O.data, R)])]))]), A = (F, R) => createVNode("tr", {
				class: `${c}-row`,
				key: `inline-${R}`
			}, [F.map((O, U) => createVNode("td", {
				key: `item-${U}`,
				class: `${c}-item`,
				colspan: O.span
			}, [createVNode("div", {
				class: [`${c}-item-label`, `${c}-item-label-inline`],
				style: v.value
			}, [_(O.data, U)]), createVNode("div", {
				class: [`${c}-item-value`, `${c}-item-value-inline`],
				style: y.value
			}, [S(O.data, U)])]))]), k = (F, R) => ["inline-horizontal", "inline-vertical"].includes(o.layout) ?
			A(F, R) : o.layout === "vertical" ? w(F) : T(F, R), M = computed(() => [c,
				`${c}-layout-${o.layout}`, `${c}-size-${d.value}`, {
					[`${c}-border`]: o.bordered
				}, {
					[`${c}-table-layout-fixed`]: o.tableLayout === "fixed"
				}
			]), D = () => {
				var F, R;
				const O = (R = (F = s.title) == null ? void 0 : F.call(s)) != null ? R : o.title;
				return O ? createVNode("div", {
					class: `${c}-title`
				}, [O]) : null
			};
		return () => {
			const F = s.default ? b(getAllElements(s.default())) : C.value;
			return createVNode("div", {
				class: M.value
			}, [D(), createVNode("div", {
				class: `${c}-body`
			}, [createVNode("table", {
				class: `${c}-table`
			}, [createVNode("tbody", null, [F.map((R, O) => k(R, O))])])])])
		}
	}
});
const _sfc_main$20 = defineComponent({
	name: "DescriptionsItem",
	props: {
		span: {
			type: Number,
			default: 1
		},
		label: String
	},
	setup() {
		return {
			prefixCls: getPrefixCls("descriptions")
		}
	}
});

function _sfc_render$1K(o, s, a, l, c, d) {
	return renderSlot(o.$slots, "default")
}
var DescriptionsItem = _export_sfc$1(_sfc_main$20, [
	["render", _sfc_render$1K]
]);
const Descriptions = Object.assign(_Descriptions, {
	DescriptionsItem,
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Descriptions.name, _Descriptions), o.component(a + DescriptionsItem.name,
			DescriptionsItem)
	}
});
var _Divider = defineComponent({
	name: "Divider",
	props: {
		direction: {
			type: String,
			default: "horizontal"
		},
		orientation: {
			type: String,
			default: "center"
		},
		type: {
			type: String
		},
		size: {
			type: Number
		},
		margin: {
			type: [Number, String]
		}
	},
	setup(o, {
		slots: s
	}) {
		const a = getPrefixCls("divider"),
			l = computed(() => o.direction === "horizontal"),
			c = computed(() => {
				const d = {};
				if (o.size && (d[l.value ? "border-bottom-width" : "border-left-width"] = isNumber$2(o
						.size) ? `${o.size}px` : o.size), o.type && (d[l.value ? "border-bottom-style" :
						"border-left-style"] = o.type), !isUndefined$1(o.margin)) {
					const f = isNumber$2(o.margin) ? `${o.margin}px` : o.margin;
					d.margin = l.value ? `${f} 0` : `0 ${f}`
				}
				return d
			});
		return () => {
			var d;
			const f = (d = s.default) == null ? void 0 : d.call(s),
				m = [a, `${a}-${o.direction}`, {
					[`${a}-with-text`]: f
				}];
			return createVNode("div", {
				role: "separator",
				class: m,
				style: c.value
			}, [f && o.direction === "horizontal" && createVNode("span", {
				class: [`${a}-text`, `${a}-text-${o.orientation}`]
			}, [f])])
		}
	}
});
const Divider = Object.assign(_Divider, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Divider.name, _Divider)
		}
	}),
	useOverflow = o => {
		const s = ref(!1),
			a = {
				overflow: "",
				width: "",
				boxSizing: ""
			};
		return {
			setOverflowHidden: () => {
				if (o.value) {
					const d = o.value;
					if (!s.value && d.style.overflow !== "hidden") {
						const f = getScrollBarWidth(d);
						(f > 0 || isScroll(d)) && (a.overflow = d.style.overflow, a.width = d.style.width, a
							.boxSizing = d.style.boxSizing, d.style.overflow = "hidden", d.style.width =
							`${d.offsetWidth-f}px`, d.style.boxSizing = "border-box", s.value = !0)
					}
				}
			},
			resetOverflow: () => {
				if (o.value && s.value) {
					const d = o.value;
					d.style.overflow = a.overflow, d.style.width = a.width, d.style.boxSizing = a.boxSizing, s
						.value = !1
				}
			}
		}
	},
	DRAWER_PLACEMENTS = ["top", "right", "bottom", "left"],
	_sfc_main$1$ = defineComponent({
		name: "Drawer",
		components: {
			ClientOnly,
			ArcoButton: Button,
			IconHover,
			IconClose
		},
		inheritAttrs: !1,
		props: {
			visible: {
				type: Boolean,
				default: !1
			},
			defaultVisible: {
				type: Boolean,
				default: !1
			},
			placement: {
				type: String,
				default: "right",
				validator: o => DRAWER_PLACEMENTS.includes(o)
			},
			title: String,
			mask: {
				type: Boolean,
				default: !0
			},
			maskClosable: {
				type: Boolean,
				default: !0
			},
			closable: {
				type: Boolean,
				default: !0
			},
			okText: String,
			cancelText: String,
			okLoading: {
				type: Boolean,
				default: !1
			},
			okButtonProps: {
				type: Object
			},
			cancelButtonProps: {
				type: Object
			},
			unmountOnClose: Boolean,
			width: {
				type: [Number, String],
				default: 250
			},
			height: {
				type: [Number, String],
				default: 250
			},
			popupContainer: {
				type: [String, Object],
				default: "body"
			},
			drawerStyle: {
				type: Object
			},
			bodyClass: {
				type: [String, Array]
			},
			bodyStyle: {
				type: [String, Object, Array]
			},
			onBeforeOk: {
				type: Function
			},
			onBeforeCancel: {
				type: Function
			},
			escToClose: {
				type: Boolean,
				default: !0
			},
			renderToBody: {
				type: Boolean,
				default: !0
			},
			header: {
				type: Boolean,
				default: !0
			},
			footer: {
				type: Boolean,
				default: !0
			},
			hideCancel: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:visible": o => !0,
			ok: o => !0,
			cancel: o => !0,
			open: () => !0,
			close: () => !0,
			beforeOpen: () => !0,
			beforeClose: () => !0
		},
		setup(o, {
			emit: s
		}) {
			const {
				popupContainer: a
			} = toRefs(o), l = getPrefixCls("drawer"), {
				t: c
			} = useI18n(), d = ref(o.defaultVisible), f = computed(() => {
				var me;
				return (me = o.visible) != null ? me : d.value
			}), m = ref(!1), g = computed(() => o.okLoading || m.value), {
				teleportContainer: v,
				containerRef: y
			} = useTeleportContainer({
				popupContainer: a,
				visible: f
			}), b = ref(f.value);
			let C = !1;
			const _ = me => {
					o.escToClose && me.key === KEYBOARD_KEY.ESC && A() && R(me)
				},
				S = () => {
					o.escToClose && !C && (C = !0, on(document.documentElement, "keydown", _))
				},
				w = () => {
					C && (C = !1, off(document.documentElement, "keydown", _))
				},
				{
					zIndex: T,
					isLastDialog: A
				} = usePopupManager("dialog", {
					visible: f
				}),
				k = computed(() => (y == null ? void 0 : y.value) === document.body);
			let M = 0;
			const D = () => {
					M++, m.value && (m.value = !1), d.value = !1, s("update:visible", !1)
				},
				F = async me => {
					const he = M,
						ce = await new Promise(async ae => {
							var fe;
							if (isFunction$2(o.onBeforeOk)) {
								let q = o.onBeforeOk((le = !0) => ae(le));
								if ((isPromise(q) || !isBoolean$2(q)) && (m.value = !0), isPromise(q))
									try {
										q = (fe = await q) != null ? fe : !0
									} catch (le) {
										throw q = !1, le
									}
								isBoolean$2(q) && ae(q)
							} else ae(!0)
						});
					he === M && (ce ? (s("ok", me), D()) : m.value && (m.value = !1))
				}, R = me => {
					var he;
					let ce = !0;
					isFunction$2(o.onBeforeCancel) && (ce = (he = o.onBeforeCancel()) != null ? he : !1), ce &&
						(s("cancel", me), D())
				}, O = me => {
					o.maskClosable && R(me)
				}, U = () => {
					f.value && s("open")
				}, V = () => {
					f.value || (b.value = !1, j(), s("close"))
				}, {
					setOverflowHidden: z,
					resetOverflow: j
				} = useOverflow(y);
			onMounted(() => {
				f.value && (b.value = !0, z(), S())
			}), onBeforeUnmount(() => {
				j(), w()
			}), watch(f, me => {
				d.value !== me && (d.value = me), me ? (s("beforeOpen"), b.value = !0, z(), S()) : (s(
					"beforeClose"), w())
			});
			const ge = computed(() => {
				var me;
				const he = {
					[o.placement]: 0,
					...(me = o.drawerStyle) != null ? me : {}
				};
				return ["right", "left"].includes(o.placement) ? he.width = isNumber$2(o.width) ?
					`${o.width}px` : o.width : he.height = isNumber$2(o.height) ? `${o.height}px` : o
					.height, he
			});
			return {
				prefixCls: l,
				style: ge,
				t: c,
				mounted: b,
				computedVisible: f,
				mergedOkLoading: g,
				zIndex: T,
				handleOk: F,
				handleCancel: R,
				handleOpen: U,
				handleClose: V,
				handleMask: O,
				isFixed: k,
				teleportContainer: v
			}
		}
	});

function _sfc_render$1J(o, s, a, l, c, d) {
	const f = resolveComponent("icon-close"),
		m = resolveComponent("icon-hover"),
		g = resolveComponent("arco-button"),
		v = resolveComponent("client-only");
	return openBlock(), createBlock(v, null, {
		default: withCtx(() => [(openBlock(), createBlock(Teleport, {
			to: o.teleportContainer,
			disabled: !o.renderToBody
		}, [!o.unmountOnClose || o.computedVisible || o.mounted ? withDirectives((
		openBlock(), createElementBlock("div", mergeProps({
			key: 0,
			class: `${o.prefixCls}-container`,
			style: o.isFixed ? {
				zIndex: o.zIndex
			} : {
				zIndex: "inherit",
				position: "absolute"
			}
		}, o.$attrs), [createVNode(Transition, {
			name: "fade-drawer",
			appear: ""
		}, {
			default: withCtx(() => [o.mask ? withDirectives((
				openBlock(), createElementBlock(
					"div", {
						key: 0,
						class: normalizeClass(
							`${o.prefixCls}-mask`
							),
						onClick: s[0] || (s[0] = (
								...y) => o
							.handleMask && o
							.handleMask(...y))
					}, null, 2)), [
				[vShow, o.computedVisible]
			]) : createCommentVNode("v-if", !0)]),
			_: 1
		}), createVNode(Transition, {
			name: `slide-${o.placement}-drawer`,
			appear: "",
			onAfterEnter: o.handleOpen,
			onAfterLeave: o.handleClose,
			persisted: ""
		}, {
			default: withCtx(() => [withDirectives(createBaseVNode(
				"div", {
					class: normalizeClass(o
						.prefixCls),
					style: normalizeStyle(o.style)
				}, [o.header ? (openBlock(),
						createElementBlock("div", {
							key: 0,
							class: normalizeClass(
								`${o.prefixCls}-header`
								)
						}, [renderSlot(o.$slots,
							"header", {},
						() => [o.$slots
								.title || o
								.title ? (
									openBlock(),
									createElementBlock(
										"div", {
											key: 0,
											class: normalizeClass(
												`${o.prefixCls}-title`
												)
										}, [renderSlot(
											o
											.$slots,
											"title", {},
											() => [
												createTextVNode(
													toDisplayString(
														o
														.title
														),
													1
													)
											]
											)],
										2)
									) :
								createCommentVNode(
									"v-if",
									!0), o
								.closable ?
								(openBlock(),
									createElementBlock(
										"div", {
											key: 1,
											tabindex: "-1",
											role: "button",
											"aria-label": "Close",
											class: normalizeClass(
												`${o.prefixCls}-close-btn`
												),
											onClick: s[
													1
													] ||
												(s[1] =
													(...
														y) =>
													o
													.handleCancel &&
													o
													.handleCancel(
														...
														y
														)
													)
										}, [createVNode(
											m,
											null, {
												default: withCtx(
													() => [
														createVNode(
															f
															)
													]
													),
												_: 1
											}
											)],
										2)
									) :
								createCommentVNode(
									"v-if",
									!0)
							])], 2)) :
					createCommentVNode("v-if", !0),
					createBaseVNode("div", {
						class: normalizeClass([
							`${o.prefixCls}-body`,
							o.bodyClass
						]),
						style: normalizeStyle(o
							.bodyStyle)
					}, [renderSlot(o.$slots,
						"default")], 6), o.footer ?
					(openBlock(),
						createElementBlock("div", {
							key: 1,
							class: normalizeClass(
								`${o.prefixCls}-footer`
								)
						}, [renderSlot(o.$slots,
							"footer", {},
						() => [o.hideCancel ?
								createCommentVNode(
									"v-if",
									!0) : (
									openBlock(),
									createBlock(
										g,
										mergeProps({
												key: 0
											},
											o
											.cancelButtonProps, {
												onClick: o
													.handleCancel
											}
											), {
											default: withCtx(
												() => [
													createTextVNode(
														toDisplayString(
															o
															.cancelText ||
															o
															.t(
																"drawer.cancelText")
															),
														1
														)
												]
												),
											_: 1
										},
										16,
										[
											"onClick"]
										)),
								createVNode(
									g,
									mergeProps({
											type: "primary",
											loading: o
												.mergedOkLoading
										}, o
										.okButtonProps, {
											onClick: o
												.handleOk
										}
										), {
										default: withCtx(
											() => [
												createTextVNode(
													toDisplayString(
														o
														.okText ||
														o
														.t(
															"drawer.okText")
														),
													1
													)
											]
											),
										_: 1
									}, 16, [
										"loading",
										"onClick"
									])
							])], 2)) :
					createCommentVNode("v-if", !0)
				], 6), [
				[vShow, o.computedVisible]
			])]),
			_: 3
		}, 8, ["name", "onAfterEnter", "onAfterLeave"])], 16)), [
			[vShow, o.computedVisible || o.mounted]
		]) : createCommentVNode("v-if", !0)], 8, ["to", "disabled"]))]),
		_: 3
	})
}
var _Drawer = _export_sfc$1(_sfc_main$1$, [
	["render", _sfc_render$1J]
]);
const open$1 = (o, s) => {
		let a = getOverlay("drawer");
		const l = () => {
				v.component && (v.component.props.visible = !1), isFunction$2(o.onOk) && o.onOk()
			},
			c = () => {
				v.component && (v.component.props.visible = !1), isFunction$2(o.onCancel) && o.onCancel()
			},
			d = async () => {
				await nextTick(), a && (render(null, a), document.body.removeChild(a)), a = null, isFunction$2(o
					.onClose) && o.onClose()
			}, f = () => {
				v.component && (v.component.props.visible = !1)
			}, m = y => {
				v.component && Object.entries(y).forEach(([b, C]) => {
					v.component.props[b] = C
				})
			}, v = createVNode(_Drawer, {
				...{
					visible: !0,
					renderToBody: !1,
					unmountOnClose: !0,
					onOk: l,
					onCancel: c,
					onClose: d
				},
				...omit(o, ["content", "title", "footer", "visible", "unmountOnClose", "onOk", "onCancel",
					"onClose"
				]),
				header: typeof o.header == "boolean" ? o.header : void 0,
				footer: typeof o.footer == "boolean" ? o.footer : void 0
			}, {
				default: getSlotFunction(o.content),
				header: typeof o.header != "boolean" ? getSlotFunction(o.header) : void 0,
				title: getSlotFunction(o.title),
				footer: typeof o.footer != "boolean" ? getSlotFunction(o.footer) : void 0
			});
		return (s ?? Drawer._context) && (v.appContext = s ?? Drawer._context), render(v, a), document.body.appendChild(
			a), {
			close: f,
			update: m
		}
	},
	Drawer = Object.assign(_Drawer, {
		open: open$1,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Drawer.name, _Drawer);
			const l = {
				open: (c, d = o._context) => open$1(c, d)
			};
			o.config.globalProperties.$drawer = l
		},
		_context: null
	});

function isOptionsObject(o) {
	return o === Object(o) && Object.keys(o).length !== 0
}

function defaultBehavior(o, s) {
	s === void 0 && (s = "auto");
	var a = "scrollBehavior" in document.body.style;
	o.forEach(function(l) {
		var c = l.el,
			d = l.top,
			f = l.left;
		c.scroll && a ? c.scroll({
			top: d,
			left: f,
			behavior: s
		}) : (c.scrollTop = d, c.scrollLeft = f)
	})
}

function getOptions(o) {
	return o === !1 ? {
		block: "end",
		inline: "nearest"
	} : isOptionsObject(o) ? o : {
		block: "start",
		inline: "nearest"
	}
}

function scrollIntoView(o, s) {
	var a = o.isConnected || o.ownerDocument.documentElement.contains(o);
	if (isOptionsObject(s) && typeof s.behavior == "function") return s.behavior(a ? i(o, s) : []);
	if (a) {
		var l = getOptions(s);
		return defaultBehavior(i(o, l), l.behavior)
	}
}
const VALIDATE_STATUSES = ["success", "warning", "error", "validating"],
	getFinalValidateStatus = o => {
		let s = "";
		for (const a of Object.keys(o)) {
			const l = o[a];
			l && (!s || VALIDATE_STATUSES.indexOf(l) > VALIDATE_STATUSES.indexOf(s)) && (s = o[a])
		}
		return s
	},
	getFinalValidateMessage = o => {
		const s = [];
		for (const a of Object.keys(o)) {
			const l = o[a];
			l && s.push(l)
		}
		return s
	},
	getFormElementId = (o, s) => {
		const a = s.replace(/[[.]/g, "_").replace(/\]/g, "");
		return o ? `${o}-${a}` : `${a}`
	},
	_sfc_main$1_ = defineComponent({
		name: "Form",
		props: {
			model: {
				type: Object,
				required: !0
			},
			layout: {
				type: String,
				default: "horizontal"
			},
			size: {
				type: String
			},
			labelColProps: {
				type: Object,
				default: () => ({
					span: 5,
					offset: 0
				})
			},
			wrapperColProps: {
				type: Object,
				default: () => ({
					span: 19,
					offset: 0
				})
			},
			labelColStyle: Object,
			wrapperColStyle: Object,
			labelAlign: {
				type: String,
				default: "right"
			},
			disabled: {
				type: Boolean,
				default: void 0
			},
			rules: {
				type: Object
			},
			autoLabelWidth: {
				type: Boolean,
				default: !1
			},
			id: {
				type: String
			},
			scrollToFirstError: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			submit: (o, s) => !0,
			submitSuccess: (o, s) => !0,
			submitFailed: (o, s) => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("form"),
				l = ref(),
				{
					id: c,
					model: d,
					layout: f,
					disabled: m,
					labelAlign: g,
					labelColProps: v,
					wrapperColProps: y,
					labelColStyle: b,
					wrapperColStyle: C,
					size: _,
					rules: S
				} = toRefs(o),
				{
					mergedSize: w
				} = useSize$1(_),
				T = computed(() => o.layout === "horizontal" && o.autoLabelWidth),
				A = [],
				k = [],
				M = reactive({}),
				D = computed(() => Math.max(...Object.values(M))),
				F = q => {
					q && q.field && A.push(q)
				},
				R = q => {
					q && q.field && A.splice(A.indexOf(q), 1)
				},
				O = q => {
					A.forEach(le => {
						q[le.field] && le.setField(q[le.field])
					})
				},
				U = (q, le) => {
					le && M[le] !== q && (M[le] = q)
				},
				V = q => {
					q && delete M[q]
				},
				z = q => {
					const le = q ? [].concat(q) : [];
					A.forEach(de => {
						(le.length === 0 || le.includes(de.field)) && de.resetField()
					})
				},
				j = q => {
					const le = q ? [].concat(q) : [];
					A.forEach(de => {
						(le.length === 0 || le.includes(de.field)) && de.clearValidate()
					})
				},
				ge = (q, le) => {
					const _e = (l.value || document.body).querySelector(`#${getFormElementId(o.id,q)}`);
					_e && scrollIntoView(_e, {
						behavior: "smooth",
						block: "nearest",
						scrollMode: "if-needed",
						...le
					})
				},
				me = q => {
					const le = isBoolean$2(o.scrollToFirstError) ? void 0 : o.scrollToFirstError;
					ge(q, le)
				},
				he = q => {
					const le = [];
					return A.forEach(de => {
						le.push(de.validate())
					}), Promise.all(le).then(de => {
						const _e = {};
						let ke = !1;
						return de.forEach(De => {
							De && (ke = !0, _e[De.field] = De)
						}), ke && o.scrollToFirstError && me(Object.keys(_e)[0]), isFunction$2(q) && q(
							ke ? _e : void 0), ke ? _e : void 0
					})
				},
				ce = (q, le) => {
					const de = [];
					for (const _e of A)(isArray$2(q) && q.includes(_e.field) || q === _e.field) && de.push(_e
						.validate());
					return Promise.all(de).then(_e => {
						const ke = {};
						let De = !1;
						return _e.forEach(Se => {
								Se && (De = !0, ke[Se.field] = Se)
							}), De && o.scrollToFirstError && me(Object.keys(ke)[0]), isFunction$2(le) &&
							le(De ? ke : void 0), De ? ke : void 0
					})
				},
				ae = q => {
					const le = [];
					A.forEach(de => {
						le.push(de.validate())
					}), Promise.all(le).then(de => {
						const _e = {};
						let ke = !1;
						de.forEach(De => {
							De && (ke = !0, _e[De.field] = De)
						}), ke ? (o.scrollToFirstError && me(Object.keys(_e)[0]), s("submitFailed", {
							values: d.value,
							errors: _e
						}, q)) : s("submitSuccess", d.value, q), s("submit", {
							values: d.value,
							errors: ke ? _e : void 0
						}, q)
					})
				};
			return provide(formInjectionKey, reactive({
				id: c,
				layout: f,
				disabled: m,
				labelAlign: g,
				labelColProps: v,
				wrapperColProps: y,
				labelColStyle: b,
				wrapperColStyle: C,
				model: d,
				size: w,
				rules: S,
				fields: A,
				touchedFields: k,
				addField: F,
				removeField: R,
				validateField: ce,
				setLabelWidth: U,
				removeLabelWidth: V,
				maxLabelWidth: D,
				autoLabelWidth: T
			})), {
				cls: computed(() => [a, `${a}-layout-${o.layout}`, `${a}-size-${w.value}`, {
					[`${a}-auto-label-width`]: o.autoLabelWidth
				}]),
				formRef: l,
				handleSubmit: ae,
				innerValidate: he,
				innerValidateField: ce,
				innerResetFields: z,
				innerClearValidate: j,
				innerSetFields: O,
				innerScrollToField: ge
			}
		},
		methods: {
			validate(o) {
				return this.innerValidate(o)
			},
			validateField(o, s) {
				return this.innerValidateField(o, s)
			},
			resetFields(o) {
				return this.innerResetFields(o)
			},
			clearValidate(o) {
				return this.innerClearValidate(o)
			},
			setFields(o) {
				return this.innerSetFields(o)
			},
			scrollToField(o) {
				return this.innerScrollToField(o)
			}
		}
	}),
	_hoisted_1$J = ["id"];

function _sfc_render$1I(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("form", {
		id: o.id,
		ref: "formRef",
		class: normalizeClass(o.cls),
		onSubmit: s[0] || (s[0] = withModifiers((...f) => o.handleSubmit && o.handleSubmit(...f), ["prevent"]))
	}, [renderSlot(o.$slots, "default")], 42, _hoisted_1$J)
}
var _Form = _export_sfc$1(_sfc_main$1_, [
		["render", _sfc_render$1I]
	]),
	opt = Object.prototype.toString;

function isArray$1(o) {
	return opt.call(o) === "[object Array]"
}

function isObject$1(o) {
	return opt.call(o) === "[object Object]"
}

function isString$1(o) {
	return opt.call(o) === "[object String]"
}

function isNumber$1(o) {
	return opt.call(o) === "[object Number]" && o === o
}

function isBoolean$1(o) {
	return opt.call(o) === "[object Boolean]"
}

function isFunction$1(o) {
	return opt.call(o) === "[object Function]"
}

function isEmptyObject(o) {
	return isObject$1(o) && Object.keys(o).length === 0
}

function isEmptyValue(o) {
	return o == null || o === ""
}

function isEmptyArray(o) {
	return isArray$1(o) && !o.length
}
var isEqual = function(o, s) {
		if (typeof o != "object" || typeof s != "object") return o === s;
		if (isFunction$1(o) && isFunction$1(s)) return o === s || o.toString() === s.toString();
		if (Object.keys(o).length !== Object.keys(s).length) return !1;
		for (var a in o) {
			var l = isEqual(o[a], s[a]);
			if (!l) return !1
		}
		return !0
	},
	mergeTemplate = function(o, s) {
		var a = Object.assign({}, o);
		return Object.keys(s || {}).forEach(function(l) {
			var c = a[l],
				d = s == null ? void 0 : s[l];
			a[l] = isObject$1(c) ? Object.assign(Object.assign({}, c), d) : d || c
		}), a
	},
	getTemplate = function(o, s) {
		for (var a = s.split("."), l = o, c = 0; c < a.length; c++)
			if (l = l && l[a[c]], l === void 0) return l;
		return l
	},
	defaultTypeTemplate = "#{field} is not a #{type} type",
	defaultValidateLocale = {
		required: "#{field} is required",
		type: {
			ip: defaultTypeTemplate,
			email: defaultTypeTemplate,
			url: defaultTypeTemplate,
			string: defaultTypeTemplate,
			number: defaultTypeTemplate,
			array: defaultTypeTemplate,
			object: defaultTypeTemplate,
			boolean: defaultTypeTemplate
		},
		number: {
			min: "`#{value}` is not greater than `#{min}`",
			max: "`#{value}` is not less than `#{max}`",
			equal: "`#{value}` is not equal to `#{equal}`",
			range: "`#{value}` is not in range `#{min} ~ #{max}`",
			positive: "`#{value}` is not a positive number",
			negative: "`#{value}` is not a negative number"
		},
		string: {
			maxLength: "#{field} cannot be longer than #{maxLength} characters",
			minLength: "#{field} must be at least #{minLength} characters",
			length: "#{field} must be exactly #{length} characters",
			match: "`#{value}` does not match pattern #{pattern}",
			uppercase: "`#{value}` must be all uppercase",
			lowercase: "`#{value}` must be all lowercased"
		},
		array: {
			length: "#{field} must be exactly #{length} in length",
			minLength: "#{field} cannot be less than #{minLength} in length",
			maxLength: "#{field} cannot be greater than #{maxLength} in length",
			includes: "#{field} is not includes #{includes}",
			deepEqual: "#{field} is not deep equal with #{deepEqual}",
			empty: "#{field} is not an empty array"
		},
		object: {
			deepEqual: "#{field} is not deep equal to expected value",
			hasKeys: "#{field} does not contain required fields",
			empty: "#{field} is not an empty object"
		},
		boolean: {
			true: "Expect true but got `#{value}`",
			false: "Expect false but got `#{value}`"
		}
	},
	Base$1 = function(s, a) {
		var l = this;
		this.getValidateMsg = function(c, d) {
				d === void 0 && (d = {});
				var f = Object.assign(Object.assign({}, d), {
						value: l.obj,
						field: l.field,
						type: l.type
					}),
					m = getTemplate(l.validateMessages, c);
				return isFunction$1(m) ? m(f) : isString$1(m) ? m.replace(/\#\{.+?\}/g, function(g) {
					var v = g.slice(2, -1);
					if (v in f) {
						if (isObject$1(f[v]) || isArray$1(f[v])) try {
							return JSON.stringify(f[v])
						} catch {
							return f[v]
						}
						return String(f[v])
					}
					return g
				}) : m
			}, isObject$1(a) && isString$1(s) && a.trim ? this.obj = s.trim() : isObject$1(a) && a.ignoreEmptyString &&
			s === "" ? this.obj = void 0 : this.obj = s, this.message = a.message, this.type = a.type, this.error =
			null, this.field = a.field || a.type, this.validateMessages = mergeTemplate(defaultValidateLocale, a
				.validateMessages)
	},
	prototypeAccessors = {
		not: {
			configurable: !0
		},
		isRequired: {
			configurable: !0
		},
		end: {
			configurable: !0
		}
	};
prototypeAccessors.not.get = function() {
	return this._not = !this._not, this
};
prototypeAccessors.isRequired.get = function() {
	if (isEmptyValue(this.obj) || isEmptyArray(this.obj)) {
		var o = this.getValidateMsg("required");
		this.error = {
			value: this.obj,
			type: this.type,
			requiredError: !0,
			message: this.message || (isObject$1(o) ? o : (this._not ? "[NOT MODE]:" : "") + o)
		}
	}
	return this
};
prototypeAccessors.end.get = function() {
	return this.error
};
Base$1.prototype.addError = function(s) {
	!this.error && s && (this.error = {
		value: this.obj,
		type: this.type,
		message: this.message || (isObject$1(s) ? s : (this._not ? "[NOT MODE]:" : "") + s)
	})
};
Base$1.prototype.validate = function(s, a) {
	var l = this._not ? s : !s;
	return l && this.addError(a), this
};
Base$1.prototype.collect = function(s) {
	s && s(this.error)
};
Object.defineProperties(Base$1.prototype, prototypeAccessors);
var StringValidator = function(o) {
		function s(l, c) {
			o.call(this, l, Object.assign(Object.assign({}, c), {
				type: "string"
			})), this.validate(c && c.strict ? isString$1(this.obj) : !0, this.getValidateMsg("type.string"))
		}
		o && (s.__proto__ = o), s.prototype = Object.create(o && o.prototype), s.prototype.constructor = s;
		var a = {
			uppercase: {
				configurable: !0
			},
			lowercase: {
				configurable: !0
			}
		};
		return s.prototype.maxLength = function(c) {
			return this.obj ? this.validate(this.obj.length <= c, this.getValidateMsg("string.maxLength", {
				maxLength: c
			})) : this
		}, s.prototype.minLength = function(c) {
			return this.obj ? this.validate(this.obj.length >= c, this.getValidateMsg("string.minLength", {
				minLength: c
			})) : this
		}, s.prototype.length = function(c) {
			return this.obj ? this.validate(this.obj.length === c, this.getValidateMsg("string.length", {
				length: c
			})) : this
		}, s.prototype.match = function(c) {
			var d = c instanceof RegExp;
			return d && (c.lastIndex = 0), this.validate(this.obj === void 0 || d && c.test(this.obj), this
				.getValidateMsg("string.match", {
					pattern: c
				}))
		}, a.uppercase.get = function() {
			return this.obj ? this.validate(this.obj.toUpperCase() === this.obj, this.getValidateMsg(
				"string.uppercase")) : this
		}, a.lowercase.get = function() {
			return this.obj ? this.validate(this.obj.toLowerCase() === this.obj, this.getValidateMsg(
				"string.lowercase")) : this
		}, Object.defineProperties(s.prototype, a), s
	}(Base$1),
	NumberValidator = function(o) {
		function s(l, c) {
			o.call(this, l, Object.assign(Object.assign({}, c), {
				type: "number"
			})), this.validate(c && c.strict ? isNumber$1(this.obj) : !0, this.getValidateMsg("type.number"))
		}
		o && (s.__proto__ = o), s.prototype = Object.create(o && o.prototype), s.prototype.constructor = s;
		var a = {
			positive: {
				configurable: !0
			},
			negative: {
				configurable: !0
			}
		};
		return s.prototype.min = function(c) {
			return isEmptyValue(this.obj) ? this : this.validate(this.obj >= c, this.getValidateMsg("number.min", {
				min: c
			}))
		}, s.prototype.max = function(c) {
			return isEmptyValue(this.obj) ? this : this.validate(this.obj <= c, this.getValidateMsg("number.max", {
				max: c
			}))
		}, s.prototype.equal = function(c) {
			return isEmptyValue(this.obj) ? this : this.validate(this.obj === c, this.getValidateMsg(
			"number.equal", {
				equal: c
			}))
		}, s.prototype.range = function(c, d) {
			return isEmptyValue(this.obj) ? this : this.validate(this.obj >= c && this.obj <= d, this
				.getValidateMsg("number.range", {
					min: c,
					max: d
				}))
		}, a.positive.get = function() {
			return isEmptyValue(this.obj) ? this : this.validate(this.obj > 0, this.getValidateMsg(
				"number.positive"))
		}, a.negative.get = function() {
			return isEmptyValue(this.obj) ? this : this.validate(this.obj < 0, this.getValidateMsg(
				"number.negative"))
		}, Object.defineProperties(s.prototype, a), s
	}(Base$1),
	ArrayValidator = function(o) {
		function s(l, c) {
			o.call(this, l, Object.assign(Object.assign({}, c), {
				type: "array"
			})), this.validate(c && c.strict ? isArray$1(this.obj) : !0, this.getValidateMsg("type.array", {
				value: this.obj,
				type: this.type
			}))
		}
		o && (s.__proto__ = o), s.prototype = Object.create(o && o.prototype), s.prototype.constructor = s;
		var a = {
			empty: {
				configurable: !0
			}
		};
		return s.prototype.length = function(c) {
			return this.obj ? this.validate(this.obj.length === c, this.getValidateMsg("array.length", {
				value: this.obj,
				length: c
			})) : this
		}, s.prototype.minLength = function(c) {
			return this.obj ? this.validate(this.obj.length >= c, this.getValidateMsg("array.minLength", {
				value: this.obj,
				minLength: c
			})) : this
		}, s.prototype.maxLength = function(c) {
			return this.obj ? this.validate(this.obj.length <= c, this.getValidateMsg("array.maxLength", {
				value: this.obj,
				maxLength: c
			})) : this
		}, s.prototype.includes = function(c) {
			var d = this;
			return this.obj ? this.validate(c.every(function(f) {
				return d.obj.indexOf(f) !== -1
			}), this.getValidateMsg("array.includes", {
				value: this.obj,
				includes: c
			})) : this
		}, s.prototype.deepEqual = function(c) {
			return this.obj ? this.validate(isEqual(this.obj, c), this.getValidateMsg("array.deepEqual", {
				value: this.obj,
				deepEqual: c
			})) : this
		}, a.empty.get = function() {
			return this.validate(isEmptyArray(this.obj), this.getValidateMsg("array.empty", {
				value: this.obj
			}))
		}, Object.defineProperties(s.prototype, a), s
	}(Base$1),
	ObjectValidator = function(o) {
		function s(l, c) {
			o.call(this, l, Object.assign(Object.assign({}, c), {
				type: "object"
			})), this.validate(c && c.strict ? isObject$1(this.obj) : !0, this.getValidateMsg("type.object"))
		}
		o && (s.__proto__ = o), s.prototype = Object.create(o && o.prototype), s.prototype.constructor = s;
		var a = {
			empty: {
				configurable: !0
			}
		};
		return s.prototype.deepEqual = function(c) {
			return this.obj ? this.validate(isEqual(this.obj, c), this.getValidateMsg("object.deepEqual", {
				deepEqual: c
			})) : this
		}, s.prototype.hasKeys = function(c) {
			var d = this;
			return this.obj ? this.validate(c.every(function(f) {
				return d.obj[f]
			}), this.getValidateMsg("object.hasKeys", {
				keys: c
			})) : this
		}, a.empty.get = function() {
			return this.validate(isEmptyObject(this.obj), this.getValidateMsg("object.empty"))
		}, Object.defineProperties(s.prototype, a), s
	}(Base$1),
	BooleanValidator = function(o) {
		function s(l, c) {
			o.call(this, l, Object.assign(Object.assign({}, c), {
				type: "boolean"
			})), this.validate(c && c.strict ? isBoolean$1(this.obj) : !0, this.getValidateMsg("type.boolean"))
		}
		o && (s.__proto__ = o), s.prototype = Object.create(o && o.prototype), s.prototype.constructor = s;
		var a = {
			true: {
				configurable: !0
			},
			false: {
				configurable: !0
			}
		};
		return a.true.get = function() {
			return this.validate(this.obj === !0, this.getValidateMsg("boolean.true"))
		}, a.false.get = function() {
			return this.validate(this.obj === !1, this.getValidateMsg("boolean.false"))
		}, Object.defineProperties(s.prototype, a), s
	}(Base$1),
	regexEmail =
	/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
	regexUrl = new RegExp(
		"^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$",
		"i"),
	regexIp = /^(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})(\.(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})){3}$/,
	TypeValidator = function(o) {
		function s(l, c) {
			o.call(this, l, Object.assign(Object.assign({}, c), {
				type: "type"
			}))
		}
		o && (s.__proto__ = o), s.prototype = Object.create(o && o.prototype), s.prototype.constructor = s;
		var a = {
			email: {
				configurable: !0
			},
			url: {
				configurable: !0
			},
			ip: {
				configurable: !0
			}
		};
		return a.email.get = function() {
			return this.type = "email", this.validate(this.obj === void 0 || regexEmail.test(this.obj), this
				.getValidateMsg("type.email"))
		}, a.url.get = function() {
			return this.type = "url", this.validate(this.obj === void 0 || regexUrl.test(this.obj), this
				.getValidateMsg("type.url"))
		}, a.ip.get = function() {
			return this.type = "ip", this.validate(this.obj === void 0 || regexIp.test(this.obj), this
				.getValidateMsg("type.ip"))
		}, Object.defineProperties(s.prototype, a), s
	}(Base$1),
	CustomValidator = function(o) {
		function s(l, c) {
			o.call(this, l, Object.assign(Object.assign({}, c), {
				type: "custom"
			}))
		}
		o && (s.__proto__ = o), s.prototype = Object.create(o && o.prototype), s.prototype.constructor = s;
		var a = {
			validate: {
				configurable: !0
			}
		};
		return a.validate.get = function() {
			var l = this;
			return function(c, d) {
				var f;
				if (c) return f = c(l.obj, l.addError.bind(l)), f && f.then ? (d && f.then(function() {
					d && d(l.error)
				}, function(m) {
					console.error(m)
				}), [f, l]) : (d && d(l.error), l.error)
			}
		}, Object.defineProperties(s.prototype, a), s
	}(Base$1),
	BValidate = function(o, s) {
		return new Validate(o, Object.assign({
			field: "value"
		}, s))
	};
BValidate.globalConfig = {};
BValidate.setGlobalConfig = function(o) {
	BValidate.globalConfig = o || {}
};
var Validate = function(s, a) {
		var l = BValidate.globalConfig,
			c = Object.assign(Object.assign(Object.assign({}, l), a), {
				validateMessages: mergeTemplate(l.validateMessages, a.validateMessages)
			});
		this.string = new StringValidator(s, c), this.number = new NumberValidator(s, c), this.array =
			new ArrayValidator(s, c), this.object = new ObjectValidator(s, c), this.boolean = new BooleanValidator(s,
			c), this.type = new TypeValidator(s, c), this.custom = new CustomValidator(s, c)
	},
	Schema = function(s, a) {
		a === void 0 && (a = {}), this.schema = s, this.options = a
	};
Schema.prototype.messages = function(s) {
	this.options = Object.assign(Object.assign({}, this.options), {
		validateMessages: mergeTemplate(this.options.validateMessages, s)
	})
};
Schema.prototype.validate = function(s, a) {
	var l = this;
	if (!isObject$1(s)) return;
	var c = [],
		d = null;

	function f(m, g) {
		d || (d = {}), (!d[m] || g.requiredError) && (d[m] = g)
	}
	this.schema && Object.keys(this.schema).forEach(function(m) {
		if (isArray$1(l.schema[m]))
			for (var g = function(b) {
					var C = l.schema[m][b],
						_ = C.type,
						S = C.message;
					if (!_ && !C.validator) throw "You must specify a type to field " + m + "!";
					var w = Object.assign(Object.assign({}, l.options), {
						message: S,
						field: m
					});
					"ignoreEmptyString" in C && (w.ignoreEmptyString = C.ignoreEmptyString), "strict" in
						C && (w.strict = C.strict);
					var T = new Validate(s[m], w),
						A = T.type[_] || null;
					if (!A)
						if (C.validator) {
							A = T.custom.validate(C.validator), Object.prototype.toString.call(A) ===
								"[object Array]" && A[0].then ? c.push({
									function: A[0],
									_this: A[1],
									key: m
								}) : A && f(m, A);
							return
						} else A = T[_];
					if (Object.keys(C).forEach(function(k) {
							C.required && (A = A.isRequired), k !== "message" && A[k] && C[k] &&
								typeof A[k] == "object" && (A = A[k]), A[k] && C[k] !== void 0 &&
								typeof A[k] == "function" && (A = A[k](C[k]))
						}), A.collect(function(k) {
							k && f(m, k)
						}), d) return "break"
				}, v = 0; v < l.schema[m].length; v++) {
				var y = g(v);
				if (y === "break") break
			}
	}), c.length > 0 ? Promise.all(c.map(function(m) {
		return m.function
	})).then(function() {
		c.forEach(function(m) {
			m._this.error && f(m.key, m._this.error)
		}), a && a(d)
	}) : a && a(d)
};
const RowContextInjectionKey = Symbol("RowContextInjectionKey"),
	GridContextInjectionKey = Symbol("GridContextInjectionKey"),
	GridDataCollectorInjectionKey = Symbol("GridDataCollectorInjectionKey"),
	_sfc_main$1Z = defineComponent({
		name: "Row",
		props: {
			gutter: {
				type: [Number, Object, Array],
				default: 0
			},
			justify: {
				type: String,
				default: "start"
			},
			align: {
				type: String,
				default: "start"
			},
			div: {
				type: Boolean
			},
			wrap: {
				type: Boolean,
				default: !0
			}
		},
		setup(o) {
			const {
				gutter: s,
				align: a,
				justify: l,
				div: c,
				wrap: d
			} = toRefs(o), f = getPrefixCls("row"), m = computed(() => ({
					[`${f}`]: !c.value,
					[`${f}-nowrap`]: !d.value,
					[`${f}-align-${a.value}`]: a.value,
					[`${f}-justify-${l.value}`]: l.value
				})), g = computed(() => Array.isArray(s.value) ? s.value[0] : s.value), v = computed(() => Array
					.isArray(s.value) ? s.value[1] : 0), y = useResponsiveState(g, 0), b = useResponsiveState(v, 0),
				C = computed(() => {
					const S = {};
					if ((y.value || b.value) && !c.value) {
						const w = -y.value / 2,
							T = -b.value / 2;
						w && (S.marginLeft = `${w}px`, S.marginRight = `${w}px`), T && (S.marginTop = `${T}px`,
							S.marginBottom = `${T}px`)
					}
					return S
				}), _ = computed(() => [y.value, b.value]);
			return provide(RowContextInjectionKey, reactive({
				gutter: _,
				div: c
			})), {
				classNames: m,
				styles: C
			}
		}
	});

function _sfc_render$1H(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames),
		style: normalizeStyle(o.styles)
	}, [renderSlot(o.$slots, "default")], 6)
}
var Row = _export_sfc$1(_sfc_main$1Z, [
	["render", _sfc_render$1H]
]);

function useResponsiveValue(o) {
	return computed(() => {
		const {
			val: a,
			key: l,
			xs: c,
			sm: d,
			md: f,
			lg: m,
			xl: g,
			xxl: v
		} = o.value;
		if (!c && !d && !f && !m && !g && !v) return a;
		const y = {};
		return responsiveArray.forEach(b => {
			const C = o.value[b];
			isNumber$2(C) ? y[b] = C : isObject$2(C) && isNumber$2(C[l]) && (y[b] = C[l])
		}), y
	})
}

function getAllowableFlexValue(o) {
	if (isString$2(o) && (["initial", "auto", "none"].includes(o) || /^\d+$/.test(o)) || isNumber$2(o)) return o;
	if (isString$2(o) && /^\d+(px|em|rem|%)$/.test(o)) return `0 0 ${o}`
}
const _sfc_main$1Y = defineComponent({
	name: "Col",
	props: {
		span: {
			type: Number,
			default: 24
		},
		offset: {
			type: Number
		},
		order: {
			type: Number
		},
		xs: {
			type: [Number, Object]
		},
		sm: {
			type: [Number, Object]
		},
		md: {
			type: [Number, Object]
		},
		lg: {
			type: [Number, Object]
		},
		xl: {
			type: [Number, Object]
		},
		xxl: {
			type: [Number, Object]
		},
		flex: {
			type: [Number, String]
		}
	},
	setup(o) {
		const s = getPrefixCls("col"),
			a = inject(RowContextInjectionKey, {}),
			l = computed(() => getAllowableFlexValue(o.flex)),
			c = computed(() => {
				const {
					div: b
				} = a, {
					span: C,
					offset: _,
					order: S,
					xs: w,
					sm: T,
					md: A,
					lg: k,
					xl: M,
					xxl: D
				} = o, F = {
					[`${s}`]: !b,
					[`${s}-order-${S}`]: S,
					[`${s}-${C}`]: !b && !w && !T && !A && !k && !M && !D,
					[`${s}-offset-${_}`]: _ && _ > 0
				}, R = {
					xs: w,
					sm: T,
					md: A,
					lg: k,
					xl: M,
					xxl: D
				};
				return Object.keys(R).forEach(O => {
					const U = R[O];
					U && isNumber$2(U) ? F[`${s}-${O}-${U}`] = !0 : U && isObject$2(U) && (F[
							`${s}-${O}-${U.span}`] = U.span, F[`${s}-${O}-offset-${U.offset}`] =
						U.offset, F[`${s}-${O}-order-${U.order}`] = U.order)
				}), F
			}),
			d = computed(() => l.value ? s : c.value),
			f = computed(() => {
				const {
					gutter: b,
					div: C
				} = a, _ = {};
				if (Array.isArray(b) && !C) {
					const S = b[0] && b[0] / 2 || 0,
						w = b[1] && b[1] / 2 || 0;
					S && (_.paddingLeft = `${S}px`, _.paddingRight = `${S}px`), w && (_.paddingTop =
						`${w}px`, _.paddingBottom = `${w}px`)
				}
				return _
			}),
			m = computed(() => l.value ? {
				flex: l.value
			} : {}),
			g = computed(() => pick(o, responsiveArray)),
			v = useResponsiveValue(computed(() => ({
				val: o.span,
				key: "span",
				...g.value
			}))),
			y = useResponsiveState(v, 24, !0);
		return {
			visible: computed(() => !!y.value),
			classNames: d,
			styles: computed(() => ({
				...f.value,
				...m.value
			}))
		}
	}
});

function _sfc_render$1G(o, s, a, l, c, d) {
	return o.visible ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(o.classNames),
		style: normalizeStyle(o.styles)
	}, [renderSlot(o.$slots, "default")], 6)) : createCommentVNode("v-if", !0)
}
var Col = _export_sfc$1(_sfc_main$1Y, [
	["render", _sfc_render$1G]
]);

function resolveItemData(o, s) {
	var a, l;
	const c = (a = s.span) != null ? a : 1,
		d = (l = s.offset) != null ? l : 0,
		f = Math.min(d, o);
	return {
		span: Math.min(f > 0 ? c + d : c, o),
		offset: f,
		suffix: "suffix" in s ? s.suffix !== !1 : !1
	}
}

function setItemVisible({
	cols: o,
	collapsed: s,
	collapsedRows: a,
	itemDataList: l
}) {
	let c = !1,
		d = [];

	function f(m) {
		return Math.ceil(m / o) > a
	}
	if (s) {
		let m = 0;
		for (let g = 0; g < l.length; g++) l[g].suffix && (m += l[g].span, d.push(g));
		if (!f(m)) {
			let g = 0;
			for (; g < l.length;) {
				const v = l[g];
				if (!v.suffix) {
					if (m += v.span, f(m)) break;
					d.push(g)
				}
				g++
			}
		}
		c = l.some((g, v) => !g.suffix && !d.includes(v))
	} else d = l.map((m, g) => g);
	return {
		overflow: c,
		displayIndexList: d
	}
}
const _sfc_main$1X = defineComponent({
	name: "Grid",
	props: {
		cols: {
			type: [Number, Object],
			default: 24
		},
		rowGap: {
			type: [Number, Object],
			default: 0
		},
		colGap: {
			type: [Number, Object],
			default: 0
		},
		collapsed: {
			type: Boolean,
			default: !1
		},
		collapsedRows: {
			type: Number,
			default: 1
		}
	},
	setup(o) {
		const {
			cols: s,
			rowGap: a,
			colGap: l,
			collapsedRows: c,
			collapsed: d
		} = toRefs(o), f = useResponsiveState(s, 24), m = useResponsiveState(l, 0), g = useResponsiveState(a,
			0), v = getPrefixCls("grid"), y = computed(() => [v]), b = computed(() => [{
				gap: `${g.value}px ${m.value}px`,
				"grid-template-columns": `repeat(${f.value}, minmax(0px, 1fr))`
			}]), C = reactive(new Map), _ = computed(() => {
				const w = [];
				for (const [T, A] of C.entries()) w[T] = A;
				return w
			}), S = reactive({
				overflow: !1,
				displayIndexList: [],
				cols: f.value,
				colGap: m.value
			});
		return watchEffect(() => {
			S.cols = f.value, S.colGap = m.value
		}), watchEffect(() => {
			const w = setItemVisible({
				cols: f.value,
				collapsed: d.value,
				collapsedRows: c.value,
				itemDataList: _.value
			});
			S.overflow = w.overflow, S.displayIndexList = w.displayIndexList
		}), provide(GridContextInjectionKey, S), provide(GridDataCollectorInjectionKey, {
			collectItemData(w, T) {
				C.set(w, T)
			},
			removeItemData(w) {
				C.delete(w)
			}
		}), {
			classNames: y,
			style: b
		}
	}
});

function _sfc_render$1F(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames),
		style: normalizeStyle(o.style)
	}, [renderSlot(o.$slots, "default")], 6)
}
var _Grid = _export_sfc$1(_sfc_main$1X, [
	["render", _sfc_render$1F]
]);
const _sfc_main$1W = defineComponent({
	name: "GridItem",
	props: {
		span: {
			type: [Number, Object],
			default: 1
		},
		offset: {
			type: [Number, Object],
			default: 0
		},
		suffix: {
			type: Boolean,
			default: !1
		}
	},
	setup(o) {
		const s = getPrefixCls("grid-item"),
			a = ref(),
			{
				computedIndex: l
			} = useIndex({
				itemRef: a,
				selector: `.${s}`
			}),
			c = inject(GridContextInjectionKey, {
				overflow: !1,
				displayIndexList: [],
				cols: 24,
				colGap: 0
			}),
			d = inject(GridDataCollectorInjectionKey),
			f = computed(() => {
				var T;
				return (T = c == null ? void 0 : c.displayIndexList) == null ? void 0 : T.includes(l.value)
			}),
			{
				span: m,
				offset: g
			} = toRefs(o),
			v = useResponsiveState(m, 1),
			y = useResponsiveState(g, 0),
			b = computed(() => resolveItemData(c.cols, {
				...o,
				span: v.value,
				offset: y.value
			})),
			C = computed(() => [s]),
			_ = computed(() => {
				const {
					offset: T,
					span: A
				} = b.value, {
					colGap: k
				} = c;
				return T > 0 ? {
					"margin-left": `calc((${`(100% - ${k*(A-1)}px) / ${A}`} * ${T}) + ${k*T}px)`
				} : {}
			}),
			S = computed(() => {
				const {
					suffix: T,
					span: A
				} = b.value, {
					cols: k
				} = c;
				return T ? `${k-A+1}` : `span ${A}`
			}),
			w = computed(() => {
				const {
					span: T
				} = b.value;
				return a.value ? [{
					"grid-column": `${S.value} / span ${T}`
				}, _.value, !f.value || T === 0 ? {
					display: "none"
				} : {}] : []
			});
		return watchEffect(() => {
			l.value !== -1 && (d == null || d.collectItemData(l.value, b.value))
		}), onUnmounted(() => {
			l.value !== -1 && (d == null || d.removeItemData(l.value))
		}), {
			classNames: C,
			style: w,
			domRef: a,
			overflow: computed(() => c.overflow)
		}
	}
});

function _sfc_render$1E(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		ref: "domRef",
		class: normalizeClass(o.classNames),
		style: normalizeStyle(o.style)
	}, [renderSlot(o.$slots, "default", {
		overflow: o.overflow
	})], 6)
}
var GridItem = _export_sfc$1(_sfc_main$1W, [
	["render", _sfc_render$1E]
]);
const Grid$1 = Object.assign(_Grid, {
		Row,
		Col,
		Item: GridItem,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + Row.name, Row), o.component(a + Col.name, Col), o.component(a + _Grid.name, _Grid),
				o.component(a + GridItem.name, GridItem)
		}
	}),
	_sfc_main$1V = defineComponent({
		name: "Tooltip",
		components: {
			Trigger
		},
		props: {
			popupVisible: {
				type: Boolean,
				default: void 0
			},
			defaultPopupVisible: {
				type: Boolean,
				default: !1
			},
			content: String,
			position: {
				type: String,
				default: "top"
			},
			mini: {
				type: Boolean,
				default: !1
			},
			backgroundColor: {
				type: String
			},
			contentClass: {
				type: [String, Array, Object]
			},
			contentStyle: {
				type: Object
			},
			arrowClass: {
				type: [String, Array, Object]
			},
			arrowStyle: {
				type: Object
			},
			popupContainer: {
				type: [String, Object]
			}
		},
		emits: {
			"update:popupVisible": o => !0,
			popupVisibleChange: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("tooltip"),
				l = ref(o.defaultPopupVisible),
				c = computed(() => {
					var y;
					return (y = o.popupVisible) != null ? y : l.value
				}),
				d = y => {
					l.value = y, s("update:popupVisible", y), s("popupVisibleChange", y)
				},
				f = computed(() => [`${a}-content`, o.contentClass, {
					[`${a}-mini`]: o.mini
				}]),
				m = computed(() => {
					if (o.backgroundColor || o.contentStyle) return {
						backgroundColor: o.backgroundColor,
						...o.contentStyle
					}
				}),
				g = computed(() => [`${a}-popup-arrow`, o.arrowClass]),
				v = computed(() => {
					if (o.backgroundColor || o.arrowStyle) return {
						backgroundColor: o.backgroundColor,
						...o.arrowStyle
					}
				});
			return {
				prefixCls: a,
				computedPopupVisible: c,
				contentCls: f,
				computedContentStyle: m,
				arrowCls: g,
				computedArrowStyle: v,
				handlePopupVisibleChange: d
			}
		}
	});

function _sfc_render$1D(o, s, a, l, c, d) {
	const f = resolveComponent("Trigger");
	return openBlock(), createBlock(f, {
		class: normalizeClass(o.prefixCls),
		trigger: "hover",
		position: o.position,
		"popup-visible": o.computedPopupVisible,
		"popup-offset": 10,
		"show-arrow": "",
		"content-class": o.contentCls,
		"content-style": o.computedContentStyle,
		"arrow-class": o.arrowCls,
		"arrow-style": o.computedArrowStyle,
		"popup-container": o.popupContainer,
		"animation-name": "zoom-in-fade-out",
		"auto-fit-transform-origin": "",
		role: "tooltip",
		onPopupVisibleChange: o.handlePopupVisibleChange
	}, {
		content: withCtx(() => [renderSlot(o.$slots, "content", {}, () => [createTextVNode(toDisplayString(o
			.content), 1)])]),
		default: withCtx(() => [renderSlot(o.$slots, "default")]),
		_: 3
	}, 8, ["class", "position", "popup-visible", "content-class", "content-style", "arrow-class", "arrow-style",
		"popup-container", "onPopupVisibleChange"
	])
}
var _Tooltip = _export_sfc$1(_sfc_main$1V, [
	["render", _sfc_render$1D]
]);
const Tooltip = Object.assign(_Tooltip, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Tooltip.name, _Tooltip)
		}
	}),
	_sfc_main$1U = defineComponent({
		name: "IconQuestionCircle",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-question-circle`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$I = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1C(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z"
	}, null, -1), createBaseVNode("path", {
		d: "M24.006 31v4.008m0-6.008L24 28c0-3 3-4 4.78-6.402C30.558 19.195 28.288 15 23.987 15c-4.014 0-5.382 2.548-5.388 4.514v.465"
	}, null, -1)]), 14, _hoisted_1$I)
}
var _IconQuestionCircle = _export_sfc$1(_sfc_main$1U, [
	["render", _sfc_render$1C]
]);
const IconQuestionCircle = Object.assign(_IconQuestionCircle, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconQuestionCircle.name, _IconQuestionCircle)
		}
	}),
	_sfc_main$1T = defineComponent({
		name: "FormItemLabel",
		components: {
			ResizeObserver: ResizeObserver$1,
			Tooltip,
			IconQuestionCircle
		},
		props: {
			required: {
				type: Boolean,
				default: !1
			},
			showColon: {
				type: Boolean,
				default: !1
			},
			component: {
				type: String,
				default: "label"
			},
			asteriskPosition: {
				type: String,
				default: "start"
			},
			tooltip: {
				type: String
			},
			attrs: Object
		},
		setup() {
			const o = getPrefixCls("form-item-label"),
				s = inject(formInjectionKey, void 0),
				a = getCurrentInstance(),
				l = ref(),
				c = () => {
					l.value && isNumber$2(l.value.offsetWidth) && (s == null || s.setLabelWidth(l.value.offsetWidth,
						a == null ? void 0 : a.uid))
				};
			return onMounted(() => {
				l.value && isNumber$2(l.value.offsetWidth) && (s == null || s.setLabelWidth(l.value
					.offsetWidth, a == null ? void 0 : a.uid))
			}), onBeforeUnmount(() => {
				s == null || s.removeLabelWidth(a == null ? void 0 : a.uid)
			}), {
				prefixCls: o,
				labelRef: l,
				handleResize: c
			}
		}
	});

function _sfc_render$1B(o, s, a, l, c, d) {
	const f = resolveComponent("icon-question-circle"),
		m = resolveComponent("Tooltip"),
		g = resolveComponent("ResizeObserver");
	return openBlock(), createBlock(g, {
		onResize: o.handleResize
	}, {
		default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(o.component), mergeProps({
			ref: "labelRef",
			class: o.prefixCls
		}, o.attrs), {
			default: withCtx(() => [o.required && o.asteriskPosition === "start" ? (
					openBlock(), createElementBlock("strong", {
						key: 0,
						class: normalizeClass(`${o.prefixCls}-required-symbol`)
					}, s[0] || (s[0] = [createBaseVNode("svg", {
						fill: "currentColor",
						viewBox: "0 0 1024 1024",
						width: "1em",
						height: "1em"
					}, [createBaseVNode("path", {
						d: "M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z"
					})], -1)]), 2)) : createCommentVNode("v-if", !0), renderSlot(o
					.$slots, "default"), o.tooltip ? (openBlock(), createBlock(m, {
					key: 1,
					content: o.tooltip
				}, {
					default: withCtx(() => [createVNode(f, {
						class: normalizeClass(
							`${o.prefixCls}-tooltip`)
					}, null, 8, ["class"])]),
					_: 1
				}, 8, ["content"])) : createCommentVNode("v-if", !0), o.required &&
				o.asteriskPosition === "end" ? (openBlock(), createElementBlock(
					"strong", {
						key: 2,
						class: normalizeClass(`${o.prefixCls}-required-symbol`)
					}, s[1] || (s[1] = [createBaseVNode("svg", {
						fill: "currentColor",
						viewBox: "0 0 1024 1024",
						width: "1em",
						height: "1em"
					}, [createBaseVNode("path", {
						d: "M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z"
					})], -1)]), 2)) : createCommentVNode("v-if", !0),
				createTextVNode(" " + toDisplayString(o.showColon ? ":" : ""), 1)
			]),
			_: 3
		}, 16, ["class"]))]),
		_: 3
	}, 8, ["onResize"])
}
var FormItemLabel = _export_sfc$1(_sfc_main$1T, [
	["render", _sfc_render$1B]
]);
const _sfc_main$1S = defineComponent({
	name: "FormItemMessage",
	props: {
		error: {
			type: Array,
			default: () => []
		},
		help: String
	},
	setup() {
		return {
			prefixCls: getPrefixCls("form-item-message")
		}
	}
});

function _sfc_render$1A(o, s, a, l, c, d) {
	return o.error.length > 0 ? (openBlock(!0), createElementBlock(Fragment, {
		key: 0
	}, renderList(o.error, f => (openBlock(), createBlock(Transition, {
		key: f,
		name: "form-blink",
		appear: ""
	}, {
		default: withCtx(() => [createBaseVNode("div", {
			role: "alert",
			class: normalizeClass([o.prefixCls])
		}, toDisplayString(f), 3)]),
		_: 2
	}, 1024))), 128)) : o.help || o.$slots.help ? (openBlock(), createBlock(Transition, {
		key: 1,
		name: "form-blink",
		appear: ""
	}, {
		default: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass([o.prefixCls, `${o.prefixCls}-help`])
		}, [renderSlot(o.$slots, "help", {}, () => [createTextVNode(toDisplayString(o.help),
			1)])], 2)]),
		_: 3
	})) : createCommentVNode("v-if", !0)
}
var FormItemMessage = _export_sfc$1(_sfc_main$1S, [
	["render", _sfc_render$1A]
]);
const _sfc_main$1R = defineComponent({
	name: "FormItem",
	components: {
		ArcoRow: Row,
		ArcoCol: Col,
		FormItemLabel,
		FormItemMessage
	},
	props: {
		field: {
			type: String,
			default: ""
		},
		label: String,
		tooltip: {
			type: String
		},
		showColon: {
			type: Boolean,
			default: !1
		},
		noStyle: {
			type: Boolean,
			default: !1
		},
		disabled: {
			type: Boolean,
			default: void 0
		},
		help: String,
		extra: String,
		required: {
			type: Boolean,
			default: !1
		},
		asteriskPosition: {
			type: String,
			default: "start"
		},
		rules: {
			type: [Object, Array]
		},
		validateStatus: {
			type: String
		},
		validateTrigger: {
			type: [String, Array],
			default: "change"
		},
		labelColProps: Object,
		wrapperColProps: Object,
		hideLabel: {
			type: Boolean,
			default: !1
		},
		hideAsterisk: {
			type: Boolean,
			default: !1
		},
		labelColStyle: Object,
		wrapperColStyle: Object,
		rowProps: Object,
		rowClass: [String, Array, Object],
		contentClass: [String, Array, Object],
		contentFlex: {
			type: Boolean,
			default: !0
		},
		mergeProps: {
			type: [Boolean, Function],
			default: !0
		},
		labelColFlex: {
			type: [Number, String]
		},
		feedback: {
			type: Boolean,
			default: !1
		},
		labelComponent: {
			type: String,
			default: "label"
		},
		labelAttrs: Object
	},
	setup(o) {
		const s = getPrefixCls("form-item"),
			{
				field: a
			} = toRefs(o),
			l = inject(formInjectionKey, {}),
			{
				autoLabelWidth: c,
				layout: d
			} = toRefs(l),
			{
				i18nMessage: f
			} = useI18n(),
			m = computed(() => {
				var de;
				const _e = {
					...(de = o.labelColProps) != null ? de : l.labelColProps
				};
				return o.labelColFlex ? _e.flex = o.labelColFlex : l.autoLabelWidth && (_e.flex =
					`${l.maxLabelWidth}px`), _e
			}),
			g = computed(() => {
				var de;
				const _e = {
					...(de = o.wrapperColProps) != null ? de : l.wrapperColProps
				};
				return a.value && (_e.id = getFormElementId(l.id, a.value)), (o.labelColFlex || l
					.autoLabelWidth) && (_e.flex = "auto"), _e
			}),
			v = computed(() => {
				var de;
				return (de = o.labelColStyle) != null ? de : l.labelColStyle
			}),
			y = computed(() => {
				var de;
				return (de = o.wrapperColStyle) != null ? de : l.wrapperColStyle
			}),
			b = getValueByPath(l.model, o.field),
			C = reactive({}),
			_ = reactive({}),
			S = computed(() => getFinalValidateStatus(C)),
			w = computed(() => getFinalValidateMessage(_)),
			T = ref(!1),
			A = computed(() => getValueByPath(l.model, o.field)),
			k = computed(() => {
				var de;
				return !!((de = o.disabled) != null ? de : l != null && l.disabled)
			}),
			M = computed(() => {
				var de;
				return (de = o.validateStatus) != null ? de : S.value
			}),
			D = computed(() => M.value === "error"),
			F = computed(() => {
				var de, _e, ke;
				const De = [].concat((ke = (_e = o.rules) != null ? _e : (de = l == null ? void 0 : l
						.rules) == null ? void 0 : de[o.field]) != null ? ke : []),
					Se = De.some(be => be.required);
				return o.required && !Se ? [{
					required: !0
				}].concat(De) : De
			}),
			R = computed(() => F.value.some(de => de.required)),
			O = o.noStyle ? inject(formItemInjectionKey, void 0) : void 0,
			U = (de, {
				status: _e,
				message: ke
			}) => {
				C[de] = _e, _[de] = ke, o.noStyle && (O == null || O.updateValidateState(de, {
					status: _e,
					message: ke
				}))
			},
			V = computed(() => o.feedback && M.value ? M.value : void 0),
			z = () => {
				var de;
				if (T.value) return Promise.resolve();
				const _e = F.value;
				if (!a.value || _e.length === 0) return S.value && me(), Promise.resolve();
				const ke = a.value,
					De = A.value;
				U(ke, {
					status: "",
					message: ""
				});
				const Se = new Schema({
					[ke]: _e.map(({
						...be
					}) => (!be.type && !be.validator && (be.type = "string"), be))
				}, {
					ignoreEmptyString: !0,
					validateMessages: (de = f.value.form) == null ? void 0 : de.validateMessages
				});
				return new Promise(be => {
					Se.validate({
						[ke]: De
					}, Me => {
						var Ve;
						const it = !!(Me != null && Me[ke]);
						U(ke, {
							status: it ? "error" : "",
							message: (Ve = Me == null ? void 0 : Me[ke].message) !=
								null ? Ve : ""
						});
						const pt = it ? {
							label: o.label,
							field: a.value,
							value: Me[ke].value,
							type: Me[ke].type,
							isRequiredError: !!Me[ke].requiredError,
							message: Me[ke].message
						} : void 0;
						be(pt)
					})
				})
			},
			j = computed(() => [].concat(o.validateTrigger)),
			ge = computed(() => j.value.reduce((de, _e) => {
				switch (_e) {
					case "change":
						return de.onChange = () => {
							z()
						}, de;
					case "input":
						return de.onInput = () => {
							nextTick(() => {
								z()
							})
						}, de;
					case "focus":
						return de.onFocus = () => {
							z()
						}, de;
					case "blur":
						return de.onBlur = () => {
							z()
						}, de;
					default:
						return de
				}
			}, {}));
		provide(formItemInjectionKey, reactive({
			eventHandlers: ge,
			size: l && toRef(l, "size"),
			disabled: k,
			error: D,
			feedback: V,
			updateValidateState: U
		}));
		const me = () => {
				a.value && U(a.value, {
					status: "",
					message: ""
				})
			},
			ae = reactive({
				field: a,
				disabled: k,
				error: D,
				validate: z,
				clearValidate: me,
				resetField: () => {
					me(), T.value = !0, l != null && l.model && a.value && setValueByPath(l.model, a
						.value, b), nextTick(() => {
						T.value = !1
					})
				},
				setField: de => {
					var _e, ke;
					a.value && (T.value = !0, "value" in de && (l != null && l.model) && a.value &&
						setValueByPath(l.model, a.value, de.value), (de.status || de.message) && U(a
							.value, {
								status: (_e = de.status) != null ? _e : "",
								message: (ke = de.message) != null ? ke : ""
							}), nextTick(() => {
							T.value = !1
						}))
				}
			});
		onMounted(() => {
			var de;
			ae.field && ((de = l.addField) == null || de.call(l, ae))
		}), onBeforeUnmount(() => {
			var de;
			ae.field && ((de = l.removeField) == null || de.call(l, ae))
		});
		const fe = computed(() => [s, `${s}-layout-${l.layout}`, {
				[`${s}-error`]: D.value,
				[`${s}-status-${M.value}`]: !!M.value
			}, o.rowClass]),
			q = computed(() => [`${s}-label-col`, {
				[`${s}-label-col-left`]: l.labelAlign === "left",
				[`${s}-label-col-flex`]: l.autoLabelWidth || o.labelColFlex
			}]),
			le = computed(() => [`${s}-wrapper-col`, {
				[`${s}-wrapper-col-flex`]: !g.value
			}]);
		return {
			prefixCls: s,
			cls: fe,
			isRequired: R,
			isError: D,
			finalMessage: w,
			mergedLabelCol: m,
			mergedWrapperCol: g,
			labelColCls: q,
			autoLabelWidth: c,
			layout: d,
			mergedLabelStyle: v,
			wrapperColCls: le,
			mergedWrapperStyle: y
		}
	}
});

function _sfc_render$1z(o, s, a, l, c, d) {
	var f;
	const m = resolveComponent("FormItemLabel"),
		g = resolveComponent("ArcoCol"),
		v = resolveComponent("FormItemMessage"),
		y = resolveComponent("ArcoRow");
	return o.noStyle ? renderSlot(o.$slots, "default", {
		key: 0
	}) : (openBlock(), createBlock(y, mergeProps({
		key: 1,
		class: [o.cls, {
			[`${o.prefixCls}-has-help`]: !!((f = o.$slots.help) != null ? f : o.help)
		}],
		wrap: !(o.labelColFlex || o.autoLabelWidth),
		div: o.layout !== "horizontal" || o.hideLabel
	}, o.rowProps), {
		default: withCtx(() => [o.hideLabel ? createCommentVNode("v-if", !0) : (openBlock(), createBlock(g,
			mergeProps({
				key: 0,
				class: o.labelColCls,
				style: o.mergedLabelStyle
			}, o.mergedLabelCol), {
				default: withCtx(() => [createVNode(m, {
					required: o.hideAsterisk ? !1 : o.isRequired,
					"show-colon": o.showColon,
					"asterisk-position": o.asteriskPosition,
					component: o.labelComponent,
					attrs: o.labelAttrs,
					tooltip: o.tooltip
				}, {
					default: withCtx(() => [o.$slots.label || o.label ?
						renderSlot(o.$slots, "label", {
							key: 0
						}, () => [createTextVNode(
							toDisplayString(o.label), 1)]) :
						createCommentVNode("v-if", !0)
					]),
					_: 3
				}, 8, ["required", "show-colon", "asterisk-position",
					"component", "attrs", "tooltip"
				])]),
				_: 3
			}, 16, ["class", "style"])), createVNode(g, mergeProps({
			class: o.wrapperColCls,
			style: o.mergedWrapperStyle
		}, o.mergedWrapperCol), {
			default: withCtx(() => [createBaseVNode("div", {
					class: normalizeClass(`${o.prefixCls}-content-wrapper`)
				}, [createBaseVNode("div", {
					class: normalizeClass([`${o.prefixCls}-content`, {
						[`${o.prefixCls}-content-flex`]: o
							.contentFlex
					}, o.contentClass])
				}, [renderSlot(o.$slots, "default")], 2)], 2), o.isError || o.$slots
				.help || o.help ? (openBlock(), createBlock(v, {
					key: 0,
					error: o.finalMessage,
					help: o.help
				}, createSlots({
					_: 2
				}, [o.$slots.help ? {
					name: "help",
					fn: withCtx(() => [renderSlot(o.$slots,
						"help")]),
					key: "0"
				} : void 0]), 1032, ["error", "help"])) : createCommentVNode("v-if",
					!0), o.$slots.extra || o.extra ? (openBlock(),
					createElementBlock("div", {
						key: 1,
						class: normalizeClass(`${o.prefixCls}-extra`)
					}, [renderSlot(o.$slots, "extra", {}, () => [
						createTextVNode(toDisplayString(o.extra), 1)
					])], 2)) : createCommentVNode("v-if", !0)
			]),
			_: 3
		}, 16, ["class", "style"])]),
		_: 3
	}, 16, ["class", "wrap", "div"]))
}
var FormItem = _export_sfc$1(_sfc_main$1R, [
	["render", _sfc_render$1z]
]);
const Form = Object.assign(_Form, {
		Item: FormItem,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Form.name, _Form), o.component(a + FormItem.name, FormItem)
		}
	}),
	_sfc_main$1Q = defineComponent({
		name: "Icon",
		props: {
			type: String,
			size: [Number, String],
			rotate: Number,
			spin: Boolean
		},
		setup(o) {
			const s = getPrefixCls("icon"),
				a = computed(() => {
					const c = {};
					return o.size && (c.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (c
						.transform = `rotate(${o.rotate}deg)`), c
				});
			return {
				cls: computed(() => [s, {
					[`${s}-loading`]: o.spin
				}, o.type]),
				innerStyle: a
			}
		}
	});

function _sfc_render$1y(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		fill: "currentColor"
	}, [renderSlot(o.$slots, "default")], 6)
}
var _Icon = _export_sfc$1(_sfc_main$1Q, [
	["render", _sfc_render$1y]
]);

function _isSlot$c(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
const scriptUrlCache = [],
	addFromIconFontCn = o => {
		const {
			src: s,
			extraProps: a = {}
		} = o;
		if (!isServerRendering && (s != null && s.length) && !scriptUrlCache.includes(s)) {
			const l = document.createElement("script");
			l.setAttribute("src", s), l.setAttribute("data-namespace", s), scriptUrlCache.push(s), document.body
				.appendChild(l)
		}
		return defineComponent({
			name: "IconFont",
			props: {
				type: String,
				size: [Number, String],
				rotate: Number,
				spin: Boolean
			},
			setup(l, {
				slots: c
			}) {
				return () => {
					var d;
					const f = l.type ? createVNode("use", {
						"xlink:href": `#${l.type}`
					}, null) : (d = c.default) == null ? void 0 : d.call(c);
					return createVNode(_Icon, mergeProps(l, a), _isSlot$c(f) ? f : {
						default: () => [f]
					})
				}
			}
		})
	},
	Icon$1 = Object.assign(_Icon, {
		addFromIconFontCn,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Icon.name, _Icon)
		}
	}),
	_sfc_main$1P = defineComponent({
		name: "ImageFooter",
		props: {
			title: {
				type: String
			},
			description: {
				type: String
			}
		},
		setup() {
			return {
				prefixCls: getPrefixCls("image-footer")
			}
		}
	}),
	_hoisted_1$H = ["title"],
	_hoisted_2$4 = ["title"];

function _sfc_render$1x(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [o.title || o.description ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-caption`)
	}, [o.title ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-caption-title`),
			title: o.title
		}, toDisplayString(o.title), 11, _hoisted_1$H)) : createCommentVNode("v-if", !0), o
		.description ? (openBlock(), createElementBlock("div", {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-caption-description`),
			title: o.description
		}, toDisplayString(o.description), 11, _hoisted_2$4)) : createCommentVNode("v-if", !0)
	], 2)) : createCommentVNode("v-if", !0), o.$slots.extra ? (openBlock(), createElementBlock("div", {
		key: 1,
		class: normalizeClass(`${o.prefixCls}-extra`)
	}, [renderSlot(o.$slots, "extra")], 2)) : createCommentVNode("v-if", !0)], 2)
}
var ImageFooter = _export_sfc$1(_sfc_main$1P, [
	["render", _sfc_render$1x]
]);
const _sfc_main$1O = defineComponent({
	name: "ImagePreviewArrow",
	components: {
		IconLeft,
		IconRight
	},
	props: {
		onPrev: {
			type: Function
		},
		onNext: {
			type: Function
		}
	},
	setup() {
		return {
			prefixCls: getPrefixCls("image-preview-arrow")
		}
	}
});

function _sfc_render$1w(o, s, a, l, c, d) {
	const f = resolveComponent("icon-left"),
		m = resolveComponent("icon-right");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [createBaseVNode("div", {
		class: normalizeClass([`${o.prefixCls}-left`, {
			[`${o.prefixCls}-disabled`]: !o.onPrev
		}]),
		onClick: s[0] || (s[0] = g => {
			g.preventDefault(), o.onPrev && o.onPrev()
		})
	}, [createVNode(f)], 2), createBaseVNode("div", {
		class: normalizeClass([`${o.prefixCls}-right`, {
			[`${o.prefixCls}-disabled`]: !o.onNext
		}]),
		onClick: s[1] || (s[1] = g => {
			g.preventDefault(), o.onNext && o.onNext()
		})
	}, [createVNode(m)], 2)], 2)
}
var PreviewArrow = _export_sfc$1(_sfc_main$1O, [
	["render", _sfc_render$1w]
]);

function _isSlot$b(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var ImagePreviewAction = defineComponent({
		name: "ImagePreviewAction",
		components: {
			Tooltip
		},
		inheritAttrs: !1,
		props: {
			name: {
				type: String
			},
			disabled: {
				type: Boolean
			}
		},
		setup(o, {
			slots: s,
			attrs: a
		}) {
			const l = getPrefixCls("image-preview-toolbar-action");
			return () => {
				var c;
				const {
					name: d,
					disabled: f
				} = o, m = (c = s.default) == null ? void 0 : c.call(s);
				if (!m || !m.length) return null;
				const g = createVNode("div", mergeProps({
					class: [`${l}`, {
						[`${l}-disabled`]: f
					}],
					onMousedown: v => {
						v.preventDefault()
					}
				}, a), [createVNode("span", {
					class: `${l}-content`
				}, [m])]);
				return d ? createVNode(Tooltip, {
					class: `${l}-tooltip`,
					content: d
				}, _isSlot$b(g) ? g : {
					default: () => [g]
				}) : g
			}
		}
	}),
	_sfc_main$1N = defineComponent({
		name: "ImagePreviewToolbar",
		components: {
			RenderFunction,
			PreviewAction: ImagePreviewAction
		},
		props: {
			actions: {
				type: Array,
				default: () => []
			},
			actionsLayout: {
				type: Array,
				default: () => []
			}
		},
		setup(o) {
			const {
				actions: s,
				actionsLayout: a
			} = toRefs(o), l = getPrefixCls("image-preview-toolbar"), c = computed(() => {
				const d = new Set(a.value),
					f = g => d.has(g.key);
				return s.value.filter(f).sort((g, v) => {
					const y = a.value.indexOf(g.key),
						b = a.value.indexOf(v.key);
					return y > b ? 1 : -1
				})
			});
			return {
				prefixCls: l,
				resultActions: c
			}
		}
	});

function _sfc_render$1v(o, s, a, l, c, d) {
	const f = resolveComponent("RenderFunction"),
		m = resolveComponent("PreviewAction");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.resultActions, g => (openBlock(),
		createBlock(m, {
			key: g.key,
			name: g.name,
			disabled: g.disabled,
			onClick: g.onClick
		}, {
			default: withCtx(() => [createVNode(f, {
				"render-func": g.content
			}, null, 8, ["render-func"])]),
			_: 2
		}, 1032, ["name", "disabled", "onClick"]))), 128)), renderSlot(o.$slots, "default")], 2)
}
var PreviewToolbar = _export_sfc$1(_sfc_main$1N, [
	["render", _sfc_render$1v]
]);

function useImageLoadStatus(o) {
	const s = ref("beforeLoad"),
		a = computed(() => s.value === "beforeLoad"),
		l = computed(() => s.value === "loading"),
		c = computed(() => s.value === "error"),
		d = computed(() => s.value === "loaded");
	return {
		status: s,
		isBeforeLoad: a,
		isLoading: l,
		isError: c,
		isLoaded: d,
		setLoadStatus: f => {
			s.value = f
		}
	}
}

function getFixTranslate(o, s, a, l, c) {
	let d = a,
		f = l;
	return a && (o.width > s.width ? d = 0 : (s.left > o.left && (d -= Math.abs(o.left - s.left) / c), s.right < o
		.right && (d += Math.abs(o.right - s.right) / c))), l && (o.height > s.height ? f = 0 : (s.top > o.top && (
		f -= Math.abs(o.top - s.top) / c), s.bottom < o.bottom && (f += Math.abs(o.bottom - s.bottom) / c))), [d, f]
}

function useImageDrag(o) {
	const {
		wrapperEl: s,
		imageEl: a,
		scale: l
	} = toRefs(o), c = ref([0, 0]), d = ref(!1);
	let f = 0,
		m = 0,
		g = [0, 0];
	const v = () => {
			if (!s.value || !a.value) return;
			const S = s.value.getBoundingClientRect(),
				w = a.value.getBoundingClientRect(),
				[T, A] = getFixTranslate(S, w, c.value[0], c.value[1], l.value);
			(T !== c.value[0] || A !== c.value[1]) && (c.value = [T, A])
		},
		y = S => {
			S.preventDefault && S.preventDefault();
			const w = g[0] + (S.pageX - f) / l.value,
				T = g[1] + (S.pageY - m) / l.value;
			c.value = [w, T]
		},
		b = S => {
			S.preventDefault && S.preventDefault(), d.value = !1, v(), _()
		},
		C = S => {
			S.target === S.currentTarget && (S.preventDefault && S.preventDefault(), d.value = !0, f = S.pageX, m = S
				.pageY, g = [...c.value], on(window, "mousemove", y, !1), on(window, "mouseup", b, !1))
		};

	function _() {
		off(window, "mousemove", y, !1), off(window, "mouseup", b, !1)
	}
	return watchEffect(S => {
		a.value && on(a.value, "mousedown", C), S(() => {
			a.value && off(a.value, "mousedown", C), _()
		})
	}), watch([l], () => {
		nextTick(() => v())
	}), {
		translate: c,
		moving: d,
		resetTranslate() {
			c.value = [0, 0]
		}
	}
}
const _sfc_main$1M = defineComponent({
		name: "IconZoomOut",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-zoom-out`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$G = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1u(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15"
	}, null, -1)]), 14, _hoisted_1$G)
}
var _IconZoomOut = _export_sfc$1(_sfc_main$1M, [
	["render", _sfc_render$1u]
]);
const IconZoomOut = Object.assign(_IconZoomOut, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconZoomOut.name, _IconZoomOut)
		}
	}),
	_sfc_main$1L = defineComponent({
		name: "IconZoomIn",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-zoom-in`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$F = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1t(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15m7 7V15"
	}, null, -1)]), 14, _hoisted_1$F)
}
var _IconZoomIn = _export_sfc$1(_sfc_main$1L, [
	["render", _sfc_render$1t]
]);
const IconZoomIn = Object.assign(_IconZoomIn, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconZoomIn.name, _IconZoomIn)
		}
	}),
	_sfc_main$1K = defineComponent({
		name: "IconFullscreen",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-fullscreen`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$E = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1s(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M42 17V9a1 1 0 0 0-1-1h-8M6 17V9a1 1 0 0 1 1-1h8m27 23v8a1 1 0 0 1-1 1h-8M6 31v8a1 1 0 0 0 1 1h8"
	}, null, -1)]), 14, _hoisted_1$E)
}
var _IconFullscreen = _export_sfc$1(_sfc_main$1K, [
	["render", _sfc_render$1s]
]);
const IconFullscreen = Object.assign(_IconFullscreen, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconFullscreen.name, _IconFullscreen)
		}
	}),
	_sfc_main$1J = defineComponent({
		name: "IconRotateLeft",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-rotate-left`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$D = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1r(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M10 22a1 1 0 0 1 1-1h20a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H11a1 1 0 0 1-1-1V22ZM23 11h11a6 6 0 0 1 6 6v6M22.5 12.893 19.587 11 22.5 9.107v3.786Z"
	}, null, -1)]), 14, _hoisted_1$D)
}
var _IconRotateLeft = _export_sfc$1(_sfc_main$1J, [
	["render", _sfc_render$1r]
]);
const IconRotateLeft = Object.assign(_IconRotateLeft, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconRotateLeft.name, _IconRotateLeft)
		}
	}),
	_sfc_main$1I = defineComponent({
		name: "IconRotateRight",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-rotate-right`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$C = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1q(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M38 22a1 1 0 0 0-1-1H17a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V22ZM25 11H14a6 6 0 0 0-6 6v6M25.5 12.893 28.413 11 25.5 9.107v3.786Z"
	}, null, -1)]), 14, _hoisted_1$C)
}
var _IconRotateRight = _export_sfc$1(_sfc_main$1I, [
	["render", _sfc_render$1q]
]);
const IconRotateRight = Object.assign(_IconRotateRight, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconRotateRight.name, _IconRotateRight)
		}
	}),
	_sfc_main$1H = defineComponent({
		name: "IconOriginalSize",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-original-size`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$B = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1p(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "m5.5 11.5 5-2.5h1v32M34 11.5 39 9h1v32"
	}, null, -1), createBaseVNode("path", {
		d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1), createBaseVNode("path", {
		d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z"
	}, null, -1)]), 14, _hoisted_1$B)
}
var _IconOriginalSize = _export_sfc$1(_sfc_main$1H, [
	["render", _sfc_render$1p]
]);
const IconOriginalSize = Object.assign(_IconOriginalSize, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconOriginalSize.name, _IconOriginalSize)
	}
});

function usePopupOverflowHidden(o) {
	const {
		container: s,
		hidden: a
	} = toRefs(o);
	let l = !1,
		c = {};
	const d = g => g.tagName === "BODY" ? window.innerWidth - (document.body.clientWidth || document.documentElement
			.clientWidth) : g.offsetWidth - g.clientWidth,
		f = () => {
			if (s.value && s.value.style.overflow !== "hidden") {
				const g = s.value.style;
				l = !0;
				const v = d(s.value);
				v && (c.width = g.width, s.value.style.width = `calc(${s.value.style.width||"100%"} - ${v}px)`), c
					.overflow = g.overflow, s.value.style.overflow = "hidden"
			}
		},
		m = () => {
			if (s.value && l) {
				const g = c;
				Object.keys(g).forEach(v => {
					s.value.style[v] = g[v]
				})
			}
			l = !1, c = {}
		};
	return watchEffect(g => {
		a.value ? f() : m(), g(() => {
			m()
		})
	}), [m, f]
}

function usePopupContainer(o, s) {
	const {
		popupContainer: a
	} = toRefs(s);
	return computed(() => (isString$2(a.value) ? querySelector(a.value) : a.value) || o)
}
const scaleAttr = [25, 33, 50, 67, 75, 80, 90, 100, 110, 125, 150, 175, 200, 250, 300, 400, 500].map(o => +(o / 100)
		.toFixed(2)),
	minScale = scaleAttr[0],
	maxScale = scaleAttr[scaleAttr.length - 1];

function getScale(o = 1, s = "zoomIn") {
	let a = scaleAttr.indexOf(o);
	return a === -1 && (a = findClosestIndex(o)), s === "zoomIn" ? a === scaleAttr.length - 1 ? o : scaleAttr[a + 1] :
		a === 0 ? o : scaleAttr[a - 1]
}

function getScaleByRate(o, s = 1.1, a = "zoomIn") {
	const l = a === "zoomIn" ? s : 1 / s,
		c = Number.parseFloat((o * l).toFixed(3));
	return Math.min(maxScale, Math.max(minScale, c))
}

function findClosestIndex(o) {
	let s = scaleAttr.length - 1;
	for (let a = 0; a < scaleAttr.length; a++) {
		const l = scaleAttr[a];
		if (o === l) {
			s = a;
			break
		}
		if (o < l) {
			const c = scaleAttr[a - 1];
			s = c === void 0 || Math.abs(c - o) <= Math.abs(l - o) ? a - 1 : a;
			break
		}
	}
	return s
}
const ROTATE_STEP = 90;
var _sfc_main$1G = defineComponent({
	name: "ImagePreview",
	components: {
		PreviewArrow,
		PreviewToolbar,
		IconLoading,
		IconClose
	},
	props: {
		renderToBody: {
			type: Boolean,
			default: !0
		},
		src: {
			type: String
		},
		visible: {
			type: Boolean,
			default: void 0
		},
		defaultVisible: {
			type: Boolean,
			default: !1
		},
		maskClosable: {
			type: Boolean,
			default: !0
		},
		closable: {
			type: Boolean,
			default: !0
		},
		actionsLayout: {
			type: Array,
			default: () => ["fullScreen", "rotateRight", "rotateLeft", "zoomIn", "zoomOut", "originalSize"]
		},
		popupContainer: {
			type: [Object, String]
		},
		inGroup: {
			type: Boolean,
			default: !1
		},
		groupArrowProps: {
			type: Object,
			default: () => ({})
		},
		escToClose: {
			type: Boolean,
			default: !0
		},
		wheelZoom: {
			type: Boolean,
			default: !0
		},
		keyboard: {
			type: Boolean,
			default: !0
		},
		defaultScale: {
			type: Number,
			default: 1
		},
		zoomRate: {
			type: Number,
			default: 1.1
		}
	},
	emits: ["close", "update:visible"],
	setup(o, {
		emit: s
	}) {
		const {
			t: a
		} = useI18n(), {
			src: l,
			popupContainer: c,
			visible: d,
			defaultVisible: f,
			maskClosable: m,
			actionsLayout: g,
			defaultScale: v,
			zoomRate: y
		} = toRefs(o), b = ref(), C = ref(), _ = getPrefixCls("image-preview"), [S, w] = useMergeState(f
			.value, reactive({
				value: d
			})), T = computed(() => [_, {
			[`${_}-hide`]: !S.value
		}]), A = usePopupContainer(document.body, reactive({
			popupContainer: c
		})), k = computed(() => A.value === document.body), {
			zIndex: M
		} = usePopupManager("dialog", {
			visible: S
		}), D = computed(() => ({
			...k.value ? {
				zIndex: M.value,
				position: "fixed"
			} : {
				zIndex: "inherit",
				position: "absolute"
			}
		})), {
			isLoading: F,
			isLoaded: R,
			setLoadStatus: O
		} = useImageLoadStatus(), U = ref(0), V = ref(v.value), {
			translate: z,
			moving: j,
			resetTranslate: ge
		} = useImageDrag(reactive({
			wrapperEl: b,
			imageEl: C,
			visible: S,
			scale: V
		})), me = ref(!1);
		let he = null;
		const ce = () => {
			!me.value && (me.value = !0), he && clearTimeout(he), he = setTimeout(() => {
				me.value = !1
			}, 1e3)
		};
		usePopupOverflowHidden(reactive({
			container: A,
			hidden: S
		}));

		function ae() {
			U.value = 0, V.value = v.value, ge()
		}
		const fe = pt => g.value.includes(pt),
			q = pt => {
				switch (pt.stopPropagation(), pt.preventDefault(), pt.key) {
					case KEYBOARD_KEY.ESC:
						o.escToClose && De();
						break;
					case KEYBOARD_KEY.ARROW_LEFT:
						o.groupArrowProps.onPrev && o.groupArrowProps.onPrev();
						break;
					case KEYBOARD_KEY.ARROW_RIGHT:
						o.groupArrowProps.onNext && o.groupArrowProps.onNext();
						break;
					case KEYBOARD_KEY.ARROW_UP:
						fe("zoomIn") && it("zoomIn");
						break;
					case KEYBOARD_KEY.ARROW_DOWN:
						fe("zoomOut") && it("zoomOut");
						break;
					case KEYBOARD_KEY.SPACE:
						fe("originalSize") && be(1);
						break
				}
			},
			le = throttleByRaf(pt => {
				if (pt.preventDefault(), pt.stopPropagation(), !o.wheelZoom) return;
				const He = (pt.deltaY || pt.deltaX) > 0 ? "zoomOut" : "zoomIn",
					Ae = getScaleByRate(V.value, y.value, He);
				be(Ae)
			});
		let de = !1;
		const _e = () => {
				nextTick(() => {
					var pt;
					(pt = b == null ? void 0 : b.value) == null || pt.focus()
				}), o.keyboard && !de && (de = !0, on(A.value, "keydown", q))
			},
			ke = () => {
				de && (de = !1, off(A.value, "keydown", q))
			};
		watch([l, S], () => {
			S.value ? (ae(), O("loading"), _e()) : ke()
		});

		function De() {
			S.value && (s("close"), s("update:visible", !1), w(!1))
		}

		function Se(pt) {
			var dt;
			(dt = b == null ? void 0 : b.value) == null || dt.focus(), m.value && pt.target === pt
				.currentTarget && De()
		}

		function be(pt) {
			V.value !== pt && (V.value = pt, ce())
		}

		function Me() {
			const pt = b.value.getBoundingClientRect(),
				dt = C.value.getBoundingClientRect(),
				He = pt.height / (dt.height / V.value),
				Ae = pt.width / (dt.width / V.value),
				xe = Math.max(He, Ae);
			be(xe)
		}

		function Ve(pt) {
			const He = pt === "clockwise" ? (U.value + ROTATE_STEP) % 360 : U.value === 0 ? 360 - ROTATE_STEP :
				U.value - ROTATE_STEP;
			U.value = He
		}

		function it(pt) {
			const dt = getScale(V.value, pt);
			be(dt)
		}
		return onBeforeUnmount(() => {
			ke()
		}), {
			prefixCls: _,
			classNames: T,
			container: A,
			wrapperStyles: D,
			scale: V,
			translate: z,
			rotate: U,
			moving: j,
			mergedVisible: S,
			isLoading: F,
			isLoaded: R,
			scaleValueVisible: me,
			refWrapper: b,
			refImage: C,
			onWheel: le,
			onMaskClick: Se,
			onCloseClick: De,
			onImgLoad() {
				O("loaded")
			},
			onImgError() {
				O("error")
			},
			actions: computed(() => [{
				key: "fullScreen",
				name: a("imagePreview.fullScreen"),
				content: () => h(IconFullscreen),
				onClick: () => Me()
			}, {
				key: "rotateRight",
				name: a("imagePreview.rotateRight"),
				content: () => h(IconRotateRight),
				onClick: () => Ve("clockwise")
			}, {
				key: "rotateLeft",
				name: a("imagePreview.rotateLeft"),
				content: () => h(IconRotateLeft),
				onClick: () => Ve("counterclockwise")
			}, {
				key: "zoomIn",
				name: a("imagePreview.zoomIn"),
				content: () => h(IconZoomIn),
				onClick: () => it("zoomIn"),
				disabled: V.value === maxScale
			}, {
				key: "zoomOut",
				name: a("imagePreview.zoomOut"),
				content: () => h(IconZoomOut),
				onClick: () => it("zoomOut"),
				disabled: V.value === minScale
			}, {
				key: "originalSize",
				name: a("imagePreview.originalSize"),
				content: () => h(IconOriginalSize),
				onClick: () => be(1)
			}])
		}
	}
});
const _hoisted_1$A = ["src"];

function _sfc_render$1o(o, s, a, l, c, d) {
	const f = resolveComponent("IconLoading"),
		m = resolveComponent("PreviewToolbar"),
		g = resolveComponent("IconClose"),
		v = resolveComponent("PreviewArrow");
	return openBlock(), createBlock(Teleport, {
		to: o.container,
		disabled: !o.renderToBody
	}, [createBaseVNode("div", {
		class: normalizeClass(o.classNames),
		style: normalizeStyle(o.wrapperStyles)
	}, [createVNode(Transition, {
		name: "image-fade",
		onBeforeEnter: s[0] || (s[0] = y => y.parentElement && (y.parentElement.style.display =
			"block")),
		onAfterLeave: s[1] || (s[1] = y => y.parentElement && (y.parentElement.style.display =
			"")),
		persisted: ""
	}, {
		default: withCtx(() => [withDirectives(createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-mask`)
		}, null, 2), [
			[vShow, o.mergedVisible]
		])]),
		_: 1
	}), o.mergedVisible ? (openBlock(), createElementBlock("div", {
		key: 0,
		ref: "refWrapper",
		tabindex: "0",
		class: normalizeClass(`${o.prefixCls}-wrapper`),
		onClick: s[6] || (s[6] = (...y) => o.onMaskClick && o.onMaskClick(...y)),
		onWheel: s[7] || (s[7] = withModifiers((...y) => o.onWheel && o.onWheel(...y), [
			"prevent", "stop"
		]))
	}, [createCommentVNode(" img "), createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-img-container`),
			style: normalizeStyle({
				transform: `scale(${o.scale}, ${o.scale})`
			}),
			onClick: s[4] || (s[4] = (...y) => o.onMaskClick && o.onMaskClick(...y))
		}, [(openBlock(), createElementBlock("img", {
			ref: "refImage",
			key: o.src,
			src: o.src,
			class: normalizeClass([`${o.prefixCls}-img`, {
				[`${o.prefixCls}-img-moving`]: o.moving
			}]),
			style: normalizeStyle({
				transform: `translate(${o.translate[0]}px, ${o.translate[1]}px) rotate(${o.rotate}deg)`
			}),
			onLoad: s[2] || (s[2] = (...y) => o.onImgLoad && o.onImgLoad(...
				y)),
			onError: s[3] || (s[3] = (...y) => o.onImgError && o.onImgError(
				...y))
		}, null, 46, _hoisted_1$A))], 6), createCommentVNode(" loading "), o.isLoading ? (
			openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-loading`)
			}, [createVNode(f)], 2)) : createCommentVNode("v-if", !0), createCommentVNode(
			" scale value "), createVNode(Transition, {
			name: "image-fade"
		}, {
			default: withCtx(() => [o.scaleValueVisible ? (openBlock(),
				createElementBlock("div", {
						key: 0,
						class: normalizeClass(`${o.prefixCls}-scale-value`)
					}, toDisplayString((o.scale * 100).toFixed(0)) + "% ",
					3)) : createCommentVNode("v-if", !0)]),
			_: 1
		}), createCommentVNode(" toolbar "), o.isLoaded && o.actionsLayout.length ? (
			openBlock(), createBlock(m, {
				key: 1,
				actions: o.actions,
				"actions-layout": o.actionsLayout
			}, {
				default: withCtx(() => [renderSlot(o.$slots, "actions")]),
				_: 3
			}, 8, ["actions", "actions-layout"])) : createCommentVNode("v-if", !0),
		createCommentVNode(" close btn "), o.closable ? (openBlock(), createElementBlock(
			"div", {
				key: 2,
				class: normalizeClass(`${o.prefixCls}-close-btn`),
				onClick: s[5] || (s[5] = (...y) => o.onCloseClick && o.onCloseClick(...
					y))
			}, [createVNode(g)], 2)) : createCommentVNode("v-if", !0), createCommentVNode(
			" group arrow "), o.inGroup ? (openBlock(), createBlock(v, normalizeProps(
			mergeProps({
				key: 3
			}, o.groupArrowProps)), null, 16)) : createCommentVNode("v-if", !0)
	], 34)) : createCommentVNode("v-if", !0)], 6)], 8, ["to", "disabled"])
}
var ImagePreview = _export_sfc$1(_sfc_main$1G, [
	["render", _sfc_render$1o]
]);

function normalizeImageSizeProp(o) {
	if (isUndefined$1(o)) return;
	if (!isNumber$2(o) && /^\d+(%)$/.test(o)) return o;
	const s = parseInt(o, 10);
	return isNumber$2(s) ? `${s}px` : void 0
}
const PreviewGroupInjectionKey = Symbol("PreviewGroupInjectionKey");
let uuid = 0;
const _sfc_main$1F = defineComponent({
		name: "Image",
		components: {
			IconImageClose,
			IconLoading,
			ImageFooter,
			ImagePreview
		},
		inheritAttrs: !1,
		props: {
			renderToBody: {
				type: Boolean,
				default: !0
			},
			src: {
				type: String
			},
			width: {
				type: [String, Number]
			},
			height: {
				type: [String, Number]
			},
			title: {
				type: String
			},
			description: {
				type: String
			},
			fit: {
				type: String
			},
			alt: {
				type: String
			},
			hideFooter: {
				type: [Boolean, String],
				default: !1
			},
			footerPosition: {
				type: String,
				default: "inner"
			},
			showLoader: {
				type: Boolean,
				default: !1
			},
			preview: {
				type: Boolean,
				default: !0
			},
			previewVisible: {
				type: Boolean,
				default: void 0
			},
			defaultPreviewVisible: {
				type: Boolean,
				default: !1
			},
			previewProps: {
				type: Object
			},
			footerClass: {
				type: [String, Array, Object]
			}
		},
		emits: ["preview-visible-change", "update:previewVisible"],
		setup(o, {
			attrs: s,
			slots: a,
			emit: l
		}) {
			const {
				t: c
			} = useI18n(), {
				height: d,
				width: f,
				hideFooter: m,
				title: g,
				description: v,
				src: y,
				footerPosition: b,
				defaultPreviewVisible: C,
				previewVisible: _,
				preview: S,
				previewProps: w
			} = toRefs(o), T = inject(PreviewGroupInjectionKey, void 0), A = getPrefixCls("image"), k = ref(), {
				isLoaded: M,
				isError: D,
				isLoading: F,
				setLoadStatus: R
			} = useImageLoadStatus(), O = computed(() => ({
				width: normalizeImageSizeProp(f == null ? void 0 : f.value),
				height: normalizeImageSizeProp(d == null ? void 0 : d.value)
			})), U = computed(() => o.fit ? {
				objectFit: o.fit
			} : {}), V = computed(() => [`${A}`, {
				[`${A}-loading`]: F.value,
				[`${A}-loading-error`]: D.value,
				[`${A}-with-footer-inner`]: M && j && b.value === "inner",
				[`${A}-with-footer-outer`]: M && j && b.value === "outer"
			}, s.class]), z = computed(() => [O.value, s.style]), j = computed(() => g != null && g.value ||
				v != null && v.value || a.extra ? isBoolean$2(m.value) ? !m.value && M.value : m.value ===
				"never" : !1), ge = computed(() => omit(s, ["class", "style"])), [me, he] = useMergeState(C
				.value, reactive({
					value: _
				})), ce = computed(() => !(T != null && T.preview) && S.value);
			watchEffect(() => {
				isServerRendering || !k.value || (k.value.src = y == null ? void 0 : y.value, R("loading"))
			});
			const ae = uuid++;
			watchEffect(_e => {
				var ke, De, Se;
				const be = (Se = T == null ? void 0 : T.registerImageUrl) == null ? void 0 : Se.call(T, ae,
					((De = (ke = w == null ? void 0 : w.value) == null ? void 0 : ke.src) != null ? De :
						y == null ? void 0 : y.value) || "", S.value);
				_e(() => {
					be == null || be()
				})
			});

			function fe() {
				R("loaded")
			}

			function q() {
				R("error")
			}

			function le() {
				S.value && (T != null && T.preview ? T.preview(ae) : (l("preview-visible-change", !0), he(!0)))
			}

			function de() {
				l("preview-visible-change", !1), he(!1)
			}
			return {
				t: c,
				refImg: k,
				prefixCls: A,
				wrapperClassNames: V,
				wrapperStyles: z,
				showFooter: j,
				imgProps: ge,
				imgStyle: O,
				isLoaded: M,
				isError: D,
				isLoading: F,
				mergedPreviewVisible: me,
				mergePreview: ce,
				onImgLoaded: fe,
				onImgLoadError: q,
				onImgClick: le,
				onPreviewClose: de,
				fitStyle: U
			}
		}
	}),
	_hoisted_1$z = ["title", "alt"];

function _sfc_render$1n(o, s, a, l, c, d) {
	const f = resolveComponent("IconImageClose"),
		m = resolveComponent("IconLoading"),
		g = resolveComponent("ImageFooter"),
		v = resolveComponent("ImagePreview");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.wrapperClassNames),
		style: normalizeStyle(o.wrapperStyles)
	}, [createBaseVNode("img", mergeProps({
			ref: "refImg",
			class: `${o.prefixCls}-img`
		}, o.imgProps, {
			style: {
				...o.imgStyle,
				...o.fitStyle
			},
			title: o.title,
			alt: o.alt,
			onLoad: s[0] || (s[0] = (...y) => o.onImgLoaded && o.onImgLoaded(...y)),
			onError: s[1] || (s[1] = (...y) => o.onImgLoadError && o.onImgLoadError(...y)),
			onClick: s[2] || (s[2] = (...y) => o.onImgClick && o.onImgClick(...y))
		}), null, 16, _hoisted_1$z), o.isLoaded ? createCommentVNode("v-if", !0) : (openBlock(),
			createElementBlock("div", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-overlay`)
			}, [o.isError ? renderSlot(o.$slots, "error", {
					key: 0
				}, () => [createBaseVNode("div", {
					class: normalizeClass(`${o.prefixCls}-error`)
				}, [createBaseVNode("div", {
						class: normalizeClass(`${o.prefixCls}-error-icon`)
					}, [renderSlot(o.$slots, "error-icon", {}, () => [createVNode(f)])], 2), o
					.alt || o.description ? (openBlock(), createElementBlock("div", {
						key: 0,
						class: normalizeClass(`${o.prefixCls}-error-alt`)
					}, toDisplayString(o.alt || o.description), 3)) : createCommentVNode("v-if",
						!0)
				], 2)]) : createCommentVNode("v-if", !0), o.isLoading && (o.showLoader || o.$slots.loader) ?
				renderSlot(o.$slots, "loader", {
					key: 1
				}, () => [createBaseVNode("div", {
					class: normalizeClass([`${o.prefixCls}-loader`])
				}, [createBaseVNode("div", {
					class: normalizeClass(`${o.prefixCls}-loader-spin`)
				}, [createVNode(m), createBaseVNode("div", {
					class: normalizeClass(`${o.prefixCls}-loader-spin-text`)
				}, toDisplayString(o.t("image.loading")), 3)], 2)], 2)]) : createCommentVNode("v-if", !0)
			], 2)), o.showFooter ? (openBlock(), createBlock(g, {
			key: 1,
			class: normalizeClass(o.footerClass),
			"prefix-cls": o.prefixCls,
			title: o.title,
			description: o.description
		}, createSlots({
			_: 2
		}, [o.$slots.extra ? {
			name: "extra",
			fn: withCtx(() => [renderSlot(o.$slots, "extra")]),
			key: "0"
		} : void 0]), 1032, ["class", "prefix-cls", "title", "description"])) : createCommentVNode("v-if", !0),
		o.isLoaded && o.mergePreview ? (openBlock(), createBlock(v, mergeProps({
			key: 2,
			src: o.src
		}, o.previewProps, {
			visible: o.mergedPreviewVisible,
			"render-to-body": o.renderToBody,
			onClose: o.onPreviewClose
		}), {
			actions: withCtx(() => [renderSlot(o.$slots, "preview-actions")]),
			_: 3
		}, 16, ["src", "visible", "render-to-body", "onClose"])) : createCommentVNode("v-if", !0)
	], 6)
}
var _Image = _export_sfc$1(_sfc_main$1F, [
		["render", _sfc_render$1n]
	]),
	_sfc_main$1E = defineComponent({
		name: "ImagePreviewGroup",
		components: {
			ImagePreview
		},
		inheritAttrs: !1,
		props: {
			renderToBody: {
				type: Boolean,
				default: !0
			},
			srcList: {
				type: Array
			},
			current: {
				type: Number
			},
			defaultCurrent: {
				type: Number,
				default: 0
			},
			infinite: {
				type: Boolean,
				default: !1
			},
			visible: {
				type: Boolean,
				default: void 0
			},
			defaultVisible: {
				type: Boolean,
				default: !1
			},
			maskClosable: {
				type: Boolean,
				default: !0
			},
			closable: {
				type: Boolean,
				default: !0
			},
			actionsLayout: {
				type: Array,
				default: () => ["fullScreen", "rotateRight", "rotateLeft", "zoomIn", "zoomOut", "originalSize"]
			},
			popupContainer: {
				type: [String, Object]
			}
		},
		emits: ["change", "update:current", "visible-change", "update:visible"],
		setup(o, {
			emit: s
		}) {
			const {
				srcList: a,
				visible: l,
				defaultVisible: c,
				current: d,
				defaultCurrent: f,
				infinite: m
			} = toRefs(o), [g, v] = useMergeState(c.value, reactive({
					value: l
				})), y = z => {
					z !== g.value && (s("visible-change", z), s("update:visible", z), v(z))
				}, b = computed(() => new Map(isArray$2(a == null ? void 0 : a.value) ? a == null ? void 0 : a.value
					.map((z, j) => [j, {
						url: z,
						canPreview: !0
					}]) : [])), C = ref(new Map(b.value || [])), _ = computed(() => Array.from(C.value.keys())), S =
				computed(() => _.value.length);

			function w(z, j, ge) {
				return b.value.has(z) || C.value.set(z, {
						url: j,
						canPreview: ge
					}),
					function() {
						b.value.has(z) || C.value.delete(z)
					}
			}
			watch(b, () => {
				C.value = new Map(b.value || [])
			});
			const [T, A] = useMergeState(f.value, reactive({
				value: d
			})), k = z => {
				z !== T.value && (s("change", z), s("update:current", z), A(z))
			}, M = computed(() => _.value[T.value]), D = z => {
				const j = _.value.indexOf(z);
				j !== T.value && k(j)
			}, F = computed(() => {
				var z;
				return (z = C.value.get(M.value)) == null ? void 0 : z.url
			});
			provide(PreviewGroupInjectionKey, reactive({
				registerImageUrl: w,
				preview: z => {
					y(!0), D(z)
				}
			}));
			const R = computed(() => {
					const z = (ge, me) => {
							var he;
							for (let ce = ge; ce <= me; ce++) {
								const ae = _.value[ce];
								if ((he = C.value.get(ae)) != null && he.canPreview) return ce
							}
						},
						j = z(T.value + 1, S.value - 1);
					return isUndefined$1(j) && m.value ? z(0, T.value - 1) : j
				}),
				O = computed(() => {
					const z = (ge, me) => {
							var he;
							for (let ce = ge; ce >= me; ce--) {
								const ae = _.value[ce];
								if ((he = C.value.get(ae)) != null && he.canPreview) return ce
							}
						},
						j = z(T.value - 1, 0);
					return isUndefined$1(j) && m.value ? z(S.value - 1, T.value + 1) : j
				}),
				U = computed(() => isUndefined$1(O.value) ? void 0 : () => {
					!isUndefined$1(O.value) && k(O.value)
				}),
				V = computed(() => isUndefined$1(R.value) ? void 0 : () => {
					!isUndefined$1(R.value) && k(R.value)
				});
			return {
				mergedVisible: g,
				currentUrl: F,
				prevIndex: O,
				nextIndex: R,
				onClose() {
					y(!1)
				},
				groupArrowProps: reactive({
					onPrev: U,
					onNext: V
				})
			}
		}
	});

function _sfc_render$1m(o, s, a, l, c, d) {
	const f = resolveComponent("ImagePreview");
	return openBlock(), createElementBlock(Fragment, null, [renderSlot(o.$slots, "default"), createVNode(f, mergeProps({
		...o.$attrs,
		groupArrowProps: o.groupArrowProps
	}, {
		"in-group": "",
		src: o.currentUrl,
		visible: o.mergedVisible,
		"mask-closable": o.maskClosable,
		closable: o.closable,
		"actions-layout": o.actionsLayout,
		"popup-container": o.popupContainer,
		"render-to-body": o.renderToBody,
		onClose: o.onClose
	}), createSlots({
		_: 2
	}, [o.$slots.actions ? {
		name: "actions",
		fn: withCtx(() => [renderSlot(o.$slots, "actions", {
			url: o.currentUrl
		})]),
		key: "0"
	} : void 0]), 1040, ["src", "visible", "mask-closable", "closable", "actions-layout",
		"popup-container", "render-to-body", "onClose"
	])], 64)
}
var ImagePreviewGroup = _export_sfc$1(_sfc_main$1E, [
	["render", _sfc_render$1m]
]);
const Image$2 = Object.assign(_Image, {
		Preview: ImagePreview,
		PreviewGroup: ImagePreviewGroup,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Image.name, _Image), o.component(a + ImagePreview.name, ImagePreview), o.component(
				a + ImagePreviewGroup.name, ImagePreviewGroup), o.component(a + ImagePreviewAction.name,
				ImagePreviewAction)
		}
	}),
	LayoutSiderInjectionKey = Symbol("LayoutSiderInjectionKey"),
	SiderInjectionKey = Symbol("SiderInjectionKey");
var _sfc_main$1D = defineComponent({
	name: "Layout",
	props: {
		hasSider: {
			type: Boolean
		}
	},
	setup(o) {
		const s = ref([]),
			a = getPrefixCls("layout"),
			l = computed(() => [a, {
				[`${a}-has-sider`]: o.hasSider || s.value.length
			}]);
		return provide(LayoutSiderInjectionKey, {
			onSiderMount: c => s.value.push(c),
			onSiderUnMount: c => {
				s.value = s.value.filter(d => d !== c)
			}
		}), {
			classNames: l
		}
	}
});

function _sfc_render$1l(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("section", {
		class: normalizeClass(o.classNames)
	}, [renderSlot(o.$slots, "default")], 2)
}
var _Layout = _export_sfc$1(_sfc_main$1D, [
	["render", _sfc_render$1l]
]);
const _sfc_main$1C = defineComponent({
	name: "LayoutHeader",
	setup() {
		return {
			classNames: [getPrefixCls("layout-header")]
		}
	}
});

function _sfc_render$1k(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("header", {
		class: normalizeClass(o.classNames)
	}, [renderSlot(o.$slots, "default")], 2)
}
var LayoutHeader = _export_sfc$1(_sfc_main$1C, [
	["render", _sfc_render$1k]
]);
const _sfc_main$1B = defineComponent({
	name: "LayoutContent",
	setup() {
		return {
			classNames: [getPrefixCls("layout-content")]
		}
	}
});

function _sfc_render$1j(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("main", {
		class: normalizeClass(o.classNames)
	}, [renderSlot(o.$slots, "default")], 2)
}
var LayoutContent = _export_sfc$1(_sfc_main$1B, [
	["render", _sfc_render$1j]
]);
const _sfc_main$1A = defineComponent({
	name: "LayoutFooter",
	setup() {
		return {
			classNames: [getPrefixCls("layout-footer")]
		}
	}
});

function _sfc_render$1i(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("footer", {
		class: normalizeClass(o.classNames)
	}, [renderSlot(o.$slots, "default")], 2)
}
var LayoutFooter = _export_sfc$1(_sfc_main$1A, [
	["render", _sfc_render$1i]
]);
const _sfc_main$1z = defineComponent({
		name: "IconDragDot",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-drag-dot`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$y = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1h(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1), createBaseVNode("path", {
		d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z"
	}, null, -1)]), 14, _hoisted_1$y)
}
var _IconDragDot = _export_sfc$1(_sfc_main$1z, [
	["render", _sfc_render$1h]
]);
const IconDragDot = Object.assign(_IconDragDot, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconDragDot.name, _IconDragDot)
		}
	}),
	_sfc_main$1y = defineComponent({
		name: "IconDragDotVertical",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-drag-dot-vertical`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$x = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1g(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1), createBaseVNode("path", {
		d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z"
	}, null, -1)]), 14, _hoisted_1$x)
}
var _IconDragDotVertical = _export_sfc$1(_sfc_main$1y, [
	["render", _sfc_render$1g]
]);
const IconDragDotVertical = Object.assign(_IconDragDotVertical, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconDragDotVertical.name, _IconDragDotVertical)
	}
});
var _sfc_main$1x = defineComponent({
	name: "ResizeTrigger",
	components: {
		ResizeObserver: ResizeObserver$2,
		IconDragDot,
		IconDragDotVertical
	},
	props: {
		prefixCls: {
			type: String,
			required: !0
		},
		direction: {
			type: String,
			default: "horizontal"
		}
	},
	emits: ["resize"],
	setup(o, {
		emit: s
	}) {
		const {
			direction: a,
			prefixCls: l
		} = toRefs(o), c = computed(() => (a == null ? void 0 : a.value) === "horizontal");
		return {
			classNames: computed(() => [l.value, {
				[`${l.value}-horizontal`]: c.value,
				[`${l.value}-vertical`]: !c.value
			}]),
			onResize: m => {
				s("resize", m)
			},
			isHorizontal: c
		}
	}
});

function _sfc_render$1f(o, s, a, l, c, d) {
	const f = resolveComponent("IconDragDot"),
		m = resolveComponent("IconDragDotVertical"),
		g = resolveComponent("ResizeObserver");
	return openBlock(), createBlock(g, {
		onResize: o.onResize
	}, {
		default: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass(o.classNames)
		}, [createCommentVNode(" @slot 自定义内容 "), renderSlot(o.$slots, "default", {}, () => [
			createBaseVNode("div", {
				class: normalizeClass(`${o.prefixCls}-icon-wrapper`)
			}, [createCommentVNode(" @slot 自定义 icon "), renderSlot(o.$slots,
			"icon", {}, () => [o.isHorizontal ? (openBlock(), createBlock(
			f, {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-icon`)
			}, null, 8, ["class"])) : (openBlock(), createBlock(m, {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-icon`)
			}, null, 8, ["class"]))])], 2)
		])], 2)]),
		_: 3
	}, 8, ["onResize"])
}
var ResizeTrigger = _export_sfc$1(_sfc_main$1x, [
	["render", _sfc_render$1f]
]);
const DIRECTION_LEFT = "left",
	DIRECTION_RIGHT = "right",
	DIRECTION_TOP = "top",
	DIRECTION_BOTTOM = "bottom",
	allDirections = [DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_TOP, DIRECTION_BOTTOM];

function getRealSize(o, s) {
	if (o === 0) return 0;
	const a = o - s;
	return a <= 0 ? 0 : a
}

function isHorizontal(o) {
	return [DIRECTION_TOP, DIRECTION_BOTTOM].indexOf(o) > -1
}
const _sfc_main$1w = defineComponent({
	name: "ResizeBox",
	components: {
		ResizeTrigger
	},
	inheritAttrs: !1,
	props: {
		width: {
			type: Number
		},
		height: {
			type: Number
		},
		component: {
			type: String,
			default: "div"
		},
		directions: {
			type: Array,
			default: () => ["right"]
		}
	},
	emits: {
		"update:width": o => !0,
		"update:height": o => !0,
		movingStart: o => !0,
		moving: (o, s) => !0,
		movingEnd: o => !0
	},
	setup(o, {
		emit: s
	}) {
		const {
			height: a,
			width: l,
			directions: c
		} = toRefs(o), [d, f] = useMergeState(null, reactive({
				value: l
			})), [m, g] = useMergeState(null, reactive({
				value: a
			})), v = ref(), y = reactive({}), b = getPrefixCls("resizebox"), C = computed(() => [b]), _ =
			computed(() => ({
				...isNumber$2(d.value) ? {
					width: `${d.value}px`
				} : {},
				...isNumber$2(m.value) ? {
					height: `${m.value}px`
				} : {},
				...y
			})), S = computed(() => c.value.filter(D => allDirections.includes(D))), w = {
				direction: "",
				startPageX: 0,
				startPageY: 0,
				startWidth: 0,
				startHeight: 0,
				moving: !1,
				padding: {
					left: 0,
					right: 0,
					top: 0,
					bottom: 0
				}
			};

		function T(D) {
			if (!w.moving) return;
			const {
				startPageX: F,
				startPageY: R,
				startWidth: O,
				startHeight: U,
				direction: V
			} = w;
			let z = O,
				j = U;
			const ge = D.pageX - F,
				me = D.pageY - R;
			switch (V) {
				case DIRECTION_LEFT:
					z = O - ge, f(z), s("update:width", z);
					break;
				case DIRECTION_RIGHT:
					z = O + ge, f(z), s("update:width", z);
					break;
				case DIRECTION_TOP:
					j = U - me, g(j), s("update:height", j);
					break;
				case DIRECTION_BOTTOM:
					j = U + me, g(j), s("update:height", j);
					break
			}
			s("moving", {
				width: z,
				height: j
			}, D)
		}

		function A(D) {
			w.moving = !1, off(window, "mousemove", T), off(window, "mouseup", A), off(window, "contextmenu",
				A), document.body.style.cursor = "default", s("movingEnd", D)
		}

		function k(D, F) {
			var R, O;
			s("movingStart", F), w.moving = !0, w.startPageX = F.pageX, w.startPageY = F.pageY, w.direction = D;
			const {
				top: U,
				left: V,
				right: z,
				bottom: j
			} = w.padding;
			w.startWidth = getRealSize(((R = v.value) == null ? void 0 : R.clientWidth) || 0, V + z), w
				.startHeight = getRealSize(((O = v.value) == null ? void 0 : O.clientHeight) || 0, U + j), on(
					window, "mousemove", T), on(window, "mouseup", A), on(window, "contextmenu", A), document
				.body.style.cursor = isHorizontal(D) ? "row-resize" : "col-resize"
		}

		function M(D, F) {
			const {
				width: R,
				height: O
			} = F.contentRect, U = isHorizontal(D) ? O : R;
			w.padding[D] = U, y[`padding-${D}`] = `${U}px`
		}
		return {
			prefixCls: b,
			classNames: C,
			styles: _,
			wrapperRef: v,
			onMoveStart: k,
			isHorizontal,
			allowDirections: S,
			onTiggerResize: M
		}
	}
});

function _sfc_render$1e(o, s, a, l, c, d) {
	const f = resolveComponent("ResizeTrigger");
	return openBlock(), createBlock(resolveDynamicComponent(o.component), mergeProps({
		ref: "wrapperRef",
		class: o.classNames
	}, o.$attrs, {
		style: o.styles
	}), {
		default: withCtx(() => [renderSlot(o.$slots, "default"), (openBlock(!0), createElementBlock(Fragment,
			null, renderList(o.allowDirections, m => (openBlock(), createBlock(f, {
				key: m,
				"prefix-cls": `${o.prefixCls}-trigger`,
				class: normalizeClass(`${o.prefixCls}-direction-${m}`),
				direction: o.isHorizontal(m) ? "horizontal" : "vertical",
				onMousedown: g => {
					o.onMoveStart(m, g)
				},
				onResize: g => {
					o.onTiggerResize(m, g)
				}
			}, createSlots({
				default: withCtx(() => [o.$slots["resize-trigger"] ? renderSlot(
					o.$slots, "resize-trigger", {
						key: 0,
						direction: m
					}) : createCommentVNode("v-if", !0)]),
				_: 2
			}, [o.$slots["resize-trigger-icon"] ? {
				name: "icon",
				fn: withCtx(() => [renderSlot(o.$slots,
					"resize-trigger-icon", {
						direction: m
					})]),
				key: "0"
			} : void 0]), 1032, ["prefix-cls", "class", "direction", "onMousedown",
				"onResize"
			]))), 128))]),
		_: 3
	}, 16, ["class", "style"])
}
var _ResizeBox = _export_sfc$1(_sfc_main$1w, [
	["render", _sfc_render$1e]
]);
const ResizeBox = Object.assign(_ResizeBox, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _ResizeBox.name, _ResizeBox)
	}
});

function useResponsive(o, s) {
	const a = computed(() => isRef(o) ? o.value : o);
	let l = "";
	onMounted(() => {
		l = responsiveObserve.subscribe((c, d) => {
			a.value && (!d || d === a.value) && s(!!c[a.value])
		})
	}), onUnmounted(() => {
		l && responsiveObserve.unsubscribe(l)
	})
}
const generateId$1 = (() => {
	let o = 0;
	return (s = "") => (o += 1, `${s}${o}`)
})();
var _sfc_main$1v = defineComponent({
	name: "LayoutSider",
	components: {
		IconLeft,
		IconRight,
		ResizeBox
	},
	props: {
		theme: {
			type: String,
			default: "light"
		},
		collapsed: {
			type: Boolean,
			default: void 0
		},
		defaultCollapsed: {
			type: Boolean
		},
		collapsible: {
			type: Boolean
		},
		width: {
			type: Number,
			default: 200
		},
		collapsedWidth: {
			type: Number,
			default: 48
		},
		reverseArrow: {
			type: Boolean
		},
		breakpoint: {
			type: String
		},
		resizeDirections: {
			type: Array,
			default: void 0
		},
		hideTrigger: {
			type: Boolean
		}
	},
	emits: ["collapse", "update:collapsed", "breakpoint"],
	setup(o, {
		emit: s
	}) {
		const {
			theme: a,
			collapsed: l,
			defaultCollapsed: c,
			collapsible: d,
			hideTrigger: f,
			breakpoint: m,
			collapsedWidth: g,
			resizeDirections: v
		} = toRefs(o), [y, b] = useMergeState(c.value, reactive({
				value: l
			})), C = computed(() => v.value ? "ResizeBox" : "div"), _ = computed(() => d.value && !f.value), S =
			getPrefixCls("layout-sider"), w = computed(() => [S, {
				[`${S}-light`]: a.value === "light",
				[`${S}-has-trigger`]: _.value,
				[`${S}-collapsed`]: l.value
			}]), T = computed(() => {
				const {
					width: F,
					collapsedWidth: R
				} = o, O = y.value ? R : F;
				return isNumber$2(O) ? `${O}px` : String(O)
			}), A = computed(() => [`${S}-trigger`, {
				[`${S}-trigger-light`]: a.value === "light"
			}]), k = () => {
				const F = !y.value;
				b(F), s("update:collapsed", F), s("collapse", F, "clickTrigger")
			};
		useResponsive(m, F => {
			const R = !F;
			R !== y.value && (b(R), s("update:collapsed", R), s("collapse", R, "responsive"), s(
				"breakpoint", R))
		});
		const M = generateId$1("__arco_layout_sider"),
			D = inject(LayoutSiderInjectionKey, void 0);
		return onMounted(() => {
			var F;
			(F = D == null ? void 0 : D.onSiderMount) == null || F.call(D, M)
		}), onUnmounted(() => {
			var F;
			(F = D == null ? void 0 : D.onSiderUnMount) == null || F.call(D, M)
		}), provide(SiderInjectionKey, reactive({
			theme: a,
			collapsed: y,
			collapsedWidth: g
		})), {
			componentTag: C,
			prefixCls: S,
			classNames: w,
			triggerClassNames: A,
			localCollapsed: y,
			siderWidth: T,
			showTrigger: _,
			toggleTrigger: k
		}
	}
});
const _hoisted_1$w = {
		key: 0
	},
	_hoisted_2$3 = {
		key: 1
	};

function _sfc_render$1d(o, s, a, l, c, d) {
	const f = resolveComponent("IconLeft"),
		m = resolveComponent("IconRight");
	return openBlock(), createBlock(resolveDynamicComponent(o.componentTag), mergeProps({
		class: o.classNames,
		style: {
			width: o.siderWidth
		}
	}, o.resizeDirections ? {
		directions: o.resizeDirections
	} : {}), {
		default: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-children`)
		}, [renderSlot(o.$slots, "default")], 2), o.showTrigger ? (openBlock(), createElementBlock(
			"div", {
				key: 0,
				class: normalizeClass(o.triggerClassNames),
				style: normalizeStyle({
					width: o.siderWidth
				}),
				onClick: s[0] || (s[0] = (...g) => o.toggleTrigger && o.toggleTrigger(...g))
			}, [renderSlot(o.$slots, "trigger", {
				collapsed: o.localCollapsed
			}, () => [o.reverseArrow ? (openBlock(), createElementBlock("div",
				_hoisted_2$3, [o.localCollapsed ? (openBlock(), createBlock(f, {
					key: 0
				})) : (openBlock(), createBlock(m, {
					key: 1
				}))])) : (openBlock(), createElementBlock("div", _hoisted_1$w, [o
				.localCollapsed ? (openBlock(), createBlock(m, {
					key: 1
				})) : (openBlock(), createBlock(f, {
					key: 0
				}))
			]))])], 6)) : createCommentVNode("v-if", !0)]),
		_: 3
	}, 16, ["class", "style"])
}
var LayoutSider = _export_sfc$1(_sfc_main$1v, [
	["render", _sfc_render$1d]
]);
const Layout = Object.assign(_Layout, {
		Header: LayoutHeader,
		Content: LayoutContent,
		Footer: LayoutFooter,
		Sider: LayoutSider,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Layout.name, _Layout), o.component(a + LayoutHeader.name, LayoutHeader), o
				.component(a + LayoutContent.name, LayoutContent), o.component(a + LayoutFooter.name,
					LayoutFooter), o.component(a + LayoutSider.name, LayoutSider)
		}
	}),
	_sfc_main$1u = defineComponent({
		name: "Pager",
		props: {
			pageNumber: {
				type: Number
			},
			current: {
				type: Number
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			style: {
				type: Object
			},
			activeStyle: {
				type: Object
			}
		},
		emits: ["click"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("pagination-item"),
				l = computed(() => o.current === o.pageNumber),
				c = m => {
					o.disabled || s("click", o.pageNumber, m)
				},
				d = computed(() => [a, {
					[`${a}-active`]: l.value
				}]),
				f = computed(() => l.value ? o.activeStyle : o.style);
			return {
				prefixCls: a,
				cls: d,
				mergedStyle: f,
				handleClick: c
			}
		}
	});

function _sfc_render$1c(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("li", {
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.mergedStyle),
		onClick: s[0] || (s[0] = (...f) => o.handleClick && o.handleClick(...f))
	}, [renderSlot(o.$slots, "default", {
		page: o.pageNumber
	}, () => [createTextVNode(toDisplayString(o.pageNumber), 1)])], 6)
}
var Pager = _export_sfc$1(_sfc_main$1u, [
	["render", _sfc_render$1c]
]);
const getLegalPage = (o, {
		min: s,
		max: a
	}) => o < s ? s : o > a ? a : o,
	_sfc_main$1t = defineComponent({
		name: "StepPager",
		components: {
			IconLeft,
			IconRight
		},
		props: {
			pages: {
				type: Number,
				required: !0
			},
			current: {
				type: Number,
				required: !0
			},
			type: {
				type: String,
				required: !0
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			simple: {
				type: Boolean,
				default: !1
			}
		},
		emits: ["click"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("pagination-item"),
				l = o.type === "next",
				c = computed(() => o.disabled ? o.disabled : !o.pages || l && o.current === o.pages ? !0 : !l && o
					.current <= 1),
				d = computed(() => getLegalPage(o.current + (l ? 1 : -1), {
					min: 1,
					max: o.pages
				})),
				f = g => {
					c.value || s("click", d.value)
				},
				m = computed(() => [a, `${a}-${o.type}`, {
					[`${a}-disabled`]: c.value
				}]);
			return {
				prefixCls: a,
				cls: m,
				isNext: l,
				handleClick: f
			}
		}
	});

function _sfc_render$1b(o, s, a, l, c, d) {
	const f = resolveComponent("icon-right"),
		m = resolveComponent("icon-left");
	return openBlock(), createBlock(resolveDynamicComponent(o.simple ? "span" : "li"), {
		class: normalizeClass(o.cls),
		onClick: o.handleClick
	}, {
		default: withCtx(() => [renderSlot(o.$slots, "default", {
			type: o.isNext ? "next" : "previous"
		}, () => [o.isNext ? (openBlock(), createBlock(f, {
			key: 0
		})) : (openBlock(), createBlock(m, {
			key: 1
		}))])]),
		_: 3
	}, 8, ["class", "onClick"])
}
var StepPager = _export_sfc$1(_sfc_main$1t, [
	["render", _sfc_render$1b]
]);
const _sfc_main$1s = defineComponent({
	name: "EllipsisPager",
	components: {
		IconMore
	},
	props: {
		current: {
			type: Number,
			required: !0
		},
		step: {
			type: Number,
			default: 5
		},
		pages: {
			type: Number,
			required: !0
		}
	},
	emits: ["click"],
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("pagination-item"),
			l = computed(() => getLegalPage(o.current + o.step, {
				min: 1,
				max: o.pages
			})),
			c = f => {
				s("click", l.value)
			},
			d = computed(() => [a, `${a}-ellipsis`]);
		return {
			prefixCls: a,
			cls: d,
			handleClick: c
		}
	}
});

function _sfc_render$1a(o, s, a, l, c, d) {
	const f = resolveComponent("icon-more");
	return openBlock(), createElementBlock("li", {
		class: normalizeClass(o.cls),
		onClick: s[0] || (s[0] = (...m) => o.handleClick && o.handleClick(...m))
	}, [renderSlot(o.$slots, "default", {}, () => [createVNode(f)])], 2)
}
var EllipsisPager = _export_sfc$1(_sfc_main$1s, [
	["render", _sfc_render$1a]
]);
const _sfc_main$1r = defineComponent({
	name: "PageJumper",
	components: {
		InputNumber
	},
	props: {
		current: {
			type: Number,
			required: !0
		},
		simple: {
			type: Boolean,
			default: !1
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		pages: {
			type: Number,
			required: !0
		},
		size: {
			type: String
		},
		onChange: {
			type: Function
		}
	},
	emits: ["change"],
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("pagination-jumper"),
			{
				t: l
			} = useI18n(),
			c = ref(o.simple ? o.current : void 0),
			d = g => {
				const v = parseInt(g.toString(), 10);
				return Number.isNaN(v) ? void 0 : String(v)
			},
			f = g => {
				s("change", c.value), nextTick(() => {
					o.simple || (c.value = void 0)
				})
			};
		watch(() => o.current, g => {
			o.simple && g !== c.value && (c.value = g)
		});
		const m = computed(() => [a, {
			[`${a}-simple`]: o.simple
		}]);
		return {
			prefixCls: a,
			cls: m,
			t: l,
			inputValue: c,
			handleChange: f,
			handleFormatter: d
		}
	}
});

function _sfc_render$19(o, s, a, l, c, d) {
	const f = resolveComponent("input-number");
	return openBlock(), createElementBlock("span", {
		class: normalizeClass(o.cls)
	}, [o.simple ? createCommentVNode("v-if", !0) : (openBlock(), createElementBlock("span", {
		key: 0,
		class: normalizeClass([`${o.prefixCls}-prepend`, `${o.prefixCls}-text-goto`])
	}, [renderSlot(o.$slots, "jumper-prepend", {}, () => [createTextVNode(toDisplayString(o.t(
		"pagination.goto")), 1)])], 2)), createVNode(f, {
		modelValue: o.inputValue,
		"onUpdate:modelValue": s[0] || (s[0] = m => o.inputValue = m),
		class: normalizeClass(`${o.prefixCls}-input`),
		min: 1,
		max: o.pages,
		size: o.size,
		disabled: o.disabled,
		"hide-button": "",
		formatter: o.handleFormatter,
		onChange: o.handleChange
	}, null, 8, ["modelValue", "class", "max", "size", "disabled", "formatter", "onChange"]), o.$slots[
		"jumper-append"] ? (openBlock(), createElementBlock("span", {
		key: 1,
		class: normalizeClass(`${o.prefixCls}-append`)
	}, [renderSlot(o.$slots, "jumper-append")], 2)) : createCommentVNode("v-if", !0), o.simple ? (
	openBlock(), createElementBlock(Fragment, {
		key: 2
	}, [createBaseVNode("span", {
		class: normalizeClass(`${o.prefixCls}-separator`)
	}, "/", 2), createBaseVNode("span", {
		class: normalizeClass(`${o.prefixCls}-total-page`)
	}, toDisplayString(o.pages), 3)], 64)) : createCommentVNode("v-if", !0)], 2)
}
var PageJumper = _export_sfc$1(_sfc_main$1r, [
	["render", _sfc_render$19]
]);
const _sfc_main$1q = defineComponent({
	name: "PageOptions",
	components: {
		ArcoSelect: Select
	},
	props: {
		sizeOptions: {
			type: Array,
			required: !0
		},
		pageSize: Number,
		disabled: Boolean,
		size: {
			type: String
		},
		onChange: {
			type: Function
		},
		selectProps: {
			type: Object
		}
	},
	emits: ["change"],
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("pagination-options"),
			{
				t: l
			} = useI18n(),
			c = computed(() => o.sizeOptions.map(f => ({
				value: f,
				label: `${f} ${l("pagination.countPerPage")}`
			})));
		return {
			prefixCls: a,
			options: c,
			handleChange: f => {
				s("change", f)
			}
		}
	}
});

function _sfc_render$18(o, s, a, l, c, d) {
	const f = resolveComponent("arco-select");
	return openBlock(), createElementBlock("span", {
		class: normalizeClass(o.prefixCls)
	}, [createVNode(f, mergeProps({
		"model-value": o.pageSize,
		options: o.options,
		size: o.size,
		disabled: o.disabled
	}, o.selectProps, {
		onChange: o.handleChange
	}), null, 16, ["model-value", "options", "size", "disabled", "onChange"])], 2)
}
var PageOptions = _export_sfc$1(_sfc_main$1q, [
		["render", _sfc_render$18]
	]),
	_Pagination = defineComponent({
		name: "Pagination",
		props: {
			total: {
				type: Number,
				required: !0
			},
			current: Number,
			defaultCurrent: {
				type: Number,
				default: 1
			},
			pageSize: Number,
			defaultPageSize: {
				type: Number,
				default: 10
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			hideOnSinglePage: {
				type: Boolean,
				default: !1
			},
			simple: {
				type: Boolean,
				default: !1
			},
			showTotal: {
				type: Boolean,
				default: !1
			},
			showMore: {
				type: Boolean,
				default: !1
			},
			showJumper: {
				type: Boolean,
				default: !1
			},
			showPageSize: {
				type: Boolean,
				default: !1
			},
			pageSizeOptions: {
				type: Array,
				default: () => [10, 20, 30, 40, 50]
			},
			pageSizeProps: {
				type: Object
			},
			size: {
				type: String
			},
			pageItemStyle: {
				type: Object
			},
			activePageItemStyle: {
				type: Object
			},
			baseSize: {
				type: Number,
				default: 6
			},
			bufferSize: {
				type: Number,
				default: 2
			},
			autoAdjust: {
				type: Boolean,
				default: !0
			}
		},
		emits: {
			"update:current": o => !0,
			"update:pageSize": o => !0,
			change: o => !0,
			pageSizeChange: o => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const l = getPrefixCls("pagination"),
				{
					t: c
				} = useI18n(),
				{
					disabled: d,
					pageItemStyle: f,
					activePageItemStyle: m,
					size: g
				} = toRefs(o),
				{
					mergedSize: v
				} = useSize$1(g),
				y = ref(o.defaultCurrent),
				b = ref(o.defaultPageSize),
				C = computed(() => {
					var R;
					return (R = o.current) != null ? R : y.value
				}),
				_ = computed(() => {
					var R;
					return (R = o.pageSize) != null ? R : b.value
				}),
				S = computed(() => Math.ceil(o.total / _.value)),
				w = R => {
					R !== C.value && isNumber$2(R) && !o.disabled && (y.value = R, s("update:current", R), s(
						"change", R))
				},
				T = R => {
					b.value = R, s("update:pageSize", R), s("pageSizeChange", R)
				},
				A = reactive({
					current: C,
					pages: S,
					disabled: d,
					style: f,
					activeStyle: m,
					onClick: w
				}),
				k = (R, O = {}) => R === "more" ? createVNode(EllipsisPager, mergeProps(O, A), {
					default: a["page-item-ellipsis"]
				}) : R === "previous" ? createVNode(StepPager, mergeProps({
					type: "previous"
				}, O, A), {
					default: a["page-item-step"]
				}) : R === "next" ? createVNode(StepPager, mergeProps({
					type: "next"
				}, O, A), {
					default: a["page-item-step"]
				}) : createVNode(Pager, mergeProps(O, A), {
					default: a["page-item"]
				}),
				M = computed(() => {
					const R = [];
					if (S.value < o.baseSize + o.bufferSize * 2)
						for (let O = 1; O <= S.value; O++) R.push(k("page", {
							key: O,
							pageNumber: O
						}));
					else {
						let O = 1,
							U = S.value,
							V = !1,
							z = !1;
						C.value > 2 + o.bufferSize && (V = !0, O = Math.min(C.value - o.bufferSize, S.value -
							2 * o.bufferSize)), C.value < S.value - (o.bufferSize + 1) && (z = !0, U = Math
							.max(C.value + o.bufferSize, 2 * o.bufferSize + 1)), V && (R.push(k("page", {
							key: 1,
							pageNumber: 1
						})), R.push(k("more", {
							key: "left-ellipsis-pager",
							step: -(o.bufferSize * 2 + 1)
						})));
						for (let j = O; j <= U; j++) R.push(k("page", {
							key: j,
							pageNumber: j
						}));
						z && (R.push(k("more", {
							key: "right-ellipsis-pager",
							step: o.bufferSize * 2 + 1
						})), R.push(k("page", {
							key: S.value,
							pageNumber: S.value
						})))
					}
					return R
				}),
				D = () => o.simple ? createVNode("span", {
					class: `${l}-simple`
				}, [k("previous", {
					simple: !0
				}), createVNode(PageJumper, {
					disabled: o.disabled,
					current: C.value,
					size: v.value,
					pages: S.value,
					simple: !0,
					onChange: w
				}, null), k("next", {
					simple: !0
				})]) : createVNode("ul", {
					class: `${l}-list`
				}, [k("previous", {
					simple: !0
				}), M.value, o.showMore && k("more", {
					key: "more",
					step: o.bufferSize * 2 + 1
				}), k("next", {
					simple: !0
				})]);
			watch(_, (R, O) => {
				if (o.autoAdjust && R !== O && C.value > 1) {
					const U = O * (C.value - 1) + 1,
						V = Math.ceil(U / R);
					V !== C.value && (y.value = V, s("update:current", V), s("change", V))
				}
			}), watch(S, (R, O) => {
				if (o.autoAdjust && R !== O && C.value > 1 && C.value > R) {
					const U = Math.max(R, 1);
					y.value = U, s("update:current", U), s("change", U)
				}
			});
			const F = computed(() => [l, `${l}-size-${v.value}`, {
				[`${l}-simple`]: o.simple,
				[`${l}-disabled`]: o.disabled
			}]);
			return () => {
				var R, O;
				return o.hideOnSinglePage && S.value <= 1 ? null : createVNode("div", {
					class: F.value
				}, [o.showTotal && createVNode("span", {
						class: `${l}-total`
					}, [(O = (R = a.total) == null ? void 0 : R.call(a, {
						total: o.total
					})) != null ? O : c("pagination.total", o.total)]), D(), o.showPageSize &&
					createVNode(PageOptions, {
						disabled: o.disabled,
						sizeOptions: o.pageSizeOptions,
						pageSize: _.value,
						size: v.value,
						onChange: T,
						selectProps: o.pageSizeProps
					}, null), !o.simple && o.showJumper && createVNode(PageJumper, {
						disabled: o.disabled,
						current: C.value,
						pages: S.value,
						size: v.value,
						onChange: w
					}, {
						"jumper-prepend": a["jumper-prepend"],
						"jumper-append": a["jumper-append"]
					})
				])
			}
		}
	});
const Pagination = Object.assign(_Pagination, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Pagination.name, _Pagination)
		}
	}),
	usePagination$1 = (o, {
		emit: s
	}) => {
		var a, l;
		const c = ref(isObject$2(o.paginationProps) && (a = o.paginationProps.defaultCurrent) != null ? a : 1),
			d = ref(isObject$2(o.paginationProps) && (l = o.paginationProps.defaultPageSize) != null ? l : 10),
			f = computed(() => {
				var y;
				return isObject$2(o.paginationProps) && (y = o.paginationProps.current) != null ? y : c.value
			}),
			m = computed(() => {
				var y;
				return isObject$2(o.paginationProps) && (y = o.paginationProps.pageSize) != null ? y : d.value
			});
		return {
			current: f,
			pageSize: m,
			handlePageChange: y => {
				c.value = y, s("pageChange", y)
			},
			handlePageSizeChange: y => {
				d.value = y, s("pageSizeChange", y)
			}
		}
	};

function _isSlot$a(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var _List = defineComponent({
		name: "List",
		props: {
			data: {
				type: Array
			},
			size: {
				type: String,
				default: "medium"
			},
			bordered: {
				type: Boolean,
				default: !0
			},
			split: {
				type: Boolean,
				default: !0
			},
			loading: {
				type: Boolean,
				default: !1
			},
			hoverable: {
				type: Boolean,
				default: !1
			},
			paginationProps: {
				type: Object
			},
			gridProps: {
				type: Object
			},
			maxHeight: {
				type: [String, Number],
				default: 0
			},
			bottomOffset: {
				type: Number,
				default: 0
			},
			virtualListProps: {
				type: Object
			},
			scrollbar: {
				type: [Object, Boolean],
				default: !0
			}
		},
		emits: {
			scroll: () => !0,
			reachBottom: () => !0,
			pageChange: o => !0,
			pageSizeChange: o => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				scrollbar: l
			} = toRefs(o), c = getPrefixCls("list"), d = inject(configProviderInjectionKey, void 0), {
				componentRef: f,
				elementRef: m
			} = useComponentRef("containerRef"), g = computed(() => o.virtualListProps), {
				displayScrollbar: v,
				scrollbarProps: y
			} = useScrollbar(l);
			let b = 0;
			const C = he => {
				const {
					scrollTop: ce,
					scrollHeight: ae,
					offsetHeight: fe
				} = he.target, q = Math.floor(ae - (ce + fe));
				ce > b && q <= o.bottomOffset && s("reachBottom"), s("scroll"), b = ce
			};
			onMounted(() => {
				if (m.value) {
					const {
						scrollTop: he,
						scrollHeight: ce,
						offsetHeight: ae
					} = m.value;
					ce <= he + ae && s("reachBottom")
				}
			});
			const {
				current: _,
				pageSize: S,
				handlePageChange: w,
				handlePageSizeChange: T
			} = usePagination$1(o, {
				emit: s
			}), A = he => {
				if (!o.paginationProps) return he;
				if (o.paginationProps && he.length > S.value) {
					const ce = (_.value - 1) * S.value;
					return he.slice(ce, ce + S.value)
				}
				return he
			}, k = he => {
				let ce;
				if (!o.gridProps) return null;
				const ae = A(he);
				if (o.gridProps.span) {
					const fe = [],
						q = 24 / o.gridProps.span;
					for (let le = 0; le < ae.length; le += q) {
						let de;
						const _e = le + q,
							ke = Math.floor(le / q);
						fe.push(createVNode(Grid$1.Row, {
							key: ke,
							class: `${c}-row`,
							gutter: o.gridProps.gutter
						}, _isSlot$a(de = ae.slice(le, _e).map((De, Se) => {
							var be;
							return createVNode(Grid$1.Col, {
								key: `${ke}-${Se}`,
								class: `${c}-col`,
								span: (be = o.gridProps) == null ? void 0 : be.span
							}, {
								default: () => {
									var Me;
									return [isVNode(De) ? De : (Me = a.item) ==
										null ? void 0 : Me.call(a, {
											item: De,
											index: Se
										})
									]
								}
							})
						})) ? de : {
							default: () => [de]
						}))
					}
					return fe
				}
				return createVNode(Grid$1.Row, {
					class: `${c}-row`,
					gutter: o.gridProps.gutter
				}, _isSlot$a(ce = ae.map((fe, q) => createVNode(Grid$1.Col, mergeProps({
					key: q,
					class: `${c}-col`
				}, omit(o.gridProps, ["gutter"])), {
					default: () => {
						var le;
						return [isVNode(fe) ? fe : (le = a.item) == null ? void 0 : le
							.call(a, {
								item: fe,
								index: q
							})
						]
					}
				}))) ? ce : {
					default: () => [ce]
				})
			}, M = he => A(he).map((ae, fe) => {
				var q;
				return isVNode(ae) ? ae : (q = a.item) == null ? void 0 : q.call(a, {
					item: ae,
					index: fe
				})
			}), D = () => {
				const he = a.default ? getAllElements(a.default()) : o.data;
				return he && he.length > 0 ? o.gridProps ? k(he) : M(he) : ge()
			}, F = () => {
				if (!o.paginationProps) return null;
				const he = omit(o.paginationProps, ["current", "pageSize", "defaultCurrent",
				"defaultPageSize"]);
				return createVNode(Pagination, mergeProps({
					class: `${c}-pagination`
				}, he, {
					current: _.value,
					pageSize: S.value,
					onChange: w,
					onPageSizeChange: T
				}), null)
			}, R = computed(() => [c, `${c}-${o.size}`, {
				[`${c}-bordered`]: o.bordered,
				[`${c}-split`]: o.split,
				[`${c}-hover`]: o.hoverable
			}]), O = computed(() => {
				if (o.maxHeight) return {
					maxHeight: isNumber$2(o.maxHeight) ? `${o.maxHeight}px` : o.maxHeight,
					overflowY: "auto"
				}
			}), U = computed(() => [`${c}-content`, {
				[`${c}-virtual`]: g.value
			}]), V = ref(), z = () => {
				var he;
				const ce = A((he = o.data) != null ? he : []);
				return ce.length ? createVNode(VirtualList, mergeProps({
					ref: V,
					class: U.value,
					data: ce
				}, o.virtualListProps, {
					onScroll: C
				}), {
					item: ({
						item: ae,
						index: fe
					}) => {
						var q;
						return (q = a.item) == null ? void 0 : q.call(a, {
							item: ae,
							index: fe
						})
					}
				}) : ge()
			}, j = () => a["scroll-loading"] ? createVNode("div", {
				class: [`${c}-item`, `${c}-scroll-loading`]
			}, [a["scroll-loading"]()]) : null, ge = () => {
				var he, ce, ae, fe, q;
				return a["scroll-loading"] ? null : (q = (fe = (he = a.empty) == null ? void 0 : he.call(a)) !=
					null ? fe : (ae = d == null ? void 0 : (ce = d.slots).empty) == null ? void 0 : ae.call(
						ce, {
							component: "list"
						})) != null ? q : createVNode(Empty, null, null)
			};
			return {
				virtualListRef: V,
				render: () => {
					const he = v.value ? Scrollbar : "div";
					return createVNode("div", {
						class: `${c}-wrapper`
					}, [createVNode(Spin, {
						class: `${c}-spin`,
						loading: o.loading
					}, {
						default: () => [createVNode(he, mergeProps({
							ref: f,
							class: R.value,
							style: O.value
						}, y.value, {
							onScroll: C
						}), {
							default: () => [createVNode("div", {
								class: `${c}-content-wrapper`
							}, [a.header && createVNode("div", {
									class: `${c}-header`
								}, [a.header()]), g.value && !o
								.gridProps ? createVNode(Fragment, null,
									[z(), j()]) : createVNode("div", {
									role: "list",
									class: U.value
								}, [D(), j()]), a.footer && createVNode(
									"div", {
										class: `${c}-footer`
									}, [a.footer()])
							])]
						}), F()]
					})])
				}
			}
		},
		methods: {
			scrollIntoView(o) {
				this.virtualListRef && this.virtualListRef.scrollTo(o)
			}
		},
		render() {
			return this.render()
		}
	}),
	ListItem = defineComponent({
		name: "ListItem",
		props: {
			actionLayout: {
				type: String,
				default: "horizontal"
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("list-item"),
				l = () => {
					var c;
					const d = (c = s.actions) == null ? void 0 : c.call(s);
					return !d || !d.length ? null : createVNode("ul", {
						class: `${a}-action`
					}, [d.map((f, m) => createVNode("li", {
						key: `${a}-action-${m}`
					}, [f]))])
				};
			return () => {
				var c, d;
				return createVNode("div", {
					role: "listitem",
					class: a
				}, [createVNode("div", {
					class: `${a}-main`
				}, [(c = s.meta) == null ? void 0 : c.call(s), createVNode("div", {
						class: `${a}-content`
					}, [(d = s.default) == null ? void 0 : d.call(s)]), o.actionLayout ===
					"vertical" && l()
				]), o.actionLayout === "horizontal" && l(), s.extra && createVNode("div", {
					class: `${a}-extra`
				}, [s.extra()])])
			}
		}
	});
const _sfc_main$1p = defineComponent({
	name: "ListItemMeta",
	props: {
		title: String,
		description: String
	},
	setup(o, {
		slots: s
	}) {
		const a = getPrefixCls("list-item-meta"),
			l = !!(o.title || o.description || s.title || s.description);
		return {
			prefixCls: a,
			hasContent: l
		}
	}
});

function _sfc_render$17(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [o.$slots.avatar ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-avatar`)
	}, [renderSlot(o.$slots, "avatar")], 2)) : createCommentVNode("v-if", !0), o.hasContent ? (openBlock(),
		createElementBlock("div", {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [o.$slots.title || o.title ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-title`)
			}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(o
				.title), 1)])], 2)) : createCommentVNode("v-if", !0), o.$slots.description || o
			.description ? (openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-description`)
			}, [renderSlot(o.$slots, "description", {}, () => [createTextVNode(toDisplayString(o
				.description), 1)])], 2)) : createCommentVNode("v-if", !0)
		], 2)) : createCommentVNode("v-if", !0)], 2)
}
var ListItemMeta = _export_sfc$1(_sfc_main$1p, [
	["render", _sfc_render$17]
]);
const List = Object.assign(_List, {
		Item: Object.assign(ListItem, {
			Meta: ListItemMeta
		}),
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _List.name, _List), o.component(a + ListItem.name, ListItem), o.component(a +
				ListItemMeta.name, ListItemMeta)
		}
	}),
	sizeStyles = ["border-width", "box-sizing", "font-family", "font-weight", "font-size", "font-variant",
		"letter-spacing", "line-height", "padding-top", "padding-bottom", "padding-left", "padding-right",
		"text-indent", "text-rendering", "text-transform", "white-space", "overflow-wrap", "width"
	],
	getSizeStyles = o => {
		const s = {};
		return sizeStyles.forEach(a => {
			s[a] = o.getPropertyValue(a)
		}), s
	},
	_sfc_main$1o = defineComponent({
		name: "Textarea",
		components: {
			ResizeObserver: ResizeObserver$2,
			IconHover,
			IconClose
		},
		inheritAttrs: !1,
		props: {
			modelValue: String,
			defaultValue: {
				type: String,
				default: ""
			},
			placeholder: String,
			disabled: {
				type: Boolean,
				default: !1
			},
			error: {
				type: Boolean,
				default: !1
			},
			maxLength: {
				type: [Number, Object],
				default: 0
			},
			showWordLimit: {
				type: Boolean,
				default: !1
			},
			allowClear: {
				type: Boolean,
				default: !1
			},
			autoSize: {
				type: [Boolean, Object],
				default: !1
			},
			wordLength: {
				type: Function
			},
			wordSlice: {
				type: Function
			},
			textareaAttrs: {
				type: Object
			}
		},
		emits: {
			"update:modelValue": o => !0,
			input: (o, s) => !0,
			change: (o, s) => !0,
			clear: o => !0,
			focus: o => !0,
			blur: o => !0
		},
		setup(o, {
			emit: s,
			attrs: a
		}) {
			const {
				disabled: l,
				error: c,
				modelValue: d
			} = toRefs(o), f = getPrefixCls("textarea"), {
				mergedDisabled: m,
				mergedError: g,
				eventHandlers: v
			} = useFormItem({
				disabled: l,
				error: c
			}), y = ref(), b = ref(), C = ref(), _ = ref(), S = ref(o.defaultValue), w = computed(() => {
				var Le;
				return (Le = d.value) != null ? Le : S.value
			}), [T, A] = useCursor(y);
			watch(d, Le => {
				(isUndefined$1(Le) || isNull$1(Le)) && (S.value = "")
			});
			const k = computed(() => isObject$2(o.maxLength) && !!o.maxLength.errorOnly),
				M = computed(() => isObject$2(o.maxLength) ? o.maxLength.length : o.maxLength),
				D = Le => {
					var Ue;
					return isFunction$2(o.wordLength) ? o.wordLength(Le) : (Ue = Le.length) != null ? Ue : 0
				},
				F = computed(() => D(w.value)),
				R = computed(() => g.value || !!(M.value && k.value && F.value > M.value)),
				O = ref(!1),
				U = ref(!1),
				V = computed(() => o.allowClear && !m.value && w.value),
				z = ref(!1),
				j = ref(""),
				ge = () => {
					T(), nextTick(() => {
						y.value && w.value !== y.value.value && (y.value.value = w.value, A())
					})
				},
				me = (Le, Ue = !0) => {
					var nt, ot;
					M.value && !k.value && D(Le) > M.value && (Le = (ot = (nt = o.wordSlice) == null ? void 0 : nt
						.call(o, Le, M.value)) != null ? ot : Le.slice(0, M.value)), S.value = Le, Ue && s(
						"update:modelValue", Le), ge()
				};
			let he = w.value;
			const ce = (Le, Ue) => {
					var nt, ot;
					Le !== he && (he = Le, s("change", Le, Ue), (ot = (nt = v.value) == null ? void 0 : nt
						.onChange) == null || ot.call(nt, Ue))
				},
				ae = Le => {
					var Ue, nt;
					U.value = !0, he = w.value, s("focus", Le), (nt = (Ue = v.value) == null ? void 0 : Ue
						.onFocus) == null || nt.call(Ue, Le)
				},
				fe = Le => {
					var Ue, nt;
					U.value = !1, s("blur", Le), (nt = (Ue = v.value) == null ? void 0 : Ue.onBlur) == null || nt
						.call(Ue, Le), ce(w.value, Le)
				},
				q = Le => {
					var Ue, nt;
					const {
						value: ot
					} = Le.target;
					if (Le.type === "compositionend") {
						if (z.value = !1, j.value = "", M.value && !k.value && w.value.length >= M.value && D(ot) >
							M.value) {
							ge();
							return
						}
						s("input", ot, Le), me(ot), (nt = (Ue = v.value) == null ? void 0 : Ue.onInput) == null ||
							nt.call(Ue, Le)
					} else z.value = !0
				},
				le = Le => {
					var Ue, nt;
					const {
						value: ot
					} = Le.target;
					if (z.value) j.value = ot;
					else {
						if (M.value && !k.value && w.value.length >= M.value && D(ot) > M.value && Le.inputType ===
							"insertText") {
							ge();
							return
						}
						s("input", ot, Le), me(ot), (nt = (Ue = v.value) == null ? void 0 : Ue.onInput) == null ||
							nt.call(Ue, Le)
					}
				},
				de = Le => {
					me(""), ce("", Le), s("clear", Le)
				};
			watch(d, Le => {
				Le !== w.value && me(Le ?? "", !1)
			});
			const _e = Le => omit(a, INPUT_EVENTS),
				ke = Le => pick(a, INPUT_EVENTS),
				De = ke(),
				Se = computed(() => {
					const Le = {
						...De,
						...o.textareaAttrs
					};
					return R.value && (Le["aria-invalid"] = !0), Le
				}),
				be = computed(() => [`${f}-wrapper`, {
					[`${f}-focus`]: U.value,
					[`${f}-disabled`]: m.value,
					[`${f}-error`]: R.value,
					[`${f}-scroll`]: O.value
				}]);
			let Me;
			const Ve = ref(0),
				it = ref(0),
				pt = computed(() => !isObject$2(o.autoSize) || !o.autoSize.minRows ? 0 : o.autoSize.minRows * Ve
					.value + it.value),
				dt = computed(() => !isObject$2(o.autoSize) || !o.autoSize.maxRows ? 0 : o.autoSize.maxRows * Ve
					.value + it.value),
				He = () => {
					const Le = getSizeStyles(Me);
					Ve.value = Number.parseInt(Le["line-height"] || 0, 10), it.value = Number.parseInt(Le[
							"border-width"] || 0, 10) * 2 + Number.parseInt(Le["padding-top"] || 0, 10) + Number
						.parseInt(Le["padding-bottom"] || 0, 10), _.value = Le, nextTick(() => {
							var Ue;
							const nt = (Ue = C.value) == null ? void 0 : Ue.offsetHeight;
							let ot = nt ?? 0,
								at = "hidden";
							pt.value && ot < pt.value && (ot = pt.value), dt.value && ot > dt.value && (ot = dt
								.value, at = "auto"), b.value = {
								height: `${ot}px`,
								resize: "none",
								overflow: at
							}
						})
				};
			onMounted(() => {
				y.value && (Me = window.getComputedStyle(y.value), o.autoSize && He()), ye()
			});
			const Ae = () => {
					o.autoSize && C.value && He(), ye()
				},
				xe = Le => {
					y.value && Le.target !== y.value && (Le.preventDefault(), y.value.focus())
				},
				ye = () => {
					y.value && (y.value.scrollHeight > y.value.offsetHeight ? O.value || (O.value = !0) : O.value &&
						(O.value = !1))
				};
			return watch(w, () => {
				o.autoSize && C.value && He(), ye()
			}), {
				prefixCls: f,
				wrapperCls: be,
				textareaRef: y,
				textareaStyle: b,
				mirrorRef: C,
				mirrorStyle: _,
				computedValue: w,
				showClearBtn: V,
				valueLength: F,
				computedMaxLength: M,
				mergedDisabled: m,
				mergeTextareaAttrs: Se,
				getWrapperAttrs: _e,
				getTextareaAttrs: ke,
				handleInput: le,
				handleFocus: ae,
				handleBlur: fe,
				handleComposition: q,
				handleClear: de,
				handleResize: Ae,
				handleMousedown: xe
			}
		},
		methods: {
			focus() {
				var o;
				(o = this.$refs.textareaRef) == null || o.focus()
			},
			blur() {
				var o;
				(o = this.$refs.textareaRef) == null || o.blur()
			}
		}
	}),
	_hoisted_1$v = ["disabled", "value", "placeholder"];

function _sfc_render$16(o, s, a, l, c, d) {
	const f = resolveComponent("resize-observer"),
		m = resolveComponent("icon-close"),
		g = resolveComponent("icon-hover");
	return openBlock(), createElementBlock("div", mergeProps(o.getWrapperAttrs(o.$attrs), {
		class: o.wrapperCls,
		onMousedown: s[7] || (s[7] = (...v) => o.handleMousedown && o.handleMousedown(...v))
	}), [o.autoSize ? (openBlock(), createElementBlock("div", {
			key: 0,
			ref: "mirrorRef",
			class: normalizeClass(`${o.prefixCls}-mirror`),
			style: normalizeStyle(o.mirrorStyle)
		}, toDisplayString(`${o.computedValue}
`), 7)) : createCommentVNode("v-if", !0), createVNode(f, {
			onResize: o.handleResize
		}, {
			default: withCtx(() => [createBaseVNode("textarea", mergeProps({
				ref: "textareaRef"
			}, o.mergeTextareaAttrs, {
				disabled: o.mergedDisabled,
				class: o.prefixCls,
				style: o.textareaStyle,
				value: o.computedValue,
				placeholder: o.placeholder,
				onInput: s[0] || (s[0] = (...v) => o.handleInput && o.handleInput(...
					v)),
				onFocus: s[1] || (s[1] = (...v) => o.handleFocus && o.handleFocus(...
					v)),
				onBlur: s[2] || (s[2] = (...v) => o.handleBlur && o.handleBlur(...v)),
				onCompositionstart: s[3] || (s[3] = (...v) => o.handleComposition && o
					.handleComposition(...v)),
				onCompositionupdate: s[4] || (s[4] = (...v) => o.handleComposition && o
					.handleComposition(...v)),
				onCompositionend: s[5] || (s[5] = (...v) => o.handleComposition && o
					.handleComposition(...v))
			}), null, 16, _hoisted_1$v)]),
			_: 1
		}, 8, ["onResize"]), renderSlot(o.$slots, "suffix"), o.computedMaxLength && o.showWordLimit ? (
			openBlock(), createElementBlock("div", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-word-limit`)
			}, toDisplayString(o.valueLength) + "/" + toDisplayString(o.computedMaxLength), 3)) :
		createCommentVNode("v-if", !0), o.showClearBtn ? (openBlock(), createElementBlock("div", {
			key: 2,
			class: normalizeClass(`${o.prefixCls}-clear-btn`),
			onClick: s[6] || (s[6] = (...v) => o.handleClear && o.handleClear(...v))
		}, [createVNode(g, null, {
			default: withCtx(() => [createVNode(m)]),
			_: 1
		})], 2)) : createCommentVNode("v-if", !0)
	], 16)
}
var _Textarea = _export_sfc$1(_sfc_main$1o, [
	["render", _sfc_render$16]
]);
const Textarea = Object.assign(_Textarea, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Textarea.name, _Textarea)
		}
	}),
	getTextBeforeSelection = o => {
		const {
			value: s,
			selectionStart: a
		} = o;
		return s.slice(0, a)
	},
	getLastMeasureIndex = (o, s) => [].concat(s).reduce((l, c) => {
		const d = o.lastIndexOf(c);
		return d > l.location ? {
			location: d,
			prefix: c
		} : l
	}, {
		location: -1,
		prefix: ""
	}),
	isValidSearch = (o, s) => !s || !o.includes(s);

function _isSlot$9(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var _Mention = defineComponent({
	name: "Mention",
	inheritAttrs: !1,
	props: {
		modelValue: String,
		defaultValue: {
			type: String,
			default: ""
		},
		data: {
			type: Array,
			default: () => []
		},
		prefix: {
			type: [String, Array],
			default: "@"
		},
		split: {
			type: String,
			default: " "
		},
		type: {
			type: String,
			default: "input"
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		allowClear: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		"update:modelValue": o => !0,
		change: o => !0,
		search: (o, s) => !0,
		select: o => !0,
		clear: o => !0,
		focus: o => !0,
		blur: o => !0
	},
	setup(o, {
		emit: s,
		attrs: a,
		slots: l
	}) {
		const c = getPrefixCls("mention");
		let d;
		const {
			mergedDisabled: f,
			eventHandlers: m
		} = useFormItem({
			disabled: toRef(o, "disabled")
		}), {
			data: g,
			modelValue: v
		} = toRefs(o), y = ref(), b = ref({}), C = ref(o.defaultValue), _ = computed(() => {
			var De;
			return (De = o.modelValue) != null ? De : C.value
		});
		watch(v, De => {
			(isUndefined$1(De) || isNull$1(De)) && (C.value = "")
		});
		const S = computed(() => _.value ? [getKeyFromValue(_.value)] : []),
			w = ref({
				measuring: !1,
				location: -1,
				prefix: "",
				text: ""
			}),
			T = () => {
				w.value = {
					measuring: !1,
					location: -1,
					prefix: "",
					text: ""
				}
			},
			A = ref(),
			k = computed(() => w.value.text),
			M = ref(!0),
			D = (De, Se) => {
				var be, Me;
				const Ve = getTextBeforeSelection(Se.target),
					it = getLastMeasureIndex(Ve, o.prefix);
				if (it.location > -1) {
					const pt = Ve.slice(it.location + it.prefix.length);
					isValidSearch(pt, o.split) ? (R.value = !0, w.value = {
						measuring: !0,
						text: pt,
						...it
					}, s("search", pt, it.prefix)) : w.value.location > -1 && T()
				} else w.value.location > -1 && T();
				C.value = De, s("update:modelValue", De), s("change", De), (Me = (be = m.value) == null ?
					void 0 : be.onChange) == null || Me.call(be)
			},
			F = De => {
				var Se, be;
				C.value = "", s("update:modelValue", ""), s("change", ""), (be = (Se = m.value) == null ?
					void 0 : Se.onChange) == null || be.call(Se), s("clear", De)
			},
			R = ref(!1),
			O = computed(() => R.value && w.value.measuring && me.value.length > 0),
			U = () => {
				ce.value = getSizeStyles(d)
			},
			V = De => {
				R.value = De
			},
			z = (De, Se) => {
				var be, Me, Ve;
				const {
					value: it
				} = (be = ge.get(De)) != null ? be : {}, pt = w.value.location, dt = w.value.location + w.value
					.text.length;
				let He = C.value.slice(0, pt),
					Ae = C.value.slice(dt + 1);
				He += !He || He.endsWith(o.split) || He.endsWith(`
`) ? "" : o.split, Ae = (!Ae || Ae.startsWith(o.split) || Ae.startsWith(`
`) ? "" : o.split) + Ae;
				const xe = `${w.value.prefix}${it}`,
					ye = `${He}${xe}${Ae}`;
				C.value = ye, s("select", it), s("update:modelValue", ye), s("change", ye), T(), (Ve = (Me = m
					.value) == null ? void 0 : Me.onChange) == null || Ve.call(Me)
			},
			{
				validOptions: j,
				optionInfoMap: ge,
				validOptionInfos: me,
				handleKeyDown: he
			} = useSelect({
				options: g,
				inputValue: k,
				filterOption: M,
				popupVisible: O,
				valueKeys: S,
				dropdownRef: y,
				optionRefs: b,
				onSelect: z,
				onPopupVisibleChange: V,
				enterToOpen: !1
			}),
			ce = ref();
		onMounted(() => {
			var De;
			o.type === "textarea" && ((De = A.value) != null && De.textareaRef) && (d = window
				.getComputedStyle(A.value.textareaRef), ce.value = getSizeStyles(d))
		});
		const ae = De => {
				if (isFunction$2(l.option) && De.value) {
					const Se = ge.get(De.key),
						be = l.option;
					return () => be({
						data: Se
					})
				}
				return () => De.label
			},
			fe = De => createVNode(Option, {
				ref: Se => {
					Se != null && Se.$el && (b.value[De.key] = Se.$el)
				},
				key: De.key,
				value: De.value,
				disabled: De.disabled,
				internal: !0
			}, {
				default: ae(De)
			}),
			q = () => {
				let De;
				return createVNode(SelectDropdown, {
					ref: y
				}, _isSlot$9(De = j.value.map(Se => fe(Se))) ? De : {
					default: () => [De]
				})
			},
			le = ref();
		watch(O, De => {
			o.type === "textarea" && De && nextTick(() => {
				var Se, be;
				(Se = A.value) != null && Se.textareaRef && A.value.textareaRef.scrollTop > 0 &&
					((be = le.value) == null || be.scrollTo(0, A.value.textareaRef.scrollTop))
			})
		});
		const de = De => {
				s("focus", De)
			},
			_e = De => {
				s("blur", De)
			};
		return {
			inputRef: A,
			render: () => {
				var De;
				return o.type === "textarea" ? createVNode("div", {
					class: c
				}, [createVNode(ResizeObserver$2, {
					onResize: U
				}, {
					default: () => [createVNode(Textarea, mergeProps(a, {
						ref: A,
						allowClear: o.allowClear,
						modelValue: _.value,
						disabled: f.value,
						onInput: D,
						onClear: F,
						onFocus: de,
						onBlur: _e,
						onKeydown: he
					}), null)]
				}), w.value.measuring && me.value.length > 0 && createVNode("div", {
					ref: le,
					style: ce.value,
					class: `${c}-measure`
				}, [(De = _.value) == null ? void 0 : De.slice(0, w.value.location),
					createVNode(Trigger, {
						trigger: "focus",
						position: "bl",
						popupOffset: 4,
						preventFocus: !0,
						popupVisible: O.value,
						clickToClose: !1,
						onPopupVisibleChange: V
					}, {
						default: () => [createVNode("span", null, [createTextVNode(
							"@")])],
						content: q
					})
				])]) : createVNode(Trigger, {
					trigger: "focus",
					position: "bl",
					animationName: "slide-dynamic-origin",
					popupOffset: 4,
					preventFocus: !0,
					popupVisible: O.value,
					clickToClose: !1,
					autoFitPopupWidth: !0,
					autoFitTransformOrigin: !0,
					disabled: f.value,
					onPopupVisibleChange: V
				}, {
					default: () => [createVNode(Input, mergeProps(a, {
						ref: A,
						allowClear: o.allowClear,
						modelValue: _.value,
						disabled: f.value,
						onInput: D,
						onClear: F,
						onFocus: de,
						onBlur: _e,
						onKeydown: he
					}), l)],
					content: q
				})
			}
		}
	},
	methods: {
		focus() {
			var o;
			(o = this.inputRef) == null || o.focus()
		},
		blur() {
			var o;
			(o = this.inputRef) == null || o.blur()
		}
	},
	render() {
		return this.render()
	}
});
const Mention = Object.assign(_Mention, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Mention.name, _Mention)
		}
	}),
	MenuInjectionKey = Symbol("MenuInjectionKey"),
	LevelInjectionKey = Symbol("LevelInjectionKey"),
	DataCollectorInjectionKey = Symbol("DataCollectorInjectionKey"),
	_sfc_main$1n = defineComponent({
		name: "IconMenuFold",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-menu-fold`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$u = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$15(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M42 11H6M42 24H22M42 37H6M13.66 26.912l-4.82-3.118 4.82-3.118v6.236Z"
	}, null, -1)]), 14, _hoisted_1$u)
}
var _IconMenuFold = _export_sfc$1(_sfc_main$1n, [
	["render", _sfc_render$15]
]);
const IconMenuFold = Object.assign(_IconMenuFold, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconMenuFold.name, _IconMenuFold)
		}
	}),
	_sfc_main$1m = defineComponent({
		name: "IconMenuUnfold",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-menu-unfold`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$t = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$14(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M6 11h36M22 24h20M6 37h36M8 20.882 12.819 24 8 27.118v-6.236Z"
	}, null, -1)]), 14, _hoisted_1$t)
}
var _IconMenuUnfold = _export_sfc$1(_sfc_main$1m, [
	["render", _sfc_render$14]
]);
const IconMenuUnfold = Object.assign(_IconMenuUnfold, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconMenuUnfold.name, _IconMenuUnfold)
	}
});

function provideLevel(o) {
	const s = computed(() => isRef(o) ? o.value : o);
	provide(LevelInjectionKey, reactive({
		level: s
	}))
}

function useLevel(o) {
	const {
		provideNextLevel: s
	} = o || {}, a = inject(LevelInjectionKey), l = computed(() => (a == null ? void 0 : a.level) || 1);
	if (s) {
		const c = computed(() => l.value + 1);
		provideLevel(c)
	}
	return {
		level: l
	}
}

function getKeys$1(o, s) {
	const a = [],
		l = c => {
			c.forEach(d => {
				s(d) && a.push(d.key), d.children && l(d.children)
			})
		};
	return l(o), a
}

function useMenuDataCollectorContext(o = !1) {
	return o ? void 0 : inject(DataCollectorInjectionKey)
}

function useMenuDataCollector(o) {
	const {
		key: s,
		type: a
	} = o, l = ref([]), c = useMenuDataCollectorContext(a === "menu");
	return provide(DataCollectorInjectionKey, {
		collectSubMenu(f, m, g = !1) {
			const v = {
				key: f,
				children: m
			};
			if (g) {
				const y = l.value.find(b => b.key === f);
				y ? y.children = m : l.value.push(v)
			} else l.value = [...l.value, v];
			g && (a === "popupMenu" ? c == null || c.reportMenuData(l.value) : a === "subMenu" && !
				isUndefined$1(f) && (c == null || c.collectSubMenu(f, l.value, !0)))
		},
		removeSubMenu(f) {
			l.value = l.value.filter(m => m.key !== f)
		},
		collectMenuItem(f) {
			l.value.push({
				key: f
			})
		},
		removeMenuItem(f) {
			l.value = l.value.filter(m => m.key !== f)
		},
		reportMenuData(f) {
			l.value = f, a === "subMenu" && !isUndefined$1(s) && (c == null || c.collectSubMenu(s, l.value, !0))
		}
	}), a === "subMenu" && !isUndefined$1(s) ? (onMounted(() => {
		c == null || c.collectSubMenu(s, l.value)
	}), onUnmounted(() => {
		c == null || c.removeSubMenu(s)
	})) : a === "popupMenu" && onMounted(() => {
		c == null || c.reportMenuData(l.value)
	}), {
		menuData: l,
		subMenuKeys: computed(() => getKeys$1(l.value, f => !!f.children)),
		menuItemKeys: computed(() => getKeys$1(l.value, f => !f.children))
	}
}

function getPath(o, s) {
	const a = [],
		l = c => {
			for (let d = 0; d < c.length; d++) {
				const f = c[d];
				if (f.key === s) return !0;
				if (f.children) {
					if (a.push(f.key), l(f.children)) return !0;
					a.pop()
				}
			}
			return !1
		};
	return l(o), a
}

function isSameKeys(o, s) {
	return o.length !== s.length ? !1 : o.toString() === s.toString()
}

function useMenuOpenState(o) {
	const {
		modelValue: s,
		defaultValue: a,
		autoOpen: l,
		autoOpenSelected: c,
		subMenuKeys: d,
		selectedKeys: f,
		menuData: m,
		accordion: g
	} = toRefs(o), v = ref(isUndefined$1(s.value) ? isUndefined$1(a.value) ? [] : a.value : s.value), y = S => {
		v.value = S
	};
	watch(s, () => {
		isUndefined$1(s.value) && y([])
	});
	let b = [];
	onMounted(() => {
		b = [...d.value];
		let S = [];
		if (l.value && (S = g.value ? d.value.slice(0, 1) : [...d.value]), c.value) {
			const w = f.value.map(T => getPath(m.value, T));
			w.length && (!l.value || g.value) && (S = g.value ? w[0] : [...new Set([].concat(...w))])
		}
		S.length && y(S)
	});
	let C = !1;
	watch(d, (S, w = []) => {
		if (C || !isSameKeys(S, b)) {
			const T = _.value.filter(A => S.includes(A));
			if (l.value) {
				const A = S.filter(k => !w.includes(k));
				T.push(...A)
			}
			y(g.value ? T.slice(0, 1) : T)
		}
		C = !0
	});
	const _ = computed(() => s.value || v.value);
	return {
		openKeys: _,
		localOpenKeys: v,
		setOpenKeys: y,
		open(S, w) {
			let T = [];
			return _.value.indexOf(S) > -1 ? g.value && w === 1 ? T = [] : T = _.value.filter(A => A !== S) : g.value &&
				w === 1 ? T = [S] : T = _.value.concat([S]), y(T), T
		}
	}
}
const _sfc_main$1l = defineComponent({
	name: "BaseMenu",
	components: {
		IconMenuFold,
		IconMenuUnfold
	},
	inheritAttrs: !1,
	props: {
		style: {
			type: Object
		},
		theme: {
			type: String,
			default: "light"
		},
		mode: {
			type: String,
			default: "vertical"
		},
		levelIndent: {
			type: Number
		},
		autoOpen: {
			type: Boolean
		},
		collapsed: {
			type: Boolean,
			default: void 0
		},
		defaultCollapsed: {
			type: Boolean
		},
		collapsedWidth: {
			type: Number
		},
		accordion: {
			type: Boolean
		},
		autoScrollIntoView: {
			type: Boolean
		},
		showCollapseButton: {
			type: Boolean
		},
		selectedKeys: {
			type: Array
		},
		defaultSelectedKeys: {
			type: Array,
			default: () => []
		},
		openKeys: {
			type: Array
		},
		defaultOpenKeys: {
			type: Array,
			default: () => []
		},
		scrollConfig: {
			type: Object
		},
		triggerProps: {
			type: Object
		},
		tooltipProps: {
			type: Object
		},
		autoOpenSelected: {
			type: Boolean
		},
		breakpoint: {
			type: String
		},
		popupMaxHeight: {
			type: [Boolean, Number],
			default: !0
		},
		prefixCls: {
			type: String
		},
		inTrigger: {
			type: Boolean
		},
		siderCollapsed: {
			type: Boolean
		},
		isRoot: {
			type: Boolean
		}
	},
	emits: ["update:collapsed", "update:selectedKeys", "update:openKeys", "collapse", "menu-item-click",
		"sub-menu-click"
	],
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			style: l,
			mode: c,
			theme: d,
			levelIndent: f,
			accordion: m,
			showCollapseButton: g,
			scrollConfig: v,
			autoScrollIntoView: y,
			collapsedWidth: b,
			autoOpen: C,
			collapsed: _,
			defaultCollapsed: S,
			selectedKeys: w,
			defaultSelectedKeys: T,
			openKeys: A,
			defaultOpenKeys: k,
			triggerProps: M,
			tooltipProps: D,
			autoOpenSelected: F,
			breakpoint: R,
			popupMaxHeight: O,
			prefixCls: U,
			inTrigger: V,
			siderCollapsed: z,
			isRoot: j
		} = toRefs(o), {
			subMenuKeys: ge,
			menuData: me
		} = useMenuDataCollector({
			type: j.value ? "menu" : "popupMenu"
		}), [he, ce] = useMergeState(T.value, reactive({
			value: w
		})), {
			openKeys: ae,
			setOpenKeys: fe,
			open: q
		} = useMenuOpenState(reactive({
			modelValue: A,
			defaultValue: k,
			autoOpen: C,
			autoOpenSelected: F,
			selectedKeys: he,
			subMenuKeys: ge,
			menuData: me,
			accordion: m
		})), [le, de] = useMergeState(S.value, reactive({
			value: _
		})), _e = computed(() => z.value || le.value || c.value === "popButton"), ke = computed(() => [
			"horizontal", "popButton"
		].indexOf(c.value) < 0 && !V.value && g.value), De = (He, Ae) => {
			He !== le.value && (de(He), s("update:collapsed", He), s("collapse", He, Ae))
		}, Se = () => {
			De(!le.value, "clickTrigger")
		};
		useResponsive(R, He => {
			De(!He, "responsive")
		});
		const be = computed(() => (U == null ? void 0 : U.value) || getPrefixCls("menu")),
			Me = computed(() => [be.value, `${be.value}-${d==null?void 0:d.value}`, {
				[`${be.value}-horizontal`]: c.value === "horizontal",
				[`${be.value}-vertical`]: c.value !== "horizontal",
				[`${be.value}-collapsed`]: _e.value,
				[`${be.value}-pop`]: c.value === "pop" || _e.value,
				[`${be.value}-pop-button`]: c.value === "popButton"
			}]),
			Ve = computed(() => {
				const He = isNumber$2(b.value) ? `${b.value}px` : void 0,
					Ae = isObject$2(l.value) ? l.value : void 0,
					xe = _e.value ? He : Ae == null ? void 0 : Ae.width;
				return [Ae ? omit(Ae, ["width"]) : l.value, {
					width: xe
				}]
			}),
			it = usePickSlots(a, "expand-icon-down"),
			pt = usePickSlots(a, "expand-icon-right"),
			dt = reactive({
				theme: d,
				mode: c,
				levelIndent: f,
				autoScrollIntoView: y,
				selectedKeys: he,
				openKeys: ae,
				prefixCls: be,
				scrollConfig: v,
				inTrigger: V,
				collapsed: _e,
				triggerProps: M,
				tooltipProps: D,
				popupMaxHeight: O,
				expandIconDown: it,
				expandIconRight: pt,
				onMenuItemClick: He => {
					ce([He]), s("update:selectedKeys", [He]), s("menu-item-click", He)
				},
				onSubMenuClick: (He, Ae) => {
					const xe = q(He, Ae);
					fe(xe), s("update:openKeys", xe), s("sub-menu-click", He, xe)
				}
			});
		return provide(MenuInjectionKey, dt), provideLevel(1), {
			computedPrefixCls: be,
			classNames: Me,
			computedStyle: Ve,
			computedCollapsed: _e,
			computedHasCollapseButton: ke,
			onCollapseBtnClick: Se
		}
	}
});

function _sfc_render$13(o, s, a, l, c, d) {
	const f = resolveComponent("IconMenuUnfold"),
		m = resolveComponent("IconMenuFold");
	return openBlock(), createElementBlock("div", mergeProps({
		class: o.classNames
	}, o.$attrs, {
		style: o.computedStyle
	}), [createBaseVNode("div", {
		class: normalizeClass(`${o.computedPrefixCls}-inner`)
	}, [renderSlot(o.$slots, "default")], 2), o.computedHasCollapseButton ? (openBlock(),
		createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.computedPrefixCls}-collapse-button`),
			onClick: s[0] || (s[0] = (...g) => o.onCollapseBtnClick && o.onCollapseBtnClick(...g))
		}, [renderSlot(o.$slots, "collapse-icon", {
			collapsed: o.computedCollapsed
		}, () => [o.computedCollapsed ? (openBlock(), createBlock(f, {
			key: 0
		})) : (openBlock(), createBlock(m, {
			key: 1
		}))])], 2)) : createCommentVNode("v-if", !0)], 16)
}
var BaseMenu = _export_sfc$1(_sfc_main$1l, [
	["render", _sfc_render$13]
]);

function getStyle$1(o, s) {
	if (!o || !s) return null;
	let a = s;
	a === "float" && (a = "cssFloat");
	try {
		if (document.defaultView) {
			const l = document.defaultView.getComputedStyle(o, "");
			return o.style[a] || l ? l[a] : ""
		}
	} catch {
		return o.style[a]
	}
	return null
}

function useMenuContext() {
	return inject(MenuInjectionKey) || {}
}
const generateId = (() => {
	let o = 0;
	return (s = "") => (o += 1, `${s}${o}`)
})();

function useMenu() {
	const o = getCurrentInstance();
	return {
		key: computed(() => (o == null ? void 0 : o.vnode.key) || generateId("__arco_menu"))
	}
}
const _sfc_main$1k = defineComponent({
	name: "MenuIndent",
	props: {
		level: {
			type: Number,
			default: 1
		}
	},
	setup() {
		const o = getPrefixCls("menu"),
			s = useMenuContext();
		return {
			prefixCls: o,
			levelIndent: toRef(s, "levelIndent")
		}
	}
});

function _sfc_render$12(o, s, a, l, c, d) {
	return o.level > 1 ? (openBlock(), createElementBlock("span", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-indent-list`)
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.level - 1, f => (openBlock(),
		createElementBlock("span", {
			key: f,
			class: normalizeClass(`${o.prefixCls}-indent`),
			style: normalizeStyle(`width: ${o.levelIndent}px`)
		}, null, 6))), 128))], 2)) : createCommentVNode("v-if", !0)
}
var MenuIndent = _export_sfc$1(_sfc_main$1k, [
	["render", _sfc_render$12]
]);
const _sfc_main$1j = defineComponent({
	name: "ExpandTransition",
	setup() {
		return {
			onBeforeEnter(o) {
				o.style.height = "0"
			},
			onEnter(o) {
				o.style.height = `${o.scrollHeight}px`
			},
			onAfterEnter(o) {
				o.style.height = ""
			},
			onBeforeLeave(o) {
				o.style.height = `${o.scrollHeight}px`
			},
			onLeave(o) {
				o.style.height = "0"
			},
			onAfterLeave(o) {
				o.style.height = ""
			}
		}
	}
});

function _sfc_render$11(o, s, a, l, c, d) {
	return openBlock(), createBlock(Transition, {
		onBeforeEnter: o.onBeforeEnter,
		onEnter: o.onEnter,
		onAfterEnter: o.onAfterEnter,
		onBeforeLeave: o.onBeforeLeave,
		onLeave: o.onLeave,
		onAfterLeave: o.onAfterLeave
	}, {
		default: withCtx(() => [renderSlot(o.$slots, "default")]),
		_: 3
	}, 8, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])
}
var ExpandTransition$1 = _export_sfc$1(_sfc_main$1j, [
	["render", _sfc_render$11]
]);
const _sfc_main$1i = defineComponent({
	name: "SubMenuInline",
	components: {
		MenuIndent,
		ExpandTransition: ExpandTransition$1
	},
	props: {
		title: {
			type: String
		},
		isChildrenSelected: {
			type: Boolean
		}
	},
	setup(o) {
		const {
			key: s
		} = useMenu(), {
				level: a
			} = useLevel({
				provideNextLevel: !0
			}), l = useMenuContext(), c = computed(() => l.prefixCls), d = computed(() => `${c.value}-inline`),
			f = computed(() => [d.value]), m = computed(() => o.isChildrenSelected), g = computed(() => (l
				.openKeys || []).indexOf(s.value) > -1);
		return {
			prefixCls: d,
			menuPrefixCls: c,
			classNames: f,
			level: a,
			isSelected: m,
			isOpen: g,
			onHeaderClick: () => {
				l.onSubMenuClick && l.onSubMenuClick(s.value, a.value)
			}
		}
	}
});

function _sfc_render$10(o, s, a, l, c, d) {
	const f = resolveComponent("MenuIndent"),
		m = resolveComponent("ExpandTransition");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [createBaseVNode("div", {
		class: normalizeClass([`${o.prefixCls}-header`, {
			[`${o.menuPrefixCls}-selected`]: o.isSelected,
			[`${o.menuPrefixCls}-has-icon`]: o.$slots.icon
		}]),
		onClick: s[0] || (s[0] = (...g) => o.onHeaderClick && o.onHeaderClick(...g))
	}, [createVNode(f, {
		level: o.level
	}, null, 8, ["level"]), o.$slots.icon ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [createBaseVNode("span", {
		class: normalizeClass(`${o.menuPrefixCls}-icon`)
	}, [renderSlot(o.$slots, "icon")], 2), createBaseVNode("span", {
		class: normalizeClass(`${o.menuPrefixCls}-title`)
	}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(o
		.title), 1)])], 2)], 64)) : renderSlot(o.$slots, "title", {
		key: 1
	}, () => [createTextVNode(toDisplayString(o.title), 1)]), createBaseVNode("span", {
		class: normalizeClass([`${o.menuPrefixCls}-icon-suffix`, {
			"is-open": o.isOpen
		}])
	}, [renderSlot(o.$slots, "expand-icon-down")], 2)], 2), createVNode(m, null, {
		default: withCtx(() => [withDirectives(createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [renderSlot(o.$slots, "default")], 2), [
			[vShow, o.isOpen]
		])]),
		_: 3
	})], 2)
}
var SubMenuInline = _export_sfc$1(_sfc_main$1i, [
	["render", _sfc_render$10]
]);
const _sfc_main$1h = defineComponent({
	name: "SubMenuPop",
	components: {
		Menu: BaseMenu,
		Trigger,
		MenuIndent,
		RenderFunction
	},
	inheritAttrs: !1,
	props: {
		title: {
			type: String
		},
		selectable: {
			type: Boolean
		},
		isChildrenSelected: {
			type: Boolean
		},
		popupMaxHeight: {
			type: [Boolean, Number],
			default: void 0
		}
	},
	setup(o) {
		const {
			key: s
		} = useMenu(), {
			level: a
		} = useLevel(), {
			selectable: l,
			isChildrenSelected: c,
			popupMaxHeight: d
		} = toRefs(o), f = useMenuContext(), {
			onSubMenuClick: m,
			onMenuItemClick: g
		} = f, v = computed(() => f.prefixCls), y = computed(() => f.mode), b = computed(() => f
			.selectedKeys || []), C = computed(() => `${v.value}-pop`), _ = computed(() => l.value && b
			.value.includes(s.value) || c.value), S = computed(() => [`${C.value}`, `${C.value}-header`, {
			[`${v.value}-selected`]: _.value
		}]), w = computed(() => y.value === "horizontal" && !f.inTrigger), T = ref(!1), A = F => {
			T.value = F
		}, k = getPrefixCls("trigger"), M = computed(() => {
			var F;
			return [`${C.value}-trigger`, {
				[`${C.value}-trigger-dark`]: f.theme === "dark"
			}, (F = f.triggerProps) == null ? void 0 : F.class]
		}), D = computed(() => omit(f.triggerProps || {}, ["class"]));
		return {
			menuPrefixCls: v,
			mode: y,
			level: a,
			classNames: S,
			isSelected: _,
			selectedKeys: b,
			needPopOnBottom: w,
			popVisible: T,
			triggerPrefixCls: k,
			triggerClassNames: M,
			triggerProps: D,
			menuContext: f,
			popupMenuStyles: computed(() => {
				var F;
				const R = (F = d.value) != null ? F : f.popupMaxHeight;
				return isNumber$2(R) ? {
					maxHeight: `${R}px`
				} : R ? {} : {
					maxHeight: "unset"
				}
			}),
			onClick: () => {
				m && m(s.value, a.value), l.value && g && g(s.value)
			},
			onMenuItemClick: F => {
				g && g(F), A(!1)
			},
			onVisibleChange: F => {
				A(F)
			}
		}
	}
});

function _sfc_render$$(o, s, a, l, c, d) {
	const f = resolveComponent("MenuIndent"),
		m = resolveComponent("RenderFunction"),
		g = resolveComponent("Menu"),
		v = resolveComponent("Trigger");
	return openBlock(), createBlock(v, mergeProps({
		trigger: "hover",
		class: o.triggerClassNames,
		position: o.needPopOnBottom ? "bl" : "rt",
		"show-arrow": "",
		"animation-class": "fade-in",
		"mouse-enter-delay": 50,
		"mouse-leave-delay": 50,
		"popup-offset": 4,
		"auto-fit-popup-min-width": !0,
		duration: 100
	}, o.triggerProps, {
		"unmount-on-close": !1,
		"popup-visible": o.popVisible,
		onPopupVisibleChange: o.onVisibleChange
	}), {
		content: withCtx(() => [createVNode(g, {
			"in-trigger": "",
			"prefix-cls": `${o.triggerPrefixCls}-menu`,
			"selected-keys": o.selectedKeys,
			theme: o.menuContext.theme,
			"trigger-props": o.menuContext.triggerProps,
			style: normalizeStyle(o.popupMenuStyles),
			onMenuItemClick: o.onMenuItemClick
		}, createSlots({
			default: withCtx(() => [renderSlot(o.$slots, "default")]),
			_: 2
		}, [o.menuContext.expandIconDown ? {
			name: "expand-icon-down",
			fn: withCtx(() => [createVNode(m, {
				"render-func": o.menuContext.expandIconDown
			}, null, 8, ["render-func"])]),
			key: "0"
		} : void 0, o.menuContext.expandIconRight ? {
			name: "expand-icon-right",
			fn: withCtx(() => [createVNode(m, {
				"render-func": o.menuContext.expandIconRight
			}, null, 8, ["render-func"])]),
			key: "1"
		} : void 0]), 1032, ["prefix-cls", "selected-keys", "theme", "trigger-props", "style",
			"onMenuItemClick"
		])]),
		default: withCtx(() => [createBaseVNode("div", mergeProps({
			class: [o.classNames, {
				[`${o.menuPrefixCls}-has-icon`]: o.$slots.icon
			}],
			"aria-haspopup": "true"
		}, o.$attrs, {
			onClick: s[0] || (s[0] = (...y) => o.onClick && o.onClick(...y))
		}), [createCommentVNode(" header "), createVNode(f, {
			level: o.level
		}, null, 8, ["level"]), o.$slots.icon ? (openBlock(), createElementBlock(Fragment, {
			key: 0
		}, [createBaseVNode("span", {
			class: normalizeClass(`${o.menuPrefixCls}-icon`)
		}, [renderSlot(o.$slots, "icon")], 2), createBaseVNode("span", {
			class: normalizeClass(`${o.menuPrefixCls}-title`)
		}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(
			toDisplayString(o.title), 1)])], 2)], 64)) : renderSlot(o.$slots, "title", {
			key: 1
		}, () => [createTextVNode(toDisplayString(o.title), 1)]), createCommentVNode(
			" suffix "), createBaseVNode("span", {
			class: normalizeClass(`${o.menuPrefixCls}-icon-suffix`)
		}, [o.needPopOnBottom ? renderSlot(o.$slots, "expand-icon-down", {
			key: 0
		}) : renderSlot(o.$slots, "expand-icon-right", {
			key: 1
		})], 2), o.isSelected && o.mode === "horizontal" ? (openBlock(), createElementBlock(
			"div", {
				key: 2,
				class: normalizeClass(`${o.menuPrefixCls}-selected-label`)
			}, null, 2)) : createCommentVNode("v-if", !0)], 16)]),
		_: 3
	}, 16, ["class", "position", "popup-visible", "onPopupVisibleChange"])
}
var SubMenuPop = _export_sfc$1(_sfc_main$1h, [
		["render", _sfc_render$$]
	]),
	SubMenu = defineComponent({
		name: "SubMenu",
		props: {
			title: {
				type: String
			},
			selectable: {
				type: Boolean
			},
			popup: {
				type: [Boolean, Function],
				default: !1
			},
			popupMaxHeight: {
				type: [Boolean, Number],
				default: void 0
			}
		},
		setup(o, {
			attrs: s
		}) {
			const {
				key: a
			} = useMenu(), {
				level: l
			} = useLevel(), {
				popup: c
			} = toRefs(o), d = useMenuContext(), f = computed(() => {
				const {
					mode: y,
					collapsed: b,
					inTrigger: C
				} = d;
				return !!(typeof c.value == "function" ? c.value(l.value) : c.value) || b || C || y !==
					"vertical"
			}), {
				subMenuKeys: m,
				menuItemKeys: g
			} = useMenuDataCollector({
				key: a.value,
				type: "subMenu"
			}), v = computed(() => {
				const y = d.selectedKeys || [],
					b = C => {
						for (let _ = 0; _ < y.length; _++) {
							const S = y[_];
							if (C.includes(S)) return !0
						}
						return !1
					};
				return b(m.value) || b(g.value)
			});
			return {
				subMenuKeys: m,
				menuItemKeys: g,
				isChildrenSelected: v,
				props: o,
				attrs: s,
				computedKey: a,
				computedPopup: f,
				expandIconDown: toRef(d, "expandIconDown"),
				expandIconRight: toRef(d, "expandIconRight")
			}
		},
		render() {
			const {
				props: o,
				attrs: s,
				computedKey: a,
				computedPopup: l,
				expandIconDown: c,
				expandIconRight: d,
				isChildrenSelected: f
			} = this, m = {
				...this.$slots,
				"expand-icon-down": this.$slots["expand-icon-down"] || c || (() => [createVNode(IconDown, null,
					null)]),
				"expand-icon-right": this.$slots["expand-icon-right"] || d || (() => [createVNode(IconRight,
					null, null)])
			};
			return l ? createVNode(SubMenuPop, mergeProps({
				key: a,
				title: o.title,
				selectable: o.selectable,
				isChildrenSelected: f,
				popupMaxHeight: o.popupMaxHeight
			}, s), m) : createVNode(SubMenuInline, mergeProps({
				key: a,
				title: o.title,
				isChildrenSelected: f
			}, s), m)
		}
	});
const OVERFLOW_THRESHOLD = 10;

function getNodeWidth(o) {
	return o && +o.getBoundingClientRect().width.toFixed(2)
}

function translatePxToNumber(o) {
	const s = Number(o.replace("px", ""));
	return Number.isNaN(s) ? 0 : s
}
var OverflowWrap = defineComponent({
		name: "MenuOverflowWrap",
		setup(o, {
			slots: s
		}) {
			const l = `${useMenuContext().prefixCls}-overflow`,
				c = `${l}-sub-menu`,
				d = `${l}-hidden-menu-item`,
				f = `${l}-sub-menu-mirror`,
				m = ref(),
				g = ref(null),
				v = ref();

			function y() {
				const b = m.value,
					C = getNodeWidth(b),
					_ = [].slice.call(b.children);
				let S = 0,
					w = 0,
					T = 0;
				for (let A = 0; A < _.length; A++) {
					const k = _[A],
						M = k.className.split(" "),
						D = M.indexOf(c) > -1,
						F = M.indexOf(f) > -1;
					if (D) continue;
					const R = getNodeWidth(k) + translatePxToNumber(getStyle$1(k, "marginLeft")) +
						translatePxToNumber(getStyle$1(k, "marginRight"));
					if (F) {
						T = R;
						continue
					}
					if (w += R, w + T + OVERFLOW_THRESHOLD > C) {
						g.value = S - 1;
						return
					}
					S++
				}
				g.value = null
			}
			return onMounted(() => {
				y(), v.value = new index$1(b => {
					b.forEach(y)
				}), m.value && v.value.observe(m.value)
			}), onUnmounted(() => {
				v.value && v.value.disconnect()
			}), () => {
				const b = (_, S) => {
						const {
							isMirror: w = !1,
							props: T = {}
						} = S || {};
						return createVNode(SubMenu, mergeProps({
							key: `__arco-menu-overflow-sub-menu${w?"-mirror":""}`,
							class: w ? f : c
						}, T), {
							title: () => createVNode("span", null, [createTextVNode("...")]),
							default: () => _
						})
					},
					C = () => {
						var _;
						const S = ((_ = s.default) == null ? void 0 : _.call(s)) || [],
							w = unFragment(S);
						let T = null;
						const A = b(null, {
								isMirror: !0
							}),
							k = w.map((M, D) => {
								const F = cloneVNode(M, g.value !== null && D > g.value ? {
									class: d
								} : {
									class: ""
								});
								if (g.value !== null && D === g.value + 1) {
									const R = w.slice(D).map(O => cloneVNode(O));
									T = b(R)
								}
								return F
							});
						return [A, ...k, T]
					};
				return createVNode("div", {
					class: `${l}-wrap`,
					ref: m
				}, [C()])
			}
		}
	}),
	_Menu = defineComponent({
		name: "Menu",
		components: {
			BaseMenu
		},
		inheritAttrs: !1,
		props: {
			theme: {
				type: String
			},
			mode: {
				type: String,
				default: "vertical"
			}
		},
		setup(o, {
			attrs: s,
			slots: a
		}) {
			const {
				theme: l,
				mode: c
			} = toRefs(o), d = inject(SiderInjectionKey, void 0), f = computed(() => (d == null ? void 0 : d
				.collapsed) || !1), m = computed(() => (l == null ? void 0 : l.value) || (d == null ? void 0 : d
				.theme) || "light");
			return provide(MenuInjectionKey, void 0), provide(LevelInjectionKey, void 0), () => createVNode(
				BaseMenu, mergeProps(o, s, {
					theme: m.value,
					inTrigger: !1,
					siderCollapsed: f.value,
					isRoot: !0
				}), {
					...a,
					default: c.value === "horizontal" && a.default ? () => createVNode(OverflowWrap, null, {
						default: () => {
							var g;
							return [(g = a.default) == null ? void 0 : g.call(a)]
						}
					}) : a.default
				})
		}
	}),
	MenuItem = defineComponent({
		name: "MenuItem",
		inheritAttrs: !1,
		props: {
			disabled: {
				type: Boolean,
				default: !1
			}
		},
		emits: ["click"],
		setup(o, {
			emit: s
		}) {
			const {
				key: a
			} = useMenu(), {
				level: l
			} = useLevel(), c = useMenuContext(), d = ref(), f = computed(() => (c.selectedKeys || []).indexOf(a
				.value) > -1), m = useMenuDataCollectorContext();
			onMounted(() => {
				m == null || m.collectMenuItem(a.value)
			}), onUnmounted(() => {
				m == null || m.removeMenuItem(a.value)
			});

			function g() {
				c.autoScrollIntoView && d.value && f.value && scrollIntoView(d.value, {
					behavior: "smooth",
					block: "nearest",
					scrollMode: "if-needed",
					boundary: document.documentElement,
					...c.scrollConfig || {}
				})
			}
			let v;
			return onMounted(() => {
				v = setTimeout(() => {
					g()
				}, 500)
			}), onUnmounted(() => {
				clearTimeout(v)
			}), watch([f], () => {
				g()
			}), {
				menuContext: c,
				level: l,
				isSelected: f,
				refItemElement: d,
				onClick(y) {
					o.disabled || (c.onMenuItemClick && c.onMenuItemClick(a.value), s("click", y))
				}
			}
		},
		render() {
			var o, s;
			const {
				level: a,
				menuContext: l,
				disabled: c,
				isSelected: d,
				onClick: f
			} = this, {
				prefixCls: m,
				collapsed: g,
				inTrigger: v,
				mode: y,
				tooltipProps: b
			} = l, C = g && !v && a === 1, _ = y === "vertical" && a > 1, S = ((s = (o = this.$slots).default) ==
					null ? void 0 : s.call(o)) || [], w = _ && !v && !g, T = this.$slots.icon && this.$slots.icon(),
				A = [w && createVNode(MenuIndent, {
					level: a
				}, null), T && createVNode("span", {
					class: `${m}-icon`
				}, [T]), w || T ? createVNode("span", {
					class: [`${m}-item-inner`, {
						[`${m}-title`]: T
					}]
				}, [S]) : S].filter(Boolean), k = createVNode("div", mergeProps({
					ref: "refItemElement",
					class: [`${m}-item`, {
						[`${m}-disabled`]: c,
						[`${m}-selected`]: d,
						[`${m}-has-icon`]: T
					}]
				}, this.$attrs, {
					onClick: f
				}), [A, d && y === "horizontal" && createVNode("div", {
					class: `${m}-selected-label`
				}, null)]);
			if (C) {
				const M = [`${m}-item-tooltip`, b == null ? void 0 : b.class];
				return createVNode(Tooltip, mergeProps({
					trigger: "hover",
					position: "right",
					class: M
				}, omit(b || {}, ["class"])), {
					default: () => k,
					content: () => S
				})
			}
			return k
		}
	});
const _sfc_main$1g = defineComponent({
	name: "MenuItemGroup",
	components: {
		MenuIndent
	},
	props: {
		title: {
			type: String
		}
	},
	setup() {
		const {
			level: o
		} = useLevel(), s = computed(() => o.value === 1 ? o.value + 1 : o.value);
		provideLevel(s);
		const a = useMenuContext(),
			l = computed(() => a.prefixCls),
			c = computed(() => [`${l.value}-group`]);
		return {
			prefixCls: l,
			classNames: c,
			level: o
		}
	}
});

function _sfc_render$_(o, s, a, l, c, d) {
	const f = resolveComponent("MenuIndent");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-group-title`)
	}, [createVNode(f, {
		level: o.level
	}, null, 8, ["level"]), renderSlot(o.$slots, "title", {}, () => [createTextVNode(
		toDisplayString(o.title), 1)])], 2), renderSlot(o.$slots, "default")], 2)
}
var MenuItemGroup = _export_sfc$1(_sfc_main$1g, [
	["render", _sfc_render$_]
]);
const Menu = Object.assign(_Menu, {
		Item: MenuItem,
		ItemGroup: MenuItemGroup,
		SubMenu,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Menu.name, _Menu), o.component(a + MenuItem.name, MenuItem), o.component(a +
				MenuItemGroup.name, MenuItemGroup), o.component(a + SubMenu.name, SubMenu)
		}
	}),
	_sfc_main$1f = defineComponent({
		name: "Message",
		components: {
			AIconHover: IconHover,
			IconInfoCircleFill,
			IconCheckCircleFill,
			IconExclamationCircleFill,
			IconCloseCircleFill,
			IconClose,
			IconLoading
		},
		props: {
			type: {
				type: String,
				default: "info"
			},
			closable: {
				type: Boolean,
				default: !1
			},
			showIcon: {
				type: Boolean,
				default: !0
			},
			duration: {
				type: Number,
				default: 3e3
			},
			resetOnUpdate: {
				type: Boolean,
				default: !1
			},
			resetOnHover: {
				type: Boolean,
				default: !1
			}
		},
		emits: ["close"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("message");
			let l = 0;
			const c = () => {
					s("close")
				},
				d = () => {
					o.duration > 0 && (l = window.setTimeout(c, o.duration))
				},
				f = () => {
					l && (window.clearTimeout(l), l = 0)
				};
			return onMounted(() => {
				d()
			}), onUpdated(() => {
				o.resetOnUpdate && (f(), d())
			}), onUnmounted(() => {
				f()
			}), {
				handleMouseEnter: () => {
					o.resetOnHover && f()
				},
				handleMouseLeave: () => {
					o.resetOnHover && d()
				},
				prefixCls: a,
				handleClose: c
			}
		}
	});

function _sfc_render$Z(o, s, a, l, c, d) {
	const f = resolveComponent("icon-info-circle-fill"),
		m = resolveComponent("icon-check-circle-fill"),
		g = resolveComponent("icon-exclamation-circle-fill"),
		v = resolveComponent("icon-close-circle-fill"),
		y = resolveComponent("icon-loading"),
		b = resolveComponent("icon-close"),
		C = resolveComponent("a-icon-hover");
	return openBlock(), createElementBlock("li", {
		role: "alert",
		class: normalizeClass([o.prefixCls, `${o.prefixCls}-${o.type}`, {
			[`${o.prefixCls}-closable`]: o.closable
		}]),
		onMouseenter: s[1] || (s[1] = (..._) => o.handleMouseEnter && o.handleMouseEnter(..._)),
		onMouseleave: s[2] || (s[2] = (..._) => o.handleMouseLeave && o.handleMouseLeave(..._))
	}, [o.showIcon && !(o.type === "normal" && !o.$slots.icon) ? (openBlock(), createElementBlock("span", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-icon`)
	}, [renderSlot(o.$slots, "icon", {}, () => [o.type === "info" ? (openBlock(), createBlock(f, {
		key: 0
	})) : o.type === "success" ? (openBlock(), createBlock(m, {
		key: 1
	})) : o.type === "warning" ? (openBlock(), createBlock(g, {
		key: 2
	})) : o.type === "error" ? (openBlock(), createBlock(v, {
		key: 3
	})) : o.type === "loading" ? (openBlock(), createBlock(y, {
		key: 4
	})) : createCommentVNode("v-if", !0)])], 2)) : createCommentVNode("v-if", !0), createBaseVNode("span", {
		class: normalizeClass(`${o.prefixCls}-content`)
	}, [renderSlot(o.$slots, "default")], 2), o.closable ? (openBlock(), createElementBlock("span", {
		key: 1,
		class: normalizeClass(`${o.prefixCls}-close-btn`),
		onClick: s[0] || (s[0] = (..._) => o.handleClose && o.handleClose(..._))
	}, [createVNode(C, null, {
		default: withCtx(() => [createVNode(b)]),
		_: 1
	})], 2)) : createCommentVNode("v-if", !0)], 34)
}
var Message$1 = _export_sfc$1(_sfc_main$1f, [
	["render", _sfc_render$Z]
]);

function _isSlot$8(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var MessageList = defineComponent({
	name: "MessageList",
	props: {
		messages: {
			type: Array,
			default: () => []
		},
		position: {
			type: String,
			default: "top"
		}
	},
	emits: ["close", "afterClose"],
	setup(o, s) {
		const a = getPrefixCls("message-list"),
			{
				zIndex: l
			} = usePopupManager("message", {
				runOnMounted: !0
			});
		return () => {
			let c;
			return createVNode(TransitionGroup, {
				class: [a, `${a}-${o.position}`],
				name: "fade-message",
				tag: "ul",
				style: {
					zIndex: l.value
				},
				onAfterLeave: () => s.emit("afterClose")
			}, _isSlot$8(c = o.messages.map(d => {
				const f = {
					default: getSlotFunction(d.content),
					icon: getSlotFunction(d.icon)
				};
				return createVNode(Message$1, {
					key: d.id,
					type: d.type,
					duration: d.duration,
					closable: d.closable,
					resetOnUpdate: d.resetOnUpdate,
					resetOnHover: d.resetOnHover,
					onClose: () => s.emit("close", d.id)
				}, f)
			})) ? c : {
				default: () => [c]
			})
		}
	}
});
class MessageManger {
	constructor(s, a) {
		this.messageCount = 0, this.add = d => {
			var f;
			this.messageCount++;
			const m = (f = d.id) != null ? f : `__arco_message_${this.messageCount}`;
			if (this.messageIds.has(m)) return this.update(m, d);
			const g = reactive({
				id: m,
				...d
			});
			return this.messages.value.push(g), this.messageIds.add(m), {
				close: () => this.remove(m)
			}
		}, this.update = (d, f) => {
			for (let m = 0; m < this.messages.value.length; m++)
				if (this.messages.value[m].id === d) {
					const g = !isUndefined$1(f.duration);
					Object.assign(this.messages.value[m], {
						...f,
						id: d,
						resetOnUpdate: g
					});
					break
				} return {
				close: () => this.remove(d)
			}
		}, this.remove = d => {
			for (let f = 0; f < this.messages.value.length; f++) {
				const m = this.messages.value[f];
				if (m.id === d) {
					isFunction$2(m.onClose) && m.onClose(d), this.messages.value.splice(f, 1), this.messageIds
						.delete(d);
					break
				}
			}
		}, this.clear = () => {
			this.messages.value.splice(0)
		}, this.destroy = () => {
			this.messages.value.length === 0 && this.container && (render(null, this.container), document.body
				.removeChild(this.container), this.container = null, messageInstance[this.position] = void 0
				)
		};
		const {
			position: l = "top"
		} = s;
		this.container = getOverlay("message"), this.messageIds = new Set, this.messages = ref([]), this.position =
			l;
		const c = createVNode(MessageList, {
			messages: this.messages.value,
			position: l,
			onClose: this.remove,
			onAfterClose: this.destroy
		});
		(a ?? Message._context) && (c.appContext = a ?? Message._context), render(c, this.container), document.body
			.appendChild(this.container)
	}
}
const messageInstance = {},
	types$2 = [...MESSAGE_TYPES, "loading", "normal"],
	message$2 = types$2.reduce((o, s) => (o[s] = (a, l) => {
		isString$2(a) && (a = {
			content: a
		});
		const c = {
				type: s,
				...a
			},
			{
				position: d = "top"
			} = c;
		return messageInstance[d] || (messageInstance[d] = new MessageManger(c, l)), messageInstance[d].add(c)
	}, o), {});
message$2.clear = o => {
	var s;
	o ? (s = messageInstance[o]) == null || s.clear() : Object.values(messageInstance).forEach(a => a == null ?
		void 0 : a.clear())
};
const Message = {
		...message$2,
		install: o => {
			const s = {
				clear: message$2.clear
			};
			for (const a of types$2) s[a] = (l, c = o._context) => message$2[a](l, c);
			o.config.globalProperties.$message = s
		},
		_context: null
	},
	useDraggable$1 = ({
		modalRef: o,
		wrapperRef: s,
		draggable: a,
		alignCenter: l
	}) => {
		const c = ref(!1),
			d = ref([0, 0]),
			f = ref([0, 0]),
			m = ref(),
			g = ref([0, 0]),
			v = ref([0, 0]),
			y = () => {
				var S, w, T;
				if (s.value && o.value) {
					const {
						top: A,
						left: k
					} = s.value.getBoundingClientRect(), {
							clientWidth: M,
							clientHeight: D
						} = s.value, {
							top: F,
							left: R,
							width: O,
							height: U
						} = o.value.getBoundingClientRect(), V = l.value ? 0 : (S = o.value) == null ? void 0 : S
						.offsetTop, z = R - k, j = F - A - V;
					(z !== ((w = f.value) == null ? void 0 : w[0]) || j !== ((T = f.value) == null ? void 0 : T[1])) &&
					(f.value = [z, j]);
					const ge = M > O ? M - O : 0,
						me = D > U ? D - U - V : 0;
					(ge !== v.value[0] || me !== v.value[1]) && (v.value = [ge, me]), V && (g.value = [0, 0 - V])
				}
			},
			b = S => {
				a.value && (S.preventDefault(), c.value = !0, y(), d.value = [S.x, S.y], on(window, "mousemove", C), on(
					window, "mouseup", _), on(window, "contextmenu", _))
			},
			C = S => {
				if (c.value) {
					const w = S.x - d.value[0],
						T = S.y - d.value[1];
					let A = f.value[0] + w,
						k = f.value[1] + T;
					A < g.value[0] && (A = g.value[0]), A > v.value[0] && (A = v.value[0]), k < g.value[1] && (k = g
						.value[1]), k > v.value[1] && (k = v.value[1]), m.value = [A, k]
				}
			},
			_ = () => {
				c.value = !1, off(window, "mousemove", C), off(window, "mouseup", _)
			};
		return {
			position: m,
			handleMoveDown: b
		}
	};
var _sfc_main$1e = defineComponent({
	name: "Modal",
	components: {
		ClientOnly,
		ArcoButton: Button,
		IconHover,
		IconClose,
		IconInfoCircleFill,
		IconCheckCircleFill,
		IconExclamationCircleFill,
		IconCloseCircleFill
	},
	inheritAttrs: !1,
	props: {
		visible: {
			type: Boolean,
			default: void 0
		},
		defaultVisible: {
			type: Boolean,
			default: !1
		},
		width: {
			type: [Number, String]
		},
		top: {
			type: [Number, String]
		},
		mask: {
			type: Boolean,
			default: !0
		},
		title: {
			type: String
		},
		titleAlign: {
			type: String,
			default: "center"
		},
		alignCenter: {
			type: Boolean,
			default: !0
		},
		unmountOnClose: Boolean,
		maskClosable: {
			type: Boolean,
			default: !0
		},
		hideCancel: {
			type: Boolean,
			default: !1
		},
		simple: {
			type: Boolean,
			default: o => o.notice
		},
		closable: {
			type: Boolean,
			default: !0
		},
		okText: String,
		cancelText: String,
		okLoading: {
			type: Boolean,
			default: !1
		},
		okButtonProps: {
			type: Object
		},
		cancelButtonProps: {
			type: Object
		},
		footer: {
			type: Boolean,
			default: !0
		},
		renderToBody: {
			type: Boolean,
			default: !0
		},
		popupContainer: {
			type: [String, Object],
			default: "body"
		},
		maskStyle: {
			type: Object
		},
		modalClass: {
			type: [String, Array]
		},
		modalStyle: {
			type: Object
		},
		onBeforeOk: {
			type: Function
		},
		onBeforeCancel: {
			type: Function
		},
		escToClose: {
			type: Boolean,
			default: !0
		},
		draggable: {
			type: Boolean,
			default: !1
		},
		fullscreen: {
			type: Boolean,
			default: !1
		},
		maskAnimationName: {
			type: String,
			default: o => o.fullscreen ? "fade-in-standard" : "fade-modal"
		},
		modalAnimationName: {
			type: String,
			default: o => o.fullscreen ? "zoom-in" : "zoom-modal"
		},
		bodyClass: {
			type: [String, Array]
		},
		bodyStyle: {
			type: [String, Object, Array]
		},
		messageType: {
			type: String
		},
		hideTitle: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		"update:visible": o => !0,
		ok: o => !0,
		cancel: o => !0,
		open: () => !0,
		close: () => !0,
		beforeOpen: () => !0,
		beforeClose: () => !0
	},
	setup(o, {
		emit: s
	}) {
		const {
			fullscreen: a,
			popupContainer: l,
			alignCenter: c
		} = toRefs(o), d = getPrefixCls("modal"), {
			t: f
		} = useI18n(), m = ref(), g = ref(), v = ref(o.defaultVisible), y = computed(() => {
			var be;
			return (be = o.visible) != null ? be : v.value
		}), b = ref(!1), C = computed(() => o.okLoading || b.value), _ = computed(() => o.draggable && !o
			.fullscreen), {
			teleportContainer: S,
			containerRef: w
		} = useTeleportContainer({
			popupContainer: l,
			visible: y
		}), T = ref(y.value), A = computed(() => o.okText || f("modal.okText")), k = computed(() => o
			.cancelText || f("modal.cancelText")), {
			zIndex: M,
			isLastDialog: D
		} = usePopupManager("dialog", {
			visible: y
		});
		let F = !1;
		const R = be => {
				o.escToClose && be.key === KEYBOARD_KEY.ESC && D() && he(be)
			},
			O = () => {
				o.escToClose && !F && (F = !0, on(document.documentElement, "keydown", R))
			},
			U = () => {
				F = !1, off(document.documentElement, "keydown", R)
			};
		let V = 0;
		const {
			position: z,
			handleMoveDown: j
		} = useDraggable$1({
			wrapperRef: m,
			modalRef: g,
			draggable: _,
			alignCenter: c
		}), ge = () => {
			V++, b.value && (b.value = !1), v.value = !1, s("update:visible", !1)
		}, me = async be => {
			const Me = V,
				Ve = await new Promise(async it => {
					var pt;
					if (isFunction$2(o.onBeforeOk)) {
						let dt = o.onBeforeOk((He = !0) => it(He));
						if ((isPromise(dt) || !isBoolean$2(dt)) && (b.value = !0), isPromise(
							dt)) try {
							dt = (pt = await dt) != null ? pt : !0
						} catch (He) {
							throw dt = !1, He
						}
						isBoolean$2(dt) && it(dt)
					} else it(!0)
				});
			Me === V && (Ve ? (s("ok", be), ge()) : b.value && (b.value = !1))
		}, he = be => {
			var Me;
			let Ve = !0;
			isFunction$2(o.onBeforeCancel) && (Ve = (Me = o.onBeforeCancel()) != null ? Me : !1), Ve &&
				(s("cancel", be), ge())
		}, ce = ref(!1), ae = be => {
			be.target === m.value && (ce.value = !0)
		}, fe = be => {
			o.mask && o.maskClosable && ce.value && he(be)
		}, q = () => {
			y.value && (!contains(m.value, document.activeElement) && document
				.activeElement instanceof HTMLElement && document.activeElement.blur(), s("open"))
		}, le = () => {
			y.value || (_.value && (z.value = void 0), T.value = !1, _e(), s("close"))
		}, {
			setOverflowHidden: de,
			resetOverflow: _e
		} = useOverflow(w);
		onMounted(() => {
			w.value = getElement(o.popupContainer), y.value && (de(), o.escToClose && O())
		}), onBeforeUnmount(() => {
			_e(), U()
		}), watch(y, be => {
			v.value !== be && (v.value = be), be ? (s("beforeOpen"), T.value = !0, ce.value = !1, de(),
				O()) : (s("beforeClose"), U())
		}), watch(a, () => {
			z.value && (z.value = void 0)
		});
		const ke = computed(() => [`${d}-wrapper`, {
				[`${d}-wrapper-align-center`]: o.alignCenter && !o.fullscreen,
				[`${d}-wrapper-moved`]: !!z.value
			}]),
			De = computed(() => [`${d}`, o.modalClass, {
				[`${d}-simple`]: o.simple,
				[`${d}-draggable`]: _.value,
				[`${d}-fullscreen`]: o.fullscreen
			}]),
			Se = computed(() => {
				var be;
				const Me = {
					...(be = o.modalStyle) != null ? be : {}
				};
				return o.width && !o.fullscreen && (Me.width = isNumber$2(o.width) ? `${o.width}px` : o
					.width), !o.alignCenter && o.top && (Me.top = isNumber$2(o.top) ? `${o.top}px` : o
					.top), z.value && (Me.transform = `translate(${z.value[0]}px, ${z.value[1]}px)`), Me
			});
		return {
			prefixCls: d,
			mounted: T,
			computedVisible: y,
			containerRef: w,
			wrapperRef: m,
			mergedModalStyle: Se,
			okDisplayText: A,
			cancelDisplayText: k,
			zIndex: M,
			handleOk: me,
			handleCancel: he,
			handleMaskClick: fe,
			handleMaskMouseDown: ae,
			handleOpen: q,
			handleClose: le,
			mergedOkLoading: C,
			modalRef: g,
			wrapperCls: ke,
			modalCls: De,
			teleportContainer: S,
			handleMoveDown: j
		}
	}
});

function _sfc_render$Y(o, s, a, l, c, d) {
	const f = resolveComponent("icon-info-circle-fill"),
		m = resolveComponent("icon-check-circle-fill"),
		g = resolveComponent("icon-exclamation-circle-fill"),
		v = resolveComponent("icon-close-circle-fill"),
		y = resolveComponent("icon-close"),
		b = resolveComponent("icon-hover"),
		C = resolveComponent("arco-button"),
		_ = resolveComponent("client-only");
	return openBlock(), createBlock(_, null, {
		default: withCtx(() => [(openBlock(), createBlock(Teleport, {
			to: o.teleportContainer,
			disabled: !o.renderToBody
		}, [!o.unmountOnClose || o.computedVisible || o.mounted ? withDirectives((
		openBlock(), createElementBlock("div", mergeProps({
			key: 0,
			class: `${o.prefixCls}-container`,
			style: {
				zIndex: o.zIndex
			}
		}, o.$attrs), [createVNode(Transition, {
			name: o.maskAnimationName,
			appear: ""
		}, {
			default: withCtx(() => [o.mask ? withDirectives((
				openBlock(), createElementBlock(
					"div", {
						key: 0,
						ref: "maskRef",
						class: normalizeClass(
							`${o.prefixCls}-mask`
							),
						style: normalizeStyle(o
							.maskStyle)
					}, null, 6)), [
				[vShow, o.computedVisible]
			]) : createCommentVNode("v-if", !0)]),
			_: 1
		}, 8, ["name"]), createBaseVNode("div", {
			ref: "wrapperRef",
			class: normalizeClass(o.wrapperCls),
			onClick: s[2] || (s[2] = withModifiers((...S) => o
				.handleMaskClick && o.handleMaskClick(...S),
				["self"])),
			onMousedown: s[3] || (s[3] = withModifiers((...S) => o
				.handleMaskMouseDown && o
				.handleMaskMouseDown(...S), ["self"]))
		}, [createVNode(Transition, {
			name: o.modalAnimationName,
			appear: "",
			onAfterEnter: o.handleOpen,
			onAfterLeave: o.handleClose,
			persisted: ""
		}, {
			default: withCtx(() => [withDirectives(
				createBaseVNode("div", {
					ref: "modalRef",
					class: normalizeClass(o
						.modalCls),
					style: normalizeStyle(o
						.mergedModalStyle
						)
				}, [!o.hideTitle && (o
						.$slots.title || o
						.title || o.closable
						) ? (openBlock(),
						createElementBlock(
							"div", {
								key: 0,
								class: normalizeClass(
									`${o.prefixCls}-header`
									),
								onMousedown: s[
										1
										] ||
									(s[1] =
										(...
											S) =>
										o
										.handleMoveDown &&
										o
										.handleMoveDown(
											...
											S
											)
										)
							}, [o.$slots
								.title || o
								.title ? (
									openBlock(),
									createElementBlock(
										"div", {
											key: 0,
											class: normalizeClass(
												[`${o.prefixCls}-title`,
													`${o.prefixCls}-title-align-${o.titleAlign}`
												]
												)
										}, [o
											.messageType ?
											(openBlock(),
												createElementBlock(
													"div", {
														key: 0,
														class: normalizeClass(
															`${o.prefixCls}-title-icon`
															)
													},
													[o.messageType ===
														"info" ?
														(openBlock(),
															createBlock(
																f, {
																	key: 0
																}
																)
															) :
														createCommentVNode(
															"v-if",
															!
															0
															),
														o
														.messageType ===
														"success" ?
														(openBlock(),
															createBlock(
																m, {
																	key: 1
																}
																)
															) :
														createCommentVNode(
															"v-if",
															!
															0
															),
														o
														.messageType ===
														"warning" ?
														(openBlock(),
															createBlock(
																g, {
																	key: 2
																}
																)
															) :
														createCommentVNode(
															"v-if",
															!
															0
															),
														o
														.messageType ===
														"error" ?
														(openBlock(),
															createBlock(
																v, {
																	key: 3
																}
																)
															) :
														createCommentVNode(
															"v-if",
															!
															0
															)
													],
													2
													)
												) :
											createCommentVNode(
												"v-if",
												!
												0
												),
											renderSlot(
												o
												.$slots,
												"title", {},
												() => [
													createTextVNode(
														toDisplayString(
															o
															.title
															),
														1
														)
												]
												)
										], 2
										)) :
								createCommentVNode(
									"v-if",
									!0), !o
								.simple && o
								.closable ?
								(openBlock(),
									createElementBlock(
										"div", {
											key: 1,
											tabindex: "-1",
											role: "button",
											"aria-label": "Close",
											class: normalizeClass(
												`${o.prefixCls}-close-btn`
												),
											onClick: s[
													0
													] ||
												(s[0] =
													(...
														S) =>
													o
													.handleCancel &&
													o
													.handleCancel(
														...
														S
														)
													)
										}, [createVNode(
											b,
											null, {
												default: withCtx(
													() => [
														createVNode(
															y
															)
													]
													),
												_: 1
											}
											)],
										2)
									) :
								createCommentVNode(
									"v-if",
									!0)
							], 34)) :
					createCommentVNode(
						"v-if", !0),
					createBaseVNode("div", {
						class: normalizeClass(
							[`${o.prefixCls}-body`,
								o
								.bodyClass
							]),
						style: normalizeStyle(
							o
							.bodyStyle
							)
					}, [renderSlot(o
						.$slots,
						"default")], 6), o
					.footer ? (openBlock(),
						createElementBlock(
							"div", {
								key: 1,
								class: normalizeClass(
									`${o.prefixCls}-footer`
									)
							}, [renderSlot(o
								.$slots,
								"footer", {},
								() => [o
									.hideCancel ?
									createCommentVNode(
										"v-if",
										!
										0
										) :
									(openBlock(),
										createBlock(
											C,
											mergeProps({
													key: 0
												},
												o
												.cancelButtonProps, {
													onClick: o
														.handleCancel
												}
												), {
												default: withCtx(
													() => [
														createTextVNode(
															toDisplayString(
																o
																.cancelDisplayText
																),
															1
															)
													]
													),
												_: 1
											},
											16,
											[
												"onClick"]
											)
										),
									createVNode(
										C,
										mergeProps({
												type: "primary"
											},
											o
											.okButtonProps, {
												loading: o
													.mergedOkLoading,
												onClick: o
													.handleOk
											}
											), {
											default: withCtx(
												() => [
													createTextVNode(
														toDisplayString(
															o
															.okDisplayText
															),
														1
														)
												]
												),
											_: 1
										},
										16,
										["loading",
											"onClick"
										]
										)
								])], 2)) :
					createCommentVNode(
						"v-if", !0)
				], 6), [
					[vShow, o.computedVisible]
				])]),
			_: 3
		}, 8, ["name", "onAfterEnter", "onAfterLeave"])], 34)], 16)), [
			[vShow, o.computedVisible || o.mounted]
		]) : createCommentVNode("v-if", !0)], 8, ["to", "disabled"]))]),
		_: 3
	})
}
var _Modal = _export_sfc$1(_sfc_main$1e, [
	["render", _sfc_render$Y]
]);
const open = (o, s) => {
		let a = getOverlay("modal");
		const l = () => {
				v.component && (v.component.props.visible = !1), isFunction$2(o.onOk) && o.onOk()
			},
			c = () => {
				v.component && (v.component.props.visible = !1), isFunction$2(o.onCancel) && o.onCancel()
			},
			d = async () => {
				await nextTick(), a && (render(null, a), document.body.removeChild(a)), a = null, isFunction$2(o
					.onClose) && o.onClose()
			}, f = () => {
				v.component && (v.component.props.visible = !1)
			}, m = y => {
				v.component && Object.entries(y).forEach(([b, C]) => {
					v.component.props[b] = C
				})
			}, v = createVNode(_Modal, {
				...{
					visible: !0,
					renderToBody: !1,
					unmountOnClose: !0,
					onOk: l,
					onCancel: c,
					onClose: d
				},
				...omit(o, ["content", "title", "footer", "visible", "unmountOnClose", "onOk", "onCancel",
					"onClose"
				]),
				footer: typeof o.footer == "boolean" ? o.footer : void 0
			}, {
				default: getSlotFunction(o.content),
				title: getSlotFunction(o.title),
				footer: typeof o.footer != "boolean" ? getSlotFunction(o.footer) : void 0
			});
		return (s ?? Modal._context) && (v.appContext = s ?? Modal._context), render(v, a), document.body.appendChild(
			a), {
				close: f,
				update: m
			}
	},
	modal = {
		open,
		confirm: (o, s) => {
			const a = {
				simple: !0,
				messageType: "warning",
				...o
			};
			return open(a, s)
		},
		...MESSAGE_TYPES.reduce((o, s) => (o[s] = (a, l) => {
			const c = {
				simple: !0,
				hideCancel: !0,
				messageType: s,
				...a
			};
			return open(c, l)
		}, o), {})
	},
	Modal = Object.assign(_Modal, {
		...modal,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Modal.name, _Modal);
			const l = {};
			for (const c of Object.keys(modal)) l[c] = (d, f = o._context) => modal[c](d, f);
			o.config.globalProperties.$modal = l
		},
		_context: null
	}),
	toKebabCase$1 = o => o.replace(/\B([A-Z])/g, "-$1").toLowerCase(),
	_sfc_main$1d = defineComponent({
		name: "Notification",
		components: {
			AIconHover: IconHover,
			IconInfoCircleFill,
			IconCheckCircleFill,
			IconExclamationCircleFill,
			IconCloseCircleFill,
			IconClose
		},
		props: {
			type: {
				type: String,
				default: "info"
			},
			showIcon: {
				type: Boolean,
				default: !0
			},
			closable: {
				type: Boolean,
				default: !1
			},
			duration: {
				type: Number,
				default: 3e3
			},
			resetOnUpdate: {
				type: Boolean,
				default: !1
			}
		},
		emits: ["close"],
		setup(o, s) {
			const a = getPrefixCls("notification");
			let l = 0;
			const c = () => {
				s.emit("close")
			};
			return onMounted(() => {
				o.duration > 0 && (l = window.setTimeout(c, o.duration))
			}), onUpdated(() => {
				o.resetOnUpdate && (l && (window.clearTimeout(l), l = 0), o.duration > 0 && (l = window
					.setTimeout(c, o.duration)))
			}), onUnmounted(() => {
				l && window.clearTimeout(l)
			}), {
				prefixCls: a,
				handleClose: c
			}
		}
	});

function _sfc_render$X(o, s, a, l, c, d) {
	const f = resolveComponent("icon-info-circle-fill"),
		m = resolveComponent("icon-check-circle-fill"),
		g = resolveComponent("icon-exclamation-circle-fill"),
		v = resolveComponent("icon-close-circle-fill"),
		y = resolveComponent("icon-close"),
		b = resolveComponent("a-icon-hover");
	return openBlock(), createElementBlock("li", {
		role: "alert",
		class: normalizeClass([o.prefixCls, `${o.prefixCls}-${o.type}`, {
			[`${o.prefixCls}-closable`]: o.closable
		}])
	}, [o.showIcon ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-left`)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-icon`)
	}, [renderSlot(o.$slots, "icon", {}, () => [o.type === "info" ? (openBlock(),
		createBlock(f, {
			key: 0
		})) : o.type === "success" ? (openBlock(), createBlock(m, {
		key: 1
	})) : o.type === "warning" ? (openBlock(), createBlock(g, {
		key: 2
	})) : o.type === "error" ? (openBlock(), createBlock(v, {
		key: 3
	})) : createCommentVNode("v-if", !0)])], 2)], 2)) : createCommentVNode("v-if", !0), createBaseVNode(
		"div", {
			class: normalizeClass(`${o.prefixCls}-right`)
		}, [o.$slots.default ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-title`)
			}, [renderSlot(o.$slots, "default")], 2)) : createCommentVNode("v-if", !0), o.$slots.content ? (
				openBlock(), createElementBlock("div", {
					key: 1,
					class: normalizeClass(`${o.prefixCls}-content`)
				}, [renderSlot(o.$slots, "content")], 2)) : createCommentVNode("v-if", !0), o.$slots
			.footer ? (openBlock(), createElementBlock("div", {
				key: 2,
				class: normalizeClass(`${o.prefixCls}-footer`)
			}, [renderSlot(o.$slots, "footer")], 2)) : createCommentVNode("v-if", !0)
		], 2), o.closable ? (openBlock(), createElementBlock("div", {
		key: 1,
		class: normalizeClass(`${o.prefixCls}-close-btn`),
		onClick: s[0] || (s[0] = (...C) => o.handleClose && o.handleClose(...C))
	}, [renderSlot(o.$slots, "closeIconElement", {}, () => [createVNode(b, null, {
		default: withCtx(() => [renderSlot(o.$slots, "closeIcon", {}, () => [
			createVNode(y)
		])]),
		_: 3
	})])], 2)) : createCommentVNode("v-if", !0)], 2)
}
var Notification$1 = _export_sfc$1(_sfc_main$1d, [
	["render", _sfc_render$X]
]);
const NOTIFICATION_POSITION = ["topLeft", "topRight", "bottomLeft", "bottomRight"];

function _isSlot$7(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var NotificationList = defineComponent({
	name: "NotificationList",
	props: {
		notifications: {
			type: Array,
			default: () => []
		},
		position: {
			type: String,
			default: "topRight",
			validator: o => NOTIFICATION_POSITION.includes(o)
		}
	},
	emits: ["close", "afterClose"],
	setup(o, s) {
		const a = getPrefixCls("notification-list"),
			l = toKebabCase$1(o.position),
			{
				zIndex: c
			} = usePopupManager("message", {
				runOnMounted: !0
			}),
			d = o.position.includes("Right");
		return () => {
			let f;
			return createVNode(TransitionGroup, {
				class: [a, `${a}-${l}`],
				style: {
					zIndex: c.value
				},
				name: `slide-${d?"right":"left"}-notification`,
				onAfterLeave: () => s.emit("afterClose"),
				tag: "ul"
			}, _isSlot$7(f = o.notifications.map(m => {
				const g = {
					default: getSlotFunction(m.title),
					content: getSlotFunction(m.content),
					icon: getSlotFunction(m.icon),
					footer: getSlotFunction(m.footer),
					closeIcon: getSlotFunction(m.closeIcon),
					closeIconElement: getSlotFunction(m.closeIconElement)
				};
				return createVNode(Notification$1, {
					key: m.id,
					type: m.type,
					style: m.style,
					class: m.class,
					duration: m.duration,
					closable: m.closable,
					showIcon: m.showIcon,
					resetOnUpdate: m.resetOnUpdate,
					onClose: () => s.emit("close", m.id)
				}, g)
			})) ? f : {
				default: () => [f]
			})
		}
	}
});
class NotificationManger {
	constructor(s, a) {
		this.notificationCount = 0, this.add = d => {
			var f;
			this.notificationCount++;
			const m = (f = d.id) != null ? f : `__arco_notification_${this.notificationCount}`;
			if (this.notificationIds.has(m)) return this.update(m, d);
			const g = reactive({
				id: m,
				...d
			});
			return this.notifications.value.push(g), this.notificationIds.add(m), {
				close: () => this.remove(m)
			}
		}, this.update = (d, f) => {
			for (let m = 0; m < this.notifications.value.length; m++)
				if (this.notifications.value[m].id === d) {
					const g = !isUndefined$1(f.duration);
					Object.assign(this.notifications.value[m], {
						...f,
						id: d,
						resetOnUpdate: g
					});
					break
				} return {
				close: () => this.remove(d)
			}
		}, this.remove = d => {
			for (let f = 0; f < this.notifications.value.length; f++) {
				const m = this.notifications.value[f];
				if (m.id === d) {
					isFunction$2(m.onClose) && m.onClose(d), this.notifications.value.splice(f, 1), this
						.notificationIds.delete(d);
					break
				}
			}
		}, this.clear = () => {
			this.notifications.value.splice(0)
		}, this.destroy = () => {
			this.notifications.value.length === 0 && this.container && (render(null, this.container), document
				.body.removeChild(this.container), this.container = null, notificationInstance[this
					.position] = void 0)
		};
		const {
			position: l = "topRight"
		} = s;
		this.container = getOverlay("notification"), this.notificationIds = new Set, this.notifications = ref([]),
			this.position = l;
		const c = createVNode(NotificationList, {
			notifications: this.notifications.value,
			position: l,
			onClose: this.remove,
			onAfterClose: this.destroy
		});
		(a ?? Notification._context) && (c.appContext = a ?? Notification._context), render(c, this.container),
			document.body.appendChild(this.container)
	}
}
const notificationInstance = {},
	notification = MESSAGE_TYPES.reduce((o, s) => (o[s] = (a, l) => {
		isString$2(a) && (a = {
			content: a
		});
		const c = {
				type: s,
				...a
			},
			{
				position: d = "topRight"
			} = c;
		return notificationInstance[d] || (notificationInstance[d] = new NotificationManger(c, l)),
			notificationInstance[d].add(c)
	}, o), {});
notification.remove = o => {
	o && Object.values(notificationInstance).forEach(s => s == null ? void 0 : s.remove(o))
};
notification.clear = o => {
	var s;
	o ? (s = notificationInstance[o]) == null || s.clear() : Object.values(notificationInstance).forEach(a => a ==
		null ? void 0 : a.clear())
};
const Notification = {
		...notification,
		install: o => {
			const s = {
				clear: notification.clear
			};
			for (const a of MESSAGE_TYPES) s[a] = (l, c = o._context) => notification[a](l, c);
			o.config.globalProperties.$notification = s
		},
		_context: null
	},
	_sfc_main$1c = defineComponent({
		name: "PageHeader",
		components: {
			AIconHover: IconHover,
			IconLeft
		},
		props: {
			title: String,
			subtitle: String,
			showBack: {
				type: Boolean,
				default: !0
			}
		},
		emits: ["back"],
		setup(o, {
			emit: s,
			slots: a
		}) {
			const l = getPrefixCls("page-header"),
				c = f => {
					s("back", f)
				},
				d = computed(() => [l, {
					[`${l}-with-breadcrumb`]: !!a.breadcrumb,
					[`${l}-with-content`]: !!a.default
				}]);
			return {
				prefixCls: l,
				cls: d,
				handleBack: c
			}
		}
	});

function _sfc_render$W(o, s, a, l, c, d) {
	const f = resolveComponent("icon-left"),
		m = resolveComponent("a-icon-hover");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-wrapper`)
		}, [o.$slots.breadcrumb ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-breadcrumb`)
		}, [renderSlot(o.$slots, "breadcrumb")], 2)) : createCommentVNode("v-if", !0), createBaseVNode(
			"div", {
				class: normalizeClass(`${o.prefixCls}-header`)
			}, [createBaseVNode("span", {
				class: normalizeClass(`${o.prefixCls}-main`)
			}, [o.showBack ? (openBlock(), createBlock(m, {
					key: 0,
					class: normalizeClass(`${o.prefixCls}-back-btn`),
					prefix: o.prefixCls,
					onClick: o.handleBack
				}, {
					default: withCtx(() => [renderSlot(o.$slots, "back-icon", {},
					() => [createVNode(f)])]),
					_: 3
				}, 8, ["class", "prefix", "onClick"])) : createCommentVNode("v-if", !0),
				createBaseVNode("span", {
					class: normalizeClass(`${o.prefixCls}-title`)
				}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(
					toDisplayString(o.title), 1)])], 2), o.$slots.subtitle || o.subtitle ? (
					openBlock(), createElementBlock("span", {
						key: 1,
						class: normalizeClass(`${o.prefixCls}-divider`)
					}, null, 2)) : createCommentVNode("v-if", !0), o.$slots.subtitle || o
				.subtitle ? (openBlock(), createElementBlock("span", {
					key: 2,
					class: normalizeClass(`${o.prefixCls}-subtitle`)
				}, [renderSlot(o.$slots, "subtitle", {}, () => [createTextVNode(
					toDisplayString(o.subtitle), 1)])], 2)) : createCommentVNode("v-if", !0)
			], 2), o.$slots.extra ? (openBlock(), createElementBlock("span", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-extra`)
			}, [renderSlot(o.$slots, "extra")], 2)) : createCommentVNode("v-if", !0)], 2)], 2), o.$slots
		.default ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [renderSlot(o.$slots, "default")], 2)) : createCommentVNode("v-if", !0)
	], 2)
}
var _PageHeader = _export_sfc$1(_sfc_main$1c, [
	["render", _sfc_render$W]
]);
const PageHeader = Object.assign(_PageHeader, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _PageHeader.name, _PageHeader)
		}
	}),
	_sfc_main$1b = defineComponent({
		name: "Popconfirm",
		components: {
			ArcoButton: Button,
			Trigger,
			IconInfoCircleFill,
			IconCheckCircleFill,
			IconExclamationCircleFill,
			IconCloseCircleFill
		},
		props: {
			content: String,
			position: {
				type: String,
				default: "top"
			},
			popupVisible: {
				type: Boolean,
				default: void 0
			},
			defaultPopupVisible: {
				type: Boolean,
				default: !1
			},
			type: {
				type: String,
				default: "info"
			},
			okText: String,
			cancelText: String,
			okLoading: {
				type: Boolean,
				default: !1
			},
			okButtonProps: {
				type: Object
			},
			cancelButtonProps: {
				type: Object
			},
			contentClass: {
				type: [String, Array, Object]
			},
			contentStyle: {
				type: Object
			},
			arrowClass: {
				type: [String, Array, Object]
			},
			arrowStyle: {
				type: Object
			},
			popupContainer: {
				type: [String, Object]
			},
			onBeforeOk: {
				type: Function
			},
			onBeforeCancel: {
				type: Function
			}
		},
		emits: {
			"update:popupVisible": o => !0,
			popupVisibleChange: o => !0,
			ok: () => !0,
			cancel: () => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("popconfirm"),
				{
					t: l
				} = useI18n(),
				c = ref(o.defaultPopupVisible),
				d = computed(() => {
					var w;
					return (w = o.popupVisible) != null ? w : c.value
				}),
				f = ref(!1),
				m = computed(() => o.okLoading || f.value);
			let g = 0;
			const v = () => {
					g++, f.value && (f.value = !1), c.value = !1, s("update:popupVisible", !1), s(
						"popupVisibleChange", !1)
				},
				y = w => {
					w ? (c.value = w, s("update:popupVisible", w), s("popupVisibleChange", w)) : v()
				},
				b = async () => {
					const w = g,
						T = await new Promise(async A => {
							var k;
							if (isFunction$2(o.onBeforeOk)) {
								let M = o.onBeforeOk((D = !0) => A(D));
								if ((isPromise(M) || !isBoolean$2(M)) && (f.value = !0), isPromise(M))
									try {
										M = (k = await M) != null ? k : !0
									} catch (D) {
										throw M = !1, D
									}
								isBoolean$2(M) && A(M)
							} else A(!0)
						});
					w === g && (T ? (s("ok"), v()) : f.value && (f.value = !1))
				}, C = () => {
					var w;
					let T = !0;
					isFunction$2(o.onBeforeCancel) && (T = (w = o.onBeforeCancel()) != null ? w : !1), T && (s(
						"cancel"), v())
				}, _ = computed(() => [`${a}-popup-content`, o.contentClass]), S = computed(() => [
					`${a}-popup-arrow`, o.arrowClass
				]);
			return {
				prefixCls: a,
				contentCls: _,
				arrowCls: S,
				computedPopupVisible: d,
				mergedOkLoading: m,
				handlePopupVisibleChange: y,
				handleOk: b,
				handleCancel: C,
				t: l
			}
		}
	});

function _sfc_render$V(o, s, a, l, c, d) {
	const f = resolveComponent("icon-info-circle-fill"),
		m = resolveComponent("icon-check-circle-fill"),
		g = resolveComponent("icon-exclamation-circle-fill"),
		v = resolveComponent("icon-close-circle-fill"),
		y = resolveComponent("arco-button"),
		b = resolveComponent("trigger");
	return openBlock(), createBlock(b, {
		class: normalizeClass(o.prefixCls),
		trigger: "click",
		position: o.position,
		"show-arrow": "",
		"popup-visible": o.computedPopupVisible,
		"popup-offset": 10,
		"popup-container": o.popupContainer,
		"content-class": o.contentCls,
		"content-style": o.contentStyle,
		"arrow-class": o.arrowCls,
		"arrow-style": o.arrowStyle,
		"animation-name": "zoom-in-fade-out",
		"auto-fit-transform-origin": "",
		onPopupVisibleChange: o.handlePopupVisibleChange
	}, {
		content: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-body`)
		}, [createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-icon`)
		}, [renderSlot(o.$slots, "icon", {}, () => [o.type === "info" ? (openBlock(),
			createBlock(f, {
				key: 0
			})) : o.type === "success" ? (openBlock(), createBlock(m, {
			key: 1
		})) : o.type === "warning" ? (openBlock(), createBlock(g, {
			key: 2
		})) : o.type === "error" ? (openBlock(), createBlock(v, {
			key: 3
		})) : createCommentVNode("v-if", !0)])], 2), createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [renderSlot(o.$slots, "content", {}, () => [createTextVNode(toDisplayString(o
			.content), 1)])], 2)], 2), createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-footer`)
		}, [createVNode(y, mergeProps({
			size: "mini"
		}, o.cancelButtonProps, {
			onClick: o.handleCancel
		}), {
			default: withCtx(() => [createTextVNode(toDisplayString(o.cancelText || o.t(
				"popconfirm.cancelText")), 1)]),
			_: 1
		}, 16, ["onClick"]), createVNode(y, mergeProps({
			type: "primary",
			size: "mini"
		}, o.okButtonProps, {
			loading: o.mergedOkLoading,
			onClick: o.handleOk
		}), {
			default: withCtx(() => [createTextVNode(toDisplayString(o.okText || o.t(
				"popconfirm.okText")), 1)]),
			_: 1
		}, 16, ["loading", "onClick"])], 2)]),
		default: withCtx(() => [renderSlot(o.$slots, "default")]),
		_: 3
	}, 8, ["class", "position", "popup-visible", "popup-container", "content-class", "content-style",
		"arrow-class", "arrow-style", "onPopupVisibleChange"
	])
}
var _Popconfirm = _export_sfc$1(_sfc_main$1b, [
	["render", _sfc_render$V]
]);
const Popconfirm = Object.assign(_Popconfirm, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Popconfirm.name, _Popconfirm)
		}
	}),
	DEFAULT_STROKE_WIDTH$1 = {
		small: 3,
		medium: 4,
		large: 8
	},
	getBackground = o => {
		if (o) return isObject$2(o) ? {
			backgroundImage: `linear-gradient(to right, ${Object.keys(o).map(a=>`${o[a]} ${a}`).join(",")})`
		} : {
			backgroundColor: o
		}
	},
	_sfc_main$1a = defineComponent({
		name: "ProgressLine",
		components: {
			IconExclamationCircleFill
		},
		props: {
			percent: {
				type: Number,
				default: 0
			},
			animation: {
				type: Boolean,
				default: !1
			},
			size: {
				type: String,
				default: "medium"
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			width: {
				type: [Number, String],
				default: "100%"
			},
			color: {
				type: [String, Object],
				default: void 0
			},
			trackColor: String,
			formatText: {
				type: Function,
				default: void 0
			},
			status: {
				type: String
			},
			showText: Boolean
		},
		setup(o) {
			const s = getPrefixCls("progress-line"),
				a = computed(() => o.strokeWidth !== 4 ? o.strokeWidth : DEFAULT_STROKE_WIDTH$1[o.size]),
				l = computed(() => `${index.times(o.percent,100)}%`),
				c = computed(() => ({
					width: o.width,
					height: `${a.value}px`,
					backgroundColor: o.trackColor
				})),
				d = computed(() => ({
					width: `${o.percent*100}%`,
					...getBackground(o.color)
				}));
			return {
				prefixCls: s,
				style: c,
				barStyle: d,
				text: l
			}
		}
	}),
	_hoisted_1$s = ["aria-valuenow"];

function _sfc_render$U(o, s, a, l, c, d) {
	const f = resolveComponent("icon-exclamation-circle-fill");
	return openBlock(), createElementBlock("div", {
		role: "progressbar",
		"aria-valuemin": "0",
		"aria-valuemax": "100",
		"aria-valuenow": o.percent,
		class: normalizeClass(`${o.prefixCls}-wrapper`)
	}, [createBaseVNode("div", {
		class: normalizeClass(o.prefixCls),
		style: normalizeStyle(o.style)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-bar-buffer`)
	}, null, 2), createBaseVNode("div", {
		class: normalizeClass([`${o.prefixCls}-bar`]),
		style: normalizeStyle(o.barStyle)
	}, null, 6)], 6), o.showText ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-text`)
	}, [renderSlot(o.$slots, "text", {
		percent: o.percent
	}, () => [createTextVNode(toDisplayString(o.text) + " ", 1), o.status === "danger" ? (
		openBlock(), createBlock(f, {
			key: 0
		})) : createCommentVNode("v-if", !0)])], 2)) : createCommentVNode("v-if", !0)], 10, _hoisted_1$s)
}
var ProgressLine = _export_sfc$1(_sfc_main$1a, [
	["render", _sfc_render$U]
]);
const _sfc_main$19 = defineComponent({
		name: "IconExclamation",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-exclamation`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$r = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$T(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M23 9h2v21h-2z"
	}, null, -1), createBaseVNode("path", {
		fill: "currentColor",
		stroke: "none",
		d: "M23 9h2v21h-2z"
	}, null, -1), createBaseVNode("path", {
		d: "M23 37h2v2h-2z"
	}, null, -1), createBaseVNode("path", {
		fill: "currentColor",
		stroke: "none",
		d: "M23 37h2v2h-2z"
	}, null, -1)]), 14, _hoisted_1$r)
}
var _IconExclamation = _export_sfc$1(_sfc_main$19, [
	["render", _sfc_render$T]
]);
const IconExclamation = Object.assign(_IconExclamation, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconExclamation.name, _IconExclamation)
		}
	}),
	_sfc_main$18 = defineComponent({
		name: "IconCheck",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-check`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$q = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$S(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M41.678 11.05 19.05 33.678 6.322 20.95"
	}, null, -1)]), 14, _hoisted_1$q)
}
var _IconCheck = _export_sfc$1(_sfc_main$18, [
	["render", _sfc_render$S]
]);
const IconCheck = Object.assign(_IconCheck, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconCheck.name, _IconCheck)
	}
});
let __ARCO_PROGRESS_SEED = 0;
const DEFAULT_WIDTH = {
		mini: 16,
		small: 48,
		medium: 64,
		large: 80
	},
	DEFAULT_STROKE_WIDTH = {
		mini: 4,
		small: 3,
		medium: 4,
		large: 4
	},
	_sfc_main$17 = defineComponent({
		name: "ProgressCircle",
		components: {
			IconExclamation,
			IconCheck
		},
		props: {
			percent: {
				type: Number,
				default: 0
			},
			type: {
				type: String
			},
			size: {
				type: String,
				default: "medium"
			},
			strokeWidth: {
				type: Number
			},
			width: {
				type: Number,
				default: void 0
			},
			color: {
				type: [String, Object],
				default: void 0
			},
			trackColor: String,
			status: {
				type: String,
				default: void 0
			},
			showText: {
				type: Boolean,
				default: !0
			},
			pathStrokeWidth: {
				type: Number
			}
		},
		setup(o) {
			const s = getPrefixCls("progress-circle"),
				a = isObject$2(o.color),
				l = computed(() => {
					var b;
					return (b = o.width) != null ? b : DEFAULT_WIDTH[o.size]
				}),
				c = computed(() => {
					var b;
					return (b = o.strokeWidth) != null ? b : o.size === "mini" ? l.value / 2 :
						DEFAULT_STROKE_WIDTH[o.size]
				}),
				d = computed(() => {
					var b;
					return (b = o.pathStrokeWidth) != null ? b : o.size === "mini" ? c.value : Math.max(2, c
						.value - 2)
				}),
				f = computed(() => (l.value - c.value) / 2),
				m = computed(() => Math.PI * 2 * f.value),
				g = computed(() => l.value / 2),
				v = computed(() => (__ARCO_PROGRESS_SEED += 1, `${s}-linear-gradient-${__ARCO_PROGRESS_SEED}`)),
				y = computed(() => `${index.times(o.percent,100)}%`);
			return {
				prefixCls: s,
				isLinearGradient: a,
				radius: f,
				text: y,
				perimeter: m,
				center: g,
				mergedWidth: l,
				mergedStrokeWidth: c,
				mergedPathStrokeWidth: d,
				linearGradientId: v
			}
		}
	}),
	_hoisted_1$p = ["aria-valuenow"],
	_hoisted_2$2 = ["viewBox"],
	_hoisted_3$1 = {
		key: 0
	},
	_hoisted_4$1 = ["id"],
	_hoisted_5 = ["offset", "stop-color"],
	_hoisted_6 = ["cx", "cy", "r", "stroke-width"],
	_hoisted_7 = ["cx", "cy", "r", "stroke-width"];

function _sfc_render$R(o, s, a, l, c, d) {
	const f = resolveComponent("icon-check"),
		m = resolveComponent("icon-exclamation");
	return openBlock(), createElementBlock("div", {
			role: "progressbar",
			"aria-valuemin": "0",
			"aria-valuemax": "100",
			"aria-valuenow": o.percent,
			class: normalizeClass(`${o.prefixCls}-wrapper`),
			style: normalizeStyle({
				width: `${o.mergedWidth}px`,
				height: `${o.mergedWidth}px`
			})
		}, [o.type === "circle" && o.size === "mini" && o.status === "success" ? (openBlock(), createBlock(f, {
			key: 0,
			style: normalizeStyle({
				fontSize: o.mergedWidth - 2,
				color: o.color
			})
		}, null, 8, ["style"])) : (openBlock(), createElementBlock("svg", {
			key: 1,
			viewBox: `0 0 ${o.mergedWidth} ${o.mergedWidth}`,
			class: normalizeClass(`${o.prefixCls}-svg`)
		}, [o.isLinearGradient ? (openBlock(), createElementBlock("defs", _hoisted_3$1, [
			createBaseVNode("linearGradient", {
				id: o.linearGradientId,
				x1: "0",
				y1: "1",
				x2: "0",
				y2: "0"
			}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(Object
				.keys(o.color), g => (openBlock(), createElementBlock(
					"stop", {
						key: g,
						offset: g,
						"stop-color": o.color[g]
					}, null, 8, _hoisted_5))), 128))], 8, _hoisted_4$1)
		])) : createCommentVNode("v-if", !0), createBaseVNode("circle", {
			class: normalizeClass(`${o.prefixCls}-bg`),
			fill: "none",
			cx: o.center,
			cy: o.center,
			r: o.radius,
			"stroke-width": o.mergedPathStrokeWidth,
			style: normalizeStyle({
				stroke: o.trackColor
			})
		}, null, 14, _hoisted_6), createBaseVNode("circle", {
			class: normalizeClass(`${o.prefixCls}-bar`),
			fill: "none",
			cx: o.center,
			cy: o.center,
			r: o.radius,
			"stroke-width": o.mergedStrokeWidth,
			style: normalizeStyle({
				stroke: o.isLinearGradient ? `url(#${o.linearGradientId})` : o.color,
				strokeDasharray: o.perimeter,
				strokeDashoffset: (o.percent >= 1 ? 0 : 1 - o.percent) * o.perimeter
			})
		}, null, 14, _hoisted_7)], 10, _hoisted_2$2)), o.showText && o.size !== "mini" ? (openBlock(),
			createElementBlock("div", {
				key: 2,
				class: normalizeClass(`${o.prefixCls}-text`)
			}, [renderSlot(o.$slots, "text", {
				percent: o.percent
			}, () => [o.status === "danger" ? (openBlock(), createBlock(m, {
				key: 0
			})) : o.status === "success" ? (openBlock(), createBlock(f, {
				key: 1
			})) : (openBlock(), createElementBlock(Fragment, {
				key: 2
			}, [createTextVNode(toDisplayString(o.text), 1)], 64))])], 2)) : createCommentVNode("v-if", !0)], 14,
		_hoisted_1$p)
}
var ProgressCircle = _export_sfc$1(_sfc_main$17, [
	["render", _sfc_render$R]
]);
const _sfc_main$16 = defineComponent({
		name: "ProgressSteps",
		components: {
			IconExclamationCircleFill
		},
		props: {
			steps: {
				type: Number,
				default: 0
			},
			percent: {
				type: Number,
				default: 0
			},
			size: {
				type: String
			},
			color: {
				type: [String, Object],
				default: void 0
			},
			trackColor: String,
			strokeWidth: {
				type: Number
			},
			status: {
				type: String,
				default: void 0
			},
			showText: {
				type: Boolean,
				default: !0
			}
		},
		setup(o) {
			const s = getPrefixCls("progress-steps"),
				a = computed(() => {
					var d;
					return ((d = o.strokeWidth) != null ? d : o.size === "small") ? 8 : 4
				}),
				l = computed(() => [...Array(o.steps)].map((d, f) => o.percent > 0 && o.percent > 1 / o.steps * f)),
				c = computed(() => `${index.times(o.percent,100)}%`);
			return {
				prefixCls: s,
				stepList: l,
				mergedStrokeWidth: a,
				text: c
			}
		}
	}),
	_hoisted_1$o = ["aria-valuenow"];

function _sfc_render$Q(o, s, a, l, c, d) {
	const f = resolveComponent("icon-exclamation-circle-fill");
	return openBlock(), createElementBlock("div", {
		role: "progressbar",
		"aria-valuemin": "0",
		"aria-valuemax": "100",
		"aria-valuenow": o.percent,
		class: normalizeClass(`${o.prefixCls}-wrapper`)
	}, [createBaseVNode("div", {
		class: normalizeClass(o.prefixCls),
		style: normalizeStyle({
			height: `${o.mergedStrokeWidth}px`
		})
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.stepList, (m, g) => (
	openBlock(), createElementBlock("div", {
			key: g,
			class: normalizeClass([`${o.prefixCls}-item`, {
				[`${o.prefixCls}-item-active`]: m
			}]),
			style: normalizeStyle({
				backgroundColor: m ? o.color : o.trackColor
			})
		}, null, 6))), 128))], 6), o.showText ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-text`)
	}, [renderSlot(o.$slots, "text", {
		percent: o.percent
	}, () => [createTextVNode(toDisplayString(o.text) + " ", 1), o.status === "danger" ? (
		openBlock(), createBlock(f, {
			key: 0
		})) : createCommentVNode("v-if", !0)])], 2)) : createCommentVNode("v-if", !0)], 10, _hoisted_1$o)
}
var ProgressSteps = _export_sfc$1(_sfc_main$16, [
	["render", _sfc_render$Q]
]);
const _sfc_main$15 = defineComponent({
	name: "Progress",
	components: {
		ProgressLine,
		ProgressCircle,
		ProgressSteps
	},
	props: {
		type: {
			type: String,
			default: "line"
		},
		size: {
			type: String
		},
		percent: {
			type: Number,
			default: 0
		},
		steps: {
			type: Number,
			default: 0
		},
		animation: {
			type: Boolean,
			default: !1
		},
		strokeWidth: {
			type: Number
		},
		width: {
			type: [Number, String]
		},
		color: {
			type: [String, Object]
		},
		trackColor: String,
		bufferColor: {
			type: [String, Object]
		},
		showText: {
			type: Boolean,
			default: !0
		},
		status: {
			type: String
		}
	},
	setup(o) {
		const s = getPrefixCls("progress"),
			{
				size: a
			} = toRefs(o),
			l = computed(() => o.steps > 0 ? "steps" : o.type),
			c = computed(() => o.status || (o.percent >= 1 ? "success" : "normal")),
			{
				mergedSize: d
			} = useSize$1(a);
		return {
			cls: computed(() => [s, `${s}-type-${l.value}`, `${s}-size-${d.value}`, `${s}-status-${c.value}`]),
			computedStatus: c,
			mergedSize: d
		}
	}
});

function _sfc_render$P(o, s, a, l, c, d) {
	const f = resolveComponent("progress-steps"),
		m = resolveComponent("progress-line"),
		g = resolveComponent("progress-circle");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [o.steps > 0 ? (openBlock(), createBlock(f, {
		key: 0,
		"stroke-width": o.strokeWidth,
		percent: o.percent,
		color: o.color,
		"track-color": o.trackColor,
		width: o.width,
		steps: o.steps,
		size: o.mergedSize,
		"show-text": o.showText
	}, createSlots({
		_: 2
	}, [o.$slots.text ? {
		name: "text",
		fn: withCtx(v => [renderSlot(o.$slots, "text", normalizeProps(guardReactiveProps(
			v)))]),
		key: "0"
	} : void 0]), 1032, ["stroke-width", "percent", "color", "track-color", "width", "steps",
		"size", "show-text"
	])) : o.type === "line" && o.mergedSize !== "mini" ? (openBlock(), createBlock(m, {
		key: 1,
		"stroke-width": o.strokeWidth,
		animation: o.animation,
		percent: o.percent,
		color: o.color,
		"track-color": o.trackColor,
		size: o.mergedSize,
		"buffer-color": o.bufferColor,
		width: o.width,
		"show-text": o.showText,
		status: o.computedStatus
	}, createSlots({
		_: 2
	}, [o.$slots.text ? {
		name: "text",
		fn: withCtx(v => [renderSlot(o.$slots, "text", normalizeProps(guardReactiveProps(
			v)))]),
		key: "0"
	} : void 0]), 1032, ["stroke-width", "animation", "percent", "color", "track-color", "size",
		"buffer-color", "width", "show-text", "status"
	])) : (openBlock(), createBlock(g, {
		key: 2,
		type: o.type,
		"stroke-width": o.type === "line" ? o.strokeWidth || 4 : o.strokeWidth,
		"path-stroke-width": o.type === "line" ? o.strokeWidth || 4 : o.strokeWidth,
		width: o.width,
		percent: o.percent,
		color: o.color,
		"track-color": o.trackColor,
		size: o.mergedSize,
		"show-text": o.showText,
		status: o.computedStatus
	}, createSlots({
		_: 2
	}, [o.$slots.text ? {
		name: "text",
		fn: withCtx(v => [renderSlot(o.$slots, "text", normalizeProps(guardReactiveProps(
			v)))]),
		key: "0"
	} : void 0]), 1032, ["type", "stroke-width", "path-stroke-width", "width", "percent", "color",
		"track-color", "size", "show-text", "status"
	]))], 2)
}
var _Progress = _export_sfc$1(_sfc_main$15, [
	["render", _sfc_render$P]
]);
const Progress = Object.assign(_Progress, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Progress.name, _Progress)
		}
	}),
	_sfc_main$14 = defineComponent({
		name: "IconStarFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-star-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$n = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$O(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M22.683 5.415c.568-1.043 2.065-1.043 2.634 0l5.507 10.098a1.5 1.5 0 0 0 1.04.756l11.306 2.117c1.168.219 1.63 1.642.814 2.505l-7.902 8.359a1.5 1.5 0 0 0-.397 1.223l1.48 11.407c.153 1.177-1.058 2.057-2.131 1.548l-10.391-4.933a1.5 1.5 0 0 0-1.287 0l-10.39 4.933c-1.073.51-2.284-.37-2.131-1.548l1.48-11.407a1.5 1.5 0 0 0-.398-1.223L4.015 20.89c-.816-.863-.353-2.286.814-2.505l11.306-2.117a1.5 1.5 0 0 0 1.04-.756l5.508-10.098Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$n)
}
var _IconStarFill = _export_sfc$1(_sfc_main$14, [
	["render", _sfc_render$O]
]);
const IconStarFill = Object.assign(_IconStarFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconStarFill.name, _IconStarFill)
		}
	}),
	_sfc_main$13 = defineComponent({
		name: "IconFaceMehFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-face-meh-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$m = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$N(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM15.999 30a2 2 0 0 1 2-2h12a2 2 0 1 1 0 4H18a2 2 0 0 1-2-2Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$m)
}
var _IconFaceMehFill = _export_sfc$1(_sfc_main$13, [
	["render", _sfc_render$N]
]);
const IconFaceMehFill = Object.assign(_IconFaceMehFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconFaceMehFill.name, _IconFaceMehFill)
		}
	}),
	_sfc_main$12 = defineComponent({
		name: "IconFaceSmileFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-face-smile-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$l = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$M(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-.355 9.953a1.91 1.91 0 0 1 2.694.177 6.66 6.66 0 0 0 5.026 2.279c1.918 0 3.7-.81 4.961-2.206a1.91 1.91 0 0 1 2.834 2.558 10.476 10.476 0 0 1-7.795 3.466 10.477 10.477 0 0 1-7.897-3.58 1.91 1.91 0 0 1 .177-2.694Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$l)
}
var _IconFaceSmileFill = _export_sfc$1(_sfc_main$12, [
	["render", _sfc_render$M]
]);
const IconFaceSmileFill = Object.assign(_IconFaceSmileFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconFaceSmileFill.name, _IconFaceSmileFill)
		}
	}),
	_sfc_main$11 = defineComponent({
		name: "IconFaceFrownFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-face-frown-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$k = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$L(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.322-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM31.68 32.88a1.91 1.91 0 0 1-2.694-.176 6.66 6.66 0 0 0-5.026-2.28c-1.918 0-3.701.81-4.962 2.207a1.91 1.91 0 0 1-2.834-2.559 10.476 10.476 0 0 1 7.796-3.465c3.063 0 5.916 1.321 7.896 3.58a1.909 1.909 0 0 1-.176 2.693Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$k)
}
var _IconFaceFrownFill = _export_sfc$1(_sfc_main$11, [
	["render", _sfc_render$L]
]);
const IconFaceFrownFill = Object.assign(_IconFaceFrownFill, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconFaceFrownFill.name, _IconFaceFrownFill)
	}
});
var _Rate = defineComponent({
	name: "Rate",
	props: {
		count: {
			type: Number,
			default: 5
		},
		modelValue: {
			type: Number,
			default: void 0
		},
		defaultValue: {
			type: Number,
			default: 0
		},
		allowHalf: {
			type: Boolean,
			default: !1
		},
		allowClear: {
			type: Boolean,
			default: !1
		},
		grading: {
			type: Boolean,
			default: !1
		},
		readonly: {
			type: Boolean,
			default: !1
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		color: {
			type: [String, Object]
		}
	},
	emits: {
		"update:modelValue": o => !0,
		change: o => !0,
		hoverChange: o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			modelValue: l
		} = toRefs(o), c = getPrefixCls("rate"), {
			mergedDisabled: d,
			eventHandlers: f
		} = useFormItem({
			disabled: toRef(o, "disabled")
		}), m = ref(o.defaultValue), g = ref(!1);
		watch(l, U => {
			(isUndefined$1(U) || isNull$1(U)) && (m.value = 0)
		});
		const v = ref(0),
			y = computed(() => {
				var U;
				return (U = o.modelValue) != null ? U : m.value
			}),
			b = computed(() => {
				const U = o.allowHalf ? index.times(index.round(index.divide(y.value, .5), 0), .5) : Math
					.round(y.value);
				return v.value || U
			}),
			C = computed(() => d.value || o.readonly),
			_ = computed(() => [...Array(o.grading ? 5 : o.count)]),
			S = computed(() => {
				var U;
				if (isString$2(o.color)) return _.value.map(() => o.color);
				if (isObject$2(o.color)) {
					const V = Object.keys(o.color).map(j => Number(j)).sort((j, ge) => ge - j);
					let z = (U = V.pop()) != null ? U : _.value.length;
					return _.value.map((j, ge) => {
						var me;
						return ge + 1 > z && (z = (me = V.pop()) != null ? me : z), o.color[String(
							z)]
					})
				}
			}),
			w = () => {
				v.value && (v.value = 0, s("hoverChange", 0))
			},
			T = (U, V) => {
				const z = V && o.allowHalf ? U + .5 : U + 1;
				z !== v.value && (v.value = z, s("hoverChange", z))
			},
			A = (U, V) => {
				var z, j, ge, me;
				const he = V && o.allowHalf ? U + .5 : U + 1;
				g.value = !0, he !== y.value ? (m.value = he, s("update:modelValue", he), s("change", he), (j =
					(z = f.value) == null ? void 0 : z.onChange) == null || j.call(z)) : o.allowClear && (m
					.value = 0, s("update:modelValue", 0), s("change", 0), (me = (ge = f.value) == null ?
						void 0 : ge.onChange) == null || me.call(ge))
			},
			k = U => {
				g.value && U + 1 >= y.value - 1 && (g.value = !1)
			},
			M = (U, V) => U > V ? createVNode(IconFaceMehFill, null, null) : V <= 2 ? createVNode(
				IconFaceFrownFill, null, null) : V <= 3 ? createVNode(IconFaceMehFill, null, null) :
			createVNode(IconFaceSmileFill, null, null),
			D = (U, V = !1) => ({
				role: "radio",
				"aria-checked": U + (V ? .5 : 1) <= y.value,
				"aria-setsize": _.value.length,
				"aria-posinset": U + (V ? .5 : 1)
			}),
			F = U => o.grading ? M(U, b.value) : a.character ? a.character({
				index: U
			}) : createVNode(IconStarFill, null, null),
			R = U => {
				const V = C.value ? {} : {
						onMouseenter: () => T(U, !0),
						onClick: () => A(U, !0)
					},
					z = C.value ? {} : {
						onMouseenter: () => T(U, !1),
						onClick: () => A(U, !1)
					},
					j = g.value ? {
						animationDelay: `${50*U}ms`
					} : void 0,
					ge = Math.ceil(b.value) - 1,
					me = S.value && o.allowHalf && U + .5 === b.value ? {
						color: S.value[ge]
					} : void 0,
					he = S.value && U + 1 <= b.value ? {
						color: S.value[ge]
					} : void 0,
					ce = [`${c}-character`, {
						[`${c}-character-half`]: o.allowHalf && U + .5 === b.value,
						[`${c}-character-full`]: U + 1 <= b.value,
						[`${c}-character-scale`]: g.value && U + 1 < y.value
					}];
				return createVNode("div", mergeProps({
					class: ce,
					style: j
				}, o.allowHalf ? void 0 : D(U), {
					onAnimationend: () => k(U)
				}), [createVNode("div", mergeProps({
					class: `${c}-character-left`,
					style: me
				}, V, o.allowHalf ? D(U, !0) : void 0), [F(U)]), createVNode("div", mergeProps({
					class: `${c}-character-right`,
					style: he
				}, z, o.allowHalf ? D(U) : void 0), [F(U)])])
			},
			O = computed(() => [c, {
				[`${c}-readonly`]: o.readonly,
				[`${c}-disabled`]: d.value
			}]);
		return () => createVNode("div", {
			class: O.value,
			onMouseleave: w
		}, [_.value.map((U, V) => R(V))])
	}
});
const Rate = Object.assign(_Rate, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Rate.name, _Rate)
		}
	}),
	_sfc_main$10 = defineComponent({
		name: "IconInfo",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-info`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$j = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$K(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M25 39h-2V18h2z"
	}, null, -1), createBaseVNode("path", {
		fill: "currentColor",
		stroke: "none",
		d: "M25 39h-2V18h2z"
	}, null, -1), createBaseVNode("path", {
		d: "M25 11h-2V9h2z"
	}, null, -1), createBaseVNode("path", {
		fill: "currentColor",
		stroke: "none",
		d: "M25 11h-2V9h2z"
	}, null, -1)]), 14, _hoisted_1$j)
}
var _IconInfo = _export_sfc$1(_sfc_main$10, [
	["render", _sfc_render$K]
]);
const IconInfo = Object.assign(_IconInfo, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconInfo.name, _IconInfo)
	}
});
var ResultForbidden = defineComponent({
		name: "ResultForbidden",
		render() {
			return createVNode("svg", {
				viewBox: "0 0 213 213",
				height: "100%",
				width: "100%",
				style: {
					fillRule: "evenodd",
					clipRule: "evenodd",
					strokeLinejoin: "round",
					strokeMiterlimit: 2
				}
			}, [createVNode("g", {
				transform: "matrix(1,0,0,1,-871.485,-445.62)"
			}, [createVNode("g", null, [createVNode("g", {
				transform: "matrix(1,0,0,1,-75.2684,-87.3801)"
			}, [createVNode("circle", {
				cx: "1053.23",
				cy: "639.477",
				r: "106.477",
				style: {
					fill: "rgb(235, 238, 246)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1,0,0,1,246.523,295.575)"
			}, [createVNode("g", {
				transform: "matrix(0.316667,0,0,0.316667,277.545,71.0298)"
			}, [createVNode("g", {
				transform: "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(253, 243, 228)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(202, 174, 136)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(102, 102, 102)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
			}, [createVNode("g", {
				transform: "matrix(1,0,0,1,-6,-6)"
			}, [createVNode("path", {
				d: "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
				style: {
					fill: "white"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
			}, [createVNode("rect", {
				x: "1748.87",
				y: "1226.67",
				width: "10.895",
				height: "13.378",
				style: {
					fill: "rgb(132, 97, 0)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.182997,0.105653,-0.494902,0.285732,814.161,66.3087)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fillOpacity: .1
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.316667,0,0,0.316667,237.301,94.2647)"
			}, [createVNode("g", {
				transform: "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(253, 243, 228)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(202, 174, 136)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(102, 102, 102)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
			}, [createVNode("g", {
				transform: "matrix(1,0,0,1,-6,-6)"
			}, [createVNode("path", {
				d: "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
				style: {
					fill: "white"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
			}, [createVNode("rect", {
				x: "1748.87",
				y: "1226.67",
				width: "10.895",
				height: "13.378",
				style: {
					fill: "rgb(132, 97, 0)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.474953,0,0,0.474953,538.938,8.95289)"
			}, [createVNode("g", {
				transform: "matrix(0.180615,0.104278,-0.973879,0.562269,790.347,286.159)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fillOpacity: .1
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.473356,0,0,0.473356,294.481,129.741)"
			}, [createVNode("g", null, [createVNode("g", {
				transform: "matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)"
			}, [createVNode("rect", {
				x: "202.62",
				y: "575.419",
				width: "124.002",
				height: "259.402",
				style: {
					fill: "rgb(235, 235, 235)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(34, 34, 34)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)"
			}, [createVNode("rect", {
				x: "202.62",
				y: "575.419",
				width: "124.002",
				height: "259.402",
				style: {
					fill: "rgb(51, 51, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(102, 102, 102)"
				}
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.473356,0,0,0.473356,192.621,188.549)"
			}, [createVNode("g", null, [createVNode("g", {
				transform: "matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)"
			}, [createVNode("rect", {
				x: "202.62",
				y: "575.419",
				width: "124.002",
				height: "259.402",
				style: {
					fill: "rgb(235, 235, 235)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(34, 34, 34)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)"
			}, [createVNode("rect", {
				x: "202.62",
				y: "575.419",
				width: "124.002",
				height: "259.402",
				style: {
					fill: "rgb(51, 51, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(102, 102, 102)"
				}
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.668111,0,0,0.668111,-123.979,-49.2109)"
			}, [createVNode("g", {
				transform: "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(235, 235, 235)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(235, 235, 235)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(102, 102, 102)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(51, 51, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(34, 34, 34)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.668111,0,0,0.668111,-123.979,-91.97)"
			}, [createVNode("g", {
				transform: "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(235, 235, 235)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(235, 235, 235)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(102, 102, 102)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(51, 51, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fill: "rgb(34, 34, 34)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)"
			}, [createVNode("rect", {
				x: "831",
				y: "1023.79",
				width: "89.214",
				height: "89.214",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.701585,5.16096e-35,-5.16096e-35,0.701585,-546.219,-21.3487)"
			}, [createVNode("g", {
				transform: "matrix(0.558202,-0.322278,0,0.882275,1033.27,615.815)"
			}, [createVNode("path", {
				d: "M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z",
				style: {
					fill: "white"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.558202,-0.322278,0,0.882275,1035.25,616.977)"
			}, [createVNode("path", {
				d: "M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z",
				style: {
					fill: "white"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1,0,0,1,418.673,507.243)"
			}, [createVNode("path", {
				d: "M1088.34,192.063C1089.79,191.209 1090.78,191.821 1090.78,191.821L1092.71,192.944C1092.71,192.944 1092.29,192.721 1091.7,192.763C1090.99,192.813 1090.34,193.215 1090.34,193.215C1090.34,193.215 1088.85,192.362 1088.34,192.063Z",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1,0,0,1,235.984,-39.1315)"
			}, [createVNode("path", {
				d: "M1164.02,805.247C1164.05,802.517 1165.64,799.379 1167.67,798.118L1169.67,799.272C1167.58,800.648 1166.09,803.702 1166.02,806.402L1164.02,805.247Z",
				style: {
					fill: "url(#_Linear1)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.396683,0,0,0.396683,1000.22,516.921)"
			}, [createVNode("path", {
				d: "M1011.2,933.14C1009.31,932.075 1008.05,929.696 1007.83,926.324L1012.87,929.235C1012.87,929.235 1012.96,930.191 1013.04,930.698C1013.16,931.427 1013.42,932.344 1013.62,932.845C1013.79,933.255 1014.59,935.155 1016.22,936.046C1015.83,935.781 1011.19,933.139 1011.19,933.139L1011.2,933.14Z",
				style: {
					fill: "rgb(238, 238, 238)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.253614,-0.146424,4.87691e-17,0.338152,1209.98,830.02)"
			}, [createVNode("circle", {
				cx: "975.681",
				cy: "316.681",
				r: "113.681",
				style: {
					fill: "rgb(245, 63, 63)"
				}
			}, null), createVNode("g", {
				transform: "matrix(1.08844,0,0,0.61677,-99.9184,125.436)"
			}, [createVNode("path", {
				d: "M1062,297.556C1062,296.697 1061.61,296 1061.12,296L915.882,296C915.395,296 915,296.697 915,297.556L915,333.356C915,334.215 915.395,334.912 915.882,334.912L1061.12,334.912C1061.61,334.912 1062,334.215 1062,333.356L1062,297.556Z",
				style: {
					fill: "white"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(5.57947,-3.22131,0.306277,0.176829,-6260.71,4938.32)"
			}, [createVNode("rect", {
				x: "1335.54",
				y: "694.688",
				width: "18.525",
				height: "6.511",
				style: {
					fill: "rgb(248, 248, 248)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.10726,0.0619268,-1.83335e-14,18.1609,1256.76,-11932.8)"
			}, [createVNode("rect", {
				x: "1335.54",
				y: "694.688",
				width: "18.525",
				height: "6.511",
				style: {
					fill: "rgb(238, 238, 238)"
				}
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.316667,0,0,0.316667,269.139,37.8829)"
			}, [createVNode("g", {
				transform: "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(253, 243, 228)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(202, 174, 136)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(102, 102, 102)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
			}, [createVNode("g", {
				transform: "matrix(1,0,0,1,-6,-6)"
			}, [createVNode("path", {
				d: "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
				style: {
					fill: "white"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
			}, [createVNode("rect", {
				x: "1748.87",
				y: "1226.67",
				width: "10.895",
				height: "13.378",
				style: {
					fill: "rgb(132, 97, 0)"
				}
			}, null)])])])])]), createVNode("defs", null, [createVNode("linearGradient", {
				id: "_Linear1",
				x1: "0",
				y1: "0",
				x2: "1",
				y2: "0",
				gradientUnits: "userSpaceOnUse",
				gradientTransform: "matrix(-2.64571,4.04098,-4.04098,-2.64571,1167.67,799.269)"
			}, [createVNode("stop", {
				offset: "0",
				style: {
					stopColor: "rgb(248, 248, 248)",
					stopOpacity: 1
				}
			}, null), createVNode("stop", {
				offset: "1",
				style: {
					stopColor: "rgb(248, 248, 248)",
					stopOpacity: 1
				}
			}, null)])])])
		}
	}),
	ResultNotFound = defineComponent({
		name: "ResultNotFound",
		render() {
			return createVNode("svg", {
				width: "100%",
				height: "100%",
				viewBox: "0 0 213 213",
				style: {
					fillRule: "evenodd",
					clipRule: "evenodd",
					strokeLinejoin: "round",
					strokeMiterlimit: 2
				}
			}, [createVNode("g", {
				transform: "matrix(1,0,0,1,-1241.95,-445.62)"
			}, [createVNode("g", null, [createVNode("g", {
				transform: "matrix(1,0,0,1,295.2,-87.3801)"
			}, [createVNode("circle", {
				cx: "1053.23",
				cy: "639.477",
				r: "106.477",
				style: {
					fill: "rgb(235, 238, 246)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.38223,0,0,0.38223,1126.12,238.549)"
			}, [createVNode("g", {
				transform: "matrix(0.566536,0.327089,-1.28774,0.74348,763.4,317.171)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fillOpacity: .1
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.29595,0.170867,-0.91077,0.525833,873.797,588.624)"
			}, [createVNode("rect", {
				x: "657.012",
				y: "404.643",
				width: "198.586",
				height: "145.08",
				style: {
					fillOpacity: .1
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1,0,0,1,275,-15)"
			}, [createVNode("path", {
				d: "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null), createVNode("g", {
				transform: "matrix(0.866025,-0.5,1,0.57735,0,-45)"
			}, [createVNode("ellipse", {
				cx: "-848.416",
				cy: "1004.25",
				rx: "6.062",
				ry: "5.25",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(1,0,0,1,183.952,-67.5665)"
			}, [createVNode("path", {
				d: "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null), createVNode("g", {
				transform: "matrix(0.866025,-0.5,1,0.57735,0,-45)"
			}, [createVNode("ellipse", {
				cx: "-848.416",
				cy: "1004.25",
				rx: "6.062",
				ry: "5.25",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(1,0,0,1,414,-95.2517)"
			}, [createVNode("path", {
				d: "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null), createVNode("g", {
				transform: "matrix(0.866025,-0.5,1,0.57735,0,-45)"
			}, [createVNode("ellipse", {
				cx: "-848.416",
				cy: "1004.25",
				rx: "6.062",
				ry: "5.25",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(1,0,0,1,322.952,-147.818)"
			}, [createVNode("path", {
				d: "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null), createVNode("g", {
				transform: "matrix(0.866025,-0.5,1,0.57735,0,-45)"
			}, [createVNode("ellipse", {
				cx: "-848.416",
				cy: "1004.25",
				rx: "6.062",
				ry: "5.25",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)])]), createVNode("g", null, [createVNode("g", {
				transform: "matrix(1.42334,-0.821763,1.11271,0.642426,-1439.64,459.621)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(253, 243, 228)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.40786,-0.812831,6.60237e-16,1.99081,-2052.17,-84.7286)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.26159,-0.728382,5.91642e-16,1.78397,-1774.67,11.2303)"
			}, [createVNode("path", {
				d: "M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z",
				style: {
					fill: "rgb(132, 97, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.2198,-0.704254,5.72043e-16,1.72488,-1697.6,37.2103)"
			}, [createVNode("path", {
				d: "M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.707187,0.408295,9.06119e-17,1.54833,-733.949,683.612)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(253, 243, 228)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.74666,0.431085,2.3583e-17,0.135259,-816.63,57.1397)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(253, 243, 228)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.750082,0,0,0.750082,163.491,354.191)"
			}, [createVNode("g", {
				transform: "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(132, 97, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(246, 220, 185)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.750082,0,0,0.750082,163.491,309.191)"
			}, [createVNode("g", {
				transform: "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(132, 97, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(246, 220, 185)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)])]), createVNode("g", {
				transform: "matrix(0.750082,0,0,0.750082,163.491,263.931)"
			}, [createVNode("g", {
				transform: "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(132, 97, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(246, 220, 185)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)])]), createVNode("path", {
				d: "M555.753,832.474L555.753,921.408L630.693,878.141L630.693,789.207L555.753,832.474Z",
				style: {
					fillOpacity: .1
				}
			}, null), createVNode("g", {
				transform: "matrix(0.750082,0,0,0.750082,236.431,272.852)"
			}, [createVNode("g", {
				transform: "matrix(1.64553,-0.950049,1.14552,0.661368,-1606.78,467.933)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(253, 243, 228)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.54477,-0.891873,1.05847,0.611108,-1456.84,490.734)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(132, 97, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.27607,-0.736739,0.751435,0.433841,-970.952,617.519)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.728038,0.420333,3.52595e-17,0.377589,-790.978,151.274)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2726.83,1873.38)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", null, [createVNode(
			"g", {
				transform: "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(132, 97, 51)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
			}, [createVNode("path", {
				d: "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
				style: {
					fill: "rgb(246, 220, 185)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
			}, [createVNode("rect", {
				x: "495.52",
				y: "1057.87",
				width: "105.078",
				height: "91",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
			}, [createVNode("rect", {
				x: "1663.92",
				y: "-407.511",
				width: "143.183",
				height: "118.292",
				style: {
					fill: "rgb(240, 218, 183)"
				}
			}, null)])])]), createVNode("g", {
				transform: "matrix(1.62765,-0.939723,4.80984e-17,0.173913,-2468.81,2307.87)"
			}, [createVNode("rect", {
				x: "1844.06",
				y: "1192.54",
				width: "106.232",
				height: "92",
				style: {
					fill: "rgb(196, 173, 142)"
				}
			}, null)])]), createVNode("g", null, [createVNode("g", {
				transform: "matrix(0.479077,0.276595,-0.564376,0.325843,598.357,-129.986)"
			}, [createVNode("path", {
				d: "M1776.14,1326C1776.14,1321.19 1772.15,1317.28 1767.24,1317.28L1684.37,1317.28C1679.46,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.46,1404.46 1684.37,1404.46L1767.24,1404.46C1772.15,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z",
				style: {
					fill: "white"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(2.61622,0,0,2.61622,-2305.73,162.161)"
			}, [createVNode("g", {
				transform: "matrix(1.09915,-0.634597,1.26919,0.73277,-299.167,-62.4615)"
			}, [createVNode("ellipse", {
				cx: "412.719",
				cy: "770.575",
				rx: "6.303",
				ry: "5.459",
				style: {
					fill: "rgb(255, 125, 0)"
				}
			}, null)]), createVNode("g", {
				transform: "matrix(0.238212,-0.137532,0.178659,0.103149,875.064,207.93)"
			}, [createVNode("text", {
				x: "413.474px",
				y: "892.067px",
				style: {
					fontFamily: "NunitoSans-Bold, Nunito Sans",
					fontWeight: 700,
					fontSize: 41.569,
					fill: "white"
				}
			}, [createTextVNode("?")])])])])])])])])
		}
	}),
	ResultServerError = defineComponent({
		name: "ResultServerError",
		render() {
			return createVNode("svg", {
				width: "100%",
				height: "100%",
				viewBox: "0 0 213 213",
				style: "fill-rule: evenodd; clip-rule: evenodd; stroke-linejoin: round; stroke-miterlimit: 2;"
			}, [createVNode("g", {
				transform: "matrix(1,0,0,1,-483.054,-445.448)"
			}, [createVNode("g", null, [createVNode("g", {
				transform: "matrix(1,0,0,1,-463.699,-87.5516)"
			}, [createVNode("circle", {
				cx: "1053.23",
				cy: "639.477",
				r: "106.477",
				style: "fill: rgb(235, 238, 246);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,260.021)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill-opacity: 0.1;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,218.845)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,238.807)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill: rgb(0, 85, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,257.804)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill: rgb(29, 105, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.428916,0,0,0.428916,19.0588,329.956)"
			}, [createVNode("clipPath", {
				id: "_clip1"
			}, [createVNode("path", {
				d: "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip1)"
			}, [createVNode("g", {
				transform: "matrix(2.33146,-0,-0,2.33146,1081.79,269.266)"
			}, [createVNode("use", {
				href: "#_Image2",
				x: "50.54",
				y: "112.301",
				width: "112.406px",
				height: "46.365px",
				transform: "matrix(0.99474,0,0,0.98649,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,265.448)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,268.45)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,271.452)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,124.262)"
			}, [createVNode("rect", {
				x: "1621.2",
				y: "1370.57",
				width: "57.735",
				height: "5.947",
				style: "fill: rgb(106, 161, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,420.796)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,419.062)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,417.329)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,415.595)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,413.862)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,196.542)"
			}, [createVNode("clipPath", {
				id: "_clip3"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip3)"
			}, [createVNode("g", {
				transform: "matrix(1.30028,1.12608,-2.25216,1.95042,68.2716,1030.07)"
			}, [createVNode("use", {
				href: "#_Image4",
				x: "50.54",
				y: "56.312",
				width: "112.406px",
				height: "64.897px",
				transform: "matrix(0.99474,0,0,0.998422,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,216.764)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill: rgb(0, 85, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,235.762)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill: rgb(29, 105, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.428916,0,0,0.428916,19.0588,307.652)"
			}, [createVNode("clipPath", {
				id: "_clip5"
			}, [createVNode("path", {
				d: "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip5)"
			}, [createVNode("g", {
				transform: "matrix(2.33146,-0,-0,2.33146,1081.79,321.266)"
			}, [createVNode("use", {
				href: "#_Image2",
				x: "50.54",
				y: "89.692",
				width: "112.406px",
				height: "46.365px",
				transform: "matrix(0.99474,0,0,0.98649,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,243.144)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,246.146)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,249.149)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,101.958)"
			}, [createVNode("rect", {
				x: "1621.2",
				y: "1370.57",
				width: "57.735",
				height: "5.947",
				style: "fill: rgb(106, 161, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,398.492)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,396.759)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,395.025)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,393.292)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,391.558)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,171.832)"
			}, [createVNode("clipPath", {
				id: "_clip6"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip6)"
			}, [createVNode("g", {
				transform: "matrix(1.30028,1.12608,-2.25216,1.95042,12.6215,1078.27)"
			}, [createVNode("use", {
				href: "#_Image7",
				x: "50.54",
				y: "31.563",
				width: "112.406px",
				height: "64.897px",
				transform: "matrix(0.99474,0,0,0.998422,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,192.055)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill: rgb(0, 85, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,211.052)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: "fill: rgb(29, 105, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.428916,0,0,0.428916,19.0588,282.943)"
			}, [createVNode("clipPath", {
				id: "_clip8"
			}, [createVNode("path", {
				d: "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip8)"
			}, [createVNode("g", {
				transform: "matrix(2.33146,-0,-0,2.33146,1081.79,378.876)"
			}, [createVNode("use", {
				href: "#_Image2",
				x: "50.54",
				y: "64.644",
				width: "112.406px",
				height: "46.365px",
				transform: "matrix(0.99474,0,0,0.98649,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,218.434)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,221.437)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,224.439)"
			}, [createVNode("path", {
				d: "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,77.2484)"
			}, [createVNode("rect", {
				x: "1621.2",
				y: "1370.57",
				width: "57.735",
				height: "5.947",
				style: "fill: rgb(106, 161, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,373.782)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: white;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,372.049)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,370.316)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,368.582)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,366.849)"
			}, [createVNode("ellipse", {
				cx: "1566.31",
				cy: "1372.3",
				rx: "4",
				ry: "3.464",
				style: "fill: rgb(64, 128, 255);"
			}, null)]), createVNode("g", {
				transform: "matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,185.45)"
			}, [createVNode("clipPath", {
				id: "_clip9"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip9)"
			}, [createVNode("g", {
				transform: "matrix(1.36821,1.1849,-2.36981,2.05231,5.46929,1071.93)"
			}, [createVNode("use", {
				href: "#_Image10",
				x: "53.151",
				y: "30.14",
				width: "106.825px",
				height: "61.676px",
				transform: "matrix(0.998367,0,0,0.994768,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,183.729)"
			}, [createVNode("path", {
				d: "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
				style: 'fill: url("#_Linear11");'
			}, null)]), createVNode("g", {
				transform: "matrix(0.407622,0,0,0.407622,47.38,278)"
			}, [createVNode("clipPath", {
				id: "_clip12"
			}, [createVNode("path", {
				d: "M1461.07,554.317C1461.07,556.747 1459.6,559.067 1456.6,560.8L1342.04,626.943C1335.41,630.767 1323.83,630.287 1316.18,625.871L1205.33,561.871C1201.14,559.456 1199,556.361 1199,553.426L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,554.317Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip12)"
			}, [createVNode("g", {
				transform: "matrix(2.45325,-0,-0,2.45325,1068.82,410.793)"
			}, [createVNode("use", {
				href: "#_Image13",
				x: "53.151",
				y: "58.978",
				width: "106.825px",
				height: "33.517px",
				transform: "matrix(0.998367,0,0,0.985808,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.371452,-0.214458,2.38096e-17,0.495269,-19.3677,248.256)"
			}, [createVNode("clipPath", {
				id: "_clip14"
			}, [createVNode("path", {
				d: "M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z"
			}, null)]), createVNode("g", {
				"clip-path": "url(#_clip14)"
			}, [createVNode("g", {
				transform: "matrix(2.69214,1.16573,-1.29422e-16,2.0191,1352.59,983.841)"
			}, [createVNode("use", {
				href: "#_Image15",
				x: "121.882",
				y: "76.034",
				width: "37.393px",
				height: "61.803px",
				transform: "matrix(0.984021,0,0,0.996825,0,0)"
			}, null)])])]), createVNode("g", {
				transform: "matrix(0.371452,-0.214458,2.38096e-17,0.495269,-15.0786,249.972)"
			}, [createVNode("path", {
				d: "M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z",
				style: "fill: white; stop-opacity: 0.9;"
			}, null)]), createVNode("g", {
				transform: "matrix(0.220199,-0.127132,1.41145e-17,0.293599,339.708,327.53)"
			}, [createVNode("path", {
				d: "M1306.5,1286.73C1307.09,1285.72 1308.6,1285.48 1310.36,1286.12C1312.13,1286.76 1313.84,1288.16 1314.73,1289.7C1326.44,1309.98 1355.4,1360.15 1363.73,1374.57C1364.33,1375.61 1364.49,1376.61 1364.18,1377.35C1363.87,1378.09 1363.11,1378.5 1362.07,1378.5C1346.41,1378.5 1288.17,1378.5 1264.07,1378.5C1262.42,1378.5 1260.37,1377.48 1258.9,1375.94C1257.44,1374.41 1256.88,1372.67 1257.5,1371.6C1268.1,1353.25 1296.8,1303.53 1306.5,1286.73Z"
			}, null)]), createVNode("g", {
				transform: "matrix(0.254264,-0.1468,1.22235e-17,0.254264,329.57,364.144)"
			}, [createVNode("text", {
				x: "1170.88px",
				y: "1451.42px",
				style: 'font-family: NunitoSans-Bold, "Nunito Sans"; font-weight: 700; font-size: 41.569px; fill: white; fill-opacity: 0.9;'
			}, [createTextVNode("!")])])])]), createVNode("defs", null, [createVNode("image", {
				id: "_Image2",
				width: "113px",
				height: "47px",
				href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAAvCAYAAADU+iVXAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABVUlEQVR4nO2aQRKCMAxFxUN4O+9/DNw4CoiTliZN8vPfQlm00ykvP3aQ5fFc11sjy/L+/nx8r3ffm7Fn845jz+aJa23XOJvfs9Zh7NBawv3YrSGtdbj+x10egkFzpRrNt+SSxMgbqkiZJCJDiQDoSmSfdYFJ3JD18GMmcXhDTHUzNZIIXhA1JIJDib0MptqiKbhKzHqQiAaT6IlSFVIiAJQIACUGpLfLhpfIw49Ml8T2v4/JTPySyIJQI3w7JTIYEp2fong3FXWJ3huqCEYSNUlYhZRoyaSCoEQAKHESlqF0kZj9NBgNJhEASgSAEgNx9WfCTmLxpygzYRIBmCORsTIlXxJZED/kk0h+KC1x9E2FKG86qEkMsh8/HG9A6SSGYqAIKDEinUIpUSDDYXiqxAw3JCNMIgDXJTIWYdBJIvukK2ynARit4XASUZ6izCScRFWKCH0BfLM84oTw1Z8AAAAASUVORK5CYII="
			}, null), createVNode("image", {
				id: "_Image4",
				width: "113px",
				height: "65px",
				href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAASeElEQVR4nN2d6ZbcNpKFL5cs9UN1W5bntWxr6XmsWTzLQ7mSJDA/gh/iApWyLalUy+AcnypVJkEAsd24EaQn/T8Yb9+XKknrOuk4pOM4tCyLpkkqpWpZJu170TzPKqVoWWZJUq3Sbx+m6VkX/wjjVW/gH7/sdZ5nTacc5lkqJT6rtWqaJtVaVUrRNE26XGbd3+9alkW1Vi3LrFKq/uvj/KrP4dUu/t3HWkupmuepWVspIcjrddc8z1qWWcdRTusLwc3z3Cz1OA5dLouOo+o4Dv3vv15e5Xm8ukX//eetTtOkdV20bWFVkrQsk+ZZOo74Xq3SNMVPqXextYal1lq1rrNqlfb90LrGXP/5/nW52Fez2B8/1FpPiSxLLLsUaV2lfZdKiZiHkHCtuFWPj/73cvpfLDQseNJxvB43++IX+cOvR5WkZQkBbdsh4uCySNtWWkxEuLVKx1HOuLecFjdp3/NnWiYKUbSuAXiOIwR8HIf+55/riz+jF73Anz7VWkq4RSkEI+m0Fun+ftflsra/r+usfY/fATVY3DzP2ratCe3Nm7UhWawv3KzO69PtllJetDBf5MJ++hRHWWu4QCkOm1h4HH2agJuVpHme2ufHUXS5zLpeQ1B8Ns9zu2ZdU3gAJdwxFh3zxjUv0cW+qAX9+KFWhMV/Urg6kCUWcxzpRvlsmno3ehwBVhDKcWRMZQ6uQ4D7HsgI1MrcDIT/koT5IhaC28T17fuudV0bWAmhTJ0QpN56ti1cq4MXSR1wiWv6+ChJ12ukGpJaunG5rJpnad9rm+NyWVRKgqiXQhQ8+yI87pEicDQIRApAg3US60gvPPYhbBceqYTH17DEo8VLSVqWTFGmKdKOZVm0LDKlqIaEQ+GeO798tpu/fV/qPE+nCwwLiwNVi1FhCaUJIFxbury7uxAiwrled0k6Dz6F78J2FgcBk2qs66J9T/QrpRt2MoH7RX6ZXuO/Py3Pcp5PftMffj0qdBeHF4AlXJwU4ETSGavUMSsAD1AlqYDHvut1P61y6QRPMg/g2bbSudnJvCNCgmsFQKEE8Z2p+1x6Hi72SW/47mPk6/u+txwNa4vfpw4hYi3Lok7AHBiHCfjArTr6ZE4Sfr+W+aVAqQgVpUCJJBQq1kas7FFxAqTLZdK//fx0wnySG/3LP2sl1uEKU4uX9r1Siu7uliYwhHwctR0y1zmz4gwO80gp3OM4dHe3NqIAy3R36kjX4yvVj31P4OR0HYJluPVOk/Qfv35/YX7XG/z4IVSVQ8d11lp1ucydsNxlLsukbQth4zLnWQ8sA85zWZYm7LCiiFEp7J6O477rOul6TU5VUpdHjgJmL4QDKiGxzmSP3OqJ8d+Tj/0uE//w61EBI57jSWldUk+hxWc9OR1Wk+4WYWNNaD2jlNKsxdMOEnZJ7dC3bTcFmZpQSimNzXHl81ok7tndvAOlW8KXvl9u+eiTAlyoIozuB4DhrAt/w6qkdL3kb1Jymli0xzSH/Vi153QcLqmJX0t6c70erTqyrusfKhPEggOjmGvqANAIxNZ10r//8rhW+WiTkTI4iCDuOGAZ+U8osXWddH+/twMn5iEIeFEswasRkroir49l4cDVhM/Bcshc44LwCkcKZD6tfW75JHN6jRJlQnld+NzzOB4vJfnmSd59rHWMTwEkFh3HeDBxDVaIwB1JjlxofhZCj0pG7bQ9508rIH+bJq6JU/eaYsybaczd3dJVRXCZpajVLhEMua2j5VueIeZxAqNXnlrrNwvzqy/+6VP1s+6Sdnpd/LAYxJ1lWbTv+2mpc8ekeOz5XJINkPEknbSABN/dIfFrniddr9uZm65tPudsGS4gLyqzX9ZTSgIq9iipoWfQKyGm1qyDxn2+DcV+1YU/faqVxbEZL8Iy3AURV0Z2Bgjv8aPW2iyJgbDcejk4YiCQnwEH6gpGuuHxknV5GAApe+rhjBIM0Zs362dJAwTM2uNzNWAnPQRtX1Py+qILEJ4kXS6Tfv89ER6D2ITLjEPpSWjiCL8DXvhezrO0eIhuJILNQ6IqUUqS2lJAfikQKWi01tq5enJBXKQn/SiK57LO3XrvDvdxZgfSAC+xbXvjat3K2a+fyZe42L/0RfI94sO+H11S7ptzwDFCbQcKHuTTitVZhR+g/x13u+/HGaPWJtBucwZOGNQXmddjl9cYr9fjjIlzQ6EolO9vjIHM4Yo65o6+L1CuK76j2b+SlvzhF959rBWEySY9r/IWBxeapJsxgs9gP9y6cHlj99q+9zwow8tRzIFr4l4jqHJkPOaAzOFzOnjy3z3ZZw73HJwRQM/PZZzLz5bwdH+/6e7ucirDnxeiP/shqPN63U1rMo5J6nI/YgiaD9IbUahX19mwI1dHp+6SRvDgBzIWbaHvIu7VB4dIHCwly09es8TF46JZH6AJl4i18H2KyMuS83tbpSvXuk4nKs70ybGBnwWe4XPx8sEf//7zVtd17YAKNJgjPrSNSjqCy5bBjBmx+FyUC5IxghyPM1w75nMIxF0v6yVmjqzQmJT7YaKYYdUJtCQ1ZaKjwNMPZ4ig+dwlxv6mdi2CJm0ZvYafnYcg1jNWSto/3r4v9ZZms/HRlTjKQ0ggMQcCXhPctiwZObr0+7iC8D0npEHCgBuGu0f+/ebN2oTh1ZFQjhAUwvBiMMriB+kpTwi1z1P9++wF0OSAB4HggpkDz+WKFF6uV2z3fljm5IgTM0ZjRqQ2ukKPDSzO3aa7orHhyGONI8FsR8wD8Prfus5dh/donX4PDjYtZ+q8ixecHUl6l/jIf8LYcOC33Dnu2lOQEEAqsKPymPchNnDBj/2yDnwmmnK9h2WEzLhWhifcnvDimm5B5xH0eFwZEah/lw2wMdryuX6sMKTVBnrl87E7oFZ1uagDHPZIDuzC2/eoF+57368z5pPUTDGMUaHhjdnPSNXhacbvO4BrBoNWQEthUQ7NXSNCcHHQYSnxtzjgZFxG7eU+6S5n0856WmJfaOXacKHTef/ZWJ4ERB4BYv0xN4IJ96fu4CC5Y/299W7b3pRx33cdx9GUwKszpFnpVQL8ZQpTT4XILvTLJWuRtVZdLuvpcY4GchAg3wnsQdf7fLJiZ7nucoleTvpViEfRbLurlKJ9P0R9zjcQ2l5PTcxDpIgaLjc/QFvRqlLKqWW90gSY6asBbNoJ5/QYcd3lMneQnYNIIAQhjkLoTAVK21+eQWrF5bI2yO9rZB8BpNxT8GwITExt3kuKpmcPJft+nCEj8QHnOU2TLpelU7JQdhR60gzHSWCPw4kvRNse6Cpb58NNhN/3+MXNp4lmpfk8uIxzjiyzWiCt63JuPONcBPjpVCSaoJhrOQ+otPgUrj3dZ+ynnGWp0lkTQMsbo6KaklYFmYBFuXsOoKS2/rT+uSl74Ae8SQhynjPnDYusZwpVTmFmTJXCC4T7zHXFd0u754zv9aQ6hJDawE1i0nrGtNHNzp3Gx3dDMwJKT6ebqJ2WpSstLb5SPkLYcbhrs66Ma7W7p1sdG5+mqeV2d3f5eFsp0UcKp5nxWuf9lnbYXjCutbbQwz7dK3C4t/7tqBdwlLhj7lgkUheUi/RlXRMLtNDkQuDQ2EwejE6Txh0Gyrpe9xYj0MrrdWtaFDeSKcbcDrBPvp2P7BXBlQPrgtlY16nrYNu2ox22K1Ek7rV5m5hD5uZAxulmM16lN7hcLlpXd9mJavEarBe37fGbGOasUn/mx2mpkPJHM6DoWCgNaHEPSZoxSQIrpr8sKcTQjocVgiAFKPMEyPnb3y7NbXiciU7qkTlJITT/PmM5STaQNzn4Oo6qbStdyoOg2XgSErWzOD+MzHOnM/bXbn2wOl4uC1DUK7S7PI/5/MTL8W/iIvdGwblH/7SXt3hSgMjcc/7twzQFsKhnHOu7zxws3mIWvM/kONRATghy7jbM4XBAaDNaz+/ExQQ2vav0DjMs7+5ubRZfStWbN+tpFRmTwhVu56GGJUfYANpHQTs9TD1jYW3MET2trCNqolCEEXe3bX8Q23wsy3KS9tNZ2chqTICsuB8MkbNEefY6UfCUjA09oeR+TjPBRDhMJj/yZHesQLjvHvnDyHcOcz+525HKg3DgQBB23BNSvafFXPHCivdWe/T0BCKBkEDO5wfrMZ690k7iBLfv2+/Nnih3ZZqVzV6eQ2ca1VOfyAVlpYPuAXf6w69HRTDOSUJ1OUODK4VJyUCftUQqERRnnTz3p47CctON4Ipo9/BnIjzPQ3mc2+WQ6d9hH5DiHJz37XDIsf5UNhTTFQY35uuE4QqFedgoxVhX6f4+FS7z2KPjSsdaLGSF9Afc6Tho+B0tKm6Q7A6jTzN6rXRqzVGVL9gZDRTBm4wkDe0cbm09COO7zsZwyM6lIhj3QOMenT1yxiisI1MtUD50JHO612B/sz04RGbg/UCu3G6lnytJfVaIDIhxKUtPvmkHFH6QuLVbLfmOEhGCF0bd/2MJY/u+Wyqbj8/yIFAsn+9WYXp0b27NiQbVXR/INSx726L+xx5w3azLH/Rx78Y8biBO03nnwB/VFP9UiFI+N4/b+1wNzA8AV0Tux8K8y8sJdCeV4T1HlwPmwn07F+oCxI17DB3LQAyvdXa51/A01Gjld3fe/9P3lUaumUqO1/E+G+ZBuM6fEo+lv9Zw/JeEyHj7vtSE6KW5tlhYDwhwB+5SvGDsKYs3XAVK7J+7cMDi7i0P0d9Tk4/Lcf3Y+uCIGqGS81FZGEEE8SnnDJxwf7+1RN2TeI+3faGgXzfM0RiyvqRb/IuEyPAne/0gvGbn8XAM0qNFjMjSEaWDFag7Ns3fYo5wYR5fODzosh6mZ58se0iXP3VKABd8qyls7FCgQoM38aIwrvXubhXPjYT1hiAvl+WrWhe/SoiMdx9r3ba9FYcdsPATq0MLSV04SEeCoE93yxyAIzxHjMsy6XpNAQaAWdr3cYNYqb/ACEXyZzWSe+1flcKAfPBWjFt9SCPwGoGUdyIg/K99Q8c3CVFK4DPmiuNz8xRzqbGND7k4MMFyvJHJEWBel+4JZcLaoarI/WLusWUkrdJDgIMdVybAjyNp0iLQqgvM+2K5npqkM1ff+qDNNwuRwZNQkiO51OQR+IyFUM+r+mfk+2Ymb5kYXVm3MQMitxDo+HQVa/Jiredmjh79+35fqvUoknce4GkgSEopj/as/6MJkfH2faluhYAF75qT+ke66TDzxByXOLpD4qbnpWPq4vkWvUDjsxOOHhGw9w8FNTbdtGLefeO4AKtjnW6hxHvW+tiPhD+6EBkgWafi0NxMqLMxV1JzO/nSvRDMSGUx3NW5sBwZ8293Y2Mvq6PbsbKQCHlurNDIEI05rOefTliU8n3eTPXdhCipPXQDqPEOs/FgsB7i3mGMgLfCe46aaDIZfY9rntLwaJv0UHnGFAIheC+QP3rnDE78VKsNEoOdTqz1+76Q4bsKkfHjh3z8jYP2eIF78u4zb8N482bV/X0++CllY7ET0t7z6k1bWA6oOL4TPz2mpkt/yBG7O7/VsXeLbXqqF/w9iRAZvCk4qyL9YUk9HUZMcsAwHhYgyHNCrMU5Tql3dQjM06Jb77FhjZ97xM4JArzIND3tO1OfVIgM3tntVsWIikc0JXkJa3y2A+33vM+tydkbKd359Rrm+rlccryPs0kjIxPr7b2HpCd/KdGzCFGKlCRLTA9fTuSVhs/1nYIo/ZAdaY6v9fL6IDVLYh41O3JcrIoOB2I3aQgx1K99ited3BrPJkSGv0k/QU1SXaBIJwPGOOYpRyLTqfs+sdObgD1l8WqL1yoldUwQXgHhS8//xsVnFyLjxw+13mJn/O1Okk5O9eGrouuNup2/+MgRqZeaHAzxXQTtL2tAOUh7njru/dG40QHyPOO3D9ME6EGAPUUWLvH337cmJBJorwyEi0xrTlaIZuVDNCtfr4fot6EXKB9Xyw6+7FxLxXopApRekCX6ePexVtzc+MZhSc1KnEgAzUpZb/SHVp3IdvLZLXPsOhgrM4/Bc36P8eIW5IP/9wWW5+S354hSz6z4+25IJ2BzmCuuiZ+AFn9x4EiKv5QX1N4aL3ZhPqDwvN/H63vENqe6kgbrCXAHObcq+k504w1eovX5eNGL8/GPX4KJBpXi4oh/lLrGd7tRdIUsx7L89SjEv/EFuS9deIxXsUgf8LF9p3a+o3TsO3UOk1eQSLQY5iulqXpIz58yfOl4VYv14awPeZ0XpEnE+Y7Hwuw4ry33k16f8BivctE+/H8/5IBkfLmfv2Wf3NIF/ZKBy5+NV7twH2OVRPJH1fp3vsG0IMTnevn6Y47/AxX1K5XSf237AAAAAElFTkSuQmCC"
			}, null), createVNode("image", {
				id: "_Image7",
				width: "113px",
				height: "65px",
				href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAMrklEQVR4nOVdW2LbNhAcUD5Xkl4scXqxpr0XiX7AQwwGu7Rj2RLV7o8lknjtc3YBygX/Afr2XOu2bQCAZVkAALVWlFJQClAr9mvLUrBt7R4A/Hp++fDA9NAL+PpjqwBQSkF9kVQkOBIFx2vLUlDr4wvyYSf/7blJghanglFLc9q2DZfLgnXddqvl9X/+vDwkPx5u0l9/bFWtTf+q8Hidwt22DaWUXYCtj3H5bPNolvkwk2Xc05hHcjep1yk8Fy4tksSmfH5ZCv768RjCPP0k3W3ysxKFtSwLaq0vAGYZXC2vtefHmKn9Lkv7TKt+BKs89QT/+FnrtnVECYwghuRukfcpOL1N4fgzrZ/umgHsbvfsVnnKiX35vlYFHUpMJQAMwMQtqpSCdV3x9HTBujbXSUUAZmVQa876A84ZL081oS/f1+qAQwGLusx+vz/rSNUtbk5FZvccpSuOdmut+PvnchrenWIidJvAKJRIaPpZY6B+Z/6nAlBrisjjp4KezKWfRZB3n8QfP2tlKuBWAHS0SMZqOFSAwu+R1QA9sVdhupA5riNapUjY946Xdxv823OtHnfIFGp+lv+pZSiaZH/e1gVIlmseCXRBk1SBFO26i6fA7xUvbz4oS2UABoaua699ZjFK25CJ/NzajukBgMmNerzUNuyD1Rw2U6XR/ihAzhu4D/C56YDM+QAMDMqScrUiYMzjiDjVmjT2aTLvlhtZLeOvI9RufWWyRCUt9906Xt5kIFpf5uaUKarlR0jUy2p+X2Nh62+2bi3faaxz1JoBInf1nr/WWm9Sj/3UAb7+2KrHo6hC4gJ0kAOMwMSf0RwwSgu8isNrDpSU1KIVBY9zX+Rz9xAaP3n/My3zUzrWOqdbhLpGPqMuFMhjkGu8pxZRKuE5H0ljYFaC0z60b8ZNutllAbatC1PdcxurPftZgvzwTnWDFuhJdSlzHFOozudGsHBsxeMYc5xiHxm6jdyx11mVojHVkt2zaJ/6+aOF+WGdffm+7hu0zrB9sCC2ULiRNUUF6fa5l9H0GjCX4nRsF9BRPsj2kVC8fyofx88KC5/lYq/uhPt7zni6FFoetZaCjQU2okPgWBBqtXrfXbczmP2qmz7a5oqAVwR6Mkv1Zz3eXpuWvLux7jBwog7bIyKTNaboEjQ+7ZMUl+RQnvdVYTKE6S48AiD6LOepwMmVTfs6Qsw+P1/XNVb5roaa7wFjzIqAgloHidaoRyUiVOruz9MOIE4ZpoVapcfben9ODpAyC9M+dc1UWmCuDGnb9wjztxqo65wXNqcNUVDXeBmdc4kWqsKLQBL78zIcx6U71aMZfa6xW86uOeKOarU6R3fZ6n2y3Bj4vcrPmx789lyrx7QsH9OFXC4F6xqnGBHo0aqJCihzpa+hV33OEWpk/ZGFkJWeh0YVI953ZSU+UIGyzeVSQDDvHgF4m2UePsAiNRmoNUXX9NcOIDkTyJhs0R782/PxZzLAtZ3XNYXxeKhMzRivfbW1XlKX/1oakn3XsVyxXtslSW+q61QNjayv1oqnp+VlMnGVxRnnwEKFQAaocFQx9BkHPWSIV1OyfUUfb2KQeRnPL13wJHWrkedyZY3auSfKrHK6mIEW7YyTd2txbVbw0vuL9/1GxvXPtG510W3xs6X4wtXyiJo9Trml6jo1vqqCaHvOVcd1AWdgz/FFBu6cTx4v9y9R3BsZO2uPCkM1Xl1vhvwi16j967PKKP0cxTMFFC4k9umxl8r2lvlmTPa4TXIBet+RG414wvbqrVhcL9xZ10Hcuo6OO0QD8/MoiNnqdIKZ4pB8AY4ql4VKNQ0zzU3XGrlgjdk6F80ds3VxHd6vto3G8fyTc4x2ftimlLYRXfx9Bg/+RxoRAYMIYUX3IxfdJz6fOHPGt+8Yis9jSjDHnAzRcj56cDg686NziEALKQNdLhQKg89oKVHvR25+2BPVCXECOvkuVGWyl7fmZF7jUCljfNB2nem8P277aIzhuG0BdJ0ag0bm6PEKlQX7dNR6uSwTCGLb7gEU0I0xMFJQzoHt13Xb16BEdE8Z1NpPOyiPW1/kbVOUJy6+MaUMGuaW1jvE3hlJNYptIhfZJ6CId0aL/XhEmdqy7yjuRrlnmz+ZU3amKVCJ5sO+lZlRESFCvbyuSuHgiXzkGN3tLnt7kuIN9zBPFIpqfktkL4NAI4TlVRXVDk6ScYBMIXEBbMt9RUd8ruVdaGXoT4Wsa1ENZ36nCkjk7IwZ4/Wcv+l1pVHZ66R4kZtuAtKxxudU4I7qSylYdHK8p9pNBvRFjh3rgtpkutvRwTtYKnJPraYrQ3OF82I5R3V1zlB3b02Rln1MjtUtYi4ucA0zSi7Wd//chD4K0EOClyL7sx2YqWA7Nhnz4a7kbdyFDSh9jxMx7MYuMHdZFAQnNrYru4A4MQBD+SqD8XroieMrc3Ujms9qfFXLJwP6urcpduv8KVi9766xucMYuLkSjC61DoqrMX/Mr0fF7Ir24k5ZBxy1I/bxbn1uGRHkBub9ui60Lnx+VjfJ/hXWKyR3N6fITZmpcZ9/+wszfc9ThcM41ePQnMwreFJBUYk0DXIBdtc5sGxYp7r+plTtu26PLb+eS9Fis1pes6hZc2gFZEhHq8s+GLWTWtMtaazAaL9kJEmhvgZ7R6M9PleJf8uLhVe48ilq1O+cqwqBHqqHmrIrjzJdleNy6crl6+acPZy4B+S6xnl2DzEAOH7gyywKWrzyoaiwI7h8OyY6/qBWM2rtnJvRerLjGGOs7Qm0H0T2Z9RiIytRiqzHrU7bRWiXbfnXT+dpH17A8KOd6g32io1PmoVvAFjX1VxbXAgYAUpvq2hQ6WhfLXc5M9DxcSOXFjGabfW6CjUqcGTz8XU3IY3u1wERkKc4vn72rWN6IXxWvRfSQngWrFWjfTG+aPZ2lFtFWsrJ6zjqLbQUxTFG1DimGmq97hK1LRALVj2HMz1atyuok3o8XU+0qZ5tFKdCJOm7EzqZyGqUGdGiIgaxjbpMzS3VYltfnEd3tRq7FOFqnOHzylivZWZzzcKB3su8hc5TQ4saQOQu3WCOdvpfFSLQD0VlKCsThPrvvtjxJRqPmd6nMydihraL4mAkkGynnVbrrjD6q3OLGD8x+6AvnyObv+W1uTcJkcSd/sjslZFR3Iqq+srQ6Liiotr2fY4vc/yMT75pm+hsaCk9pXDhZ3E5U+bIUx3FPi+8v2U3X+m3hEji9pW6uKOJRxpHxmg88A1gXfDR+ZouiDnuaLw8iu0TY4LrPjb78L5UOTxsRHxQPr3nDOq7hEjyHwaKDjpFsTJzJZGL3Cdaeo7Fw1fRM1FKQWUBxkIC73Hu0Y8zeExrfcRbVUcuNVN4Heu9h4ivEiLQUawDhkAOALRgsEzxTZ9xrScz94kbkFGA47sb6g5Lab+q0Sw9Pi7ZxxjzP68kqTVyHvxOPmTHULgPClz/YurVQiTpu/fDAAkQcMa6Fkcbq15XVQFGxwd53wGIx0udBxAXFzxdorJkz+kcVMBt7e3vR73r/2FCJPm7GRkgIJGpwJhAq9D8tJ3qicdHLbpHqNaF6CAt3hQe88kIWPn61KXrXwAf/uLphwuR5O/mAzEIUe1u17XwO8Y1t1rdQPb+dQwlzw0jhJmVHCNAlYGkTMCf8U7/pwkRGH+XDRhztAhgROhTBaUC8SqNWjzHygBTlgY4ZejV+1aX6aiT1x7uTWGn6PW3iMmkjBEeWzLk6y7TyWObu9YobrZ2CEt3fN7jfa23+TWNmwiRpL9dE0HwaOdbGeIC6e44P2LpVSG3IHePfiSQlBUAVNDX5nvvpZsKkURhZpYF5AXpKN3gcx6TFDkeKU0Elvg3eukGiBWOz9/6t2zuIkRgfFknQoJRhUaL4wo6nDKAEVWAvBzom9aRq492VIDrXhS9hu4mRJL+LKaDE1IE+9vz84azu9hIgBHAigCOWqgKj6+j8dr/9rfdnHzLi+Qul9eAectHD3rpfbf43maOi442gX5kg5vcFOZZfmUx/mXYO5AyRC3MXWP0mbLUE3BKUWrCds1ix+OPHLe3WXC5XNL53ptOMxElLaz7ybUsufadBY9/fu4mugZgf7vZx6SQz/hvF043ISX/Mdsoz9QYmCX8fMYL0hEqzXLWM1me02knpuRbXsC8tdM+x7vmWmrrQh/P7mgMVGU4A3B5jU49OaXX/i8Gy3N+iizKEbPKkVvsma1P6SEmqeRVH2U8CwGa/wHjXqG++KPWrHniGePeET3UZJX05VhgLouR/H526uxWdc7PoIectBJ/a8B3872yoxvHwHxu51EFCPwHhAjMv/gBzNUYIP5duEeJe0f0L+D749HrhKeLAAAAAElFTkSuQmCC"
			}, null), createVNode("image", {
				id: "_Image10",
				width: "107px",
				height: "62px",
				href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAA+CAYAAAAs/OVIAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nN2dWa8saXaWn5jnzMjMPZ5T1V3tsrGR+TNIvjAgC+y2uw22bIONzB/gBgkEAowZJbiBCyR+CzdIIHDX0Gfvs4fMjHmO+LhYEbGrrabdQw2nCKl0ztlDROQ3rPWu933XVxpf0+vn/0CpplEAeJ7G83MBQByHmCaczzVx7GEYMI7QtjAMA/f/1tK+yvf+Wa6v5Yt/4+8olWU5YRgCYJoawyATZxgargtVBZoGZVlhWRamaeJ5Gl0HRVFx/I/B1+6zf61e+Ju/o1TXDTw/P3N7e4NhQN8rbFujaUY0TSMMdU6nhjh2GUfoezBN+a/rIM9LLi8DHh8LNpuQj/+l9rUZg6/Fi17+eq00TaNpGjabDZ6noesyEY4jk2BZUBQKTdPQNIgiyHMYx4lpmnh+fiaKIq6vAz799MxmsyEMDboOlOJrMWnv9Au++s6gLMvgeDxzc7Pj+Tnn4iICIElqLMvCMAxcV2MYoOtGdF0HoOs6NhuH47HAMAw8z0PXIQyhruHx8cwHH+zo+2Wi4aN/8W5P2Dv7cq+/OyrL0jFNAQhl2RIEDtMEwzDRNA2GYWCaJrZtcDwm7PcxVdXQdR37/Ya2HTFNg7bt6LqOi4uQpoEggGGQnFYUA45jzvcdiWOD//GP3s1Je+de6uf/QKkkqXFdlzDUyLKR/d7g+bmfJ0Yjy+T7fd8DEAQ2AIYhIbGqGkzTpCxLttstcSwTrhSk6YjrGuS5THZZllxcxOg6uK6EzjiWifzv//DdmrR35mVuf6tXlmUyTYqqqthuAwxDBm0YBCBoGjw9CURXSrHbRUyT/P4wTLiujq5DWY4YhsHbt2/58MMbHh4KXr8OOZ8nlFJM04TnWVRVh67r6LqO7+u8fZsQxzGGAUVREwTeO5XL3okX+cU/VCpNe7quw3VdbNtgmmQnBAGkqYSq5+czV1e7dVeM40gQuOuEdV2P61r0vXzBsnSaRnZkVVVomkbXdWiaxmazwTDk44+jQinFOI64rkXXCbLUdZ0ggKendwPqf6Uv8Oo7gxrHkf3eJk0FHBiGhmVJ2Hp6EmBR1xPavMCTJMGyLDRNIwgC6rpmHEeUUmy3EXXdst87VBV4HhTFhOPo1PVAFJn0Pei63B9kxyoFeS45sW1Hmqbh/fcD2lZ28+Njxe2tT5Iovv+n+lc2Zl/Jg3e/lisAwzC4ufFmiK0wTY2qahnHEd/3sSxBba7rMk0Tr14FVJUMcF0LPO86uWffy78fH1s8z1mfVVWyC+PYommgrjtc10bXwbbh+bnC932qqsLzPDRNI0kSwjDEtk0sS+6tafJf3yt8X+N//ZMvPzx+qQ/8xt9RCgR1WZZBVTW4rouuQ123dF3H9XXE+dxydeXQdTIxaTphWfoKApJEQMfpNLLdSsh8fq4YxxHLstjvXepaQmieK6JIo65hGGRBLGiwaWQyHcdhGAa2W4tpetl1SVLiui5ZlrHb7VBKYRgamw0cjyN3/8b8UsdP/7IedPG3KrXdwjQp2ralLGvC0GW3g+0WqqqawxlomsbxOFCWE30vNVPT9HSdoq5hszE4HgeCwJjBwIRpmrx+HXFx4ZIkHY4jfGDXdYyj1FKGIbTU+TzO7MbIxYVLHGsMw0Cej+i6TFLfw/vvB2y3Bo7jEEl5R5YVvH3bSH77lUe1/Rup+rLG8AtfGX/p7yk1jpAkFWHoM00CsR1HcsfjY0UQ+KRpNoceHcOQHVUUijjWqCqYJil6o8jANOGTTxLeey+maaDrJrquw/Nc2rbDcWyKouT6OkDTIMvkPkmi2Gw0jsduDXv7vUNZQlEUbLchj49HXr8+rCVA27YEQYBpmozjOIdUeHrqmaYJy7IA2G71L7w++8Ju/kt/pFTfQ12P9H2PruvEsY1SMlF3dxWvXvlkGWw28uGVUvi+jWHA8SiDl+cVjiM5KAyNleuzrIVOGpkmgeS2bWOazPBdBvPyUn738VFyl6ZpuK5J3yssS8P3hfRdCuhpUniexjRBUXQz+2GsTMeSv2ybmd3vsW2ZsGGQ+PlFhcfPPQxef7tVv/zHStU1pGlNFBlEkQtInkjTjrKE/d7n/r7G8+D+vp4LXpthgKoaiaKQYVDouo6maWy3BgB13VPXik8+OdO2LUmSsNtZTJNwgAtpOwwDYejQNHA6DTPMt+j7nr5XpGmK5wlQUUrAjiwkYebbVhFFNk3ToJSE7+MxZxwnum7g/v5MVUEUWXRdTxDAdmuQ5znv/231hYTGz3WyXn93VI5j07ZwOiV4nkdZKrKsZr+3CUPwfZtxhDzvKYqC47HB9z0MQxJ/FMlAx7Hcs65r+r7n8bECIAyteSJCuk6K2rKUwfZ9naIYaBrwfY++l/DbdR1RFOA4cH3tsdlInfX01OD7EpYNQ547DLKDhmGgaRS+73M+SyE+DAOapnE4mDNDUtP3cHtr0XWQJAPvvy9F9eavJ+qD3/18J+1z2a7X324VgOMI7XM6nQHQdZ3NZoNlCYL63vdSXr3aUlUSMmzboGl6qqpis9lgmhpJkq/E636vkabQdVIUN00/k7fQNBJa27YlDP0VtpumCcjAWpZFGOqkac9mYzEMzEVuz25nUZbQNO2aj2zbRinZdZeX8VqTLXVf0wwYhuxw09RwHAmhris5tW0VYaiRJBLSlVJ4nkPTdDz8e+dnHuuf6Qa7X8vV9XWIZcFHHyVzYbrFdfWVfTif1YzIRnY7n7aVAQCJ/a4Lb9/mRFFEXdd4nkdVCejoup793sKy4HhU6LrIH6dTwqtXMVk24Lom4whFUc7PD9E0Zgguz7ZtG8PQqKqGvu85HCK6DsqyxDRNHMdZ0eMCfJoG+n7g6srk6UlykYANH5CclSQ1tm0TBAZv30qxHscBXSclwgI3TFNy3c/K6v/Uv3z567WKY3fl4ZqmIQhc6rrjcLDpe3h4SLm93a4F7MIqZJmiLEssS0Ka7/szoRry9JQTx4KTpwnqull3y7ID0jTl9es9b9+m2LaNZVl0XUcY+tR1y/W1gIqylHukqYSxzSZkHBXDMNC27TyJBpZlcDolXF7GaJrsEAmJA77vEYbyzn3fs9lImJ8m+bfr2uu7Sn6THRVFPmEoIGgYhIGxLA3DgP/9T3+6SfuJc1b0187qm7+j1OWly/lcs9sJlHYchywrVz2p72G/3zIM8nt5Ln+ezwNxrKGUwjRN4jjgcNB4770Qz4M4juYBG5gmNSNEk67r6Pue3c7A9/05pAXYto1tm/PPQRg6HI8jeS7vUNcdnucRxyF9/8L5tW3LdmvTdR2GARcXMVXVUxQdti1j+eqVx/Pzcf3sSikeHzMA0jRlu7Vpmo7n5xOmCRcXLlHkYZomeV5xOo0YhnCURVHg+/JOr74zqJvf7H7ifPZjz/B7vz0ppdScrF2Uku3dNPIhNE2jqiouLnzGUVZaWUrN07YdFxf2al4ZRzgeG4Zh4OYm5OGhJAwDxlF4vDR9get5nrPbCdooipKLi4Dz+QWGT9PEdmtTlhNBoK9C4kIPCZID3xdC+HAwub+v5h1lEQQ6SdLOSHSYw6KEsK57uUfbdrNtwMJx5BllKWHQ9405Cgzouo5t63TdRBjKwjVNuL8v8TyPpmnWksVxZPw++ZMfb6f9hTvrw99X6hf+rlJZlqFpGp7nkqYVVdXx9JSTpikguSeKfE6nBtuWiYoim74fmKaJuoaHh448Z4buAufrGrbbYKaREspSapv9XuqbwyGmKEpME3zfp2nkd7MsI45Ntlt7DrM6x2PFOC6c4Uhd9+i6TPLjY8luZ/LxxwkAlmWRpum8++p5UGWH6jo8PCSM40RZ1ozjRBjKLpSwquj7kcPBmxeMLEDPM2fKC8JQ5/4+pSwVaarYbAKqShbhQoVlWU/X9T821P+Rk/X6u6MaR6mPvvWtLbouRSSI4HdzExGGIaapMY4yQI7j8OmnCZqmEUWsVX8Uwc2NvSZw4flcum6kbUf6njnW27RtS9+/cHSO49A0I0GgMU2KcYT9fr8O0jAMdB3Ytk3XQZoKEnVdi6YZub2VcFmWsNvFXF0Jcbvb7ajrnutr2bmbjYZl6bQt3N7GGIbOxYXH4aBTliK1TJP8XF3XGIY8p+tk8ppmxLYtzueGuoY43hIEkqvO52z+2W7O5xVKKW5vLTQNfu73lFpQ9f/r+qHbz/qr9+rDD28YBkE8mqZxdeVyd1dwcRFi27K6hmHAcSzOZwESDw9iD3McDaUkPrvuwihIQnYcG8+TuibLFK6rkeeyC7tOVNokEUjteQ6nk8j1SskOCYIAXRdEeDjEKyNSVeJyenqS+s5xnJmyknDrui5RZFJVijzP2W43lGU112cOeV6x3/v0vYTMtoXHxwTf99ls7DXcPzw88OrVDUVRYds24zhS1zWHQzwvnhc5x/MEUCyFN8i96/olvC6k8v19MpcvOn3/w0niH/hC+KsntdvtZugrDPM4KrZbjTyXAZYQJ1SNhBjxN3zwQcgwvEB1WTUuZSmUU1EU7HbbFY3VdU0cb6iqBt93KQqB63kuyO2zxpcoivB9g2GQiX96+qym5dP3gmIOB5OyhCQRm5llQV1PxLHO42OzcodRZK8KdJIUKKUIw5BhGFZRU9O0dZJlMQitFcfCzJ9O9fw9bd79gnYXrWwcX+ist28rdjt//nvLdisLqSwlFwpQkXquqiRvRpF8/7NKtQbwwe8q5TiQpsJzaZo8XOCo1AwgyEoEQgPL0lY+7XxOuLqKSdMa3xcXkePA8VgzTRPX18G6A85ncRgdjx2bjXCFCwgYBlkMS6gcR7i/zzFNk7Zt8TyP16+FQioKIV89z8OyjHWVlqXcbwm/4ziuueLy0uajj8SGJpKIQ12rVb8KQ4u2lR0kphsHTRP+b7+3yHN5pmVZc8h2sW1517Zd0GdDXYvzStd1HMdhuzXWiWzbkTA0SFPR1dq2xzAM0jTl1asdZTlhmjrjqKjrGsdx1l2m/ZV/oFSWsdq08lyI1ft7QTq6rs+eBYHowj4M+L6JbcPp1BEENlUlrECWTUSRzt1dShxvGQZRgPu+ZxxHwtADpPa5vAxnmkaK4jiGLBPpQrg84Qo9j3kXy4TI7pYdGwQGeS6DWZby/U8/TbBtmzj2ybKGsizZ7/fzhLtkmTwvyzJev96QptOsWcV0nZhwltJCPBpwPqdcX285nSo2G5++V+tOdBydthXH1cWFT1lKydE0DTc3AooELcoY6LrOMAwcDj739xJql5C6eBkXt1YQyOe2bdAXo6Ss4oq6btcJCQKDYRjYbAzGcVFoayzLpK7HWSey6Hvh7N68STEMna4Tri7LcnRdRylFENhEkYemycDHcbjunu02IgzhdJrWWmgphA1DVm2ajmgavHmT8NFHKboutU6evyT+/V5W99VVjO/7KAW+73I4HCjLcg1pcRyhlMJxnBnF6ViWhW0LMXt5abHbCdAR24Di8nJLnvdcXvqcz1I0TtOEbctkmqbObuevoXu71TkcfO7uCqZJFGZRqxtcVxaSbcN778WM40iWZRiGweOj3PvqKp69IRIeTRP0slQUxTCHPmf2IahVCGya5geS7n7vMU0KxzE4nxsBJJaEy/1+S98PZFm91jGyKwUxDQNkWUWeN2voEGGx43zu15eWUKtTlt2cv8A0DYZhJIoibm+3WBYcDvsZTWmczx2nk8T2cZQoIQ0JPZoGFxfhCsuXLOB5Ds/PFedzRRAEPD1l1LWi70VLMwyDIBB4Lova4ulJgIXjaBwODsMgu2ah0IZBFnRdy9d3u5CybHFdjdOp5fXreJVXJMf3OI6DrutEkcyBUswLRyPLJpSSn9Vlpk08T1ZKkkiCD8OQtpU/01TY5b6XxBqGGk0zcHUl3ogXWM3skHWpqgrXdbm8NGYxUQrNqyufw8FlGCR+L+Kd48ifu91uDpkTrmtTVR1ZVmNZsNsJrVUUE3kOux3c3QmYsSwLz5OFs4Tn8znFdS2mSdgNIWtllSdJQt+PRJE/85Adt7cbgkCjKCRP931P2/Zst3A+J2ga3Nz4aJpGWfZzflQURTtrW6IMbLfbWcHuOR4z4tjh8VGose9//8zpVJGm/ZyrRYv7xjdC7u8lH55OCXUNd3fZLP0IwNEOf7NUC+sgtY7krDRlVVOXLg2ZWBddXxjnabV3Lbxd3/c0TUMcx0SRwfEoqElW3UCWZWw2G+LY4nwWVsC2rRni9mRZNsvoIUEgFb5hvDAiS/ja7eDP/uzFmqaU4vra4/m5m8OnQd/3DMMw+wJ9np6eME0TTdP45jdjigKyTJiFKNLpe1nBS+gRH7wiy7LZpxjT98PMZBjc3yfz38MZlhtomoyLMBmSb9++fSF8FyI7z8Woo2lSpvR9z8VFyPlcz5KRLOZpmnAcWYjaYlNumn71zJ1OJ25uLgHW9plFUZWXkUnbbGQwxxEeH4/s93tsW3ZQmopJMgjg7dty5vVi6loMKotnT9fh+VlI1CU0+v4LU11VkqzP5zOO43A4hOS5wF0pxGVAl8vztJmz9DidxEL25k1BEAT4vsbxWBFF/uqL3++1Wf4QdTkIRErx/UUsbZmmadbHBmzbZBgkVzXNsOZWXWeWbsY53ztUVTfbDTxc18B1hRsVf6KzSi+uK97EIPDRdXn2w0M1q+sueT4DE8PQGQaF686zp2lcXFzQNBLrP/nkiK7LRNV1MwuELuM4znWCmgFDPPsbsjlceLRtP/Nr2oy+cm5uXA4Hjb4fqev2MywFc64oSJKONFWzu0m6R0zTxHVdDEPYk9Oppm3VHIYbDEPD8zSSRMwsAqV7qkpCeRRpFMU452XZBV3XkSSyQNpWEQQWx2NOlhXzTh7nWs6b84hJ28rAdd1EURQ4juSoMISuU+vC6bppLTeapqHrFEky4jgmwzBg26xCZ9PA7a1ocraQ+Fxe+nPBrdjvLbZbV+imzUabfd6KoijQdY3NxqIoGl6/PpDn1Sp9C3qCKDJ4fj6jaRrPz+lniladp6eMqoI4lrpFaKBOaoa7isfHgSgy2G4lmb56FVOWzDkkpKoqTFOjrru5PnN49WqLpmmzaRMuLz0cR4jc3c7j6em4vuP1tWha2+2WPJe6pyjAsowZaUqxfH3tEMfw+Jiy2Whz2PJo23ZGlwKSzueUNE1xXbBtsQbYtr7SW+M48sknCXGsURTFHLrElp1l2Spquq4xRzB3DrkTRTFwPCYkiXCIadpxPIr14fY2mEsIyX9rdfxLf6RUUYjOdHkZkiQtUeTMiGrAssw11CxajoQRk/N5XF9sAQy7nb+WBOKulXadZcX7vkWaVtzc+PNASjhI08U2JtJ/HFsoBff36YzCHJqmYZomwjCc2fF+VYa3W5MkEfV5yVXDMHBxIS7d+fVoGoH+oiZL7ghDef5CChyPJZtNQBiymkvzfFhFUssyOZ3OxHFMWZa8ehXy8CAOYc/z8H2Dh4eE29uYtoWm6fA8e65XpUYUEfOFohJ0LX+vKvn5PBf79g/QTe/99qQ8TyPP+1WgE1len7sw1JwIhR5ZFFnPg48/lmTfdWrt/kiShIuLA1mWc3sbUVXC6d3cxNS18ILCM76Ic54nAzkMwp6/fSsTKsWyTHKSlPK+7wWzfCE5482bZGYWIjYbE8OA+/uCOA5n4CBq89L8YNs2fd/jeR5ZlnF1teV0KmeNzJpRsZhKNxuDspR8soAe8XgkXFzEFIV0W3adjIfY7xr2e5eqkp/b72NcVxbMxx9L4f76tc+bNxXTNHE4hLMFrub62qMsf1Bd/qFE7vW3W3VxYfPxx0LNyPaVVhmxNBe4rsswDFxfuzw8CL8nu47ZFqZxPhc4joPrWivddDxWbLc+VSXU1uKB2O8NkkTNZpiXnxeXVMnNTUCWiXVZdkU2W6xNsixnv49WC/WnnyazsBnSNOJxf3jIuLraoGmQJC23tw53d/Le0/RS4I6jLELDWDzwNZuNmG+macIw9BURGoZBXQuYEZpKJsX3fS4v7bWrsusk5IHoc9/85pb7e6lFw9CmbcX+JjRagW3bP9Sz8SNFL/dXHtXFxcUqyi3EbpIk3N7ueHrKORwimuZlGxuGwPrvfe8tH3xwQ1VJK87iim0aOJ/Pcy2i43mQJB2WZeE4Ur9EkbUW0GHoE8fw/Cwf1vd1hmGRRl6oLN+3aZqBvu8JAo9xlETvuhpFIQtjATFSZE6z1yOY/YUG9/fC9KephOyFXpP7QFGM+L6B5wlhLbltWkGI9IcpLi+liBZ7tlBISdICzKDE4fY2pCggzwt0Xef2VqLHjxIif6Se1fzXK+37f6prCyEq6rA228BEjxKI3X8GlS3o5oY8l0Q8lyFzp2GBaZr0fc/5nJDnQrhO08T5XHJxYVHXiq6bCAIfzxOzzOEgWlBRDKRpObMZxsyE27guM1vt0TQdbdtSVRVVNVKW5QyH09nvLjWk7/trC1CaCqMxjmr2lKjZONNiGHB3dyYM5et3dxVBoLHdujiOQxx7zAgeXdf45JNqNd90XUdVKaLImZVpcfem6UTX9VxdhbP/Uf2FivGPLevf/lavxnEkihzqesRxDLpOGOKlvgBmuf1Fspa6TAq9um6wLIu2bbm99TmdFh5Q53xOef16uxLBDw/CpARBgKaJ1CCrmzVESn0npGwQQJL0lGXJbhdTltXqbNrv/dVSIMy/7Ib9XuPTTyWnWZaE8PNZdvMwCPQW86m1cppZJnJHUfT0fc9+768O3cfHdmbahWfsOmZILwtFhFoBFVnWcnHhkKYTb/618WPNw0/ssvm531OqqiRUSfErjMF2a/P0VHB9HfL8XHN15VFVUFXtHJqCub5Y6jl4eCjm5jkhYpcicRzVGtocB56f61lM1ElTETiXGL+gvsUDcn29o20FvLx9K/1dWSbhCiCOPaZJNDEhdh1cV6Np1ErcfvjhjtNJ7h2GPlXVEIYuWVZxOPgUxThbD2TXAytRvKgLi3NqYdilTpTnOI5GXf/kXSg/tRXt6jcatds5ZNlAGJorKmuaht3OpW2XLvh+RjpCej495VxeRiRJQxRJu8/xWLDbhZzPBVEkMdOy4HyWMytAEr4UlQZl2a4OJSmUDYpCWArD0EnTjJubzbxYRNJYitRhGNjtIvJcdjvIbhP/vRhy7u7On+EoRzzPJQzh6amZuU/xMmZZtxpbF5/7QjjbtsEwCHBoW1G5bdvm+tr6qXuVf2aX6F/++0rJJEnyrSoRJIXYlGTq+xZdJ6v9fK7mVWYTRfDmjfzMxYXFRx+d125GOadCm3WrmosLj/NZtLOuU7MPQpiCpTkhihzKsl9lGYA4Nueww9pDLMYWKcLD0FgprbaVRSCuX52yrFYuse97osinqgRJns/LCTYiNEoXypY0TWeUKnLI5aXH83OzaoOf/quf3uj5udinf/mPpWPk6Unif5IUvP9+SJqKRLEgSduWvJAkFXHs0zQCl/v+Bbm1LatAB5Kg5XvCNhgGPD2p2e+3AB9h3S3LWOX052epa8TTCHd3+SxDBKv7Vu4riK8opEl8IV2X0LrbidD58HAmiiK6ruPmxl89KEFgzfodlKUYXZUS/tTz3PUZn0en5OfamvLeb09KQp5BnktCXpqzP2tpLsuSzSbkdEpm352P677UJGUpk1nXUowuRPLiUxgGGYAsm6jrmv0+4HgsOBzEzHN/L+1Ci1IQRUIoPz8LUfvmzRO6rnN9fZhbTyXnSDuQuy6WIDBWqJ9lEqIti1VvWkJ9WU6cz2cuLw+AfEbZ6Qb/8x9/fj1bX0gf0TJpfd8Thu6aH3xfEJthGGuN9fwsSXwcpZAWL4bi+fmZ/X6PruszMdtyOATkeT9bzPrZhLOjLKVoXgjZaRKJ4nQ68fr1AcuSfKfrOufzmffe2895pCaKPBwH8nyakZzk0JubkDwXXUuUXmHcXfflqIdPPz3yC79w4O5OdpGgYvHfT9Pnf8TQF9ZMd/UbjdpuRQZ4eKhm+O3N/cPdipSyLOP997eMI5zP3bqq+75fm+kuLvx1hy6QuG1lwNp2YrvV5w5IxX4vH0kpePtWlOzt1uXhQSxqfd/zjW9IiO77ic1G5/m54fLS5XTqubiw1ibyYZAdE8/9R8LMmPT9uDq0ttvt6nHf7Xy67sd32P6k1xfepvr6u6NaTCdNs8j0+io3RJGF6wqt1PfM9ZI0iKdpznYrTQrL15cmiO3W5XgsaNuWq6vDLOP0q74kjXVyFBC85MHbW4ePP5b7iggou35RbTVNI4417u7KuRbzSVOZvLIUoFOWi7G0WwXEsvziz8r40rrNlxNklILj8cirV4f1WATTlB2T5xO+r5PnPYeDWL/O5wTDMNhsIoZhXLs0tltr3lmsNdrzsyjbck9Rt4W81Wcm5AWJ1nWL4zgrk7H0MS8uX8mfPZ5n0bbjeqCKlCbe7NUQ0+oXtZP+/PWln+Xw4e8rlSQyQHVdz40A1mxFlhDXdf0s95ukqdRlZSmtPldX+zUkLpY1zxPTpijHclLNe+8Fs2AquXMxhcqgO6sBaJFFhkHAzCITXV+Hs/dBmPoFVb55I7LK0qZ0+k/hlzaGX8mhJT//B0qlabNyi0tH4vEo0FfafWRGgsBeqaCyHFe/uFILdA6wLI00FWu1uGuFSLVtGVzf9/E8a0Wjcp6FPnNzFlUFed4xTRP7vYvrwsODyDHLwsiyksMhIE2lFnv77+z/vw8t+fNX+Ksntd/vVmtY2/azVGHjujLgi4zuOA6bjRTJYfiieS1HNeS5eBjKUsBM0zR861s7zmcpxstSjKnzQWozky8F/HYr/vqlt3ix4rVtSxQFNE1HGNqUZf+VTNJyfWmHlvywq/gve+2TP9E0yQ8DRVGsO0aI4A7ft9ak//QkHpCPPz7PTW/Mztd+1paa+SxcjziOOZ/FmZTn3Xw24dLoPc4yy4jvC7sh8jucTvIOeZ6vB0q6rs3/+Wea9lVOFLwjp6It1y/+oTzw8moAAAHYSURBVFJl+cJOLBrZZmOQ52IWTVOxQ4vxJVhdUkqJoadtWyzL4nDw1zZWOWjEnk+gfhH6kkSOrNM0+V3fd9fifQE9bQvf++df/jlNP+x6J17is9f1t1slsNtc/eJRFK2+jEWUXPyMy0Eii31rYfhBmtsk1y07zqTr5J6CEB36fmS3M+beXykZyrKmbVvy/7x7p8bnnXqZz17f/B2lmqabpXRhuhf6yLZt8jxns9ng+8I6LKzC6TSujLznuSuh7Hketm3MLMo4d+2LMzjPO4ZhmPWp7Tt7Vu47+VKfvV59Z1B1Xa/Iz/etGVio9biE5aihpVuy7wWG17XkvcPB5u4un21rW5qmY7ezubtL567MkGmSXPlV56Ufdb2zL/bZ6+Y3O+W6FmXZrAJfFFkUxbDmryhyZxVYWAyhgnyaZlxNKLe3Huezms0uL4eN/CRN2F/l9c6/4GevX/ojpapKitMX1gPyXDjA5WyLxUMoNmWXzcbg8bFkuw3WBkA5zvXLPzPwZ7m+Ni/62Wv5/5Asx4W7rs3pJK2rV1fB3GB9nifKo22Fxlr8hVXV8vgf3K/dZ//avfBnr8tfr9UC1a+u/PXM9udnYc+zbPH+vfx/Sx4eHuj/2+3X8nP/X8+jjAy2QdiEAAAAAElFTkSuQmCC"
			}, null), createVNode("linearGradient", {
				id: "_Linear11",
				x1: "0",
				y1: "0",
				x2: "1",
				y2: "0",
				gradientUnits: "userSpaceOnUse",
				gradientTransform: "matrix(-118.47,-106.79,210.785,-180.125,69.2121,1372.7)"
			}, [createVNode("stop", {
				offset: "0",
				style: "stop-color: rgb(64, 128, 255); stop-opacity: 1;"
			}, null), createVNode("stop", {
				offset: "1",
				style: "stop-color: rgb(64, 128, 255); stop-opacity: 1;"
			}, null)]), createVNode("image", {
				id: "_Image13",
				width: "107px",
				height: "34px",
				href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAiCAYAAABY6CeoAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABFElEQVRoge2aQRKDMAhFmx6it/P+x7Ab64xOmaAG8vnwFnWhiOGFOG3TPsu6vpS0djpuH61zXoz5F3s6r4rRxipiftddeUbp3t18QozEu3/JfdSzgCy5VWpTWcVYSlaPqcvDEUpZQPUdCqUsSAbMoJIViJIVCBNZrO+MHtbjrs4KRMkKBJUs9uXXTxZ7JR2g6ix27sly6BIxReIOHdpZWevoNe68y2DAmTVXFmDBAB9pJ29nBYRCln5jgkVyv1QUsrIAJyvtvg1F7iGykF/KlniPG66zKDCyWLI2IqwOJSsQz2URbqZEpTorEDCypn6xnciVYT+SlbS+08Zt01lJfv7xBmYZLPpgy6p/pA9gyxIArKMLXxexLNiBCThLAAAAAElFTkSuQmCC"
			}, null), createVNode("image", {
				id: "_Image15",
				width: "38px",
				height: "62px",
				href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAA+CAYAAABHuGlYAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGaElEQVRogcVZSWLjOAwsblIu+oD+/zZ/YC4di8sc7IKLsJzJdCdpXGxLXIACUADpgL8oIYR9jKG/wd/hL+m080uMEb33pwHpR9UBkFLaU7ptW0rBGAOKGgAsy/KjiO3Aw105Z4wx0FpDSgmtNVPqer0if7c2Oee91oqUEsYY5rZaK5ZlQYwRx3HY+J+IsSmOQghPqKhwTO8dIYRvU8yU0kzzEmPEGGNSiGO/Ovh3ABtwQ4UI5ZxRSjEFKBprYwyUUtB7v6H3hQqhlGIb1loRY0RKCcdxIKWE3rshUkqZYsvLHykWQthjjJZZGtwqpRS01ia3MaZCCKi1cj2MMZBS+n1XhhB2brKuK2qtj/hIyeJHkVEypft678g5I+c8uf53FNsBbLoJF6RwU800kirjinM18HXcpxULIewANi5KyDWT1nWd3KquXZbF5tGVmq2qXO/9UzG2f/SSyK3rivf395e1T5/TmBAClmXB+/u7AnBD+7NK5fwoEiE822OM7d7lnBFjtIwlmkSMga97hBBelqRdraTf1SIvnsm1/gEwVBgCfMfPpwQ6UWgj0XGQxgrfeUWJFIO7tYacs20WYzRDPbqkDcZs790U25dl2ai9xoKK+V+oQFEhspzvWZ4kC2DKTK6tCRBjjDtd4RVZlgVvb2/T4lqMj+Ow9yRaRU/Xi/E5nIkUjWLMpZSQxhibn8C6dhyHlRZa6Ru73jtKKbYgDeBmWor8PN2LLmf8JdyLrsKrlV7hp+XeRa01G+/jjaj4hGE49N6ngm/vVakQgqU1N9c2uPc+pTdLjyqpn7qOFz6PMU48RjBsVcaHr/hqPZVZ13XKMn3v+U4zmiWKhur6mpm994diDDwN2BDCxD80wD9TZWqttimfE1lPQYyndV2n32OMW4xp6jI7vGi80CqSr48PRZGGkttSShO/sV9b19XHcjSkmEWKmP5mcKsiipaXs/hjCFCUO1ncASDFGLdXmxJBjRFFk4VbfxNVpRi6h/F2tgfBoRdiaw3LshifeCGPsW3hQsCj/lER5T1SCN3nWd76rhehk0IIGxVQC7iAh3xZlmksUVQC1eMaS5gqRve/OoXXWm/Br0jwANFas3aFStFNuomlt7iZ2aeErUox8Espxp9U1GomgJ0WTec6l23+HcvIWWPIHoytkM7lfYWi7ue21hBZ/9TiUsqUPWcMT746U6rWOvVnOvdVJaAYjeScNwYorSeFeDL0LO838W5WQ/S7ZZ4klc/4eL1eLViZsrVW8z39f9a2eKR8u8Mg93NpZGsNx3FMBxTzEoDt7KCqCcFNtTNVK1+dK1trljxKEWyVfDfLLM05I7Fz1c191tVarbPwLlXOMjecKKWbMtEo/s6s945IjWutBq1apxbpUR94JAkX00Kv8aSuZDZynWVZTCltNs2VHikN/DP+okvOEsCHA68BPFLa3XoujZqFKlqctRx5BfQsSI7iHACWeeoySmvt6eDDsmaIeSF18PbPu5ZjtCroe7+mP01pS+T3tZM4G7uzWGCvpNZpdhExZqx2ptpRKPX47oJoszMG7j2/xoIqx8DU1oYLcxwTxbfkPl5jjFN4MAP53p8nIsmV15G+9yICXIyKcNHjOKY5KjqXY6kc6yzXbK0ZkjFGhFLKzoH2UG75xIIP6xzT3X8HHg3B2TGOzabe+/PiblOfn8UEn3MToqnI6R0GjfOJoOXNcx7r552CLmmMsem1NjdX7uGiSqa6IUWPa2eZzoOtntBVeu8XAP8AuF1D5ZytmKoVFH/0OpNX79St/lMo5uLnJdzvUzXwpk5SiFTpwlv9qnfXYm8F+jHPEPJiaUR21gzTf8fUytba1E2Qw/TcSdECzaS6U8sTShPS/MKOk27T9FXxqKirSBetNby9veHXr182XrL0Q4UokVdInnO0vj1Zc+ciJUV2HloVXON4+axSAJDJ2F4Bn+p6tD9rhbkGkZee//JR0rySlHPelLfOWhUqqH966gFFKYRz7p+fRuhJsRDCaWtNJf1JiJvqkf6E4y6999Ns+6xkbVtIE2enZ0XKX4VzPP5HDP2XGI8B81W5lhTlOZYiV3YuY4w/QshLVJeR/TVOBA0TF49fhpJKptXaT/mSoZlLRa/X67coRAkAdt+OnP2ZLvKtClEy8Bz4L5T6EYUoU2utqGm9+2mlAMz/vunfxHda+HGFKP8C6wW6ett+DK8AAAAASUVORK5CYII="
			}, null)])])
		}
	});
const RESULT_STATUS = ["info", "success", "warning", "error", "403", "404", "500", null],
	_sfc_main$$ = defineComponent({
		name: "Result",
		components: {
			IconInfo,
			IconCheck,
			IconExclamation,
			IconClose,
			ResultForbidden,
			ResultNotFound,
			ResultServerError
		},
		props: {
			status: {
				type: String,
				default: "info",
				validator: o => RESULT_STATUS.includes(o)
			},
			title: String,
			subtitle: String
		},
		setup() {
			return {
				prefixCls: getPrefixCls("result")
			}
		}
	});

function _sfc_render$J(o, s, a, l, c, d) {
	const f = resolveComponent("icon-info"),
		m = resolveComponent("icon-check"),
		g = resolveComponent("icon-exclamation"),
		v = resolveComponent("icon-close"),
		y = resolveComponent("result-forbidden"),
		b = resolveComponent("result-not-found"),
		C = resolveComponent("result-server-error");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [createBaseVNode("div", {
			class: normalizeClass([`${o.prefixCls}-icon`, {
				[`${o.prefixCls}-icon-${o.status}`]: o.status,
				[`${o.prefixCls}-icon-custom`]: o.status === null
			}])
		}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-icon-tip`)
		}, [renderSlot(o.$slots, "icon", {}, () => [o.status === "info" ? (openBlock(), createBlock(
			f, {
				key: 0
			})) : o.status === "success" ? (openBlock(), createBlock(m, {
			key: 1
		})) : o.status === "warning" ? (openBlock(), createBlock(g, {
			key: 2
		})) : o.status === "error" ? (openBlock(), createBlock(v, {
			key: 3
		})) : o.status === "403" ? (openBlock(), createBlock(y, {
			key: 4
		})) : o.status === "404" ? (openBlock(), createBlock(b, {
			key: 5
		})) : o.status === "500" ? (openBlock(), createBlock(C, {
			key: 6
		})) : createCommentVNode("v-if", !0)])], 2)], 2), o.title || o.$slots.title ? (openBlock(),
			createElementBlock("div", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-title`)
			}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(o.title), 1)])], 2)) :
		createCommentVNode("v-if", !0), o.subtitle || o.$slots.subtitle ? (openBlock(), createElementBlock(
			"div", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-subtitle`)
			}, [renderSlot(o.$slots, "subtitle", {}, () => [createTextVNode(toDisplayString(o.subtitle),
				1)])], 2)) : createCommentVNode("v-if", !0), o.$slots.extra ? (openBlock(), createElementBlock(
			"div", {
				key: 2,
				class: normalizeClass(`${o.prefixCls}-extra`)
			}, [renderSlot(o.$slots, "extra")], 2)) : createCommentVNode("v-if", !0), o.$slots.default ? (
			openBlock(), createElementBlock("div", {
				key: 3,
				class: normalizeClass(`${o.prefixCls}-content`)
			}, [renderSlot(o.$slots, "default")], 2)) : createCommentVNode("v-if", !0)
	], 2)
}
var _Result = _export_sfc$1(_sfc_main$$, [
	["render", _sfc_render$J]
]);
const Result = Object.assign(_Result, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Result.name, _Result)
		}
	}),
	_sfc_main$_ = defineComponent({
		name: "Skeleton",
		props: {
			loading: {
				type: Boolean,
				default: !0
			},
			animation: {
				type: Boolean,
				default: !1
			}
		},
		setup(o) {
			const s = getPrefixCls("skeleton"),
				a = computed(() => [s, {
					[`${s}-animation`]: o.animation
				}]);
			return {
				prefixCls: s,
				cls: a
			}
		}
	});

function _sfc_render$I(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [o.loading ? renderSlot(o.$slots, "default", {
		key: 0
	}) : renderSlot(o.$slots, "content", {
		key: 1
	})], 2)
}
var _Skeleton = _export_sfc$1(_sfc_main$_, [
	["render", _sfc_render$I]
]);
const _sfc_main$Z = defineComponent({
	name: "SkeletonLine",
	props: {
		rows: {
			type: Number,
			default: 1
		},
		widths: {
			type: Array,
			default: () => []
		},
		lineHeight: {
			type: Number,
			default: 20
		},
		lineSpacing: {
			type: Number,
			default: 15
		}
	},
	setup(o) {
		const s = getPrefixCls("skeleton-line"),
			a = [];
		for (let l = 0; l < o.rows; l++) {
			const c = {};
			isNumber$2(o.widths[l]) ? c.width = `${o.widths[l]}px` : isString$2(o.widths[l]) && (c.width =
				String(o.widths[l])), c.height = `${o.lineHeight}px`, l > 0 && (c.marginTop =
				`${o.lineSpacing}px`), a.push(c)
		}
		return {
			prefixCls: s,
			lines: a
		}
	}
});

function _sfc_render$H(o, s, a, l, c, d) {
	return openBlock(!0), createElementBlock(Fragment, null, renderList(o.lines, (f, m) => (openBlock(),
		createElementBlock("ul", {
			key: m,
			class: normalizeClass(o.prefixCls)
		}, [createBaseVNode("li", {
			class: normalizeClass(`${o.prefixCls}-row`),
			style: normalizeStyle(f)
		}, null, 6)], 2))), 128)
}
var SkeletonLine = _export_sfc$1(_sfc_main$Z, [
	["render", _sfc_render$H]
]);
const _sfc_main$Y = defineComponent({
	name: "SkeletonShape",
	props: {
		shape: {
			type: String,
			default: "square"
		},
		size: {
			type: String,
			default: "medium"
		}
	},
	setup(o) {
		const s = getPrefixCls("skeleton-shape"),
			a = computed(() => [s, `${s}-${o.shape}`, `${s}-${o.size}`]);
		return {
			prefixCls: s,
			cls: a
		}
	}
});

function _sfc_render$G(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, null, 2)
}
var SkeletonShape = _export_sfc$1(_sfc_main$Y, [
	["render", _sfc_render$G]
]);
const Skeleton$1 = Object.assign(_Skeleton, {
		Line: SkeletonLine,
		Shape: SkeletonShape,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Skeleton.name, _Skeleton), o.component(a + SkeletonLine.name, SkeletonLine), o
				.component(a + SkeletonShape.name, SkeletonShape)
		}
	}),
	_sfc_main$X = defineComponent({
		name: "SliderButton",
		components: {
			Tooltip
		},
		inheritAttrs: !1,
		props: {
			direction: {
				type: String,
				default: "horizontal"
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			min: {
				type: Number,
				required: !0
			},
			max: {
				type: Number,
				required: !0
			},
			formatTooltip: {
				type: Function
			},
			value: [String, Number],
			tooltipPosition: {
				type: String
			},
			showTooltip: {
				type: Boolean,
				default: !0
			}
		},
		emits: ["movestart", "moving", "moveend"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("slider-btn"),
				l = ref(!1),
				c = b => {
					o.disabled || (b.preventDefault(), l.value = !0, on(window, "mousemove", d), on(window,
						"touchmove", d), on(window, "mouseup", f), on(window, "contextmenu", f), on(window,
						"touchend", f), s("movestart"))
				},
				d = b => {
					let C, _;
					b.type.startsWith("touch") ? (_ = b.touches[0].clientY, C = b.touches[0].clientX) : (_ = b
						.clientY, C = b.clientX), s("moving", C, _)
				},
				f = () => {
					l.value = !1, off(window, "mousemove", d), off(window, "mouseup", f), off(window, "touchend",
						f), s("moveend")
				},
				m = computed(() => [a]),
				g = computed(() => {
					var b;
					return ((b = o.tooltipPosition) != null ? b : o.direction === "vertical") ? "right" : "top"
				}),
				v = computed(() => {
					var b, C;
					return (C = (b = o.formatTooltip) == null ? void 0 : b.call(o, o.value)) != null ? C :
						`${o.value}`
				}),
				y = computed(() => o.showTooltip ? l.value ? !0 : void 0 : !1);
			return {
				prefixCls: a,
				cls: m,
				tooltipContent: v,
				mergedTooltipPosition: g,
				popupVisible: y,
				handleMouseDown: c
			}
		}
	}),
	_hoisted_1$i = ["aria-disabled", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"];

function _sfc_render$F(o, s, a, l, c, d) {
	const f = resolveComponent("tooltip");
	return openBlock(), createBlock(f, {
		"popup-visible": o.popupVisible,
		position: o.mergedTooltipPosition,
		content: o.tooltipContent
	}, {
		default: withCtx(() => [createBaseVNode("div", mergeProps(o.$attrs, {
			tabindex: "0",
			role: "slider",
			"aria-disabled": o.disabled,
			"aria-valuemax": o.max,
			"aria-valuemin": o.min,
			"aria-valuenow": o.value,
			"aria-valuetext": o.tooltipContent,
			class: o.cls,
			onMousedown: s[0] || (s[0] = (...m) => o.handleMouseDown && o.handleMouseDown(
				...m)),
			onTouchstart: s[1] || (s[1] = (...m) => o.handleMouseDown && o.handleMouseDown(
				...m)),
			onContextmenu: s[2] || (s[2] = withModifiers(() => {}, ["prevent"])),
			onClick: s[3] || (s[3] = withModifiers(() => {}, ["stop"]))
		}), null, 16, _hoisted_1$i)]),
		_: 1
	}, 8, ["popup-visible", "position", "content"])
}
var SliderButton = _export_sfc$1(_sfc_main$X, [
	["render", _sfc_render$F]
]);
const getOffsetPercent = (o, [s, a]) => {
		const l = Math.max((o - s) / (a - s), 0);
		return `${index.round(l*100,2)}%`
	},
	getPositionStyle = (o, s) => s === "vertical" ? {
		bottom: o
	} : {
		left: o
	},
	_sfc_main$W = defineComponent({
		name: "SliderDots",
		props: {
			data: {
				type: Array,
				required: !0
			},
			min: {
				type: Number,
				required: !0
			},
			max: {
				type: Number,
				required: !0
			},
			direction: {
				type: String,
				default: "horizontal"
			}
		},
		setup(o) {
			return {
				prefixCls: getPrefixCls("slider"),
				getStyle: l => getPositionStyle(getOffsetPercent(l, [o.min, o.max]), o.direction)
			}
		}
	});

function _sfc_render$E(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-dots`)
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.data, (f, m) => (openBlock(),
		createElementBlock("div", {
			key: m,
			class: normalizeClass(`${o.prefixCls}-dot-wrapper`),
			style: normalizeStyle(o.getStyle(f.key))
		}, [createBaseVNode("div", {
			class: normalizeClass([`${o.prefixCls}-dot`, {
				[`${o.prefixCls}-dot-active`]: f.isActive
			}])
		}, null, 2)], 6))), 128))], 2)
}
var SliderDots = _export_sfc$1(_sfc_main$W, [
	["render", _sfc_render$E]
]);
const _sfc_main$V = defineComponent({
	name: "SliderMarks",
	props: {
		data: {
			type: Array,
			required: !0
		},
		min: {
			type: Number,
			required: !0
		},
		max: {
			type: Number,
			required: !0
		},
		direction: {
			type: String,
			default: "horizontal"
		}
	},
	setup(o) {
		return {
			prefixCls: getPrefixCls("slider"),
			getStyle: l => getPositionStyle(getOffsetPercent(l, [o.min, o.max]), o.direction)
		}
	}
});

function _sfc_render$D(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-marks`)
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.data, (f, m) => (openBlock(),
		createElementBlock("div", {
			key: m,
			"aria-hidden": "true",
			class: normalizeClass(`${o.prefixCls}-mark`),
			style: normalizeStyle(o.getStyle(f.key))
		}, toDisplayString(f.content), 7))), 128))], 2)
}
var SliderMarks = _export_sfc$1(_sfc_main$V, [
	["render", _sfc_render$D]
]);
const _sfc_main$U = defineComponent({
	name: "SliderTicks",
	props: {
		value: {
			type: Array,
			required: !0
		},
		step: {
			type: Number,
			required: !0
		},
		min: {
			type: Number,
			required: !0
		},
		max: {
			type: Number,
			required: !0
		},
		direction: {
			type: String,
			default: "horizontal"
		}
	},
	setup(o) {
		const s = getPrefixCls("slider"),
			a = computed(() => {
				const c = [],
					d = Math.floor((o.max - o.min) / o.step);
				for (let f = 0; f <= d; f++) {
					const m = index.plus(f * o.step, o.min);
					m <= o.min || m >= o.max || c.push({
						key: m,
						isActive: m >= o.value[0] && m <= o.value[1]
					})
				}
				return c
			});
		return {
			prefixCls: s,
			steps: a,
			getStyle: c => getPositionStyle(getOffsetPercent(c, [o.min, o.max]), o.direction)
		}
	}
});

function _sfc_render$C(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-ticks`)
	}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.steps, (f, m) => (openBlock(),
		createElementBlock("div", {
			key: m,
			class: normalizeClass([`${o.prefixCls}-tick`, {
				[`${o.prefixCls}-tick-active`]: f.isActive
			}]),
			style: normalizeStyle(o.getStyle(f.key))
		}, null, 6))), 128))], 2)
}
var SliderTicks = _export_sfc$1(_sfc_main$U, [
	["render", _sfc_render$C]
]);
const _sfc_main$T = defineComponent({
	name: "SliderInput",
	components: {
		InputNumber
	},
	props: {
		modelValue: {
			type: Array,
			required: !0
		},
		min: {
			type: Number
		},
		max: {
			type: Number
		},
		step: {
			type: Number
		},
		disabled: {
			type: Boolean
		},
		range: {
			type: Boolean
		}
	},
	emits: ["startChange", "endChange"],
	setup(o, {
		emit: s
	}) {
		return {
			prefixCls: getPrefixCls("slider")
		}
	}
});

function _sfc_render$B(o, s, a, l, c, d) {
	const f = resolveComponent("input-number");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(`${o.prefixCls}-input`)
	}, [o.range ? (openBlock(), createElementBlock(Fragment, {
		key: 0
	}, [createVNode(f, {
		min: o.min,
		max: o.max,
		step: o.step,
		disabled: o.disabled,
		"model-value": o.modelValue[0],
		"hide-button": "",
		onChange: s[0] || (s[0] = m => o.$emit("startChange", m))
	}, null, 8, ["min", "max", "step", "disabled", "model-value"]), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-input-hyphens`)
	}, null, 2)], 64)) : createCommentVNode("v-if", !0), createVNode(f, {
		min: o.min,
		max: o.max,
		step: o.step,
		disabled: o.disabled,
		"model-value": o.modelValue[1],
		"hide-button": "",
		onChange: s[1] || (s[1] = m => o.$emit("endChange", m))
	}, null, 8, ["min", "max", "step", "disabled", "model-value"])], 2)
}
var SliderInput = _export_sfc$1(_sfc_main$T, [
	["render", _sfc_render$B]
]);
const _sfc_main$S = defineComponent({
	name: "Slider",
	components: {
		SliderButton,
		SliderDots,
		SliderMarks,
		SliderTicks,
		SliderInput
	},
	props: {
		modelValue: {
			type: [Number, Array],
			default: void 0
		},
		defaultValue: {
			type: [Number, Array],
			default: 0
		},
		step: {
			type: Number,
			default: 1
		},
		min: {
			type: Number,
			default: 0
		},
		marks: {
			type: Object
		},
		max: {
			type: Number,
			default: 100
		},
		direction: {
			type: String,
			default: "horizontal"
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		showTicks: {
			type: Boolean,
			default: !1
		},
		showInput: {
			type: Boolean,
			default: !1
		},
		range: {
			type: Boolean,
			default: !1
		},
		formatTooltip: {
			type: Function
		},
		showTooltip: {
			type: Boolean,
			default: !0
		}
	},
	emits: {
		"update:modelValue": o => !0,
		change: o => !0
	},
	setup(o, {
		emit: s
	}) {
		const {
			modelValue: a
		} = toRefs(o), l = getPrefixCls("slider"), {
			mergedDisabled: c,
			eventHandlers: d
		} = useFormItem({
			disabled: toRef(o, "disabled")
		}), f = ref(null), m = ref(), g = o.modelValue ? o.modelValue : o.defaultValue, v = ref(isArray$2(
			g) ? g[0] : 0), y = ref(isArray$2(g) ? g[1] : g);
		watch(a, j => {
			var ge, me, he, ce, ae;
			isArray$2(j) ? (v.value = (me = (ge = j[0]) != null ? ge : o.min) != null ? me : 0, y
				.value = (ce = (he = j[1]) != null ? he : o.min) != null ? ce : 0) : y.value = (ae =
				j ?? o.min) != null ? ae : 0
		});
		const b = () => {
				var j, ge;
				o.range ? (s("update:modelValue", [v.value, y.value]), s("change", [v.value, y.value])) : (s(
					"update:modelValue", y.value), s("change", y.value)), (ge = (j = d.value) == null ?
					void 0 : j.onChange) == null || ge.call(j)
			},
			C = j => {
				j = j ?? o.min, v.value = j, b()
			},
			_ = j => {
				j = j ?? o.min, y.value = j, b()
			},
			S = computed(() => {
				var j, ge, me;
				return o.range ? isArray$2(o.modelValue) ? o.modelValue : [v.value, (j = o.modelValue) !=
					null ? j : y.value
				] : isUndefined$1(o.modelValue) ? [v.value, y.value] : isArray$2(o.modelValue) ? [(ge =
					o.min) != null ? ge : 0, o.modelValue[1]] : [(me = o.min) != null ? me : 0, o
					.modelValue
				]
			}),
			w = computed(() => Object.keys(o.marks || {}).map(j => {
				var ge;
				const me = Number(j);
				return {
					key: me,
					content: (ge = o.marks) == null ? void 0 : ge[me],
					isActive: me >= S.value[0] && me <= S.value[1]
				}
			})),
			T = j => getPositionStyle(getOffsetPercent(j, [o.min, o.max]), o.direction),
			A = ref(!1),
			k = () => {
				A.value = !0, f.value && (m.value = f.value.getBoundingClientRect())
			};

		function M(j, ge) {
			if (!m.value) return 0;
			const {
				left: me,
				top: he,
				width: ce,
				height: ae
			} = m.value, fe = o.direction === "horizontal" ? ce : ae, q = fe * o.step / (o.max - o.min);
			let le = o.direction === "horizontal" ? j - me : he + ae - ge;
			le < 0 && (le = 0), le > fe && (le = fe);
			const de = Math.round(le / q);
			return index.plus(o.min, index.times(de, o.step))
		}
		const D = (j, ge) => {
				y.value = M(j, ge), b()
			},
			F = j => {
				if (c.value) return;
				const {
					clientX: ge,
					clientY: me
				} = j;
				f.value && (m.value = f.value.getBoundingClientRect()), y.value = M(ge, me), b()
			};

		function R([j, ge]) {
			return j > ge && ([j, ge] = [ge, j]), o.direction === "vertical" ? {
				bottom: getOffsetPercent(j, [o.min, o.max]),
				top: getOffsetPercent(o.max + o.min - ge, [o.min, o.max])
			} : {
				left: getOffsetPercent(j, [o.min, o.max]),
				right: getOffsetPercent(o.max + o.min - ge, [o.min, o.max])
			}
		}
		const O = (j, ge) => {
				v.value = M(j, ge), b()
			},
			U = () => {
				A.value = !1
			},
			V = computed(() => [l, {
				[`${l}-vertical`]: o.direction === "vertical",
				[`${l}-with-marks`]: !!o.marks
			}]),
			z = computed(() => [`${l}-track`, {
				[`${l}-track-disabled`]: c.value,
				[`${l}-track-vertical`]: o.direction === "vertical"
			}]);
		return {
			prefixCls: l,
			cls: V,
			trackCls: z,
			trackRef: f,
			computedValue: S,
			mergedDisabled: c,
			markList: w,
			getBtnStyle: T,
			getBarStyle: R,
			handleClick: F,
			handleMoveStart: k,
			handleEndMoving: D,
			handleMoveEnd: U,
			handleStartMoving: O,
			handleStartChange: C,
			handleEndChange: _
		}
	}
});

function _sfc_render$A(o, s, a, l, c, d) {
	const f = resolveComponent("slider-ticks"),
		m = resolveComponent("slider-dots"),
		g = resolveComponent("slider-marks"),
		v = resolveComponent("slider-button"),
		y = resolveComponent("slider-input");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [createBaseVNode("div", {
		ref: "trackRef",
		class: normalizeClass(o.trackCls),
		onClick: s[0] || (s[0] = (...b) => o.handleClick && o.handleClick(...b))
	}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-bar`),
			style: normalizeStyle(o.getBarStyle(o.computedValue))
		}, null, 6), o.showTicks ? (openBlock(), createBlock(f, {
			key: 0,
			value: o.computedValue,
			step: o.step,
			min: o.min,
			max: o.max,
			direction: o.direction
		}, null, 8, ["value", "step", "min", "max", "direction"])) : createCommentVNode("v-if", !0), o
		.marks ? (openBlock(), createBlock(m, {
			key: 1,
			data: o.markList,
			min: o.min,
			max: o.max,
			direction: o.direction
		}, null, 8, ["data", "min", "max", "direction"])) : createCommentVNode("v-if", !0), o.marks ? (
			openBlock(), createBlock(g, {
				key: 2,
				data: o.markList,
				min: o.min,
				max: o.max,
				direction: o.direction
			}, null, 8, ["data", "min", "max", "direction"])) : createCommentVNode("v-if", !0), o
		.range ? (openBlock(), createBlock(v, {
			key: 3,
			style: normalizeStyle(o.getBtnStyle(o.computedValue[0])),
			value: o.computedValue[0],
			direction: o.direction,
			disabled: o.mergedDisabled,
			min: o.min,
			max: o.max,
			"format-tooltip": o.formatTooltip,
			"show-tooltip": o.showTooltip,
			onMovestart: o.handleMoveStart,
			onMoving: o.handleStartMoving,
			onMoveend: o.handleMoveEnd
		}, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip",
			"show-tooltip", "onMovestart", "onMoving", "onMoveend"
		])) : createCommentVNode("v-if", !0), createVNode(v, {
			style: normalizeStyle(o.getBtnStyle(o.computedValue[1])),
			value: o.computedValue[1],
			direction: o.direction,
			disabled: o.mergedDisabled,
			min: o.min,
			max: o.max,
			"format-tooltip": o.formatTooltip,
			"show-tooltip": o.showTooltip,
			onMovestart: o.handleMoveStart,
			onMoving: o.handleEndMoving,
			onMoveend: o.handleMoveEnd
		}, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip",
			"show-tooltip", "onMovestart", "onMoving", "onMoveend"
		])
	], 2), o.showInput ? (openBlock(), createBlock(y, {
		key: 0,
		"model-value": o.computedValue,
		min: o.min,
		max: o.max,
		step: o.step,
		range: o.range,
		disabled: o.disabled,
		onStartChange: o.handleStartChange,
		onEndChange: o.handleEndChange
	}, null, 8, ["model-value", "min", "max", "step", "range", "disabled", "onStartChange",
		"onEndChange"
	])) : createCommentVNode("v-if", !0)], 2)
}
var _Slider = _export_sfc$1(_sfc_main$S, [
	["render", _sfc_render$A]
]);
const Slider = Object.assign(_Slider, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Slider.name, _Slider)
	}
});
var _Space = defineComponent({
	name: "Space",
	props: {
		align: {
			type: String
		},
		direction: {
			type: String,
			default: "horizontal"
		},
		size: {
			type: [Number, String, Array],
			default: "small"
		},
		wrap: {
			type: Boolean
		},
		fill: {
			type: Boolean
		}
	},
	setup(o, {
		slots: s
	}) {
		const a = getPrefixCls("space"),
			l = computed(() => {
				var m;
				return (m = o.align) != null ? m : o.direction === "horizontal" ? "center" : ""
			}),
			c = computed(() => [a, {
				[`${a}-${o.direction}`]: o.direction,
				[`${a}-align-${l.value}`]: l.value,
				[`${a}-wrap`]: o.wrap,
				[`${a}-fill`]: o.fill
			}]);

		function d(m) {
			if (isNumber$2(m)) return m;
			switch (m) {
				case "mini":
					return 4;
				case "small":
					return 8;
				case "medium":
					return 16;
				case "large":
					return 24;
				default:
					return 8
			}
		}
		const f = m => {
			const g = {},
				v = `${d(isArray$2(o.size)?o.size[0]:o.size)}px`,
				y = `${d(isArray$2(o.size)?o.size[1]:o.size)}px`;
			return m ? o.wrap ? {
				marginBottom: y
			} : {} : (o.direction === "horizontal" && (g.marginRight = v), (o.direction ===
				"vertical" || o.wrap) && (g.marginBottom = y), g)
		};
		return () => {
			var m;
			const g = getAllElements((m = s.default) == null ? void 0 : m.call(s), !0).filter(v => v
				.type !== Comment$1);
			return createVNode("div", {
				class: c.value
			}, [g.map((v, y) => {
				var b, C;
				const _ = s.split && y > 0;
				return createVNode(Fragment, {
					key: (b = v.key) != null ? b : `item-${y}`
				}, [_ && createVNode("div", {
					class: `${a}-item-split`,
					style: f(!1)
				}, [(C = s.split) == null ? void 0 : C.call(s)]), createVNode(
					"div", {
						class: `${a}-item`,
						style: f(y === g.length - 1)
					}, [v])])
			})])
		}
	}
});
const Space = Object.assign(_Space, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Space.name, _Space)
	}
});

function getSizeConfig(o) {
	const s = isString$2(o) ? parseFloat(o) : o;
	let a = "";
	return isNumber$2(o) || String(s) === o ? a = s > 1 ? "px" : "%" : a = "px", {
		size: s,
		unit: a,
		isPx: a === "px"
	}
}

function getPxSize({
	size: o,
	defaultSize: s,
	containerSize: a
}) {
	const l = getSizeConfig(o ?? s);
	return l.isPx ? l.size : l.size * a
}

function px2percent(o, s) {
	return parseFloat(o) / parseFloat(s)
}
const _sfc_main$R = defineComponent({
	name: "Split",
	components: {
		ResizeTrigger
	},
	props: {
		component: {
			type: String,
			default: "div"
		},
		direction: {
			type: String,
			default: "horizontal"
		},
		size: {
			type: [Number, String],
			default: void 0
		},
		defaultSize: {
			type: [Number, String],
			default: .5
		},
		min: {
			type: [Number, String]
		},
		max: {
			type: [Number, String]
		},
		disabled: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		moveStart: o => !0,
		moving: o => !0,
		moveEnd: o => !0,
		"update:size": o => !0
	},
	setup(o, {
		emit: s
	}) {
		const {
			direction: a,
			size: l,
			defaultSize: c,
			min: d,
			max: f
		} = toRefs(o), m = ref(0), g = ref(), v = getPrefixCls("split"), [y, b] = useMergeState(c.value,
				reactive({
					value: l
				})), C = computed(() => getSizeConfig(y.value)), _ = computed(() => a.value === "horizontal"),
			S = computed(() => [v, {
				[`${v}-horizontal`]: _.value,
				[`${v}-vertical`]: !_.value
			}]), w = computed(() => {
				const {
					size: V,
					unit: z,
					isPx: j
				} = C.value;
				return {
					flex: `0 0 calc(${j?V:V*100}${z} - ${m.value/2}px)`
				}
			}), T = {
				startPageX: 0,
				startPageY: 0,
				startContainerSize: 0,
				startSize: 0
			};
		async function A() {
			const V = () => {
				var z, j;
				return _.value ? (z = g.value) == null ? void 0 : z.clientWidth : ((j = g.value) ==
					null ? void 0 : j.clientHeight) || 0
			};
			return (!g.value || V()) && await nextTick(), V()
		}

		function k(V, z) {
			if (!z) return;
			const j = C.value.isPx ? `${V}px` : px2percent(V, z);
			y.value !== j && (b(j), s("update:size", j))
		}

		function M(V, z) {
			const j = getPxSize({
					size: V,
					containerSize: z
				}),
				ge = getPxSize({
					size: d.value,
					defaultSize: "0px",
					containerSize: z
				}),
				me = getPxSize({
					size: f.value,
					defaultSize: `${z}px`,
					containerSize: z
				});
			let he = j;
			return he = Math.max(he, ge), he = Math.min(he, me), he
		}

		function D({
			startContainerSize: V,
			startSize: z,
			startPosition: j,
			endPosition: ge
		}) {
			const me = getPxSize({
				size: z,
				containerSize: V
			});
			return M(`${me+(ge-j)}px`, V)
		}

		function F(V) {
			s("moving", V);
			const z = _.value ? D({
				startContainerSize: T.startContainerSize,
				startSize: T.startSize,
				startPosition: T.startPageX,
				endPosition: V.pageX
			}) : D({
				startContainerSize: T.startContainerSize,
				startSize: T.startSize,
				startPosition: T.startPageY,
				endPosition: V.pageY
			});
			k(z, T.startContainerSize)
		}

		function R(V) {
			off(window, "mousemove", F), off(window, "mouseup", R), off(window, "contextmenu", R), document.body
				.style.cursor = "default", s("moveEnd", V)
		}
		async function O(V) {
			s("moveStart", V), T.startPageX = V.pageX, T.startPageY = V.pageY, T.startContainerSize =
				await A(), T.startSize = y.value, on(window, "mousemove", F), on(window, "mouseup", R), on(
					window, "contextmenu", R), document.body.style.cursor = _.value ? "col-resize" :
				"row-resize"
		}

		function U(V) {
			const {
				width: z,
				height: j
			} = V.contentRect;
			m.value = _.value ? z : j
		}
		return onMounted(async () => {
			const V = await A(),
				z = M(y.value, V);
			k(z, V)
		}), {
			prefixCls: v,
			classNames: S,
			isHorizontal: _,
			wrapperRef: g,
			onMoveStart: O,
			onTriggerResize: U,
			firstPaneStyles: w
		}
	}
});

function _sfc_render$z(o, s, a, l, c, d) {
	const f = resolveComponent("ResizeTrigger");
	return openBlock(), createBlock(resolveDynamicComponent(o.component), {
		ref: "wrapperRef",
		class: normalizeClass(o.classNames)
	}, {
		default: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass([`${o.prefixCls}-pane`, `${o.prefixCls}-pane-first`]),
			style: normalizeStyle(o.firstPaneStyles)
		}, [renderSlot(o.$slots, "first")], 6), o.disabled ? createCommentVNode("v-if", !0) : (
			openBlock(), createBlock(f, {
				key: 0,
				"prefix-cls": `${o.prefixCls}-trigger`,
				direction: o.isHorizontal ? "vertical" : "horizontal",
				onMousedown: o.onMoveStart,
				onResize: o.onTriggerResize
			}, {
				default: withCtx(() => [renderSlot(o.$slots, "resize-trigger")]),
				icon: withCtx(() => [renderSlot(o.$slots, "resize-trigger-icon")]),
				_: 3
			}, 8, ["prefix-cls", "direction", "onMousedown", "onResize"])), createBaseVNode("div", {
			class: normalizeClass([`${o.prefixCls}-pane`, `${o.prefixCls}-pane-second`])
		}, [renderSlot(o.$slots, "second")], 2)]),
		_: 3
	}, 8, ["class"])
}
var _Split = _export_sfc$1(_sfc_main$R, [
	["render", _sfc_render$z]
]);
const Split = Object.assign(_Split, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Split.name, _Split)
		}
	}),
	_sfc_main$Q = defineComponent({
		name: "Statistic",
		props: {
			title: String,
			value: {
				type: [Number, Object]
			},
			format: {
				type: String,
				default: "HH:mm:ss"
			},
			extra: String,
			start: {
				type: Boolean,
				default: !0
			},
			precision: {
				type: Number,
				default: 0
			},
			separator: String,
			showGroupSeparator: {
				type: Boolean,
				default: !1
			},
			animation: {
				type: Boolean,
				default: !1
			},
			animationDuration: {
				type: Number,
				default: 2e3
			},
			valueFrom: {
				type: Number,
				default: void 0
			},
			placeholder: {
				type: String
			},
			valueStyle: {
				type: Object
			}
		},
		setup(o) {
			var s;
			const a = getPrefixCls("statistic"),
				l = computed(() => isNumber$2(o.value) ? o.value : 0),
				c = ref((s = o.valueFrom) != null ? s : o.value),
				d = ref(null),
				{
					value: f
				} = toRefs(o),
				m = computed(() => isUndefined$1(o.value)),
				g = (y = (C => (C = o.valueFrom) != null ? C : 0)(), b = l.value) => {
					var C;
					y !== b && (d.value = new Tween({
						from: {
							value: y
						},
						to: {
							value: b
						},
						duration: o.animationDuration,
						easing: "quartOut",
						onUpdate: _ => {
							c.value = _.value
						},
						onFinish: () => {
							c.value = b
						}
					}), (C = d.value) == null || C.start())
				},
				v = computed(() => {
					let y = c.value;
					if (isNumber$2(y)) {
						isNumber$2(o.precision) && (y = index.round(y, o.precision).toFixed(o.precision));
						const b = String(y).split("."),
							C = o.showGroupSeparator ? Number(b[0]).toLocaleString("en-US") : b[0],
							_ = b[1];
						return {
							isNumber: !0,
							integer: C,
							decimal: _
						}
					}
					return o.format && (y = originDayjs(y).format(o.format)), {
						isNumber: !1,
						value: y
					}
				});
			return onMounted(() => {
				o.animation && o.start && g()
			}), watch(() => o.start, y => {
				y && o.animation && !d.value && g()
			}), watch(f, y => {
				var b;
				d.value && ((b = d.value) == null || b.stop(), d.value = null), c.value = y, o.animation &&
					o.start && g()
			}), {
				prefixCls: a,
				showPlaceholder: m,
				formatValue: v
			}
		}
	}),
	_hoisted_1$h = {
		key: 0
	};

function _sfc_render$y(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [o.title || o.$slots.title ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-title`)
		}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(o.title), 1)])], 2)) :
		createCommentVNode("v-if", !0), createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-value`),
			style: normalizeStyle(o.valueStyle)
		}, [o.showPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_1$h,
			toDisplayString(o.placeholder), 1)) : (openBlock(), createElementBlock(Fragment, {
			key: 1
		}, [o.$slots.prefix ? (openBlock(), createElementBlock("span", {
				key: 0,
				class: normalizeClass(`${o.prefixCls}-prefix`)
			}, [renderSlot(o.$slots, "prefix")], 2)) : createCommentVNode("v-if", !0), o
			.formatValue.isNumber ? (openBlock(), createElementBlock(Fragment, {
				key: 1
			}, [createBaseVNode("span", {
					class: normalizeClass(`${o.prefixCls}-value-integer`)
				}, toDisplayString(o.formatValue.integer), 3), o.formatValue
				.decimal ? (openBlock(), createElementBlock("span", {
					key: 0,
					class: normalizeClass(
						`${o.prefixCls}-value-decimal`)
				}, " ." + toDisplayString(o.formatValue.decimal), 3)) :
				createCommentVNode("v-if", !0)
			], 64)) : (openBlock(), createElementBlock(Fragment, {
				key: 2
			}, [createTextVNode(toDisplayString(o.formatValue.value), 1)], 64)), o
			.$slots.suffix ? (openBlock(), createElementBlock("span", {
				key: 3,
				class: normalizeClass(`${o.prefixCls}-suffix`)
			}, [renderSlot(o.$slots, "suffix")], 2)) : createCommentVNode("v-if", !0)
		], 64))], 6), o.extra || o.$slots.extra ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-extra`)
		}, [renderSlot(o.$slots, "extra", {}, () => [createTextVNode(toDisplayString(o.extra),
			1)])], 2)) : createCommentVNode("v-if", !0)], 2)
	], 2)
}
var _Statistic = _export_sfc$1(_sfc_main$Q, [
	["render", _sfc_render$y]
]);
const units = [
	["Y", 1e3 * 60 * 60 * 24 * 365],
	["M", 1e3 * 60 * 60 * 24 * 30],
	["D", 1e3 * 60 * 60 * 24],
	["H", 1e3 * 60 * 60],
	["m", 1e3 * 60],
	["s", 1e3],
	["S", 1]
];

function getDateString(o, s) {
	let a = o;
	return units.reduce((l, [c, d]) => {
		if (l.indexOf(c) !== -1) {
			const f = Math.floor(a / d);
			return a -= f * d, l.replace(new RegExp(`${c}+`, "g"), m => {
				const g = m.length;
				return String(f).padStart(g, "0")
			})
		}
		return l
	}, s)
}
const _sfc_main$P = defineComponent({
	name: "Countdown",
	props: {
		title: String,
		value: {
			type: Number,
			default: () => Date.now() + 3e5
		},
		now: {
			type: Number,
			default: () => Date.now()
		},
		format: {
			type: String,
			default: "HH:mm:ss"
		},
		start: {
			type: Boolean,
			default: !0
		},
		valueStyle: {
			type: Object
		}
	},
	emits: {
		finish: () => !0
	},
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("statistic"),
			{
				start: l,
				value: c,
				now: d,
				format: f
			} = toRefs(o),
			m = ref(getDateString(Math.max(originDayjs(o.value).diff(originDayjs(o.now), "millisecond"), 0), o
				.format));
		watch([c, d, f], () => {
			const b = getDateString(Math.max(originDayjs(o.value).diff(originDayjs(o.now),
				"millisecond"), 0), o.format);
			b !== m.value && (m.value = b)
		});
		const g = ref(0),
			v = () => {
				g.value && (window.clearInterval(g.value), g.value = 0)
			},
			y = () => {
				originDayjs(o.value).valueOf() < Date.now() || (g.value = window.setInterval(() => {
					const b = originDayjs(o.value).diff(originDayjs(), "millisecond");
					b <= 0 && (v(), s("finish")), m.value = getDateString(Math.max(b, 0), o.format)
				}, 1e3 / 30))
			};
		return onMounted(() => {
			o.start && y()
		}), onBeforeUnmount(() => {
			v()
		}), watch(l, b => {
			b && !g.value && y()
		}), {
			prefixCls: a,
			displayValue: m
		}
	}
});

function _sfc_render$x(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass([`${o.prefixCls}`, `${o.prefixCls}-countdown`])
	}, [o.title || o.$slots.title ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-title`)
		}, [renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(o.title), 1)])], 2)) :
		createCommentVNode("v-if", !0), createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-value`),
			style: normalizeStyle(o.valueStyle)
		}, toDisplayString(o.displayValue), 7)], 2)
	], 2)
}
var Countdown = _export_sfc$1(_sfc_main$P, [
	["render", _sfc_render$x]
]);
const Statistic = Object.assign(_Statistic, {
		Countdown,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Statistic.name, _Statistic), o.component(a + Countdown.name, Countdown)
		}
	}),
	stepsInjectionKey = Symbol("ArcoSteps"),
	_sfc_main$O = defineComponent({
		name: "Steps",
		props: {
			type: {
				type: String,
				default: "default"
			},
			direction: {
				type: String,
				default: "horizontal"
			},
			labelPlacement: {
				type: String,
				default: "horizontal"
			},
			current: {
				type: Number,
				default: void 0
			},
			defaultCurrent: {
				type: Number,
				default: 1
			},
			status: {
				type: String,
				default: "process"
			},
			lineLess: {
				type: Boolean,
				default: !1
			},
			small: {
				type: Boolean,
				default: !1
			},
			changeable: {
				type: Boolean,
				default: !1
			}
		},
		emits: {
			"update:current": o => !0,
			change: (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				type: l,
				lineLess: c
			} = toRefs(o), d = getPrefixCls("steps"), f = ref(o.defaultCurrent), m = computed(() => {
					var A;
					return (A = o.current) != null ? A : f.value
				}), g = computed(() => ["navigation", "arrow"].includes(o.type) ? "horizontal" : o.direction), v =
				computed(() => o.type === "dot" ? g.value === "vertical" ? "horizontal" : "vertical" : o.type ===
					"navigation" ? "horizontal" : o.labelPlacement), y = A => A < m.value ? "finish" : A > m.value ?
				"wait" : o.status, b = (A, k) => {
					o.changeable && (f.value = A, s("update:current", A), s("change", A, k))
				}, C = reactive(new Map), _ = computed(() => Array.from(C.values()).filter(A => A.status ===
					"error").map(A => A.step)), S = (A, k) => {
					C.set(A, k)
				}, w = A => {
					C.delete(A)
				}, T = computed(() => [d, `${d}-${g.value}`, `${d}-label-${v.value}`, `${d}-mode-${l.value}`, {
					[`${d}-changeable`]: o.changeable,
					[`${d}-size-small`]: o.small && o.type !== "dot",
					[`${d}-line-less`]: c.value
				}]);
			return provide(stepsInjectionKey, reactive({
				type: l,
				direction: g,
				labelPlacement: v,
				lineLess: c,
				current: m,
				errorSteps: _,
				getStatus: y,
				addItem: S,
				removeItem: w,
				onClick: b,
				parentCls: d
			})), {
				cls: T
			}
		}
	});

function _sfc_render$w(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [renderSlot(o.$slots, "default")], 2)
}
var _Steps = _export_sfc$1(_sfc_main$O, [
	["render", _sfc_render$w]
]);
const _sfc_main$N = defineComponent({
	name: "Step",
	components: {
		IconCheck,
		IconClose
	},
	props: {
		title: String,
		description: String,
		status: {
			type: String
		},
		disabled: {
			type: Boolean,
			default: !1
		}
	},
	setup(o) {
		const s = getPrefixCls("steps-item"),
			a = getCurrentInstance(),
			l = getPrefixCls("steps-icon"),
			c = inject(stepsInjectionKey, void 0),
			d = computed(() => {
				var S;
				return (S = c == null ? void 0 : c.type) != null ? S : "default"
			}),
			f = ref(),
			{
				computedIndex: m
			} = useIndex({
				itemRef: f,
				selector: `.${s}`,
				parentClassName: c == null ? void 0 : c.parentCls
			}),
			g = computed(() => m.value + 1),
			v = computed(() => {
				var S, w;
				return (w = (S = o.status) != null ? S : c == null ? void 0 : c.getStatus(g.value)) !=
					null ? w : "process"
			}),
			y = computed(() => {
				var S;
				return (S = c == null ? void 0 : c.errorSteps.includes(g.value + 1)) != null ? S : !1
			});
		a && (c == null || c.addItem(a.uid, reactive({
			step: g,
			status: v
		}))), onBeforeUnmount(() => {
			a && (c == null || c.removeItem(a.uid))
		});
		const b = computed(() => !(c != null && c.lineLess) && ((c == null ? void 0 : c.labelPlacement) ===
				"vertical" || (c == null ? void 0 : c.direction) === "vertical")),
			C = S => {
				o.disabled || c == null || c.onClick(g.value, S)
			},
			_ = computed(() => [s, `${s}-${v.value}`, {
				[`${s}-active`]: g.value === (c == null ? void 0 : c.current),
				[`${s}-next-error`]: y.value,
				[`${s}-disabled`]: o.disabled
			}]);
		return {
			prefixCls: s,
			iconCls: l,
			cls: _,
			itemRef: f,
			showTail: b,
			stepNumber: g,
			computedStatus: v,
			type: d,
			handleClick: C
		}
	}
});

function _sfc_render$v(o, s, a, l, c, d) {
	const f = resolveComponent("icon-check"),
		m = resolveComponent("icon-close");
	return openBlock(), createElementBlock("div", {
		ref: "itemRef",
		class: normalizeClass(o.cls),
		onClick: s[0] || (s[0] = (...g) => o.handleClick && o.handleClick(...g))
	}, [o.showTail ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-tail`)
		}, null, 2)) : createCommentVNode("v-if", !0), o.type !== "arrow" ? (openBlock(), createElementBlock(
			"div", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-node`)
			}, [renderSlot(o.$slots, "node", {
				step: o.stepNumber,
				status: o.computedStatus
			}, () => [o.type !== "dot" ? (openBlock(), createElementBlock("div", {
				key: 0,
				class: normalizeClass(o.iconCls)
			}, [renderSlot(o.$slots, "icon", {
				step: o.stepNumber,
				status: o.computedStatus
			}, () => [o.computedStatus === "finish" ? (openBlock(), createBlock(
				f, {
					key: 0
				})) : o.computedStatus === "error" ? (openBlock(),
				createBlock(m, {
					key: 1
				})) : (openBlock(), createElementBlock(Fragment, {
					key: 2
				}, [createTextVNode(toDisplayString(o.stepNumber), 1)],
				64))])], 2)) : createCommentVNode("v-if", !0)])], 2)) : createCommentVNode("v-if", !0),
		createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-title`)
		}, [renderSlot(o.$slots, "default", {}, () => [createTextVNode(toDisplayString(o.title),
			1)])], 2), o.description || o.$slots.description ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-description`)
		}, [renderSlot(o.$slots, "description", {}, () => [createTextVNode(toDisplayString(o
			.description), 1)])], 2)) : createCommentVNode("v-if", !0)], 2)
	], 2)
}
var Step = _export_sfc$1(_sfc_main$N, [
	["render", _sfc_render$v]
]);
const Steps = Object.assign(_Steps, {
		Step,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Steps.name, _Steps), o.component(a + Step.name, Step)
		}
	}),
	_sfc_main$M = defineComponent({
		name: "Switch",
		components: {
			IconLoading
		},
		props: {
			modelValue: {
				type: [String, Number, Boolean],
				default: void 0
			},
			defaultChecked: {
				type: Boolean,
				default: !1
			},
			disabled: {
				type: Boolean,
				default: !1
			},
			loading: {
				type: Boolean,
				default: !1
			},
			type: {
				type: String,
				default: "circle"
			},
			size: {
				type: String
			},
			checkedValue: {
				type: [String, Number, Boolean],
				default: !0
			},
			uncheckedValue: {
				type: [String, Number, Boolean],
				default: !1
			},
			checkedColor: {
				type: String
			},
			uncheckedColor: {
				type: String
			},
			beforeChange: {
				type: Function
			},
			checkedText: {
				type: String
			},
			uncheckedText: {
				type: String
			}
		},
		emits: {
			"update:modelValue": o => !0,
			change: (o, s) => !0,
			focus: o => !0,
			blur: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const {
				disabled: a,
				size: l,
				modelValue: c
			} = toRefs(o), d = getPrefixCls("switch"), {
				mergedSize: f
			} = useSize$1(l), {
				mergedDisabled: m,
				mergedSize: g,
				eventHandlers: v
			} = useFormItem({
				disabled: a,
				size: f
			}), y = ref(o.defaultChecked ? o.checkedValue : o.uncheckedValue), b = computed(() => {
				var D;
				return ((D = o.modelValue) != null ? D : y.value) === o.checkedValue
			}), C = ref(!1), _ = computed(() => C.value || o.loading), S = (D, F) => {
				var R, O;
				y.value = D ? o.checkedValue : o.uncheckedValue, s("update:modelValue", y.value), s("change", y
					.value, F), (O = (R = v.value) == null ? void 0 : R.onChange) == null || O.call(R, F)
			}, w = async D => {
				if (_.value || m.value) return;
				const F = !b.value,
					R = F ? o.checkedValue : o.uncheckedValue,
					O = o.beforeChange;
				if (isFunction$2(O)) {
					C.value = !0;
					try {
						const U = await O(R);
						(U ?? !0) && S(F, D)
					} finally {
						C.value = !1
					}
				} else S(F, D)
			}, T = D => {
				var F, R;
				s("focus", D), (R = (F = v.value) == null ? void 0 : F.onFocus) == null || R.call(F, D)
			}, A = D => {
				var F, R;
				s("blur", D), (R = (F = v.value) == null ? void 0 : F.onBlur) == null || R.call(F, D)
			};
			watch(c, D => {
				(isUndefined$1(D) || isNull$1(D)) && (y.value = o.uncheckedValue)
			});
			const k = computed(() => [d, `${d}-type-${o.type}`, {
					[`${d}-small`]: g.value === "small" || g.value === "mini",
					[`${d}-checked`]: b.value,
					[`${d}-disabled`]: m.value,
					[`${d}-loading`]: _.value,
					[`${d}-custom-color`]: o.type === "line" && (o.checkedColor || o.uncheckedColor)
				}]),
				M = computed(() => {
					if (b.value && o.checkedColor) return o.type === "line" ? {
						"--custom-color": o.checkedColor
					} : {
						backgroundColor: o.checkedColor
					};
					if (!b.value && o.uncheckedColor) return o.type === "line" ? {
						"--custom-color": o.uncheckedColor
					} : {
						backgroundColor: o.uncheckedColor
					}
				});
			return {
				prefixCls: d,
				cls: k,
				mergedDisabled: m,
				buttonStyle: M,
				computedCheck: b,
				computedLoading: _,
				handleClick: w,
				handleFocus: T,
				handleBlur: A
			}
		}
	}),
	_hoisted_1$g = ["aria-checked", "disabled"];

function _sfc_render$u(o, s, a, l, c, d) {
	const f = resolveComponent("icon-loading");
	return openBlock(), createElementBlock("button", {
		type: "button",
		role: "switch",
		"aria-checked": o.computedCheck,
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.buttonStyle),
		disabled: o.mergedDisabled,
		onClick: s[0] || (s[0] = (...m) => o.handleClick && o.handleClick(...m)),
		onFocus: s[1] || (s[1] = (...m) => o.handleFocus && o.handleFocus(...m)),
		onBlur: s[2] || (s[2] = (...m) => o.handleBlur && o.handleBlur(...m))
	}, [createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-handle`)
		}, [createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-handle-icon`)
		}, [o.computedLoading ? (openBlock(), createBlock(f, {
			key: 0
		})) : (openBlock(), createElementBlock(Fragment, {
			key: 1
		}, [o.computedCheck ? renderSlot(o.$slots, "checked-icon", {
			key: 0
		}) : renderSlot(o.$slots, "unchecked-icon", {
			key: 1
		})], 64))], 2)], 2), createCommentVNode("  prettier-ignore  "), o.type !== "line" && o.size !==
		"small" && (o.$slots.checked || o.checkedText || o.$slots.unchecked || o.uncheckedText) ? (openBlock(),
			createElementBlock(Fragment, {
				key: 0
			}, [createBaseVNode("span", {
				class: normalizeClass(`${o.prefixCls}-text-holder`)
			}, [o.computedCheck ? renderSlot(o.$slots, "checked", {
				key: 0
			}, () => [createTextVNode(toDisplayString(o.checkedText), 1)]) : renderSlot(o
				.$slots, "unchecked", {
					key: 1
				}, () => [createTextVNode(toDisplayString(o.uncheckedText), 1)])], 2), createBaseVNode(
				"span", {
					class: normalizeClass(`${o.prefixCls}-text`)
				}, [o.computedCheck ? renderSlot(o.$slots, "checked", {
					key: 0
				}, () => [createTextVNode(toDisplayString(o.checkedText), 1)]) : renderSlot(o
					.$slots, "unchecked", {
						key: 1
					}, () => [createTextVNode(toDisplayString(o.uncheckedText), 1)])], 2)], 64)) :
		createCommentVNode("v-if", !0)
	], 46, _hoisted_1$g)
}
var _Switch = _export_sfc$1(_sfc_main$M, [
	["render", _sfc_render$u]
]);
const Switch = Object.assign(_Switch, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Switch.name, _Switch)
		}
	}),
	getDataColumnsNumber = o => {
		let s = 0;
		const a = l => {
			if (isArray$2(l) && l.length > 0)
				for (const c of l) c.children ? a(c.children) : s += 1
		};
		return a(o), s
	},
	getTotalHeaderRows = o => {
		let s = 0;
		if (isArray$2(o) && o.length > 0) {
			s = 1;
			for (const a of o)
				if (a.children) {
					const l = getTotalHeaderRows(a.children);
					l > 0 && (s = Math.max(s, l + 1))
				}
		}
		return s
	},
	setParentFixed = (o, s) => {
		let {
			parent: a
		} = o;
		for (; a;) a.fixed === s && (s === "left" ? a.isLastLeftFixed = !0 : a.isFirstRightFixed = !0), a = a.parent
	},
	getGroupColumns = (o, s, a) => {
		const l = getTotalHeaderRows(o);
		s.clear();
		const c = [],
			d = [...Array(l)].map(() => []);
		let f, m;
		const g = (v, {
			level: y = 0,
			parent: b,
			fixed: C
		} = {}) => {
			var _;
			for (const S of v) {
				const w = {
					...S,
					parent: b
				};
				if (isArray$2(w.children)) {
					const T = getDataColumnsNumber(w.children);
					T > 1 && (w.colSpan = T), d[y].push(w), g(w.children, {
						level: y + 1,
						parent: w,
						fixed: w.fixed
					})
				} else {
					const T = l - y;
					T > 1 && (w.rowSpan = T), (C || w.fixed) && (w.fixed = (_ = w.fixed) != null ? _ : C, w
							.fixed === "left" ? f = c.length : isUndefined$1(m) && (m = c.length)), (isUndefined$1(w
							.dataIndex) || isNull$1(w.dataIndex)) && (w.dataIndex =
						`__arco_data_index_${c.length}`), a[w.dataIndex] && (w._resizeWidth = a[w.dataIndex]), s
						.set(w.dataIndex, w), c.push(w), d[y].push(w)
				}
			}
		};
		return g(o), isUndefined$1(f) || (c[f].isLastLeftFixed = !0, setParentFixed(c[f], "left")), isUndefined$1(m) ||
			(c[m].isFirstRightFixed = !0, setParentFixed(c[m], "right")), {
				dataColumns: c,
				groupColumns: d
			}
	},
	getOperationColumnIndex = (o, s) => {
		for (let a = 0; a < o.length; a++)
			if (o[a].name === s) return a;
		return -1
	},
	getOperationFixedNumber = (o, s) => {
		var a;
		const l = getOperationColumnIndex(s, o.name);
		if (l <= 0) return 0;
		let c = 0;
		const d = s.slice(0, l);
		for (const f of d) c += (a = f.width) != null ? a : 0;
		return c
	},
	getFirstDataColumn = o => o.children && o.children.length > 0 ? getFirstDataColumn(o.children[0]) : o,
	getLastDataColumn = o => o.children && o.children.length > 0 ? getFirstDataColumn(o.children[o.children.length -
	1]) : o,
	getFixedNumber = (o, {
		dataColumns: s,
		operations: a
	}) => {
		var l, c, d;
		let f = 0;
		if (o.fixed === "left") {
			for (const v of a) f += (l = v.width) != null ? l : 40;
			const g = getFirstDataColumn(o);
			for (const v of s) {
				if (g.dataIndex === v.dataIndex) break;
				f += (d = (c = v._resizeWidth) != null ? c : v.width) != null ? d : 0
			}
			return f
		}
		const m = getLastDataColumn(o);
		for (let g = s.length - 1; g > 0; g--) {
			const v = s[g];
			if (m.dataIndex === v.dataIndex) break;
			v.fixed === "right" && (f += v.width)
		}
		return f
	},
	getOperationFixedCls = (o, s) => s.fixed ? [`${o}-col-fixed-left`, {
		[`${o}-col-fixed-left-last`]: s.isLastLeftFixed
	}] : [],
	getFixedCls = (o, s) => s.fixed === "left" ? [`${o}-col-fixed-left`, {
		[`${o}-col-fixed-left-last`]: s.isLastLeftFixed
	}] : s.fixed === "right" ? [`${o}-col-fixed-right`, {
		[`${o}-col-fixed-right-first`]: s.isFirstRightFixed
	}] : [],
	getStyle = (o, {
		dataColumns: s,
		operations: a
	}) => {
		if (o.fixed) {
			const l = `${getFixedNumber(o,{dataColumns:s,operations:a})}px`;
			return o.fixed === "left" ? {
				left: l
			} : {
				right: l
			}
		}
		return {}
	},
	getOperationStyle = (o, s) => o.fixed ? {
		left: `${getOperationFixedNumber(o,s)}px`
	} : {};

function mapArrayWithChildren(o) {
	return o.map(s => {
		const a = {
			...s
		};
		return a.children && (a.children = mapArrayWithChildren(a.children)), a
	})
}

function mapRawTableData(o) {
	return o.map(s => {
		const a = s.raw;
		return s.children && a.children && (a.children = mapRawTableData(s.children)), s.raw
	})
}
const getLeafKeys = o => {
		const s = [];
		if (o.children)
			for (const a of o.children) a.isLeaf ? s.push(a.key) : s.push(...getLeafKeys(a));
		return s
	},
	getSelectionStatus = (o, s) => {
		let a = !1,
			l = !1;
		const c = s.filter(d => o.includes(d));
		return c.length > 0 && (c.length >= s.length ? a = !0 : l = !0), {
			checked: a,
			indeterminate: l
		}
	},
	union = (o, s, a = !1) => a ? o.filter(l => !s.includes(l)) : Array.from(new Set(o.concat(s))),
	getReverse = o => {
		const s = [];
		for (let a = 0; a < o.length; a++) s[a] = o[o.length - 1 - a];
		return s
	},
	useRowSelection = ({
		selectedKeys: o,
		defaultSelectedKeys: s,
		rowSelection: a,
		currentAllRowKeys: l,
		currentAllEnabledRowKeys: c,
		emit: d
	}) => {
		var f, m, g;
		const v = computed(() => {
				var M;
				return ((M = a.value) == null ? void 0 : M.type) === "radio"
			}),
			y = ref((g = (m = s.value) != null ? m : (f = a.value) == null ? void 0 : f.defaultSelectedRowKeys) !=
				null ? g : []),
			b = computed(() => {
				var M, D, F;
				return (F = (D = o.value) != null ? D : (M = a.value) == null ? void 0 : M.selectedRowKeys) !=
					null ? F : y.value
			}),
			C = computed(() => b.value.filter(M => l.value.includes(M)));
		return {
			isRadio: v,
			selectedRowKeys: b,
			currentSelectedRowKeys: C,
			handleSelectAll: M => {
				const D = union(b.value, c.value, !M);
				y.value = D, d("selectAll", M), d("selectionChange", D), d("update:selectedKeys", D)
			},
			handleSelect: (M, D) => {
				const F = v.value ? [D.key] : union(b.value, [D.key], !M);
				y.value = F, d("select", F, D.key, D.raw), d("selectionChange", F), d("update:selectedKeys", F)
			},
			handleSelectAllLeafs: (M, D) => {
				const F = union(b.value, getLeafKeys(M), !D);
				y.value = F, d("select", F, M.key, M.raw), d("selectionChange", F), d("update:selectedKeys", F)
			},
			select: (M, D = !0) => {
				const F = [].concat(M),
					R = v.value ? F : union(b.value, F, !D);
				y.value = R, d("selectionChange", R), d("update:selectedKeys", R)
			},
			selectAll: (M = !0) => {
				const D = union(b.value, c.value, !M);
				y.value = D, d("selectionChange", D), d("update:selectedKeys", D)
			},
			clearSelected: () => {
				y.value = [], d("selectionChange", []), d("update:selectedKeys", [])
			}
		}
	},
	useExpand = ({
		expandedKeys: o,
		defaultExpandedKeys: s,
		defaultExpandAllRows: a,
		expandable: l,
		allRowKeys: c,
		emit: d
	}) => {
		const m = ref((() => {
				var C, _;
				return s.value ? s.value : (C = l.value) != null && C.defaultExpandedRowKeys ? l.value
					.defaultExpandedRowKeys : a.value || (_ = l.value) != null && _.defaultExpandAllRows ? [...c
						.value
					] : []
			})()),
			g = computed(() => {
				var C, _, S;
				return (S = (_ = o.value) != null ? _ : (C = l.value) == null ? void 0 : C.expandedRowKeys) !=
					null ? S : m.value
			});
		return {
			expandedRowKeys: g,
			handleExpand: (C, _) => {
				const w = g.value.includes(C) ? g.value.filter(T => C !== T) : g.value.concat(C);
				m.value = w, d("expand", C, _), d("expandedChange", w), d("update:expandedKeys", w)
			},
			expand: (C, _ = !0) => {
				const S = [].concat(C),
					w = _ ? g.value.concat(S) : g.value.filter(T => !S.includes(T));
				m.value = w, d("expandedChange", w), d("update:expandedKeys", w)
			},
			expandAll: (C = !0) => {
				const _ = C ? [...c.value] : [];
				m.value = _, d("expandedChange", _), d("update:expandedKeys", _)
			}
		}
	},
	usePagination = (o, s) => {
		var a, l;
		const c = ref(isObject$2(o.pagination) && (a = o.pagination.defaultCurrent) != null ? a : 1),
			d = ref(isObject$2(o.pagination) && (l = o.pagination.defaultPageSize) != null ? l : 10),
			f = computed(() => {
				var y;
				return isObject$2(o.pagination) && (y = o.pagination.pageSize) != null ? y : d.value
			});
		return {
			page: computed(() => {
				var y;
				return isObject$2(o.pagination) && (y = o.pagination.current) != null ? y : c.value
			}),
			pageSize: f,
			handlePageChange: y => {
				c.value = y, s("pageChange", y)
			},
			handlePageSizeChange: y => {
				d.value = y, s("pageSizeChange", y)
			}
		}
	},
	_sfc_main$L = defineComponent({
		name: "ColGroup",
		props: {
			dataColumns: {
				type: Array,
				required: !0
			},
			operations: {
				type: Array,
				required: !0
			},
			columnWidth: {
				type: Object
			}
		},
		setup() {
			return {
				fixedWidth: (s, a) => {
					if (s) {
						const l = Math.max(s, a || 0);
						return {
							width: `${s}px`,
							minWidth: `${l}px`,
							maxWidth: `${s}px`
						}
					}
					if (a) return {
						minWidth: `${a}px`
					}
				}
			}
		}
	});

function _sfc_render$t(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("colgroup", null, [(openBlock(!0), createElementBlock(Fragment, null,
		renderList(o.operations, f => (openBlock(), createElementBlock("col", {
			key: `arco-col-${f.name}`,
			class: normalizeClass(`arco-table-${f.name}-col`),
			style: normalizeStyle(o.fixedWidth(f.width))
		}, null, 6))), 128)), (openBlock(!0), createElementBlock(Fragment, null, renderList(o.dataColumns,
		f => (openBlock(), createElementBlock("col", {
			key: `arco-col-${f.dataIndex}`,
			style: normalizeStyle(o.fixedWidth(o.columnWidth && f.dataIndex && o
				.columnWidth[f.dataIndex] || f.width, f.minWidth))
		}, null, 4))), 128))])
}
var ColGroup = _export_sfc$1(_sfc_main$L, [
		["render", _sfc_render$t]
	]),
	Thead = defineComponent({
		name: "Thead",
		setup(o, {
			slots: s
		}) {
			return () => {
				var a, l;
				return createVNode((l = (a = s.thead) == null ? void 0 : a.call(s)[0]) != null ? l : "thead",
					null, {
						default: s.default
					})
			}
		}
	}),
	Tbody = defineComponent({
		name: "Tbody",
		setup(o, {
			slots: s
		}) {
			return () => {
				var a, l;
				return createVNode((l = (a = s.tbody) == null ? void 0 : a.call(s)[0]) != null ? l : "tbody",
					null, {
						default: s.default
					})
			}
		}
	}),
	Tr = defineComponent({
		name: "Tr",
		props: {
			expand: {
				type: Boolean
			},
			empty: {
				type: Boolean
			},
			checked: {
				type: Boolean
			},
			rowIndex: Number,
			record: {
				type: Object,
				default: () => ({})
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("table"),
				l = computed(() => [`${a}-tr`, {
					[`${a}-tr-expand`]: o.expand,
					[`${a}-tr-empty`]: o.empty,
					[`${a}-tr-checked`]: o.checked
				}]);
			return () => {
				var c, d, f;
				return createVNode((f = (d = s.tr) == null ? void 0 : d.call(s, {
					rowIndex: o.rowIndex,
					record: (c = o.record) == null ? void 0 : c.raw
				})[0]) != null ? f : "tr", {
					class: l.value
				}, {
					default: s.default
				})
			}
		}
	});
const _sfc_main$K = defineComponent({
		name: "IconCaretDown",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-caret-down`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$f = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$s(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M24.938 34.829a1.2 1.2 0 0 1-1.875 0L9.56 17.949c-.628-.785-.069-1.949.937-1.949h27.007c1.006 0 1.565 1.164.937 1.95L24.937 34.829Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$f)
}
var _IconCaretDown = _export_sfc$1(_sfc_main$K, [
	["render", _sfc_render$s]
]);
const IconCaretDown = Object.assign(_IconCaretDown, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconCaretDown.name, _IconCaretDown)
		}
	}),
	_sfc_main$J = defineComponent({
		name: "IconCaretUp",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-caret-up`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$e = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$r(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M23.063 13.171a1.2 1.2 0 0 1 1.875 0l13.503 16.88c.628.785.069 1.949-.937 1.949H10.497c-1.006 0-1.565-1.164-.937-1.95l13.503-16.879Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$e)
}
var _IconCaretUp = _export_sfc$1(_sfc_main$J, [
	["render", _sfc_render$r]
]);
const IconCaretUp = Object.assign(_IconCaretUp, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconCaretUp.name, _IconCaretUp)
		}
	}),
	_sfc_main$I = defineComponent({
		name: "IconFilter",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-filter`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$d = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$q(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M30 42V22.549a1 1 0 0 1 .463-.844l10.074-6.41A1 1 0 0 0 41 14.45V8a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v6.451a1 1 0 0 0 .463.844l10.074 6.41a1 1 0 0 1 .463.844V37"
	}, null, -1)]), 14, _hoisted_1$d)
}
var _IconFilter = _export_sfc$1(_sfc_main$I, [
	["render", _sfc_render$q]
]);
const IconFilter = Object.assign(_IconFilter, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconFilter.name, _IconFilter)
		}
	}),
	useColumnSorter = ({
		column: o,
		tableCtx: s
	}) => {
		const a = computed(() => {
				var v;
				if (o.value.dataIndex && o.value.dataIndex === ((v = s.sorter) == null ? void 0 : v.field)) return s
					.sorter.direction
			}),
			l = computed(() => {
				var v, y, b;
				return (b = (y = (v = o.value) == null ? void 0 : v.sortable) == null ? void 0 : y
					.sortDirections) != null ? b : []
			}),
			c = computed(() => l.value.length > 0),
			d = computed(() => l.value.includes("ascend")),
			f = computed(() => l.value.includes("descend")),
			m = computed(() => {
				var v, y;
				return a.value ? a.value === l.value[0] && (y = l.value[1]) != null ? y : "" : (v = l.value[0]) !=
					null ? v : ""
			});
		return {
			sortOrder: a,
			hasSorter: c,
			hasAscendBtn: d,
			hasDescendBtn: f,
			nextSortOrder: m,
			handleClickSorter: v => {
				var y;
				o.value.dataIndex && ((y = s.onSorterChange) == null || y.call(s, o.value.dataIndex, m.value, v))
			}
		}
	},
	useColumnFilter = ({
		column: o,
		tableCtx: s
	}) => {
		const a = computed(() => {
				var _;
				return o.value.dataIndex && ((_ = s.filters) != null && _[o.value.dataIndex]) ? s.filters[o.value
					.dataIndex] : []
			}),
			l = ref(!1),
			c = computed(() => a.value.length > 0),
			d = computed(() => {
				var _;
				return !!((_ = o.value.filterable) != null && _.multiple)
			}),
			f = ref(a.value);
		watch(a, _ => {
			isArray$2(_) && String(_) !== String(f.value) && (f.value = _)
		});
		const m = _ => {
				l.value = _
			},
			g = _ => {
				f.value = _
			};
		return {
			filterPopupVisible: l,
			isFilterActive: c,
			isMultipleFilter: d,
			columnFilterValue: f,
			handleFilterPopupVisibleChange: m,
			setFilterValue: g,
			handleCheckboxFilterChange: _ => {
				g(_)
			},
			handleRadioFilterChange: _ => {
				g([_])
			},
			handleFilterConfirm: _ => {
				var S;
				o.value.dataIndex && ((S = s.onFilterChange) == null || S.call(s, o.value.dataIndex, f.value, _)),
					m(!1)
			},
			handleFilterReset: _ => {
				var S;
				g([]), o.value.dataIndex && ((S = s.onFilterChange) == null || S.call(s, o.value.dataIndex, f.value,
					_)), m(!1)
			}
		}
	},
	tableInjectionKey = Symbol("ArcoTable"),
	tableColumnInjectionKey = Symbol("ArcoTableColumn");

function _isSlot$6(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var AutoTooltip = defineComponent({
	name: "AutoTooltip",
	inheritAttrs: !1,
	props: {
		tooltipProps: {
			type: Object
		}
	},
	setup(o, {
		attrs: s,
		slots: a
	}) {
		const l = getPrefixCls("auto-tooltip"),
			c = ref(),
			d = ref(),
			f = ref(""),
			m = ref(!1),
			g = () => {
				if (c.value && d.value) {
					const C = d.value.offsetWidth > c.value.offsetWidth;
					C !== m.value && (m.value = C)
				}
			},
			v = () => {
				var C;
				(C = d.value) != null && C.textContent && d.value.textContent !== f.value && (f.value = d.value
					.textContent)
			},
			y = () => {
				v(), g()
			};
		onMounted(() => {
			v(), g()
		}), onUpdated(() => {
			v(), g()
		});
		const b = () => createVNode("span", mergeProps({
			ref: c,
			class: l
		}, s), [createVNode(ResizeObserver$1, {
			onResize: y
		}, {
			default: () => {
				var C;
				return [createVNode("span", {
					ref: d,
					class: `${l}-content`
				}, [(C = a.default) == null ? void 0 : C.call(a)])]
			}
		})]);
		return () => {
			let C;
			if (m.value) {
				let _;
				return createVNode(Tooltip, mergeProps({
					content: f.value,
					onResize: y
				}, o.tooltipProps), _isSlot$6(_ = b()) ? _ : {
					default: () => [_]
				})
			}
			return createVNode(ResizeObserver$1, {
				onResize: y
			}, _isSlot$6(C = b()) ? C : {
				default: () => [C]
			})
		}
	}
});

function _isSlot$5(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var Th = defineComponent({
	name: "Th",
	props: {
		column: {
			type: Object,
			default: () => ({})
		},
		operations: {
			type: Array,
			default: () => []
		},
		dataColumns: {
			type: Array,
			default: () => []
		},
		resizable: Boolean
	},
	setup(o, {
		slots: s
	}) {
		const {
			column: a
		} = toRefs(o), l = getPrefixCls("table"), {
			t: c
		} = useI18n(), d = inject(tableInjectionKey, {}), f = computed(() => {
			var fe;
			return ((fe = o.column) == null ? void 0 : fe.dataIndex) && d.resizingColumn === o.column
				.dataIndex
		}), m = computed(() => {
			var fe;
			if (isObject$2((fe = o.column) == null ? void 0 : fe.tooltip)) return o.column.tooltip
		}), g = computed(() => {
			var fe;
			return (fe = o.column) != null && fe.filterable && isBoolean$2(o.column.filterable
				.alignLeft) ? o.column.filterable.alignLeft : d.filterIconAlignLeft
		}), {
			sortOrder: v,
			hasSorter: y,
			hasAscendBtn: b,
			hasDescendBtn: C,
			nextSortOrder: _,
			handleClickSorter: S
		} = useColumnSorter({
			column: a,
			tableCtx: d
		}), {
			filterPopupVisible: w,
			isFilterActive: T,
			isMultipleFilter: A,
			columnFilterValue: k,
			handleFilterPopupVisibleChange: M,
			setFilterValue: D,
			handleCheckboxFilterChange: F,
			handleRadioFilterChange: R,
			handleFilterConfirm: O,
			handleFilterReset: U
		} = useColumnFilter({
			column: a,
			tableCtx: d
		}), V = () => {
			var fe, q, le, de, _e;
			let ke, De;
			const {
				filterable: Se
			} = o.column;
			return (fe = o.column.slots) != null && fe["filter-content"] ? (q = o.column.slots) == null ?
				void 0 : q["filter-content"]({
					filterValue: k.value,
					setFilterValue: D,
					handleFilterConfirm: O,
					handleFilterReset: U
				}) : Se != null && Se.slotName ? (de = (le = d == null ? void 0 : d.slots) == null ?
					void 0 : le[Se == null ? void 0 : Se.slotName]) == null ? void 0 : de.call(le, {
					filterValue: k.value,
					setFilterValue: D,
					handleFilterConfirm: O,
					handleFilterReset: U
				}) : Se != null && Se.renderContent ? Se.renderContent({
					filterValue: k.value,
					setFilterValue: D,
					handleFilterConfirm: O,
					handleFilterReset: U
				}) : createVNode("div", {
					class: `${l}-filters-content`
				}, [createVNode("ul", {
					class: `${l}-filters-list`
				}, [(_e = Se == null ? void 0 : Se.filters) == null ? void 0 : _e.map((be,
					Me) => {
						var Ve;
						return createVNode("li", {
							class: `${l}-filters-item`,
							key: Me
						}, [A.value ? createVNode(Checkbox, {
							value: be.value,
							modelValue: k.value,
							uninjectGroupContext: !0,
							onChange: F
						}, {
							default: () => [be.text]
						}) : createVNode(Radio, {
							value: be.value,
							modelValue: (Ve = k.value[0]) != null ? Ve : "",
							uninjectGroupContext: !0,
							onChange: R
						}, {
							default: () => [be.text]
						})])
					})]), createVNode("div", {
					class: `${l}-filters-bottom`
				}, [createVNode(Button, {
					size: "mini",
					onClick: U
				}, _isSlot$5(ke = c("table.resetText")) ? ke : {
					default: () => [ke]
				}), createVNode(Button, {
					type: "primary",
					size: "mini",
					onClick: O
				}, _isSlot$5(De = c("table.okText")) ? De : {
					default: () => [De]
				})])])
		}, z = () => {
			const {
				filterable: fe
			} = o.column;
			return fe ? createVNode(Trigger, mergeProps({
				popupVisible: w.value,
				trigger: "click",
				autoFitPosition: !0,
				popupOffset: g.value ? 4 : 0,
				onPopupVisibleChange: M
			}, fe.triggerProps), {
				default: () => [createVNode(IconHover, {
					class: [`${l}-filters`, {
						[`${l}-filters-active`]: T.value,
						[`${l}-filters-open`]: w.value,
						[`${l}-filters-align-left`]: g.value
					}],
					disabled: !g.value,
					onClick: q => q.stopPropagation()
				}, {
					default: () => {
						var q, le, de, _e, ke;
						return [(ke = (_e = (le = (q = o.column.slots) == null ?
									void 0 : q["filter-icon"]) == null ?
								void 0 : le.call(q)) != null ? _e : (de = fe
								.icon) == null ? void 0 : de.call(fe)) != null ?
							ke : createVNode(IconFilter, null, null)
						]
					}
				})],
				content: V
			}) : null
		}, j = computed(() => {
			var fe, q;
			const le = [`${l}-cell`,
				`${l}-cell-align-${(q=(fe=o.column)==null?void 0:fe.align)!=null?q:o.column.children?"center":"left"}`
			];
			return y.value && le.push(`${l}-cell-with-sorter`, {
				[`${l}-cell-next-ascend`]: _.value === "ascend",
				[`${l}-cell-next-descend`]: _.value === "descend"
			}), g.value && le.push(`${l}-cell-with-filter`), le
		}), ge = () => {
			var fe, q, le, de, _e, ke;
			return s.default ? s.default() : (fe = o.column) != null && fe.titleSlotName && ((q = d
					.slots) != null && q[o.column.titleSlotName]) ? (de = (le = d.slots)[o.column
					.titleSlotName]) == null ? void 0 : de.call(le, {
					column: o.column
				}) : (ke = (_e = o.column) == null ? void 0 : _e.slots) != null && ke.title ? o.column.slots
				.title() : isFunction$2(o.column.title) ? o.column.title() : o.column.title
		}, me = () => {
			var fe, q, le;
			let de;
			return createVNode("span", {
				class: j.value,
				onClick: y.value ? S : void 0
			}, [(fe = o.column) != null && fe.ellipsis && ((q = o.column) != null && q.tooltip) ?
				createVNode(AutoTooltip, {
					class: `${l}-th-title`,
					tooltipProps: m.value
				}, _isSlot$5(de = ge()) ? de : {
					default: () => [de]
				}) : createVNode("span", {
					class: [`${l}-th-title`, {
						[`${l}-text-ellipsis`]: (le = o.column) == null ? void 0 : le
							.ellipsis
					}]
				}, [ge()]), y.value && createVNode("span", {
					class: `${l}-sorter`
				}, [b.value && createVNode("div", {
					class: [`${l}-sorter-icon`, {
						[`${l}-sorter-icon-active`]: v.value === "ascend"
					}]
				}, [createVNode(IconCaretUp, null, null)]), C.value && createVNode("div", {
					class: [`${l}-sorter-icon`, {
						[`${l}-sorter-icon-active`]: v.value === "descend"
					}]
				}, [createVNode(IconCaretDown, null, null)])]), g.value && z()
			])
		}, he = computed(() => {
			var fe, q;
			return {
				...getStyle(o.column, {
					dataColumns: o.dataColumns,
					operations: o.operations
				}),
				...(fe = o.column) == null ? void 0 : fe.cellStyle,
				...(q = o.column) == null ? void 0 : q.headerCellStyle
			}
		}), ce = computed(() => {
			var fe, q;
			return [`${l}-th`, {
				[`${l}-col-sorted`]: !!v.value,
				[`${l}-th-resizing`]: f.value
			}, ...getFixedCls(l, o.column), (fe = o.column) == null ? void 0 : fe.cellClass, (
				q = o.column) == null ? void 0 : q.headerCellClass]
		}), ae = fe => {
			var q, le, de;
			(q = o.column) != null && q.dataIndex && ((de = d.onThMouseDown) == null || de.call(d, (le = o
				.column) == null ? void 0 : le.dataIndex, fe))
		};
		return () => {
			var fe, q, le, de;
			const _e = (fe = o.column.colSpan) != null ? fe : 1,
				ke = (q = o.column.rowSpan) != null ? q : 1;
			return createVNode((de = (le = s.th) == null ? void 0 : le.call(s, {
				column: o.column
			})[0]) != null ? de : "th", {
				class: ce.value,
				style: he.value,
				colspan: _e > 1 ? _e : void 0,
				rowspan: ke > 1 ? ke : void 0
			}, {
				default: () => [me(), !g.value && z(), o.resizable && createVNode("span", {
					class: `${l}-column-handle`,
					onMousedown: ae
				}, null)]
			})
		}
	}
});

function _isSlot$4(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var Td = defineComponent({
		name: "Td",
		props: {
			rowIndex: Number,
			record: {
				type: Object,
				default: () => ({})
			},
			column: {
				type: Object,
				default: () => ({})
			},
			type: {
				type: String,
				default: "normal"
			},
			operations: {
				type: Array,
				default: () => []
			},
			dataColumns: {
				type: Array,
				default: () => []
			},
			colSpan: {
				type: Number,
				default: 1
			},
			rowSpan: {
				type: Number,
				default: 1
			},
			isFixedExpand: {
				type: Boolean,
				default: !1
			},
			containerWidth: {
				type: Number
			},
			showExpandBtn: {
				type: Boolean,
				default: !1
			},
			indentSize: {
				type: Number,
				default: 0
			},
			renderExpandBtn: {
				type: Function
			},
			summary: {
				type: Boolean,
				default: !1
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("table"),
				l = computed(() => {
					var T;
					if (isObject$2((T = o.column) == null ? void 0 : T.tooltip)) return o.column.tooltip
				}),
				c = computed(() => {
					var T, A;
					return ((T = o.column) == null ? void 0 : T.dataIndex) && ((A = b.sorter) == null ? void 0 :
						A.field) === o.column.dataIndex
				}),
				d = computed(() => {
					var T;
					return ((T = o.column) == null ? void 0 : T.dataIndex) && b.resizingColumn === o.column
						.dataIndex
				}),
				f = () => {
					var T, A, k, M, D, F;
					return o.summary ? isFunction$2((T = o.column) == null ? void 0 : T.summaryCellClass) ? o.column
						.summaryCellClass((A = o.record) == null ? void 0 : A.raw) : (k = o.column) == null ?
						void 0 : k.summaryCellClass : isFunction$2((M = o.column) == null ? void 0 : M
							.bodyCellClass) ? o.column.bodyCellClass((D = o.record) == null ? void 0 : D.raw) : (F =
							o.column) == null ? void 0 : F.bodyCellClass
				},
				m = computed(() => {
					var T;
					return [`${a}-td`, {
						[`${a}-col-sorted`]: c.value,
						[`${a}-td-resizing`]: d.value
					}, ...getFixedCls(a, o.column), (T = o.column) == null ? void 0 : T.cellClass, f()]
				}),
				g = () => {
					var T, A, k, M, D, F;
					return o.summary ? isFunction$2((T = o.column) == null ? void 0 : T.summaryCellStyle) ? o.column
						.summaryCellStyle((A = o.record) == null ? void 0 : A.raw) : (k = o.column) == null ?
						void 0 : k.summaryCellStyle : isFunction$2((M = o.column) == null ? void 0 : M
							.bodyCellStyle) ? o.column.bodyCellStyle((D = o.record) == null ? void 0 : D.raw) : (F =
							o.column) == null ? void 0 : F.bodyCellStyle
				},
				v = computed(() => {
					var T;
					const A = getStyle(o.column, {
							dataColumns: o.dataColumns,
							operations: o.operations
						}),
						k = g();
					return {
						...A,
						...(T = o.column) == null ? void 0 : T.cellStyle,
						...k
					}
				}),
				y = computed(() => {
					if (o.isFixedExpand && o.containerWidth) return {
						width: `${o.containerWidth}px`
					}
				}),
				b = inject(tableInjectionKey, {}),
				C = () => {
					var T, A, k, M, D, F, R, O;
					if (s.default) return s.default();
					const U = {
						record: (T = o.record) == null ? void 0 : T.raw,
						column: o.column,
						rowIndex: (A = o.rowIndex) != null ? A : -1
					};
					return s.cell ? s.cell(U) : (k = o.column.slots) != null && k.cell ? o.column.slots.cell(U) : o
						.column.render ? o.column.render(U) : o.column.slotName && ((M = b.slots) != null && M[o
							.column.slotName]) ? (F = (D = b.slots)[o.column.slotName]) == null ? void 0 : F.call(D,
							U) : String((O = getValueByPath((R = o.record) == null ? void 0 : R.raw, o.column
							.dataIndex)) != null ? O : "")
				},
				_ = ref(!1),
				S = T => {
					var A, k;
					isFunction$2(b.loadMore) && !((A = o.record) != null && A.isLeaf) && !((k = o.record) != null &&
						k.children) && (_.value = !0, new Promise(M => {
						var D;
						(D = b.loadMore) == null || D.call(b, o.record.raw, M)
					}).then(M => {
						var D;
						(D = b.addLazyLoadData) == null || D.call(b, M, o.record), _.value = !1
					})), T.stopPropagation()
				},
				w = () => {
					var T, A, k, M, D, F;
					let R;
					return createVNode("span", {
						class: [`${a}-cell`,
							`${a}-cell-align-${(A=(T=o.column)==null?void 0:T.align)!=null?A:"left"}`, {
								[`${a}-cell-fixed-expand`]: o.isFixedExpand,
								[`${a}-cell-expand-icon`]: o.showExpandBtn
							}
						],
						style: y.value
					}, [o.indentSize > 0 && createVNode("span", {
							style: {
								paddingLeft: `${o.indentSize}px`
							}
						}, null), o.showExpandBtn && createVNode("span", {
							class: `${a}-cell-inline-icon`,
							onClick: S
						}, [_.value ? createVNode(IconLoading, null, null) : (k = o.renderExpandBtn) ==
							null ? void 0 : k.call(o, o.record, !1)
						]), (M = o.column) != null && M.ellipsis && ((D = o.column) != null && D.tooltip) ?
						createVNode(AutoTooltip, {
							class: `${a}-td-content`,
							tooltipProps: l.value
						}, _isSlot$4(R = C()) ? R : {
							default: () => [R]
						}) : createVNode("span", {
							class: [`${a}-td-content`, {
								[`${a}-text-ellipsis`]: (F = o.column) == null ? void 0 : F
									.ellipsis
							}]
						}, [C()])
					])
				};
			return () => {
				var T, A, k, M;
				return createVNode((M = (k = s.td) == null ? void 0 : k.call(s, {
					record: (T = o.record) == null ? void 0 : T.raw,
					column: o.column,
					rowIndex: (A = o.rowIndex) != null ? A : -1
				})[0]) != null ? M : "td", {
					class: m.value,
					style: v.value,
					rowspan: o.rowSpan > 1 ? o.rowSpan : void 0,
					colspan: o.colSpan > 1 ? o.colSpan : void 0
				}, {
					default: () => [w()]
				})
			}
		}
	}),
	OperationTh = defineComponent({
		name: "OperationTh",
		props: {
			operationColumn: {
				type: Object,
				required: !0
			},
			operations: {
				type: Array,
				required: !0
			},
			rowSpan: {
				type: Number,
				default: 1
			},
			selectAll: {
				type: Boolean,
				default: !1
			}
		},
		setup(o) {
			const s = getPrefixCls("table"),
				a = inject(tableInjectionKey, {}),
				l = computed(() => {
					var m, g, v, y;
					let b = !1,
						C = !1;
					const S = ((g = (m = a.currentSelectedRowKeys) == null ? void 0 : m.filter(T => {
							var A, k;
							return (k = (A = a.currentAllEnabledRowKeys) == null ? void 0 : A
								.includes(T)) != null ? k : !0
						})) != null ? g : []).length,
						w = (y = (v = a.currentAllEnabledRowKeys) == null ? void 0 : v.length) != null ? y : 0;
					return S > 0 && (S >= w ? b = !0 : C = !0), {
						checked: b,
						indeterminate: C
					}
				}),
				c = () => o.selectAll ? createVNode(Checkbox, {
					modelValue: l.value.checked,
					indeterminate: l.value.indeterminate,
					uninjectGroupContext: !0,
					onChange: m => {
						var g;
						(g = a.onSelectAll) == null || g.call(a, m)
					}
				}, {
					default: isFunction$2(o.operationColumn.title) ? o.operationColumn.title() : o
						.operationColumn.title
				}) : o.operationColumn.title ? isFunction$2(o.operationColumn.title) ? o.operationColumn.title() : o
				.operationColumn.title : null,
				d = computed(() => getOperationStyle(o.operationColumn, o.operations)),
				f = computed(() => [`${s}-th`, `${s}-operation`, {
					[`${s}-checkbox`]: o.selectAll
				}, ...getOperationFixedCls(s, o.operationColumn)]);
			return () => createVNode("th", {
				class: f.value,
				style: d.value,
				rowspan: o.rowSpan > 1 ? o.rowSpan : void 0
			}, [createVNode("span", {
				class: `${s}-cell`
			}, [c()])])
		}
	}),
	OperationTd = defineComponent({
		name: "OperationTd",
		components: {
			Checkbox,
			Radio,
			IconPlus,
			IconMinus
		},
		props: {
			operationColumn: {
				type: Object,
				required: !0
			},
			operations: {
				type: Array,
				required: !0
			},
			record: {
				type: Object,
				required: !0
			},
			hasExpand: {
				type: Boolean,
				default: !1
			},
			selectedRowKeys: {
				type: Array
			},
			renderExpandBtn: {
				type: Function
			},
			colSpan: {
				type: Number,
				default: 1
			},
			rowSpan: {
				type: Number,
				default: 1
			},
			summary: {
				type: Boolean,
				default: !1
			}
		},
		emits: ["select"],
		setup(o, {
			emit: s,
			slots: a
		}) {
			const l = getPrefixCls("table"),
				c = inject(tableInjectionKey, {}),
				d = computed(() => getOperationStyle(o.operationColumn, o.operations)),
				f = computed(() => [`${l}-td`, `${l}-operation`, {
					[`${l}-checkbox`]: o.operationColumn.name === "selection-checkbox",
					[`${l}-radio`]: o.operationColumn.name === "selection-radio",
					[`${l}-expand`]: o.operationColumn.name === "expand",
					[`${l}-drag-handle`]: o.operationColumn.name === "drag-handle"
				}, ...getOperationFixedCls(l, o.operationColumn)]),
				m = computed(() => getLeafKeys(o.record)),
				g = computed(() => {
					var y;
					return getSelectionStatus((y = c.currentSelectedRowKeys) != null ? y : [], m.value)
				}),
				v = () => {
					var y, b, C, _, S, w;
					if (o.summary) return null;
					if (o.operationColumn.render) return o.operationColumn.render(o.record.raw);
					if (o.operationColumn.name === "selection-checkbox") {
						const T = o.record.key;
						return !c.checkStrictly && !o.record.isLeaf ? createVNode(Checkbox, {
							modelValue: g.value.checked,
							indeterminate: g.value.indeterminate,
							disabled: !!o.record.disabled,
							uninjectGroupContext: !0,
							onChange: A => {
								var k;
								return (k = c.onSelectAllLeafs) == null ? void 0 : k.call(c, o.record,
									A)
							},
							onClick: A => A.stopPropagation()
						}, null) : createVNode(Checkbox, {
							modelValue: (b = (y = o.selectedRowKeys) == null ? void 0 : y.includes(T)) !=
								null ? b : !1,
							disabled: !!o.record.disabled,
							uninjectGroupContext: !0,
							onChange: A => {
								var k;
								return (k = c.onSelect) == null ? void 0 : k.call(c, A, o.record)
							},
							onClick: A => A.stopPropagation()
						}, null)
					}
					if (o.operationColumn.name === "selection-radio") {
						const T = o.record.key;
						return createVNode(Radio, {
							modelValue: (_ = (C = o.selectedRowKeys) == null ? void 0 : C.includes(T)) !=
								null ? _ : !1,
							disabled: !!o.record.disabled,
							uninjectGroupContext: !0,
							onChange: A => {
								var k;
								return (k = c.onSelect) == null ? void 0 : k.call(c, A, o.record)
							},
							onClick: A => A.stopPropagation()
						}, null)
					}
					return o.operationColumn.name === "expand" ? o.hasExpand && o.renderExpandBtn ? o
						.renderExpandBtn(o.record) : null : o.operationColumn.name === "drag-handle" ? (w = (S = a[
							"drag-handle-icon"]) == null ? void 0 : S.call(a)) != null ? w : createVNode(
							IconDragDotVertical, null, null) : null
				};
			return () => createVNode("td", {
				class: f.value,
				style: d.value,
				rowspan: o.rowSpan > 1 ? o.rowSpan : void 0,
				colspan: o.colSpan > 1 ? o.colSpan : void 0
			}, [createVNode("span", {
				class: `${l}-cell`
			}, [v()])])
		}
	});
const useDrag = o => {
		const s = computed(() => {
				if (o.value) return o.value.type === "handle" ? "handle" : "row"
			}),
			a = reactive({
				dragging: !1,
				sourceKey: "",
				sourcePath: [],
				targetPath: [],
				data: {}
			}),
			l = () => {
				a.dragging = !1, a.sourceKey = "", a.sourcePath = [], a.targetPath = [], a.data = {}
			};
		return {
			dragType: s,
			dragState: a,
			handleDragStart: (y, b, C, _) => {
				if (y.dataTransfer && (y.dataTransfer.effectAllowed = "move", y.target && y.target.tagName ===
					"TD")) {
					const {
						parentElement: S
					} = y.target;
					S && S.tagName === "TR" && y.dataTransfer.setDragImage(S, 0, 0)
				}
				a.dragging = !0, a.sourceKey = b, a.sourcePath = C, a.targetPath = [...C], a.data = _
			},
			handleDragEnter: (y, b) => {
				y.dataTransfer && (y.dataTransfer.dropEffect = "move"), a.targetPath.toString() !== b.toString() &&
					(a.targetPath = b), y.preventDefault()
			},
			handleDragLeave: y => {},
			handleDragover: y => {
				y.dataTransfer && (y.dataTransfer.dropEffect = "move"), y.preventDefault()
			},
			handleDragEnd: y => {
				var b;
				((b = y.dataTransfer) == null ? void 0 : b.dropEffect) === "none" && l()
			},
			handleDrop: y => {
				l(), y.preventDefault()
			}
		}
	},
	useColumnResize = (o, s) => {
		const a = ref(""),
			l = reactive({}),
			c = (m, g) => {
				g.preventDefault(), a.value = m, on(window, "mousemove", f), on(window, "mouseup", d), on(window,
					"contextmenu", d)
			},
			d = () => {
				a.value = "", off(window, "mousemove", f), off(window, "mouseup", d), off(window, "contextmenu", d)
			},
			f = m => {
				const g = o.value[a.value];
				if (g) {
					const {
						clientX: v
					} = m, {
						x: y
					} = g.getBoundingClientRect();
					let b = Math.ceil(v - y);
					b < 40 && (b = 40), l[a.value] = b, s("columnResize", a.value, b)
				}
			};
		return {
			resizingColumn: a,
			columnWidth: l,
			handleThMouseDown: c,
			handleThMouseUp: d
		}
	},
	useFilter = ({
		columns: o,
		onFilterChange: s
	}) => {
		const a = ref(getDefaultFilters(o.value));
		watch(o, f => {
			const m = getDefaultFilters(f);
			isEqual$1(m, a.value) || (a.value = m)
		});
		const l = computed(() => {
			var f, m;
			const g = {};
			for (const v of o.value)
				if (v.dataIndex) {
					const y = (m = (f = v.filterable) == null ? void 0 : f.filteredValue) != null ? m : a.value[
						v.dataIndex];
					y && (g[v.dataIndex] = y)
				} return g
		});
		return {
			_filters: a,
			computedFilters: l,
			resetFilters: f => {
				var m;
				const g = f ? [].concat(f) : [],
					v = {};
				for (const y of o.value)
					if (y.dataIndex && y.filterable && (g.length === 0 || g.includes(y.dataIndex))) {
						const b = (m = y.filterable.defaultFilteredValue) != null ? m : [];
						v[y.dataIndex] = b, s(y.dataIndex, b)
					} a.value = v
			},
			clearFilters: f => {
				const m = f ? [].concat(f) : [],
					g = {};
				for (const v of o.value)
					if (v.dataIndex && v.filterable && (m.length === 0 || m.includes(v.dataIndex))) {
						const y = [];
						g[v.dataIndex] = y, s(v.dataIndex, y)
					} a.value = g
			}
		}
	},
	getDefaultFilters = o => {
		var s;
		const a = {};
		for (const l of o) l.dataIndex && ((s = l.filterable) != null && s.defaultFilteredValue) && (a[l.dataIndex] = l
			.filterable.defaultFilteredValue);
		return a
	},
	useSorter = ({
		columns: o,
		onSorterChange: s
	}) => {
		const a = ref(getDefaultSorter(o.value));
		watch(o, f => {
			const m = getDefaultSorter(f);
			isEqual$1(m, a.value) || (a.value = m)
		});
		const l = computed(() => {
			var f;
			for (const m of o.value)
				if (m.dataIndex && m.sortable) {
					const g = isString$2(m.sortable.sortOrder) ? m.sortable.sortOrder : ((f = a.value) == null ?
						void 0 : f.field) === m.dataIndex ? a.value.direction : "";
					if (g) return {
						field: m.dataIndex,
						direction: g
					}
				}
		});
		return {
			_sorter: a,
			computedSorter: l,
			resetSorters: () => {
				var f;
				let m;
				for (const g of o.value) g.dataIndex && g.sortable && (!m && g.sortable.defaultSortOrder && (m = {
					field: g.dataIndex,
					direction: g.sortable.defaultSortOrder
				}), s(g.dataIndex, (f = g.sortable.defaultSortOrder) != null ? f : ""));
				a.value = m
			},
			clearSorters: () => {
				for (const f of o.value) f.dataIndex && f.sortable && s(f.dataIndex, "")
			}
		}
	},
	getDefaultSorter = o => {
		var s;
		for (const a of o)
			if (a.dataIndex && ((s = a.sortable) != null && s.defaultSortOrder)) return {
				field: a.dataIndex,
				direction: a.sortable.defaultSortOrder
			}
	},
	useSpan = ({
		spanMethod: o,
		data: s,
		columns: a
	}) => {
		const l = (m, g) => {
			m == null || m.forEach((v, y) => {
				var b;
				v.hasSubtree && ((b = v.children) != null && b.length) && l(v.children || [], g), a.value
					.forEach((C, _) => {
						var S, w;
						const {
							rowspan: T = 1,
							colspan: A = 1
						} = (w = (S = o.value) == null ? void 0 : S.call(o, {
							record: v.raw,
							column: C,
							rowIndex: y,
							columnIndex: _
						})) != null ? w : {};
						(T > 1 || A > 1) && (g[`${y}-${_}-${v.key}`] = [T, A], Array.from({
							length: T
						}).forEach((k, M) => {
							var D;
							if (y + M < m.length) {
								const {
									key: F
								} = (D = m[y + M]) != null ? D : {};
								Array.from({
									length: A
								}).forEach((R, O) => {
									_ + O < a.value.length && `${y}-${_}-${v.key}` !=
										`${y+M}-${_+O}-${F}` && (c.value[
											`${y+M}-${_+O}-${F}`] = [0, 0])
								})
							}
						}))
					})
			})
		};
		let c = ref({});
		const d = computed(() => {
				const m = {};
				return c.value = {}, o.value && l(s.value, m), m
			}),
			f = computed(() => {
				const m = [];
				for (const g of Object.keys(c.value)) m.push(g);
				return m
			});
		return {
			tableSpan: d,
			removedCells: f
		}
	};

function _isSlot$3(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
const DEFAULT_BORDERED = {
	wrapper: !0,
	cell: !1,
	headerCell: !1,
	bodyCell: !1
};
var _Table = defineComponent({
	name: "Table",
	props: {
		columns: {
			type: Array,
			default: () => []
		},
		data: {
			type: Array,
			default: () => []
		},
		bordered: {
			type: [Boolean, Object],
			default: !0
		},
		hoverable: {
			type: Boolean,
			default: !0
		},
		stripe: {
			type: Boolean,
			default: !1
		},
		size: {
			type: String,
			default: () => {
				var o, s;
				return (s = (o = inject(configProviderInjectionKey, void 0)) == null ? void 0 : o.size) !=
					null ? s : "large"
			}
		},
		tableLayoutFixed: {
			type: Boolean,
			default: !1
		},
		loading: {
			type: [Boolean, Object],
			default: !1
		},
		rowSelection: {
			type: Object
		},
		expandable: {
			type: Object
		},
		scroll: {
			type: Object
		},
		pagination: {
			type: [Boolean, Object],
			default: !0
		},
		pagePosition: {
			type: String,
			default: "br"
		},
		indentSize: {
			type: Number,
			default: 16
		},
		rowKey: {
			type: String,
			default: "key"
		},
		showHeader: {
			type: Boolean,
			default: !0
		},
		virtualListProps: {
			type: Object
		},
		spanMethod: {
			type: Function
		},
		spanAll: {
			type: Boolean,
			default: !1
		},
		components: {
			type: Object
		},
		loadMore: {
			type: Function
		},
		filterIconAlignLeft: {
			type: Boolean,
			default: !1
		},
		hideExpandButtonOnEmpty: {
			type: Boolean,
			default: !1
		},
		rowClass: {
			type: [String, Array, Object, Function]
		},
		draggable: {
			type: Object
		},
		rowNumber: {
			type: [Boolean, Object]
		},
		columnResizable: {
			type: Boolean
		},
		summary: {
			type: [Boolean, Function]
		},
		summaryText: {
			type: String,
			default: "Summary"
		},
		summarySpanMethod: {
			type: Function
		},
		selectedKeys: {
			type: Array
		},
		defaultSelectedKeys: {
			type: Array
		},
		expandedKeys: {
			type: Array
		},
		defaultExpandedKeys: {
			type: Array
		},
		defaultExpandAllRows: {
			type: Boolean,
			default: !1
		},
		stickyHeader: {
			type: [Boolean, Number],
			default: !1
		},
		scrollbar: {
			type: [Object, Boolean],
			default: !0
		},
		showEmptyTree: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		"update:selectedKeys": o => !0,
		"update:expandedKeys": o => !0,
		expand: (o, s) => !0,
		expandedChange: o => !0,
		select: (o, s, a) => !0,
		selectAll: o => !0,
		selectionChange: o => !0,
		sorterChange: (o, s) => !0,
		filterChange: (o, s) => !0,
		pageChange: o => !0,
		pageSizeChange: o => !0,
		change: (o, s, a) => !0,
		cellMouseEnter: (o, s, a) => !0,
		cellMouseLeave: (o, s, a) => !0,
		cellClick: (o, s, a) => !0,
		rowClick: (o, s) => !0,
		headerClick: (o, s) => !0,
		columnResize: (o, s) => !0,
		rowDblclick: (o, s) => !0,
		cellDblclick: (o, s, a) => !0,
		rowContextmenu: (o, s) => !0,
		cellContextmenu: (o, s, a) => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			columns: l,
			rowKey: c,
			rowSelection: d,
			expandable: f,
			loadMore: m,
			filterIconAlignLeft: g,
			selectedKeys: v,
			defaultSelectedKeys: y,
			expandedKeys: b,
			defaultExpandedKeys: C,
			defaultExpandAllRows: _,
			spanMethod: S,
			draggable: w,
			summarySpanMethod: T,
			scrollbar: A,
			showEmptyTree: k
		} = toRefs(o), M = getPrefixCls("table"), D = inject(configProviderInjectionKey, void 0), F = computed(
		() => isObject$2(o.bordered) ? {
			...DEFAULT_BORDERED,
			...o.bordered
		} : {
			...DEFAULT_BORDERED,
			wrapper: o.bordered
		}), {
			children: R,
			components: O
		} = useChildrenComponents("TableColumn"), U = computed(() => {
			var ht, _t;
			return (_t = (ht = d.value) == null ? void 0 : ht.checkStrictly) != null ? _t : !0
		}), {
			displayScrollbar: V,
			scrollbarProps: z
		} = useScrollbar(A), j = computed(() => {
			var ht, _t, kt, Bt;
			const Vt = !!((ht = o.scroll) != null && ht.x || (_t = o.scroll) != null && _t.minWidth),
				Wt = !!((kt = o.scroll) != null && kt.y || (Bt = o.scroll) != null && Bt.maxHeight);
			return {
				x: Vt,
				y: Wt
			}
		}), ge = ref(), me = ref({}), {
			componentRef: he,
			elementRef: ce
		} = useComponentRef("containerRef"), {
			componentRef: ae,
			elementRef: fe
		} = useComponentRef("containerRef"), {
			elementRef: q
		} = useComponentRef("viewportRef"), {
			componentRef: le,
			elementRef: de
		} = useComponentRef("containerRef"), _e = computed(() => ke.value ? qn.value ? q.value : fe.value :
			ce.value), ke = computed(() => j.value.y || o.stickyHeader || qn.value || j.value.x && fn.value
			.length === 0), De = reactive(new Map), Se = ref();
		watch([O, De], ([ht, _t]) => {
			if (ht.length > 0) {
				const kt = [];
				ht.forEach(Bt => {
					const Vt = _t.get(Bt);
					Vt && kt.push(Vt)
				}), Se.value = kt
			} else Se.value = void 0
		});
		const be = new Map,
			Me = ref([]),
			Ve = ref([]),
			{
				resizingColumn: it,
				columnWidth: pt,
				handleThMouseDown: dt
			} = useColumnResize(me, s);
		watch([l, Se, pt], ([ht, _t]) => {
			var kt;
			const Bt = getGroupColumns((kt = _t ?? ht) != null ? kt : [], be, pt);
			Me.value = Bt.dataColumns, Ve.value = Bt.groupColumns
		}, {
			immediate: !0,
			deep: !0
		});
		const He = computed(() => ["tl", "top", "tr"].includes(o.pagePosition)),
			Ae = ref(!1),
			xe = ref(!1),
			ye = ref(!1);
		watchEffect(() => {
			var ht, _t, kt;
			let Bt = !1,
				Vt = !1,
				Wt = !1;
			((ht = o.rowSelection) != null && ht.fixed || (_t = o.expandable) != null && _t.fixed || (
				kt = o.draggable) != null && kt.fixed) && (Bt = !0);
			for (const an of Me.value) an.fixed === "left" ? (Bt = !0, Wt = !0) : an.fixed ===
				"right" && (Vt = !0);
			Bt !== Ae.value && (Ae.value = Bt), Vt !== xe.value && (xe.value = Vt), Wt !== ye.value && (
				ye.value = Wt)
		});
		const Le = computed(() => {
				for (const ht of Me.value)
					if (ht.ellipsis) return !0;
				return !1
			}),
			Ue = ht => {
				const _t = {
					type: ht,
					page: Ot.value,
					pageSize: nn.value,
					sorter: $e.value,
					filters: Je.value,
					dragTarget: ht === "drag" ? dn.data : void 0
				};
				s("change", zn.value, _t, Nt.value)
			},
			nt = (ht, _t) => {
				at.value = {
					...Je.value,
					[ht]: _t
				}, s("filterChange", ht, _t), Ue("filter")
			},
			ot = (ht, _t) => {
				Ce.value = _t ? {
					field: ht,
					direction: _t
				} : void 0, s("sorterChange", ht, _t), Ue("sorter")
			},
			{
				_filters: at,
				computedFilters: Je,
				resetFilters: Ne,
				clearFilters: we
			} = useFilter({
				columns: Me,
				onFilterChange: nt
			}),
			{
				_sorter: Ce,
				computedSorter: $e,
				resetSorters: Fe,
				clearSorters: Ge
			} = useSorter({
				columns: Me,
				onSorterChange: ot
			}),
			ze = new Set,
			Oe = computed(() => {
				const ht = [];
				ze.clear();
				const _t = kt => {
					if (isArray$2(kt) && kt.length > 0)
						for (const Bt of kt) ht.push(Bt[c.value]), Bt.disabled && ze.add(Bt[c.value]),
							Bt.children && _t(Bt.children)
				};
				return _t(o.data), ht
			}),
			Xe = computed(() => {
				const ht = [],
					_t = kt => {
						for (const Bt of kt) ht.push(Bt.key), Bt.children && _t(Bt.children)
					};
				return _t(fn.value), ht
			}),
			rt = computed(() => {
				const ht = [],
					_t = kt => {
						for (const Bt of kt) Bt.disabled || ht.push(Bt.key), Bt.children && _t(Bt.children)
					};
				return _t(fn.value), ht
			}),
			{
				selectedRowKeys: ut,
				currentSelectedRowKeys: gt,
				handleSelect: Et,
				handleSelectAllLeafs: Ze,
				handleSelectAll: Ye,
				select: ct,
				selectAll: yt,
				clearSelected: wt
			} = useRowSelection({
				selectedKeys: v,
				defaultSelectedKeys: y,
				rowSelection: d,
				currentAllRowKeys: Xe,
				currentAllEnabledRowKeys: rt,
				emit: s
			}),
			{
				expandedRowKeys: Qe,
				handleExpand: At,
				expand: Ct,
				expandAll: xt
			} = useExpand({
				expandedKeys: b,
				defaultExpandedKeys: C,
				defaultExpandAllRows: _,
				expandable: f,
				allRowKeys: Oe,
				emit: s
			}),
			Rt = reactive({}),
			$t = (ht, _t) => {
				ht && (Rt[_t.key] = ht)
			},
			zt = ht => {
				var _t, kt;
				for (const Bt of Object.keys(Je.value)) {
					const Vt = Je.value[Bt],
						Wt = be.get(Bt);
					if (Wt && ((_t = Wt.filterable) != null && _t.filter) && Vt.length > 0) {
						const an = (kt = Wt.filterable) == null ? void 0 : kt.filter(Vt, ht.raw);
						if (!an) return an
					}
				}
				return !0
			},
			{
				dragType: sn,
				dragState: dn,
				handleDragStart: Mt,
				handleDragEnter: qt,
				handleDragover: pn,
				handleDragEnd: Te,
				handleDrop: Pe
			} = useDrag(w),
			lt = computed(() => {
				var ht;
				const _t = kt => {
					const Bt = [];
					for (const Vt of kt) {
						const Wt = {
							raw: Vt,
							key: Vt[o.rowKey],
							disabled: Vt.disabled,
							expand: Vt.expand,
							isLeaf: Vt.isLeaf
						};
						Vt.children ? (Wt.isLeaf = !1, Wt.children = _t(Vt.children)) : o.loadMore && !
							Vt.isLeaf ? (Wt.isLeaf = !1, Rt[Wt.key] && (Wt.children = _t(Rt[Wt.key]))) :
							Wt.isLeaf = !0, Wt.hasSubtree = !!(Wt.children ? !o
								.hideExpandButtonOnEmpty || Wt.children.length > 0 : o.loadMore && !Wt
								.isLeaf), Bt.push(Wt)
					}
					return Bt
				};
				return _t((ht = o.data) != null ? ht : [])
			}),
			bt = computed(() => {
				const ht = _t => _t.filter(kt => zt(kt) ? (kt.children && (kt.children = ht(kt.children)), !
					0) : !1);
				return Object.keys(Je.value).length > 0 ? ht(lt.value) : lt.value
			}),
			Nt = computed(() => {
				var ht, _t, kt;
				const Bt = mapArrayWithChildren(bt.value);
				if (Bt.length > 0) {
					if ((ht = $e.value) != null && ht.field) {
						const an = be.get($e.value.field);
						if (an && ((_t = an.sortable) == null ? void 0 : _t.sorter) !== !0) {
							const {
								field: bn,
								direction: xn
							} = $e.value;
							Bt.sort((Ln, tr) => {
								var Jn;
								const lr = getValueByPath(Ln.raw, bn),
									En = getValueByPath(tr.raw, bn);
								if ((Jn = an.sortable) != null && Jn.sorter && isFunction$2(an
										.sortable.sorter)) return an.sortable.sorter(Ln.raw, tr
								.raw, {
									dataIndex: bn,
									direction: xn
								});
								const Xn = lr > En ? 1 : -1;
								return xn === "descend" ? -Xn : Xn
							})
						}
					}
					const {
						sourcePath: Vt,
						targetPath: Wt
					} = dn;
					if (dn.dragging && Wt.length && Wt.toString() !== Vt.toString() && Vt.length === Wt
						.length && Vt.slice(0, -1).toString() === Wt.slice(0, -1).toString()) {
						let an = Bt;
						for (let bn = 0; bn < Vt.length; bn++) {
							const xn = Vt[bn];
							if (bn >= Vt.length - 1) {
								const tr = an[xn],
									Jn = Wt[bn];
								Jn > xn ? (an.splice(Jn + 1, 0, tr), an.splice(xn, 1)) : (an.splice(Jn, 0,
									tr), an.splice(xn + 1, 1))
							} else an = (kt = an[xn].children) != null ? kt : []
						}
					}
				}
				return Bt
			}),
			{
				page: Ot,
				pageSize: nn,
				handlePageChange: Cn,
				handlePageSizeChange: wn
			} = usePagination(o, s),
			Mn = computed(() => {
				var ht, _t;
				return (_t = (ht = d.value) == null ? void 0 : ht.onlyCurrent) != null ? _t : !1
			});
		watch(Ot, (ht, _t) => {
			ht !== _t && Mn.value && wt()
		});
		const fn = computed(() => o.pagination && Nt.value.length > nn.value ? Nt.value.slice((Ot.value - 1) *
				nn.value, Ot.value * nn.value) : Nt.value),
			zn = computed(() => mapRawTableData(fn.value)),
			On = () => Me.value.reduce((ht, _t, kt) => {
				if (_t.dataIndex)
					if (kt === 0) setValueByPath(ht, _t.dataIndex, o.summaryText, {
						addPath: !0
					});
					else {
						let Bt = 0,
							Vt = !1;
						fn.value.forEach(Wt => {
							if (_t.dataIndex) {
								const an = getValueByPath(Wt.raw, _t.dataIndex);
								isNumber$2(an) ? Bt += an : !isUndefined$1(an) && !isNull$1(an) && (
									Vt = !0)
							}
						}), setValueByPath(ht, _t.dataIndex, Vt ? "" : Bt, {
							addPath: !0
						})
					} return ht
			}, {}),
			Nn = ht => ht && ht.length > 0 ? ht.map(_t => ({
				raw: _t,
				key: _t[o.rowKey]
			})) : [],
			An = computed(() => o.summary ? isFunction$2(o.summary) ? Nn(o.summary({
				columns: Me.value,
				data: zn.value
			})) : Nn([On()]) : []),
			$n = ref(0),
			Rn = ref(!0),
			We = ref(!0),
			et = () => {
				let ht = !0,
					_t = !0;
				const kt = _e.value;
				kt && (ht = $n.value === 0, _t = Math.ceil($n.value + kt.offsetWidth) >= kt.scrollWidth), ht !==
					Rn.value && (Rn.value = ht), _t !== We.value && (We.value = _t)
			},
			ft = () => Rn.value && We.value ? `${M}-scroll-position-both` : Rn.value ?
			`${M}-scroll-position-left` : We.value ? `${M}-scroll-position-right` :
			`${M}-scroll-position-middle`,
			vt = () => {
				const ht = [];
				return Ae.value && ht.push(`${M}-has-fixed-col-left`), xe.value && ht.push(
					`${M}-has-fixed-col-right`), ht
			},
			mt = ht => {
				ht.target.scrollLeft !== $n.value && ($n.value = ht.target.scrollLeft), et()
			},
			Dt = ht => {
				mt(ht);
				const {
					scrollLeft: _t
				} = ht.target;
				de.value && (de.value.scrollLeft = _t), ge.value && (ge.value.scrollLeft = _t)
			},
			Pt = (ht, _t) => {
				s("rowClick", ht.raw, _t)
			},
			Lt = (ht, _t) => {
				s("rowDblclick", ht.raw, _t)
			},
			Ht = (ht, _t) => {
				s("rowContextmenu", ht.raw, _t)
			},
			rn = (ht, _t, kt) => {
				s("cellClick", ht.raw, _t, kt)
			},
			en = debounce$1((ht, _t, kt) => {
				s("cellMouseEnter", ht.raw, _t, kt)
			}, 30),
			Xt = debounce$1((ht, _t, kt) => {
				s("cellMouseLeave", ht.raw, _t, kt)
			}, 30),
			un = (ht, _t, kt) => {
				s("cellDblclick", ht.raw, _t, kt)
			},
			mn = (ht, _t, kt) => {
				s("cellContextmenu", ht.raw, _t, kt)
			},
			Tn = (ht, _t) => {
				s("headerClick", ht, _t)
			},
			cn = computed(() => {
				var ht, _t;
				const kt = [],
					Bt = Ae.value || xe.value;
				let Vt, Wt, an;
				((ht = o.draggable) == null ? void 0 : ht.type) === "handle" && (Vt = {
					name: "drag-handle",
					title: o.draggable.title,
					width: o.draggable.width,
					fixed: o.draggable.fixed || Bt
				}, kt.push(Vt)), o.expandable && (Wt = {
					name: "expand",
					title: o.expandable.title,
					width: o.expandable.width,
					fixed: o.expandable.fixed || Bt
				}, kt.push(Wt)), o.rowSelection && (an = {
					name: o.rowSelection.type === "radio" ? "selection-radio" :
						"selection-checkbox",
					title: o.rowSelection.title,
					width: o.rowSelection.width,
					fixed: o.rowSelection.fixed || Bt
				}, kt.push(an)), !ye.value && kt.length > 0 && kt[kt.length - 1].fixed && (kt[kt
					.length - 1].isLastLeftFixed = !0);
				const bn = (_t = o.components) == null ? void 0 : _t.operations;
				return isFunction$2(bn) ? bn({
					dragHandle: Vt,
					expand: Wt,
					selection: an
				}) : kt
			}),
			hn = computed(() => {
				var ht, _t, kt, Bt;
				if (j.value.x) {
					const Vt = {
						width: isNumber$2((ht = o.scroll) == null ? void 0 : ht.x) ?
							`${(_t=o.scroll)==null?void 0:_t.x}px` : (kt = o.scroll) == null ? void 0 :
							kt.x
					};
					return (Bt = o.scroll) != null && Bt.minWidth && (Vt.minWidth = isNumber$2(o.scroll
						.minWidth) ? `${o.scroll.minWidth}px` : o.scroll.minWidth), Vt
				}
			}),
			Zt = computed(() => {
				var ht, _t, kt, Bt;
				if (j.value.x && fn.value.length > 0) {
					const Vt = {
						width: isNumber$2((ht = o.scroll) == null ? void 0 : ht.x) ?
							`${(_t=o.scroll)==null?void 0:_t.x}px` : (kt = o.scroll) == null ? void 0 :
							kt.x
					};
					return (Bt = o.scroll) != null && Bt.minWidth && (Vt.minWidth = isNumber$2(o.scroll
						.minWidth) ? `${o.scroll.minWidth}px` : o.scroll.minWidth), Vt
				}
			});
		provide(tableInjectionKey, reactive({
			loadMore: m,
			addLazyLoadData: $t,
			slots: a,
			sorter: $e,
			filters: Je,
			filterIconAlignLeft: g,
			resizingColumn: it,
			checkStrictly: U,
			currentAllEnabledRowKeys: rt,
			currentSelectedRowKeys: gt,
			addColumn: (ht, _t) => {
				De.set(ht, _t)
			},
			removeColumn: ht => {
				De.delete(ht)
			},
			onSelectAll: Ye,
			onSelect: Et,
			onSelectAllLeafs: Ze,
			onSorterChange: ot,
			onFilterChange: nt,
			onThMouseDown: dt
		}));
		const jn = computed(() => [M, `${M}-size-${o.size}`, {
				[`${M}-border`]: F.value.wrapper,
				[`${M}-border-cell`]: F.value.cell,
				[`${M}-border-header-cell`]: !F.value.cell && F.value.headerCell,
				[`${M}-border-body-cell`]: !F.value.cell && F.value.bodyCell,
				[`${M}-stripe`]: o.stripe,
				[`${M}-hover`]: o.hoverable,
				[`${M}-dragging`]: dn.dragging,
				[`${M}-type-selection`]: !!o.rowSelection,
				[`${M}-empty`]: o.data && fn.value.length === 0,
				[`${M}-layout-fixed`]: o.tableLayoutFixed || j.value.x || ke.value || Le.value
			}]),
			Sn = computed(() => [`${M}-pagination`, {
				[`${M}-pagination-left`]: o.pagePosition === "tl" || o.pagePosition === "bl",
				[`${M}-pagination-center`]: o.pagePosition === "top" || o.pagePosition === "bottom",
				[`${M}-pagination-right`]: o.pagePosition === "tr" || o.pagePosition === "br",
				[`${M}-pagination-top`]: He.value
			}]),
			Vn = computed(() => {
				const ht = vt();
				return j.value.x && ht.push(ft()), ke.value && ht.push(`${M}-scroll-y`), ht
			}),
			qn = computed(() => !!o.virtualListProps),
			yn = ref({}),
			Un = () => {
				const ht = {};
				for (const _t of Object.keys(me.value)) ht[_t] = me.value[_t].offsetWidth;
				yn.value = ht
			},
			Bn = ref(!1),
			In = () => fe.value ? fe.value.offsetWidth > fe.value.clientWidth : !1,
			Pn = () => {
				const ht = In();
				Bn.value !== ht && (Bn.value = ht), et(), Un()
			};
		onMounted(() => {
			Bn.value = In(), Un()
		});
		const er = computed(() => isObject$2(o.loading) ? o.loading : {
				loading: o.loading
			}),
			Kn = () => createVNode(Tr, {
				empty: !0
			}, {
				default: () => [createVNode(Td, {
					colSpan: Me.value.length + cn.value.length
				}, {
					default: () => {
						var ht, _t, kt, Bt, Vt;
						return [(Vt = (Bt = (ht = a.empty) == null ? void 0 : ht.call(a)) !=
							null ? Bt : (kt = D == null ? void 0 : (_t = D.slots)
								.empty) == null ? void 0 : kt.call(_t, {
								component: "table"
							})) != null ? Vt : createVNode(Empty, null, null)]
					}
				})]
			}),
			tn = ht => {
				var _t;
				if (ht.expand) return isFunction$2(ht.expand) ? ht.expand() : ht.expand;
				if (a["expand-row"]) return a["expand-row"]({
					record: ht.raw
				});
				if ((_t = o.expandable) != null && _t.expandedRowRender) return o.expandable.expandedRowRender(
					ht.raw)
			},
			nr = computed(() => [].concat(cn.value, Me.value)),
			Be = computed(() => o.spanAll ? nr.value : Me.value),
			{
				tableSpan: Ie,
				removedCells: qe
			} = useSpan({
				spanMethod: S,
				data: fn,
				columns: Be
			}),
			{
				tableSpan: je,
				removedCells: Ke
			} = useSpan({
				spanMethod: T,
				data: An,
				columns: nr
			}),
			St = ht => {
				if (!(!qn.value || !ht || !yn.value[ht])) return {
					width: `${yn.value[ht]}px`
				}
			},
			Tt = (ht, _t) => createVNode(Tr, {
				key: `table-summary-${_t}`,
				class: [`${M}-tr-summary`, isFunction$2(o.rowClass) ? o.rowClass(ht.raw, _t) : o.rowClass],
				onClick: kt => Pt(ht, kt)
			}, {
				default: () => [cn.value.map((kt, Bt) => {
					var Vt;
					const Wt = `${_t}-${Bt}-${ht.key}`,
						[an, bn] = (Vt = je.value[Wt]) != null ? Vt : [1, 1];
					if (Ke.value.includes(Wt)) return null;
					const xn = St(kt.name);
					return createVNode(OperationTd, {
						style: xn,
						operationColumn: kt,
						operations: cn.value,
						record: ht,
						rowSpan: an,
						colSpan: bn,
						summary: !0
					}, null)
				}), Me.value.map((kt, Bt) => {
					var Vt;
					const Wt = `${_t}-${cn.value.length+Bt}-${ht.key}`,
						[an, bn] = (Vt = je.value[Wt]) != null ? Vt : [1, 1];
					if (Ke.value.includes(Wt)) return null;
					const xn = St(kt.dataIndex);
					return createVNode(Td, {
						key: `td-${Wt}`,
						style: xn,
						rowIndex: _t,
						record: ht,
						column: kt,
						operations: cn.value,
						dataColumns: Me.value,
						rowSpan: an,
						colSpan: bn,
						summary: !0,
						onClick: Ln => rn(ht, kt, Ln),
						onDblclick: Ln => un(ht, kt, Ln),
						onMouseenter: Ln => en(ht, kt, Ln),
						onMouseleave: Ln => Xt(ht, kt, Ln),
						onContextmenu: Ln => mn(ht, kt, Ln)
					}, {
						td: a.td,
						cell: a["summary-cell"]
					})
				})],
				tr: a.tr
			}),
			jt = () => An.value && An.value.length > 0 ? createVNode("tfoot", null, [An.value.map((ht, _t) =>
				Tt(ht, _t))]) : null,
			Ft = (ht, _t = !0) => {
				var kt, Bt, Vt, Wt, an;
				const bn = ht.key,
					xn = Qe.value.includes(bn);
				return createVNode("button", {
					type: "button",
					class: `${M}-expand-btn`,
					onClick: Ln => {
						At(bn, ht.raw), _t && Ln.stopPropagation()
					}
				}, [(an = (Wt = (kt = a["expand-icon"]) == null ? void 0 : kt.call(a, {
						expanded: xn,
						record: ht.raw
					})) != null ? Wt : (Vt = (Bt = o.expandable) == null ? void 0 : Bt.icon) ==
					null ? void 0 : Vt.call(Bt, xn, ht.raw)) != null ? an : createVNode(xn ?
					IconMinus : IconPlus, null, null)])
			},
			Ut = (ht, {
				indentSize: _t,
				indexPath: kt,
				allowDrag: Bt,
				expandContent: Vt
			}) => {
				var Wt, an;
				if (ht.hasSubtree) return ((Wt = ht.children) == null ? void 0 : Wt.length) === 0 && k.value ?
					Kn() : (an = ht.children) == null ? void 0 : an.map((bn, xn) => Kt(bn, xn, {
						indentSize: _t,
						indexPath: kt,
						allowDrag: Bt
					}));
				if (Vt) {
					const bn = _e.value;
					return createVNode(Tr, {
						key: `${ht.key}-expand`,
						expand: !0
					}, {
						default: () => [createVNode(Td, {
							isFixedExpand: Ae.value || xe.value,
							containerWidth: bn == null ? void 0 : bn.clientWidth,
							colSpan: Me.value.length + cn.value.length
						}, _isSlot$3(Vt) ? Vt : {
							default: () => [Vt]
						})]
					})
				}
				return null
			},
			Kt = (ht, _t, {
				indentSize: kt = 0,
				indexPath: Bt,
				allowDrag: Vt = !0
			} = {}) => {
				var Wt;
				const an = ht.key,
					bn = (Bt ?? []).concat(_t),
					xn = tn(ht),
					Ln = Qe.value.includes(an),
					tr = dn.sourceKey === ht.key,
					Jn = sn.value ? {
						draggable: Vt,
						onDragstart: En => {
							Vt && Mt(En, ht.key, bn, ht.raw)
						},
						onDragend: En => {
							Vt && Te(En)
						}
					} : {},
					lr = sn.value ? {
						onDragenter: En => {
							Vt && qt(En, bn)
						},
						onDragover: En => {
							Vt && pn(En)
						},
						onDrop: En => {
							Vt && (Ue("drag"), Pe(En))
						}
					} : {};
				return createVNode(Fragment, null, [createVNode(Tr, mergeProps({
					key: an,
					class: [{
							[`${M}-tr-draggable`]: sn.value === "row",
							[`${M}-tr-drag`]: tr
						}, isFunction$2(o.rowClass) ? o.rowClass(ht.raw, _t) : o
						.rowClass
					],
					rowIndex: _t,
					record: ht,
					checked: o.rowSelection && ((Wt = ut.value) == null ? void 0 : Wt
						.includes(an)),
					onClick: En => Pt(ht, En),
					onDblclick: En => Lt(ht, En),
					onContextmenu: En => Ht(ht, En)
				}, sn.value === "row" ? Jn : {}, lr), {
					default: () => [cn.value.map((En, Xn) => {
						var ir;
						const or = `${_t}-${Xn}-${ht.key}`,
							[ur, cr] = o.spanAll ? (ir = Ie.value[or]) != null ?
							ir : [1, 1] : [1, 1];
						if (o.spanAll && qe.value.includes(or)) return null;
						const dr = St(En.name);
						return createVNode(OperationTd, mergeProps({
							key: `operation-td-${Xn}`,
							style: dr,
							operationColumn: En,
							operations: cn.value,
							record: ht,
							hasExpand: !!xn,
							selectedRowKeys: gt.value,
							rowSpan: ur,
							colSpan: cr,
							renderExpandBtn: Ft
						}, sn.value === "handle" ? Jn : {}), {
							"drag-handle-icon": a["drag-handle-icon"]
						})
					}), Me.value.map((En, Xn) => {
						var ir;
						const or =
							`${_t}-${o.spanAll?cn.value.length+Xn:Xn}-${ht.key}`,
							[ur, cr] = (ir = Ie.value[or]) != null ? ir : [1, 1];
						if (qe.value.includes(or)) return null;
						const dr = Xn === 0 ? {
								showExpandBtn: ht.hasSubtree,
								indentSize: ht.hasSubtree ? kt - 20 : kt
							} : {},
							Cr = St(En.dataIndex);
						return createVNode(Td, mergeProps({
							key: `td-${Xn}`,
							style: Cr,
							rowIndex: _t,
							record: ht,
							column: En,
							operations: cn.value,
							dataColumns: Me.value,
							rowSpan: ur,
							renderExpandBtn: Ft,
							colSpan: cr
						}, dr, {
							onClick: Qn => rn(ht, En, Qn),
							onDblclick: Qn => un(ht, En, Qn),
							onMouseenter: Qn => en(ht, En, Qn),
							onMouseleave: Qn => Xt(ht, En, Qn),
							onContextmenu: Qn => mn(ht, En, Qn)
						}), {
							td: a.td
						})
					})],
					tr: a.tr
				}), Ln && Ut(ht, {
					indentSize: kt + o.indentSize,
					indexPath: bn,
					allowDrag: Vt && !tr,
					expandContent: xn
				})])
			},
			It = () => {
				const ht = fn.value.some(_t => !!_t.hasSubtree);
				return createVNode(Tbody, null, {
					default: () => [fn.value.length > 0 ? fn.value.map((_t, kt) => Kt(_t, kt, {
						indentSize: ht ? 20 : 0
					})) : Kn()],
					tbody: a.tbody
				})
			},
			Yt = () => createVNode(Thead, null, {
				default: () => [Ve.value.map((ht, _t) => createVNode(Tr, {
					key: `header-row-${_t}`
				}, {
					default: () => [_t === 0 && cn.value.map((kt, Bt) => {
						var Vt;
						return createVNode(OperationTh, {
							key: `operation-th-${Bt}`,
							ref: Wt => {
								Wt != null && Wt.$el && kt.name && (
									me.value[kt.name] = Wt.$el)
							},
							operationColumn: kt,
							operations: cn.value,
							selectAll: !!(kt.name ===
								"selection-checkbox" && ((Vt = o
										.rowSelection) != null && Vt
									.showCheckedAll)),
							rowSpan: Ve.value.length
						}, null)
					}), ht.map((kt, Bt) => {
						const Vt = o.columnResizable && !!kt.dataIndex && Bt <
							ht.length - 1;
						return createVNode(Th, {
							key: `th-${Bt}`,
							ref: Wt => {
								Wt != null && Wt.$el && kt
									.dataIndex && (me.value[kt
										.dataIndex] = Wt.$el)
							},
							column: kt,
							operations: cn.value,
							dataColumns: Me.value,
							resizable: Vt,
							onClick: Wt => Tn(kt, Wt)
						}, {
							th: a.th
						})
					})]
				}))],
				thead: a.thead
			}),
			Gt = () => {
				var ht, _t;
				if (ke.value) {
					const kt = isNumber$2(o.stickyHeader) ? `${o.stickyHeader}px` : void 0,
						Bt = [(ht = z.value) == null ? void 0 : ht.outerClass];
					o.stickyHeader && Bt.push(`${M}-header-sticky`);
					const Vt = {
							top: kt,
							...(_t = z.value) == null ? void 0 : _t.outerStyle
						},
						Wt = V.value ? Scrollbar : "div";
					return createVNode(Fragment, null, [o.showHeader && createVNode(Wt, mergeProps({
						ref: le,
						class: [`${M}-header`, {
							[`${M}-header-sticky`]: o.stickyHeader && !V.value
						}],
						style: {
							overflowY: Bn.value ? "scroll" : void 0,
							top: V.value ? void 0 : kt
						}
					}, A.value ? {
						hide: fn.value.length !== 0,
						disableVertical: !0,
						...z.value,
						outerClass: Bt,
						outerStyle: Vt
					} : void 0), {
						default: () => [createVNode("table", {
							class: `${M}-element`,
							style: hn.value,
							cellpadding: 0,
							cellspacing: 0
						}, [createVNode(ColGroup, {
							dataColumns: Me.value,
							operations: cn.value,
							columnWidth: pt
						}, null), Yt()])]
					}), createVNode(ResizeObserver$2, {
						onResize: Pn
					}, {
						default: () => {
							var an, bn;
							return [qn.value && fn.value.length ? createVNode(VirtualList,
								mergeProps({
									ref: xn => {
										xn != null && xn.$el && (fe.value =
											xn.$el)
									},
									class: `${M}-body`,
									data: fn.value,
									itemKey: "_key",
									component: {
										list: "table",
										content: "tbody"
									},
									listAttrs: {
										class: `${M}-element`,
										style: Zt.value
									},
									paddingPosition: "list",
									height: "auto"
								}, o.virtualListProps, {
									onScroll: Dt
								}), {
									item: ({
										item: xn,
										index: Ln
									}) => Kt(xn, Ln)
								}) : createVNode(Wt, mergeProps({
								ref: ae,
								class: `${M}-body`,
								style: {
									maxHeight: isNumber$2((an = o.scroll) ==
											null ? void 0 : an.y) ?
										`${(bn=o.scroll)==null?void 0:bn.y}px` :
										"100%"
								}
							}, A.value ? {
								outerStyle: {
									display: "flex",
									minHeight: "0"
								},
								...z.value
							} : void 0, {
								onScroll: Dt
							}), {
								default: () => [createVNode("table", {
									class: `${M}-element`,
									style: Zt.value,
									cellpadding: 0,
									cellspacing: 0
								}, [fn.value.length !== 0 &&
									createVNode(ColGroup, {
										dataColumns: Me.value,
										operations: cn.value,
										columnWidth: pt
									}, null), It()
								])]
							})]
						}
					}), An.value && An.value.length > 0 && createVNode("div", {
						ref: ge,
						class: `${M}-tfoot`,
						style: {
							overflowY: Bn.value ? "scroll" : "hidden"
						}
					}, [createVNode("table", {
						class: `${M}-element`,
						style: Zt.value,
						cellpadding: 0,
						cellspacing: 0
					}, [createVNode(ColGroup, {
						dataColumns: Me.value,
						operations: cn.value,
						columnWidth: pt
					}, null), jt()])])])
				}
				return createVNode(ResizeObserver$2, {
					onResize: () => et()
				}, {
					default: () => [createVNode("table", {
						class: `${M}-element`,
						cellpadding: 0,
						cellspacing: 0,
						style: Zt.value
					}, [createVNode(ColGroup, {
							dataColumns: Me.value,
							operations: cn.value,
							columnWidth: pt
						}, null), o.showHeader && Yt(), It(), An.value && An.value.length >
						0 && jt()
					])]
				})
			},
			Qt = ht => {
				var _t;
				const kt = (_t = o.scroll) != null && _t.maxHeight ? {
						maxHeight: o.scroll.maxHeight
					} : void 0,
					Bt = V.value ? Scrollbar : "div";
				return createVNode(Fragment, null, [createVNode("div", {
					class: [`${M}-container`, Vn.value]
				}, [createVNode(Bt, mergeProps({
					ref: he,
					class: [`${M}-content`, {
						[`${M}-content-scroll-x`]: !ke.value
					}],
					style: kt
				}, A.value ? {
					outerStyle: {
						height: "100%"
					},
					...z.value
				} : void 0, {
					onScroll: mt
				}), {
					default: () => [ht ? createVNode("table", {
						class: `${M}-element`,
						cellpadding: 0,
						cellspacing: 0
					}, [ht()]) : Gt()]
				})]), a.footer && createVNode("div", {
					class: `${M}-footer`
				}, [a.footer()])])
			},
			Jt = () => {
				var ht, _t;
				const kt = isObject$2(o.pagination) ? omit(o.pagination, ["current", "pageSize",
					"defaultCurrent", "defaultPageSize"
				]) : {};
				return createVNode("div", {
					class: Sn.value
				}, [(ht = a["pagination-left"]) == null ? void 0 : ht.call(a), createVNode(Pagination,
					mergeProps({
						total: bt.value.length,
						current: Ot.value,
						pageSize: nn.value,
						onChange: Bt => {
							Cn(Bt), Ue("pagination")
						},
						onPageSizeChange: Bt => {
							wn(Bt), Ue("pagination")
						}
					}, kt), null), (_t = a["pagination-right"]) == null ? void 0 : _t.call(a)])
			},
			kn = computed(() => {
				var ht, _t;
				if (isString$2((ht = o.scroll) == null ? void 0 : ht.y)) return {
					height: (_t = o.scroll) == null ? void 0 : _t.y
				}
			});
		return {
			render: () => {
				var ht;
				return a.default ? createVNode("div", {
					class: jn.value
				}, [Qt(a.default)]) : (R.value = (ht = a.columns) == null ? void 0 : ht.call(a),
					createVNode("div", {
						class: jn.value,
						style: kn.value
					}, [R.value, createVNode(Spin, er.value, {
						default: () => [o.pagination !== !1 && (fn.value.length > 0 || Nt
								.value.length > 0) && He.value && Jt(), Qt(), o
							.pagination !== !1 && (fn.value.length > 0 || Nt.value
								.length > 0) && !He.value && Jt()
						]
					})]))
			},
			selfExpand: Ct,
			selfExpandAll: xt,
			selfSelect: ct,
			selfSelectAll: yt,
			selfResetFilters: Ne,
			selfClearFilters: we,
			selfResetSorters: Fe,
			selfClearSorters: Ge
		}
	},
	methods: {
		selectAll(o) {
			return this.selfSelectAll(o)
		},
		select(o, s) {
			return this.selfSelect(o, s)
		},
		expandAll(o) {
			return this.selfExpandAll(o)
		},
		expand(o, s) {
			return this.selfExpand(o, s)
		},
		resetFilters(o) {
			return this.selfResetFilters(o)
		},
		clearFilters(o) {
			return this.selfClearFilters(o)
		},
		resetSorters() {
			return this.selfResetSorters()
		},
		clearSorters() {
			return this.selfClearSorters()
		}
	},
	render() {
		return this.render()
	}
});
const usePureProp = (o, s) => {
	const a = toRef(o, s),
		l = ref(a.value);
	return watch(a, (c, d) => {
		isEqual$1(c, d) || (l.value = c)
	}), l
};
var TableColumn = defineComponent({
	name: "TableColumn",
	props: {
		dataIndex: String,
		title: String,
		width: Number,
		minWidth: Number,
		align: {
			type: String
		},
		fixed: {
			type: String
		},
		ellipsis: {
			type: Boolean,
			default: !1
		},
		sortable: {
			type: Object,
			default: void 0
		},
		filterable: {
			type: Object,
			default: void 0
		},
		cellClass: {
			type: [String, Array, Object]
		},
		headerCellClass: {
			type: [String, Array, Object]
		},
		bodyCellClass: {
			type: [String, Array, Object, Function]
		},
		summaryCellClass: {
			type: [String, Array, Object, Function]
		},
		cellStyle: {
			type: Object
		},
		headerCellStyle: {
			type: Object
		},
		bodyCellStyle: {
			type: [Object, Function]
		},
		summaryCellStyle: {
			type: [Object, Function]
		},
		index: {
			type: Number
		},
		tooltip: {
			type: [Boolean, Object],
			default: !1
		}
	},
	setup(o, {
		slots: s
	}) {
		var a;
		const {
			dataIndex: l,
			title: c,
			width: d,
			align: f,
			fixed: m,
			ellipsis: g,
			index: v,
			minWidth: y
		} = toRefs(o), b = usePureProp(o, "sortable"), C = usePureProp(o, "filterable"), _ = usePureProp(o,
				"cellClass"), S = usePureProp(o, "headerCellClass"), w = usePureProp(o, "bodyCellClass"), T =
			usePureProp(o, "summaryCellClass"), A = usePureProp(o, "cellStyle"), k = usePureProp(o,
				"headerCellStyle"), M = usePureProp(o, "bodyCellStyle"), D = usePureProp(o, "summaryCellStyle"),
			F = usePureProp(o, "tooltip"), R = getCurrentInstance(), O = inject(tableInjectionKey, {}), U =
			inject(tableColumnInjectionKey, void 0), {
				children: V,
				components: z
			} = useChildrenComponents("TableColumn"), j = reactive(new Map);
		provide(tableColumnInjectionKey, {
			addChild: (ae, fe) => {
				j.set(ae, fe)
			},
			removeChild: ae => {
				j.delete(ae)
			}
		});
		const he = ref();
		watch([z, j], ([ae, fe]) => {
			if (ae.length > 0) {
				const q = [];
				ae.forEach(le => {
					const de = fe.get(le);
					de && q.push(de)
				}), he.value = q
			} else he.value = void 0
		});
		const ce = reactive({
			dataIndex: l,
			title: c,
			width: d,
			minWidth: y,
			align: f,
			fixed: m,
			ellipsis: g,
			sortable: b,
			filterable: C,
			cellClass: _,
			headerCellClass: S,
			bodyCellClass: w,
			summaryCellClass: T,
			cellStyle: A,
			headerCellStyle: k,
			bodyCellStyle: M,
			summaryCellStyle: D,
			index: v,
			tooltip: F,
			children: he,
			slots: s
		});
		return R && (U ? U.addChild(R.uid, ce) : (a = O.addColumn) == null || a.call(O, R.uid, ce)),
			onBeforeUnmount(() => {
				var ae;
				R && (U ? U.removeChild(R.uid) : (ae = O.removeColumn) == null || ae.call(O, R.uid))
			}), () => {
				var ae;
				return V.value = (ae = s.default) == null ? void 0 : ae.call(s), V.value
			}
	}
});
const Table = Object.assign(_Table, {
		Thead,
		Tbody,
		Tr,
		Th,
		Td,
		Column: TableColumn,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Table.name, _Table), o.component(a + Thead.name, Thead), o.component(a + Tbody
				.name, Tbody), o.component(a + Tr.name, Tr), o.component(a + Th.name, Th), o.component(a +
				Td.name, Td), o.component(a + TableColumn.name, TableColumn)
		}
	}),
	getTabListStyle = ({
		direction: o,
		type: s,
		offset: a
	}) => o === "vertical" ? {
		transform: `translateY(${-a}px)`
	} : {
		transform: `translateX(${-a}px)`
	},
	updateScrollOffset = (o, s) => {
		const {
			scrollTop: a,
			scrollLeft: l
		} = o;
		s === "horizontal" && l && o.scrollTo({
			left: -1 * l
		}), s === "vertical" && a && o.scrollTo({
			top: -1 * a
		})
	},
	tabsInjectionKey = Symbol("ArcoTabs"),
	_sfc_main$H = defineComponent({
		name: "TabsTab",
		components: {
			IconHover,
			IconClose
		},
		props: {
			tab: {
				type: Object,
				required: !0
			},
			active: Boolean,
			editable: Boolean
		},
		emits: ["click", "delete"],
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("tabs-tab"),
				l = inject(tabsInjectionKey, {}),
				c = v => {
					o.tab.disabled || s("click", o.tab.key, v)
				},
				d = v => {
					v.key === "Enter" && c(v)
				},
				f = computed(() => Object.assign(l.trigger === "click" ? {
					onClick: c
				} : {
					onMouseover: c
				}, {
					onKeydown: d
				})),
				m = v => {
					o.tab.disabled || s("delete", o.tab.key, v)
				},
				g = computed(() => [a, {
					[`${a}-active`]: o.active,
					[`${a}-closable`]: o.editable && o.tab.closable,
					[`${a}-disabled`]: o.tab.disabled
				}]);
			return {
				prefixCls: a,
				cls: g,
				eventHandlers: f,
				handleDelete: m
			}
		}
	});

function _sfc_render$p(o, s, a, l, c, d) {
	const f = resolveComponent("icon-close"),
		m = resolveComponent("icon-hover");
	return openBlock(), createElementBlock("div", mergeProps({
		tabindex: "0",
		class: o.cls
	}, o.eventHandlers), [createBaseVNode("span", {
		class: normalizeClass(`${o.prefixCls}-title`)
	}, [renderSlot(o.$slots, "default")], 2), o.editable && o.tab.closable ? (openBlock(), createBlock(m, {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-close-btn`),
		onClick: withModifiers(o.handleDelete, ["stop"])
	}, {
		default: withCtx(() => [createVNode(f)]),
		_: 1
	}, 8, ["class", "onClick"])) : createCommentVNode("v-if", !0)], 16)
}
var TabsTab = _export_sfc$1(_sfc_main$H, [
	["render", _sfc_render$p]
]);

function _isSlot$2(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var TabsButton = defineComponent({
	name: "TabsButton",
	props: {
		type: {
			type: String,
			default: "next"
		},
		direction: {
			type: String,
			default: "horizontal"
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		onClick: {
			type: Function
		}
	},
	emits: ["click"],
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("tabs-nav-button"),
			l = f => {
				o.disabled || s("click", o.type, f)
			},
			c = () => o.direction === "horizontal" ? o.type === "next" ? createVNode(IconRight, null, null) :
			createVNode(IconLeft, null, null) : o.type === "next" ? createVNode(IconDown, null, null) :
			createVNode(IconUp, null, null),
			d = computed(() => [a, {
				[`${a}-disabled`]: o.disabled,
				[`${a}-left`]: o.direction === "horizontal" && o.type === "previous",
				[`${a}-right`]: o.direction === "horizontal" && o.type === "next",
				[`${a}-up`]: o.direction === "vertical" && o.type === "previous",
				[`${a}-down`]: o.direction === "vertical" && o.type === "next"
			}]);
		return () => {
			let f;
			return createVNode("div", {
				class: d.value,
				onClick: l
			}, [createVNode(IconHover, {
				disabled: o.disabled
			}, _isSlot$2(f = c()) ? f : {
				default: () => [f]
			})])
		}
	}
});
const _sfc_main$G = defineComponent({
	name: "TabsNavInk",
	props: {
		activeTabRef: {
			type: Object
		},
		direction: {
			type: String
		},
		disabled: Boolean,
		animation: Boolean
	},
	setup(o) {
		const {
			activeTabRef: s
		} = toRefs(o), a = getPrefixCls("tabs-nav-ink"), l = ref(0), c = ref(0), d = computed(() => o
			.direction === "vertical" ? {
				top: `${l.value}px`,
				height: `${c.value}px`
			} : {
				left: `${l.value}px`,
				width: `${c.value}px`
			}), f = () => {
			if (s.value) {
				const g = o.direction === "vertical" ? s.value.offsetTop : s.value.offsetLeft,
					v = o.direction === "vertical" ? s.value.offsetHeight : s.value.offsetWidth;
				(g !== l.value || v !== c.value) && (l.value = g, c.value = v)
			}
		};
		onMounted(() => {
			nextTick(() => f())
		}), onUpdated(() => {
			f()
		});
		const m = computed(() => [a, {
			[`${a}-animation`]: o.animation,
			[`${a}-disabled`]: o.disabled
		}]);
		return {
			prefixCls: a,
			cls: m,
			style: d
		}
	}
});

function _sfc_render$o(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.style)
	}, null, 6)
}
var TabsNavInk = _export_sfc$1(_sfc_main$G, [
		["render", _sfc_render$o]
	]),
	TabsNav = defineComponent({
		name: "TabsNav",
		props: {
			tabs: {
				type: Array,
				required: !0
			},
			direction: {
				type: String,
				required: !0
			},
			type: {
				type: String,
				required: !0
			},
			activeKey: {
				type: [String, Number]
			},
			activeIndex: {
				type: Number,
				required: !0
			},
			position: {
				type: String,
				required: !0
			},
			size: {
				type: String,
				required: !0
			},
			showAddButton: {
				type: Boolean,
				default: !1
			},
			editable: {
				type: Boolean,
				default: !1
			},
			animation: {
				type: Boolean,
				required: !0
			},
			headerPadding: {
				type: Boolean,
				default: !0
			},
			scrollPosition: {
				type: String,
				default: "auto"
			}
		},
		emits: ["click", "add", "delete"],
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				tabs: l,
				activeKey: c,
				activeIndex: d,
				direction: f,
				scrollPosition: m
			} = toRefs(o), g = getPrefixCls("tabs-nav"), v = ref(), y = ref(), b = ref({}), C = computed(() => {
					if (!isUndefined$1(c.value)) return b.value[c.value]
				}), _ = ref(), S = computed(() => o.editable && ["line", "card", "card-gutter"].includes(o.type)),
				w = ref(!1), T = ref(0), A = ref(0), k = ref(0), M = () => {
					var le, de, _e;
					return (_e = f.value === "vertical" ? (le = v.value) == null ? void 0 : le.offsetHeight : (de =
						v.value) == null ? void 0 : de.offsetWidth) != null ? _e : 0
				}, D = () => !y.value || !v.value ? 0 : f.value === "vertical" ? y.value.offsetHeight - v.value
				.offsetHeight : y.value.offsetWidth - v.value.offsetWidth, F = () => {
					w.value = R(), w.value ? (T.value = M(), A.value = D(), k.value > A.value && (k.value = A
						.value)) : k.value = 0
				}, R = () => v.value && y.value ? o.direction === "vertical" ? y.value.offsetHeight > v.value
				.offsetHeight : y.value.offsetWidth > v.value.offsetWidth : !1, O = le => {
					(!v.value || !y.value || le < 0) && (le = 0), k.value = Math.min(le, A.value)
				}, U = () => {
					if (!C.value || !v.value || !w.value) return;
					updateScrollOffset(v.value, f.value);
					const le = f.value === "horizontal",
						de = le ? "offsetLeft" : "offsetTop",
						_e = le ? "offsetWidth" : "offsetHeight",
						ke = C.value[de],
						De = C.value[_e],
						Se = v.value[_e],
						be = window.getComputedStyle(C.value),
						Me = le ? m.value === "end" ? "marginRight" : "marginLeft" : m.value === "end" ?
						"marginBottom" : "marginTop",
						Ve = parseFloat(be[Me]) || 0;
					m.value === "auto" ? ke < k.value ? O(ke - Ve) : ke + De > k.value + Se && O(ke + De - Se +
						Ve) : m.value === "center" ? O(ke + (De - Se + Ve) / 2) : m.value === "start" ? O(ke - Ve) :
						m.value === "end" ? O(ke + De - Se + Ve) : isNumber$2(m.value) && O(ke - m.value)
				}, V = le => {
					if (!w.value) return;
					le.preventDefault();
					const {
						deltaX: de,
						deltaY: _e
					} = le;
					Math.abs(de) > Math.abs(_e) ? O(k.value + de) : O(k.value + _e)
				}, z = (le, de) => {
					s("click", le, de)
				}, j = (le, de) => {
					s("delete", le, de), nextTick(() => {
						delete b.value[le]
					})
				}, ge = le => {
					const de = le === "previous" ? k.value - T.value : k.value + T.value;
					O(de)
				}, me = () => {
					F(), _.value && _.value.$forceUpdate()
				};
			watch(l, () => {
				nextTick(() => {
					F()
				})
			}), watch([d, m], () => {
				setTimeout(() => {
					U()
				}, 0)
			}), onMounted(() => {
				F(), v.value && on(v.value, "wheel", V, {
					passive: !1
				})
			}), onUnmounted(() => {
				v.value && off(v.value, "wheel", V)
			});
			const he = () => !S.value || !o.showAddButton ? null : createVNode("div", {
					class: `${g}-add-btn`,
					onClick: le => s("add", le)
				}, [createVNode(IconHover, null, {
					default: () => [createVNode(IconPlus, null, null)]
				})]),
				ce = computed(() => [g, `${g}-${o.direction}`, `${g}-${o.position}`, `${g}-size-${o.size}`,
					`${g}-type-${o.type}`
				]),
				ae = computed(() => [`${g}-tab-list`, {
					[`${g}-tab-list-no-padding`]: !o.headerPadding && ["line", "text"].includes(o.type) && o
						.direction === "horizontal"
				}]),
				fe = computed(() => getTabListStyle({
					direction: o.direction,
					type: o.type,
					offset: k.value
				})),
				q = computed(() => [`${g}-tab`, {
					[`${g}-tab-scroll`]: w.value
				}]);
			return () => {
				var le;
				return createVNode("div", {
					class: ce.value
				}, [w.value && createVNode(TabsButton, {
					type: "previous",
					direction: o.direction,
					disabled: k.value <= 0,
					onClick: ge
				}, null), createVNode(ResizeObserver$2, {
					onResize: () => F()
				}, {
					default: () => [createVNode("div", {
						class: q.value,
						ref: v
					}, [createVNode(ResizeObserver$2, {
						onResize: me
					}, {
						default: () => [createVNode("div", {
							ref: y,
							class: ae.value,
							style: fe.value
						}, [o.tabs.map((de, _e) => createVNode(
								TabsTab, {
									key: de.key,
									ref: ke => {
										ke != null && ke
											.$el && (b
												.value[
													de
													.key
													] =
												ke.$el)
									},
									active: de.key === c
										.value,
									tab: de,
									editable: o.editable,
									onClick: z,
									onDelete: j
								}, {
									default: () => {
										var ke, De, Se;
										return [(Se = (De =
													(ke =
														de
														.slots
														)
													.title
													) ==
												null ?
												void 0 :
												De
												.call(
													ke
													)
												) !=
											null ?
											Se : de
											.title
										]
									}
								})), o.type === "line" && C
							.value && createVNode(TabsNavInk, {
								ref: _,
								activeTabRef: C.value,
								direction: o.direction,
								disabled: !1,
								animation: o.animation
							}, null)
						])]
					}), !w.value && he()])]
				}), w.value && createVNode(TabsButton, {
					type: "next",
					direction: o.direction,
					disabled: k.value >= A.value,
					onClick: ge
				}, null), createVNode("div", {
					class: `${g}-extra`
				}, [w.value && he(), (le = a.extra) == null ? void 0 : le.call(a)])])
			}
		}
	}),
	_Tabs = defineComponent({
		name: "Tabs",
		props: {
			activeKey: {
				type: [String, Number],
				default: void 0
			},
			defaultActiveKey: {
				type: [String, Number],
				default: void 0
			},
			position: {
				type: String,
				default: "top"
			},
			size: {
				type: String
			},
			type: {
				type: String,
				default: "line"
			},
			direction: {
				type: String,
				default: "horizontal"
			},
			editable: {
				type: Boolean,
				default: !1
			},
			showAddButton: {
				type: Boolean,
				default: !1
			},
			destroyOnHide: {
				type: Boolean,
				default: !1
			},
			lazyLoad: {
				type: Boolean,
				default: !1
			},
			justify: {
				type: Boolean,
				default: !1
			},
			animation: {
				type: Boolean,
				default: !1
			},
			headerPadding: {
				type: Boolean,
				default: !0
			},
			autoSwitch: {
				type: Boolean,
				default: !1
			},
			hideContent: {
				type: Boolean,
				default: !1
			},
			trigger: {
				type: String,
				default: "click"
			},
			scrollPosition: {
				type: [String, Number],
				default: "auto"
			}
		},
		emits: {
			"update:activeKey": o => !0,
			change: o => !0,
			tabClick: (o, s) => !0,
			add: o => !0,
			delete: (o, s) => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				size: l,
				lazyLoad: c,
				destroyOnHide: d,
				trigger: f
			} = toRefs(o), m = getPrefixCls("tabs"), {
					mergedSize: g
				} = useSize$1(l), v = computed(() => o.direction === "vertical" ? "left" : o.position), y =
				computed(() => ["left", "right"].includes(v.value) ? "vertical" : "horizontal"), {
					children: b,
					components: C
				} = useChildrenComponents("TabPane"), _ = reactive(new Map), S = computed(() => {
					const j = [];
					return C.value.forEach(ge => {
						const me = _.get(ge);
						me && j.push(me)
					}), j
				}), w = computed(() => S.value.map(j => j.key)), T = (j, ge) => {
					_.set(j, ge)
				}, A = j => {
					_.delete(j)
				}, k = ref(o.defaultActiveKey), M = computed(() => {
					var j;
					const ge = (j = o.activeKey) != null ? j : k.value;
					return isUndefined$1(ge) ? w.value[0] : ge
				}), D = computed(() => {
					const j = w.value.indexOf(M.value);
					return j === -1 ? 0 : j
				});
			provide(tabsInjectionKey, reactive({
				lazyLoad: c,
				destroyOnHide: d,
				activeKey: M,
				addItem: T,
				removeItem: A,
				trigger: f
			}));
			const F = j => {
					j !== M.value && (k.value = j, s("update:activeKey", j), s("change", j))
				},
				R = (j, ge) => {
					F(j), s("tabClick", j, ge)
				},
				O = j => {
					s("add", j), o.autoSwitch && nextTick(() => {
						const ge = w.value[w.value.length - 1];
						F(ge)
					})
				},
				U = (j, ge) => {
					s("delete", j, ge)
				},
				V = () => createVNode("div", {
					class: [`${m}-content`, {
						[`${m}-content-hide`]: o.hideContent
					}]
				}, [createVNode("div", {
					class: [`${m}-content-list`, {
						[`${m}-content-animation`]: o.animation
					}],
					style: {
						marginLeft: `-${D.value*100}%`
					}
				}, [b.value])]),
				z = computed(() => [m, `${m}-${y.value}`, `${m}-${v.value}`, `${m}-type-${o.type}`,
					`${m}-size-${g.value}`, {
						[`${m}-justify`]: o.justify
					}
				]);
			return () => {
				var j;
				return b.value = (j = a.default) == null ? void 0 : j.call(a), createVNode("div", {
					class: z.value
				}, [v.value === "bottom" && V(), createVNode(TabsNav, {
					tabs: S.value,
					activeKey: M.value,
					activeIndex: D.value,
					direction: y.value,
					position: v.value,
					editable: o.editable,
					animation: o.animation,
					showAddButton: o.showAddButton,
					headerPadding: o.headerPadding,
					scrollPosition: o.scrollPosition,
					size: g.value,
					type: o.type,
					onClick: R,
					onAdd: O,
					onDelete: U
				}, {
					extra: a.extra
				}), v.value !== "bottom" && V()])
			}
		}
	});
const _sfc_main$F = defineComponent({
	name: "TabPane",
	props: {
		title: String,
		disabled: {
			type: Boolean,
			default: !1
		},
		closable: {
			type: Boolean,
			default: !0
		},
		destroyOnHide: {
			type: Boolean,
			default: !1
		}
	},
	setup(o, {
		slots: s
	}) {
		var a;
		const {
			title: l,
			disabled: c,
			closable: d
		} = toRefs(o), f = getCurrentInstance(), m = getPrefixCls("tabs"), g = inject(tabsInjectionKey, {}), v =
			ref(), y = computed(() => f == null ? void 0 : f.vnode.key), b = computed(() => y.value === g
				.activeKey), C = ref(g.lazyLoad ? b.value : !0), _ = reactive({
				key: y,
				title: l,
				disabled: c,
				closable: d,
				slots: s
			});
		return f != null && f.uid && ((a = g.addItem) == null || a.call(g, f.uid, _)), onBeforeUnmount(() => {
			var S;
			f != null && f.uid && ((S = g.removeItem) == null || S.call(g, f.uid))
		}), watch(b, S => {
			S ? C.value || (C.value = !0) : (o.destroyOnHide || g.destroyOnHide) && (C.value = !1)
		}), onUpdated(() => {
			_.slots = {
				...s
			}
		}), {
			prefixCls: m,
			active: b,
			itemRef: v,
			mounted: C
		}
	}
});

function _sfc_render$n(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		ref: "itemRef",
		class: normalizeClass([`${o.prefixCls}-content-item`, {
			[`${o.prefixCls}-content-item-active`]: o.active
		}])
	}, [o.mounted ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-pane`)
	}, [renderSlot(o.$slots, "default")], 2)) : createCommentVNode("v-if", !0)], 2)
}
var TabPane = _export_sfc$1(_sfc_main$F, [
	["render", _sfc_render$n]
]);
const Tabs = Object.assign(_Tabs, {
	TabPane,
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Tabs.name, _Tabs), o.component(a + TabPane.name, TabPane)
	}
});

function useTimeState(o) {
	const {
		modelValue: s,
		defaultValue: a,
		format: l,
		isRange: c
	} = toRefs(o);

	function d() {
		return c.value ? [] : void 0
	}

	function f(T) {
		if (!isUndefined$1(T)) return c.value ? isArray$2(T) ? T : [T, void 0] : T
	}
	const m = computed(() => {
			const T = f(s.value);
			return getDayjsValue(T, l.value)
		}),
		g = computed(() => {
			const T = f(a.value);
			return getDayjsValue(T, l.value)
		}),
		[v, y] = useState(isUndefined$1(m.value) ? isUndefined$1(g.value) ? d() : g.value : m.value);
	watch(m, () => {
		isUndefined$1(m.value) && y(d())
	});
	const b = computed(() => m.value || v.value),
		[C, _] = useState(b.value);
	watch([b], () => {
		_(b.value)
	});
	const [S, w] = useState();
	return watch([C], () => {
		w(void 0)
	}), {
		computedValue: b,
		panelValue: C,
		inputValue: S,
		setValue: y,
		setPanelValue: _,
		setInputValue: w
	}
}
var RangePanel = defineComponent({
	name: "TimePickerRangePanel",
	components: {
		Panel: Panel$1
	},
	props: {
		value: {
			type: Array
		},
		displayIndex: {
			type: Number,
			default: 0
		}
	},
	emits: ["select", "confirm", "update:displayIndex", "display-index-change"],
	setup(o, {
		emit: s
	}) {
		const {
			value: a,
			displayIndex: l
		} = toRefs(o), c = ref(l.value);
		watch(l, () => {
			c.value = l.value
		});
		const d = computed(() => a != null && a.value ? a.value[c.value] : void 0);

		function f(g) {
			const v = isUndefined$1(a) || isUndefined$1(a == null ? void 0 : a.value) ? [] : [...a.value];
			v[c.value] = g, s("select", v)
		}

		function m() {
			if (isValidRangeValue$1(a == null ? void 0 : a.value)) s("confirm", a == null ? void 0 : a.value);
			else {
				const g = (c.value + 1) % 2;
				c.value = g, s("display-index-change", g), s("update:displayIndex", g)
			}
		}
		return {
			displayValue: d,
			onSelect: f,
			onConfirm: m
		}
	},
	render() {
		const o = {
			...this.$attrs,
			isRange: !0,
			value: this.displayValue,
			onSelect: this.onSelect,
			onConfirm: this.onConfirm
		};
		return createVNode(Panel$1, o, this.$slots)
	}
});
const _sfc_main$E = defineComponent({
	name: "TimePicker",
	components: {
		Trigger,
		DateInput,
		DateRangeInput,
		Panel: Panel$1,
		RangePanel,
		IconClockCircle
	},
	inheritAttrs: !1,
	props: {
		type: {
			type: String,
			default: "time"
		},
		modelValue: {
			type: [String, Number, Date, Array]
		},
		defaultValue: {
			type: [String, Number, Date, Array]
		},
		disabled: {
			type: Boolean
		},
		allowClear: {
			type: Boolean,
			default: !0
		},
		readonly: {
			type: Boolean
		},
		error: {
			type: Boolean
		},
		format: {
			type: String,
			default: "HH:mm:ss"
		},
		placeholder: {
			type: [String, Array]
		},
		size: {
			type: String
		},
		popupContainer: {
			type: [String, Object]
		},
		use12Hours: {
			type: Boolean
		},
		step: {
			type: Object
		},
		disabledHours: {
			type: Function
		},
		disabledMinutes: {
			type: Function
		},
		disabledSeconds: {
			type: Function
		},
		hideDisabledOptions: {
			type: Boolean
		},
		disableConfirm: {
			type: Boolean
		},
		position: {
			type: String,
			default: "bl"
		},
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean,
			default: !1
		},
		triggerProps: {
			type: Object
		},
		unmountOnClose: {
			type: Boolean
		}
	},
	emits: {
		change: (o, s) => !0,
		"update:modelValue": o => !0,
		select: (o, s) => !0,
		clear: () => !0,
		"popup-visible-change": o => !0,
		"update:popupVisible": o => !0
	},
	setup(o, {
		emit: s
	}) {
		const {
			type: a,
			format: l,
			use12Hours: c,
			modelValue: d,
			defaultValue: f,
			popupVisible: m,
			defaultPopupVisible: g,
			disabled: v,
			placeholder: y,
			disableConfirm: b,
			disabledHours: C,
			disabledMinutes: _,
			disabledSeconds: S
		} = toRefs(o), {
			mergedDisabled: w,
			eventHandlers: T
		} = useFormItem({
			disabled: v
		}), A = computed(() => a.value === "time-range"), k = getPrefixCls("timepicker"), M = ref(), {
			format: D,
			use12Hours: F
		} = useTimeFormat(reactive({
			format: l,
			use12Hours: c
		})), {
			computedValue: R,
			panelValue: O,
			inputValue: U,
			setValue: V,
			setPanelValue: z,
			setInputValue: j
		} = useTimeState(reactive({
			modelValue: d,
			defaultValue: f,
			isRange: A,
			format: D
		})), [ge, me] = useMergeState(g.value, reactive({
			value: m
		})), he = ye => {
			ye !== ge.value && (me(ye), s("popup-visible-change", ye), s("update:popupVisible", ye))
		}, {
			t: ce
		} = useI18n(), [ae, fe] = useState(0), q = computed(() => {
			const ye = y == null ? void 0 : y.value;
			return A.value ? isUndefined$1(ye) ? ce("datePicker.rangePlaceholder.time") : isArray$2(
				ye) ? ye : [ye, ye] : isUndefined$1(ye) ? ce("datePicker.placeholder.time") : ye
		}), le = useIsDisabledTime(reactive({
			disabledHours: C,
			disabledMinutes: _,
			disabledSeconds: S
		}));

		function de(ye) {
			var Le, Ue;
			if (isValueChange(ye, R.value)) {
				const nt = getFormattedValue(ye, D.value),
					ot = getDateValue$1(ye);
				s("update:modelValue", nt), s("change", nt, ot), (Ue = (Le = T.value) == null ? void 0 : Le
					.onChange) == null || Ue.call(Le)
			}
		}

		function _e(ye, Le) {
			if (le(ye)) return;
			let Ue = ye;
			if (isArray$2(ye)) {
				const nt = dayjs();
				Ue = ye.map(ot => (ot && (ot = ot.year(nt.year()), ot = ot.month(nt.month()), ot = ot.date(nt
					.date())), ot)), isValidRangeValue$1(Ue) && (Ue = getSortedDayjsArray(Ue)), (Ue ==
					null ? void 0 : Ue.length) === 0 && (Ue = void 0)
			}
			de(Ue), V(Ue), Le !== ge.value && he(Le)
		}

		function ke(ye, Le) {
			z(ye), Le !== ge.value && he(Le)
		}

		function De(ye) {
			M.value && M.value.focus && M.value.focus(ye)
		}

		function Se(ye) {
			w.value || (he(ye), ye && nextTick(() => {
				De(ae.value)
			}))
		}

		function be(ye) {
			const Le = getFormattedValue(ye, D.value),
				Ue = getDateValue$1(ye);
			s("select", Le, Ue), b.value && (!A.value || isValidRangeValue$1(ye)) ? _e(ye, !0) : (ke(ye, !0), j(
				void 0))
		}

		function Me(ye) {
			_e(ye, !1)
		}

		function Ve() {
			_e(O.value || R.value, !1)
		}

		function it() {
			if (isValidRangeValue$1(O.value)) _e(O.value, !1);
			else {
				const ye = (ae.value + 1) % 2;
				fe(ye), De(ye)
			}
		}

		function pt(ye) {
			he(!0);
			const Le = ye.target.value;
			if (j(Le), !isValidInputValue(Le, D.value)) return;
			const Ue = dayjs(Le, D.value);
			le(Ue) || (b.value ? _e(Ue, !0) : ke(Ue, !0))
		}

		function dt(ye) {
			he(!0);
			const Le = ye.target.value,
				Ue = isArray$2(U.value) ? [...U.value] : isArray$2(O.value) && getFormattedValue(O.value, D
					.value) || [];
			if (Ue[ae.value] = Le, j(Ue), !isValidInputValue(Le, D.value)) return;
			const nt = dayjs(Le, D.value);
			if (le(nt)) return;
			const ot = isArray$2(O.value) ? [...O.value] : [];
			ot[ae.value] = nt, b.value && isValidRangeValue$1(ot) ? _e(ot, !0) : ke(ot, !0)
		}

		function He(ye) {
			ye.stopPropagation(), z(void 0), _e(void 0, A.value)
		}
		watch(ge, (ye, Le) => {
			ye !== Le && z(R.value), ye || j(void 0)
		});
		const Ae = computed(() => A.value ? {
				focusedIndex: ae.value,
				onFocusedIndexChange: ye => {
					fe(ye)
				},
				onChange: dt,
				onPressEnter: it
			} : {
				onChange: pt,
				onPressEnter: Ve
			}),
			xe = computed(() => A.value ? {
				displayIndex: ae.value,
				onDisplayIndexChange: ye => {
					fe(ye), De(ye)
				}
			} : {});
		return {
			refInput: M,
			isRange: A,
			prefixCls: k,
			panelVisible: ge,
			focusedInputIndex: ae,
			computedPlaceholder: q,
			panelValue: O,
			inputValue: U,
			computedFormat: D,
			computedUse12Hours: F,
			inputProps: Ae,
			panelProps: xe,
			mergedDisabled: w,
			onPanelVisibleChange: Se,
			onInputClear: He,
			onPanelSelect: be,
			onPanelConfirm: Me,
			onPanelClick: () => {
				De(ae.value)
			}
		}
	}
});

function _sfc_render$m(o, s, a, l, c, d) {
	const f = resolveComponent("IconClockCircle"),
		m = resolveComponent("Trigger");
	return openBlock(), createBlock(m, mergeProps({
		trigger: "click",
		"animation-name": "slide-dynamic-origin",
		"auto-fit-transform-origin": "",
		"click-to-close": !1,
		position: o.position,
		disabled: o.mergedDisabled || o.readonly,
		"popup-offset": 4,
		"popup-visible": o.panelVisible,
		"prevent-focus": !0,
		"unmount-on-close": o.unmountOnClose,
		"popup-container": o.popupContainer
	}, {
		...o.triggerProps
	}, {
		onPopupVisibleChange: o.onPanelVisibleChange
	}), {
		content: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-container`),
			onClick: s[0] || (s[0] = (...g) => o.onPanelClick && o.onPanelClick(...g))
		}, [(openBlock(), createBlock(resolveDynamicComponent(o.isRange ? "RangePanel" :
			"Panel"), mergeProps(o.panelProps, {
			value: o.panelValue,
			visible: o.panelVisible,
			format: o.computedFormat,
			"use12-hours": o.computedUse12Hours,
			step: o.step,
			"disabled-hours": o.disabledHours,
			"disabled-minutes": o.disabledMinutes,
			"disabled-seconds": o.disabledSeconds,
			"hide-disabled-options": o.hideDisabledOptions,
			"hide-footer": o.disableConfirm,
			onSelect: o.onPanelSelect,
			onConfirm: o.onPanelConfirm
		}), createSlots({
			_: 2
		}, [o.$slots.extra ? {
			name: "extra-footer",
			fn: withCtx(() => [renderSlot(o.$slots, "extra")]),
			key: "0"
		} : void 0]), 1040, ["value", "visible", "format", "use12-hours", "step",
			"disabled-hours", "disabled-minutes", "disabled-seconds",
			"hide-disabled-options", "hide-footer", "onSelect", "onConfirm"
		]))], 2)]),
		default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(o.isRange ? "DateRangeInput" :
			"DateInput"), mergeProps({
			...o.$attrs,
			...o.inputProps
		}, {
			ref: "refInput",
			"input-value": o.inputValue,
			value: o.panelValue,
			size: o.size,
			focused: o.panelVisible,
			format: o.computedFormat,
			visible: o.panelVisible,
			disabled: o.mergedDisabled,
			error: o.error,
			readonly: o.readonly,
			editable: !o.readonly,
			"allow-clear": o.allowClear && !o.readonly,
			placeholder: o.computedPlaceholder,
			onClear: o.onInputClear
		}), createSlots({
			"suffix-icon": withCtx(() => [renderSlot(o.$slots, "suffix-icon", {},
			() => [createVNode(f)])]),
			_: 2
		}, [o.$slots.prefix ? {
			name: "prefix",
			fn: withCtx(() => [renderSlot(o.$slots, "prefix")]),
			key: "0"
		} : void 0]), 1040, ["input-value", "value", "size", "focused", "format", "visible",
			"disabled", "error", "readonly", "editable", "allow-clear", "placeholder",
			"onClear"
		]))]),
		_: 3
	}, 16, ["position", "disabled", "popup-visible", "unmount-on-close", "popup-container",
		"onPopupVisibleChange"
	])
}
var _TimePicker = _export_sfc$1(_sfc_main$E, [
	["render", _sfc_render$m]
]);
const TimePicker = Object.assign(_TimePicker, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _TimePicker.name, _TimePicker)
		}
	}),
	timelineInjectionKey = Symbol("ArcoTimeline"),
	getDefaultPosition = (o, s, a, l) => {
		let c = ["left", "right"];
		a === "horizontal" && (c = ["top", "bottom"]);
		const d = s === "alternate" ? l || c[o % 2] : s;
		return c.indexOf(d) > -1 ? d : c[0]
	},
	_sfc_main$D = defineComponent({
		name: "TimelineItem",
		props: {
			dotColor: {
				type: String
			},
			dotType: {
				type: String,
				default: "solid"
			},
			lineType: {
				type: String,
				default: "solid"
			},
			lineColor: {
				type: String
			},
			label: {
				type: String
			},
			position: {
				type: String
			}
		},
		setup(o) {
			const s = getPrefixCls("timeline-item"),
				a = getCurrentInstance(),
				l = inject(timelineInjectionKey, {}),
				c = computed(() => {
					var C, _, S;
					return (S = (_ = l.items) == null ? void 0 : _.indexOf((C = a == null ? void 0 : a.uid) !=
						null ? C : -1)) != null ? S : -1
				}),
				d = computed(() => {
					var C;
					return (C = l == null ? void 0 : l.direction) != null ? C : "vertical"
				}),
				f = computed(() => {
					var C;
					return (C = l == null ? void 0 : l.labelPosition) != null ? C : "same"
				}),
				m = computed(() => {
					const {
						items: C = [],
						reverse: _,
						labelPosition: S,
						mode: w = "left"
					} = l, T = d.value, A = getDefaultPosition(c.value, w, T, o.position);
					return [s, {
						[`${s}-${T}-${A}`]: T,
						[`${s}-label-${S}`]: S,
						[`${s}-last`]: c.value === (_ === !0 ? 0 : C.length - 1)
					}]
				}),
				g = computed(() => [`${s}-dot-line`, `${s}-dot-line-is-${d.value}`]),
				v = computed(() => {
					const {
						direction: C
					} = l || {};
					return {
						[C === "horizontal" ? "borderTopStyle" : "borderLeftStyle"]: o.lineType,
						...o.lineColor ? {
							borderColor: o.lineColor
						} : {}
					}
				}),
				y = computed(() => [`${s}-dot`, `${s}-dot-${o.dotType}`]),
				b = computed(() => ({
					[o.dotType === "solid" ? "backgroundColor" : "borderColor"]: o.dotColor
				}));
			return {
				cls: m,
				dotLineCls: g,
				dotTypeCls: y,
				prefixCls: s,
				computedDotLineStyle: v,
				computedDotStyle: b,
				labelPosition: f
			}
		}
	});

function _sfc_render$l(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("div", {
		role: "listitem",
		class: normalizeClass(o.cls)
	}, [createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-dot-wrapper`)
	}, [createBaseVNode("div", {
		class: normalizeClass(o.dotLineCls),
		style: normalizeStyle(o.computedDotLineStyle)
	}, null, 6), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-dot-content`)
	}, [o.$slots.dot ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-dot-custom`)
	}, [renderSlot(o.$slots, "dot")], 2)) : (openBlock(), createElementBlock("div", {
		key: 1,
		class: normalizeClass(o.dotTypeCls),
		style: normalizeStyle(o.computedDotStyle)
	}, null, 6))], 2)], 2), createBaseVNode("div", {
		class: normalizeClass(`${o.prefixCls}-content-wrapper`)
	}, [o.$slots.default ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-content`)
		}, [renderSlot(o.$slots, "default")], 2)) : createCommentVNode("v-if", !0), o.labelPosition !==
		"relative" ? (openBlock(), createElementBlock("div", {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-label`)
		}, [o.$slots.label ? renderSlot(o.$slots, "label", {
			key: 0
		}) : (openBlock(), createElementBlock(Fragment, {
			key: 1
		}, [createTextVNode(toDisplayString(o.label), 1)], 64))], 2)) : createCommentVNode("v-if", !0)
	], 2), o.labelPosition === "relative" ? (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass(`${o.prefixCls}-label`)
	}, [o.$slots.label ? renderSlot(o.$slots, "label", {
		key: 0
	}) : (openBlock(), createElementBlock(Fragment, {
		key: 1
	}, [createTextVNode(toDisplayString(o.label), 1)], 64))], 2)) : createCommentVNode("v-if", !0)], 2)
}
var TimelineItem = _export_sfc$1(_sfc_main$D, [
		["render", _sfc_render$l]
	]),
	_Timeline = defineComponent({
		name: "Timeline",
		components: {
			Item: TimelineItem,
			Spin
		},
		props: {
			reverse: {
				type: Boolean
			},
			direction: {
				type: String,
				default: "vertical"
			},
			mode: {
				type: String,
				default: "left"
			},
			pending: {
				type: [Boolean, String]
			},
			labelPosition: {
				type: String,
				default: "same"
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("timeline"),
				l = computed(() => o.pending || s.pending),
				{
					children: c,
					components: d
				} = useChildrenComponents("TimelineItem"),
				{
					reverse: f,
					direction: m,
					labelPosition: g,
					mode: v
				} = toRefs(o),
				y = reactive({
					items: d,
					direction: m,
					reverse: f,
					labelPosition: g,
					mode: v
				});
			provide(timelineInjectionKey, y);
			const b = computed(() => [a, `${a}-${o.mode}`, `${a}-direction-${o.direction}`, {
				[`${a}-is-reverse`]: o.reverse
			}]);
			return () => {
				var C, _;
				return l.value ? c.value = (C = s.default) == null ? void 0 : C.call(s).concat(createVNode(
					TimelineItem, {
						lineType: "dashed"
					}, {
						default: () => [o.pending !== !0 && createVNode("div", null, [o.pending])],
						dot: () => {
							var S, w;
							return (w = (S = s.dot) == null ? void 0 : S.call(s)) != null ? w :
								createVNode(Spin, {
									size: 12
								}, null)
						}
					})) : c.value = (_ = s.default) == null ? void 0 : _.call(s), createVNode("div", {
					role: "list",
					class: b.value
				}, [c.value])
			}
		}
	});
const Timeline = Object.assign(_Timeline, {
		Item: TimelineItem,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Timeline.name, _Timeline), o.component(a + TimelineItem.name, TimelineItem)
		}
	}),
	_sfc_main$C = defineComponent({
		name: "IconDelete",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-delete`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$c = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$k(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M5 11h5.5m0 0v29a1 1 0 0 0 1 1h25a1 1 0 0 0 1-1V11m-27 0H16m21.5 0H43m-5.5 0H32m-16 0V7h16v4m-16 0h16M20 18v15m8-15v15"
	}, null, -1)]), 14, _hoisted_1$c)
}
var _IconDelete = _export_sfc$1(_sfc_main$C, [
	["render", _sfc_render$k]
]);
const IconDelete = Object.assign(_IconDelete, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconDelete.name, _IconDelete)
		}
	}),
	transferInjectionKey = Symbol("ArcoTransfer");
var TransferListItem = defineComponent({
	name: "TransferListItem",
	props: {
		type: {
			type: String
		},
		data: {
			type: Object,
			required: !0
		},
		allowClear: {
			type: Boolean
		},
		disabled: {
			type: Boolean
		},
		draggable: {
			type: Boolean
		},
		simple: Boolean
	},
	setup(o) {
		const s = getPrefixCls("transfer-list-item"),
			a = inject(transferInjectionKey, void 0),
			l = () => {
				o.simple && !o.disabled && (a == null || a.moveTo([o.data.value], o.type === "target" ?
					"source" : "target"))
			},
			c = computed(() => [s, {
				[`${s}-disabled`]: o.disabled,
				[`${s}-draggable`]: o.draggable
			}]),
			d = () => {
				a == null || a.moveTo([o.data.value], "source")
			};
		return () => {
			var f, m, g;
			return createVNode("div", {
				class: c.value,
				onClick: l
			}, [o.allowClear || o.simple ? createVNode("span", {
				class: `${s}-content`
			}, [(g = (m = a == null ? void 0 : (f = a.slots).item) == null ? void 0 : m
				.call(f, {
					label: o.data.label,
					value: o.data.value
				})) != null ? g : o.data.label]) : createVNode(Checkbox, {
				class: [`${s}-content`, `${s}-checkbox`],
				modelValue: a == null ? void 0 : a.selected,
				value: o.data.value,
				onChange: v => a == null ? void 0 : a.onSelect(v),
				uninjectGroupContext: !0,
				disabled: o.disabled
			}, {
				default: () => {
					var v, y, b;
					return [(b = (y = a == null ? void 0 : (v = a.slots).item) == null ?
						void 0 : y.call(v, {
							label: o.data.label,
							value: o.data.value
						})) != null ? b : o.data.label]
				}
			}), o.allowClear && !o.disabled && createVNode(IconHover, {
				class: `${s}-remove-btn`,
				onClick: d
			}, {
				default: () => [createVNode(IconClose, null, null)]
			})])
		}
	}
});
const _sfc_main$B = defineComponent({
	name: "TransferView",
	components: {
		Empty: Empty$1,
		Checkbox,
		IconHover,
		IconDelete,
		InputSearch: Input.Search,
		List,
		TransferListItem,
		Scrollbar
	},
	props: {
		type: {
			type: String
		},
		dataInfo: {
			type: Object,
			required: !0
		},
		title: String,
		data: {
			type: Array,
			required: !0
		},
		disabled: Boolean,
		allowClear: Boolean,
		selected: {
			type: Array,
			required: !0
		},
		showSearch: Boolean,
		showSelectAll: Boolean,
		simple: Boolean,
		inputSearchProps: {
			type: Object
		}
	},
	emits: ["search"],
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("transfer-view"),
			l = ref(""),
			c = inject(transferInjectionKey, void 0),
			d = computed(() => o.dataInfo.selected.length),
			f = computed(() => o.dataInfo.data.length),
			m = computed(() => o.dataInfo.selected.length > 0 && o.dataInfo.selected.length === o.dataInfo
				.allValidValues.length),
			g = computed(() => o.dataInfo.selected.length > 0 && o.dataInfo.selected.length < o.dataInfo
				.allValidValues.length),
			v = _ => {
				_ ? c == null || c.onSelect([...o.selected, ...o.dataInfo.allValidValues]) : c == null || c
					.onSelect(o.selected.filter(S => !o.dataInfo.allValidValues.includes(S)))
			},
			y = computed(() => o.dataInfo.data.filter(_ => l.value ? _.label.includes(l.value) : !0));
		return {
			prefixCls: a,
			filteredData: y,
			filter: l,
			checked: m,
			indeterminate: g,
			countSelected: d,
			countRendered: f,
			handleSelectAllChange: v,
			handleSearch: _ => {
				s("search", _, o.type)
			},
			handleClear: () => {
				c == null || c.moveTo(o.dataInfo.allValidValues, "source")
			},
			transferCtx: c
		}
	}
});

function _sfc_render$j(o, s, a, l, c, d) {
	const f = resolveComponent("checkbox"),
		m = resolveComponent("icon-delete"),
		g = resolveComponent("icon-hover"),
		v = resolveComponent("input-search"),
		y = resolveComponent("transfer-list-item"),
		b = resolveComponent("list"),
		C = resolveComponent("Scrollbar"),
		_ = resolveComponent("Empty");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.prefixCls)
	}, [createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-header`)
		}, [renderSlot(o.$slots, "title", {
			countTotal: o.dataInfo.data.length,
			countSelected: o.dataInfo.selected.length,
			searchValue: o.filter,
			checked: o.checked,
			indeterminate: o.indeterminate,
			onSelectAllChange: o.handleSelectAllChange,
			onClear: o.handleClear
		}, () => [createBaseVNode("span", {
				class: normalizeClass(`${o.prefixCls}-header-title`)
			}, [o.allowClear || o.simple || !o.showSelectAll ? (openBlock(), createElementBlock(
				"span", {
					key: 0,
					class: normalizeClass(`${o.prefixCls}-header-title-simple`)
				}, toDisplayString(o.title), 3)) : (openBlock(), createBlock(f, {
				key: 1,
				"model-value": o.checked,
				indeterminate: o.indeterminate,
				disabled: o.disabled,
				"uninject-group-context": "",
				onChange: o.handleSelectAllChange
			}, {
				default: withCtx(() => [createTextVNode(toDisplayString(o.title),
					1)]),
				_: 1
			}, 8, ["model-value", "indeterminate", "disabled", "onChange"]))], 2), o.allowClear ? (
				openBlock(), createBlock(g, {
					key: 0,
					disabled: o.disabled,
					class: normalizeClass(`${o.prefixCls}-header-clear-btn`),
					onClick: o.handleClear
				}, {
					default: withCtx(() => [createVNode(m)]),
					_: 1
				}, 8, ["disabled", "class", "onClick"])) : o.simple ? createCommentVNode("v-if", !
			0) : (openBlock(), createElementBlock("span", {
				key: 1,
				class: normalizeClass(`${o.prefixCls}-header-count`)
			}, toDisplayString(o.dataInfo.selected.length) + " / " + toDisplayString(o
				.dataInfo.data.length), 3))
		])], 2), o.showSearch ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(`${o.prefixCls}-search`)
		}, [createVNode(v, mergeProps({
			modelValue: o.filter,
			"onUpdate:modelValue": s[0] || (s[0] = S => o.filter = S),
			disabled: o.disabled
		}, o.inputSearchProps, {
			onChange: o.handleSearch
		}), null, 16, ["modelValue", "disabled", "onChange"])], 2)) : createCommentVNode("v-if", !0),
		createBaseVNode("div", {
			class: normalizeClass(`${o.prefixCls}-body`)
		}, [o.filteredData.length > 0 ? (openBlock(), createBlock(C, {
			key: 0
		}, {
			default: withCtx(() => {
				var S, w;
				return [renderSlot(o.$slots, "default", {
					data: o.filteredData,
					selectedKeys: (S = o.transferCtx) == null ? void 0 : S
						.selected,
					onSelect: (w = o.transferCtx) == null ? void 0 : w
						.onSelect
				}, () => [createVNode(b, {
					class: normalizeClass(`${o.prefixCls}-list`),
					bordered: !1,
					scrollbar: !1
				}, {
					default: withCtx(() => [(openBlock(!0),
						createElementBlock(Fragment,
							null, renderList(o
								.filteredData, T => (
									openBlock(),
									createBlock(y, {
										key: T
											.value,
										type: o
											.type,
										data: T,
										simple: o
											.simple,
										"allow-clear": o
											.allowClear,
										disabled: o
											.disabled ||
											T
											.disabled
									}, null, 8, [
										"type",
										"data",
										"simple",
										"allow-clear",
										"disabled"
									]))), 128))]),
					_: 1
				}, 8, ["class"])])]
			}),
			_: 3
		})) : (openBlock(), createBlock(_, {
			key: 1,
			class: normalizeClass(`${o.prefixCls}-empty`)
		}, null, 8, ["class"]))], 2)
	], 2)
}
var TransferView = _export_sfc$1(_sfc_main$B, [
	["render", _sfc_render$j]
]);
const _sfc_main$A = defineComponent({
	name: "Transfer",
	components: {
		ArcoButton: Button,
		TransferView,
		IconLeft,
		IconRight
	},
	props: {
		data: {
			type: Array,
			default: () => []
		},
		modelValue: {
			type: Array,
			default: void 0
		},
		defaultValue: {
			type: Array,
			default: () => []
		},
		selected: {
			type: Array,
			default: void 0
		},
		defaultSelected: {
			type: Array,
			default: () => []
		},
		disabled: {
			type: Boolean,
			default: !1
		},
		simple: {
			type: Boolean,
			default: !1
		},
		oneWay: {
			type: Boolean,
			default: !1
		},
		showSearch: {
			type: Boolean,
			default: !1
		},
		showSelectAll: {
			type: Boolean,
			default: !0
		},
		title: {
			type: Array,
			default: () => ["Source", "Target"]
		},
		sourceInputSearchProps: {
			type: Object
		},
		targetInputSearchProps: {
			type: Object
		}
	},
	emits: {
		"update:modelValue": o => !0,
		"update:selected": o => !0,
		change: o => !0,
		select: o => !0,
		search: (o, s) => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			mergedDisabled: l,
			eventHandlers: c
		} = useFormItem({
			disabled: toRef(o, "disabled")
		}), d = getPrefixCls("transfer"), f = ref(o.defaultValue), m = computed(() => {
			var k;
			return (k = o.modelValue) != null ? k : f.value
		}), g = ref(o.defaultSelected), v = computed(() => {
			var k;
			return (k = o.selected) != null ? k : g.value
		}), y = computed(() => {
			var k;
			return (k = o.title) == null ? void 0 : k[0]
		}), b = computed(() => {
			var k;
			return (k = o.title) == null ? void 0 : k[1]
		}), C = computed(() => {
			const k = {
					data: [],
					allValidValues: [],
					selected: [],
					validSelected: []
				},
				M = {
					data: [],
					allValidValues: [],
					selected: [],
					validSelected: []
				};
			for (const D of o.data) m.value.includes(D.value) ? (M.data.push(D), D.disabled || M
				.allValidValues.push(D.value), v.value.includes(D.value) && (M.selected.push(D
					.value), D.disabled || M.validSelected.push(D.value))) : (k.data.push(D), D
				.disabled || k.allValidValues.push(D.value), v.value.includes(D.value) && (k
					.selected.push(D.value), D.disabled || k.validSelected.push(D.value)));
			return {
				sourceInfo: k,
				targetInfo: M
			}
		}), _ = (k, M) => {
			s("search", k, M)
		}, S = (k, M) => {
			var D, F;
			const R = M === "target" ? [...m.value, ...k] : m.value.filter(O => !k.includes(O));
			T(C.value[M === "target" ? "targetInfo" : "sourceInfo"].selected), f.value = R, s(
				"update:modelValue", R), s("change", R), (F = (D = c.value) == null ? void 0 : D
				.onChange) == null || F.call(D)
		}, w = k => {
			const M = k === "target" ? C.value.sourceInfo.validSelected : C.value.targetInfo.validSelected;
			S(M, k)
		}, T = k => {
			g.value = k, s("update:selected", k), s("select", k)
		};
		provide(transferInjectionKey, reactive({
			selected: v,
			slots: a,
			moveTo: S,
			onSelect: T
		}));
		const A = computed(() => [d, {
			[`${d}-simple`]: o.simple,
			[`${d}-disabled`]: l.value
		}]);
		return {
			prefixCls: d,
			cls: A,
			dataInfo: C,
			computedSelected: v,
			mergedDisabled: l,
			sourceTitle: y,
			targetTitle: b,
			handleClick: w,
			handleSearch: _
		}
	}
});

function _sfc_render$i(o, s, a, l, c, d) {
	const f = resolveComponent("transfer-view"),
		m = resolveComponent("icon-right"),
		g = resolveComponent("arco-button"),
		v = resolveComponent("icon-left");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.cls)
	}, [createVNode(f, {
		type: "source",
		class: normalizeClass(`${o.prefixCls}-view-source`),
		title: o.sourceTitle,
		"data-info": o.dataInfo.sourceInfo,
		data: o.dataInfo.sourceInfo.data,
		disabled: o.mergedDisabled,
		selected: o.computedSelected,
		"show-search": o.showSearch,
		"show-select-all": o.showSelectAll,
		simple: o.simple,
		"input-search-props": o.sourceInputSearchProps,
		onSearch: o.handleSearch
	}, createSlots({
		_: 2
	}, [o.$slots.source ? {
		name: "default",
		fn: withCtx(y => [renderSlot(o.$slots, "source", normalizeProps(guardReactiveProps(
			y)))]),
		key: "0"
	} : void 0, o.$slots["source-title"] ? {
		name: "title",
		fn: withCtx(y => [renderSlot(o.$slots, "source-title", normalizeProps(
			guardReactiveProps(y)))]),
		key: "1"
	} : void 0]), 1032, ["class", "title", "data-info", "data", "disabled", "selected", "show-search",
		"show-select-all", "simple", "input-search-props", "onSearch"
	]), o.simple ? createCommentVNode("v-if", !0) : (openBlock(), createElementBlock("div", {
		key: 0,
		class: normalizeClass([`${o.prefixCls}-operations`])
	}, [createVNode(g, {
		tabindex: "-1",
		"aria-label": "Move selected right",
		size: "small",
		shape: "round",
		disabled: o.dataInfo.sourceInfo.validSelected.length === 0,
		onClick: s[0] || (s[0] = y => o.handleClick("target"))
	}, {
		icon: withCtx(() => [renderSlot(o.$slots, "to-target-icon", {}, () => [createVNode(
			m)])]),
		_: 3
	}, 8, ["disabled"]), o.oneWay ? createCommentVNode("v-if", !0) : (openBlock(), createBlock(
		g, {
			key: 0,
			tabindex: "-1",
			"aria-label": "Move selected left",
			size: "small",
			shape: "round",
			disabled: o.dataInfo.targetInfo.validSelected.length === 0,
			onClick: s[1] || (s[1] = y => o.handleClick("source"))
		}, {
			icon: withCtx(() => [renderSlot(o.$slots, "to-source-icon", {}, () => [
				createVNode(v)
			])]),
			_: 3
		}, 8, ["disabled"]))], 2)), createVNode(f, {
		type: "target",
		class: normalizeClass(`${o.prefixCls}-view-target`),
		title: o.targetTitle,
		"data-info": o.dataInfo.targetInfo,
		data: o.dataInfo.targetInfo.data,
		disabled: o.mergedDisabled,
		selected: o.computedSelected,
		"allow-clear": o.oneWay,
		"show-search": o.showSearch,
		"show-select-all": o.showSelectAll,
		simple: o.simple,
		"input-search-props": o.targetInputSearchProps,
		onSearch: o.handleSearch
	}, createSlots({
		_: 2
	}, [o.$slots.target ? {
		name: "default",
		fn: withCtx(y => [renderSlot(o.$slots, "target", normalizeProps(guardReactiveProps(
			y)))]),
		key: "0"
	} : void 0, o.$slots["target-title"] ? {
		name: "title",
		fn: withCtx(y => [renderSlot(o.$slots, "target-title", normalizeProps(
			guardReactiveProps(y)))]),
		key: "1"
	} : void 0]), 1032, ["class", "title", "data-info", "data", "disabled", "selected", "allow-clear",
		"show-search", "show-select-all", "simple", "input-search-props", "onSearch"
	])], 2)
}
var _Transfer = _export_sfc$1(_sfc_main$A, [
	["render", _sfc_render$i]
]);
const Transfer = Object.assign(_Transfer, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Transfer.name, _Transfer)
		}
	}),
	TreeInjectionKey = Symbol("TreeInjectionKey");

function getFlattenTreeData(o) {
	const s = [];

	function a(l) {
		l && l.forEach(c => {
			s.push(c), a(c.children)
		})
	}
	return a(o), s
}

function getKey2TreeNode(o) {
	const s = new Map;
	return o.forEach(a => {
		s.set(a.key, a)
	}), s
}

function isNodeSelectable(o) {
	return o.selectable && !o.disabled
}

function isNodeExpandable(o) {
	return !o.isLeaf && o.children
}

function isLeafNode(o) {
	return isBoolean$2(o.isLeaf) ? o.isLeaf : !o.children
}

function SetAdd(o) {
	return Set.prototype.add.bind(o)
}

function SetDelete(o) {
	return Set.prototype.delete.bind(o)
}

function isNodeCheckable(o) {
	return o.disabled || o.disableCheckbox ? !1 : !!o.checkable
}

function getChildrenKeys(o) {
	var s;
	const a = [];
	return (s = o.children) == null || s.forEach(l => {
		isNodeCheckable(l) && a.push(l.key, ...getChildrenKeys(l))
	}), a
}

function updateParent(o) {
	var s;
	const {
		node: a,
		checkedKeySet: l,
		indeterminateKeySet: c
	} = o;
	let d = a.parent;
	for (; d;) {
		if (isNodeCheckable(d)) {
			const f = d.key,
				m = ((s = d.children) == null ? void 0 : s.filter(isNodeCheckable)) || [];
			let g = 0;
			const v = m.length;
			m.some(({
				key: y
			}) => {
				if (l.has(y)) g += 1;
				else if (c.has(y)) return g += .5, !0;
				return !1
			}), g && g !== v ? c.add(f) : c.delete(f), g && g === v ? l.add(f) : l.delete(f)
		}
		d = d.parent
	}
}

function getCheckedStateByCheck(o) {
	const {
		node: s,
		checked: a,
		checkedKeys: l,
		indeterminateKeys: c,
		checkStrictly: d = !1
	} = o, {
		key: f
	} = s, m = new Set(l), g = new Set(c);
	if (a ? m.add(f) : m.delete(f), g.delete(f), !d) {
		const v = getChildrenKeys(s);
		a ? v.forEach(SetAdd(m)) : v.forEach(SetDelete(m)), v.forEach(SetDelete(g)), updateParent({
			node: s,
			checkedKeySet: m,
			indeterminateKeySet: g
		})
	}
	return [
		[...m],
		[...g]
	]
}

function getCheckedStateByInitKeys(o) {
	const {
		initCheckedKeys: s,
		key2TreeNode: a,
		checkStrictly: l,
		onlyCheckLeaf: c
	} = o, d = new Set, f = new Set, m = new Set;
	return l ? s.forEach(SetAdd(d)) : s.forEach(g => {
		var v;
		const y = a.get(g);
		if (!y || f.has(g) || c && ((v = y.children) != null && v.length)) return;
		const b = getChildrenKeys(y);
		b.forEach(SetAdd(f)), b.forEach(SetDelete(m)), d.add(g), m.delete(g), updateParent({
			node: y,
			checkedKeySet: d,
			indeterminateKeySet: m
		})
	}), [
		[...d, ...f],
		[...m]
	]
}

function useTreeContext() {
	return inject(TreeInjectionKey) || {}
}
const _sfc_main$z = defineComponent({
		name: "IconFile",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-file`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$b = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$h(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M16 21h16m-16 8h10m11 13H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z"
	}, null, -1)]), 14, _hoisted_1$b)
}
var _IconFile = _export_sfc$1(_sfc_main$z, [
	["render", _sfc_render$h]
]);
const IconFile = Object.assign(_IconFile, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconFile.name, _IconFile)
	}
});
var _sfc_main$y = defineComponent({
	name: "TreeNodeSwitcher",
	components: {
		IconLoading,
		RenderFunction
	},
	props: {
		prefixCls: String,
		loading: Boolean,
		showLine: Boolean,
		treeNodeData: {
			type: Object
		},
		icons: {
			type: Object
		},
		nodeStatus: {
			type: Object
		}
	},
	emits: ["click"],
	setup(o, {
		slots: s,
		emit: a
	}) {
		const {
			icons: l,
			nodeStatus: c,
			treeNodeData: d
		} = toRefs(o), f = useTreeContext(), m = usePickSlots(s, "switcher-icon"), g = usePickSlots(s,
			"loading-icon");
		return {
			getSwitcherIcon: () => {
				var v, y, b;
				const C = (y = (v = l == null ? void 0 : l.value) == null ? void 0 : v.switcherIcon) !=
					null ? y : m.value;
				return C ? C(c.value) : (b = f.switcherIcon) == null ? void 0 : b.call(f, d.value, c.value)
			},
			getLoadingIcon: () => {
				var v, y, b;
				const C = (y = (v = l == null ? void 0 : l.value) == null ? void 0 : v.loadingIcon) !=
					null ? y : g.value;
				return C ? C(c.value) : (b = f.loadingIcon) == null ? void 0 : b.call(f, d.value, c.value)
			},
			onClick(v) {
				a("click", v)
			}
		}
	},
	render() {
		var o, s, a;
		const {
			prefixCls: l,
			getSwitcherIcon: c,
			getLoadingIcon: d,
			onClick: f,
			nodeStatus: m = {},
			loading: g,
			showLine: v
		} = this, {
			expanded: y,
			isLeaf: b
		} = m;
		if (g) return (o = d()) != null ? o : h(IconLoading);
		let C = null,
			_ = !1;
		if (b) v && (C = (a = c()) != null ? a : h(IconFile));
		else {
			const w = v ? h("span", {
				class: `${l}-${y?"minus":"plus"}-icon`
			}) : h(IconCaretDown);
			C = (s = c()) != null ? s : w, _ = !v
		}
		if (!C) return null;
		const S = h("span", {
			class: `${l}-switcher-icon`,
			onClick: f
		}, C);
		return _ ? h(IconHover, {
			class: `${l}-icon-hover`
		}, () => S) : S
	}
});
const generateKey = (() => {
	let o = 0;
	return () => (o += 1, `__arco_tree${o}`)
})();

function getBoolean(o, s) {
	return !!(isUndefined$1(o) ? s : o)
}

function mapObject$1(o, s) {
	const a = {
		...o
	};
	return s && Object.keys(s).forEach(c => {
		const d = s[c];
		d !== c && (a[c] = o[d], delete a[d])
	}), a
}

function getEnableResult({
	subEnable: o,
	superEnable: s,
	isLeaf: a,
	treeNodeData: l,
	level: c
}) {
	return isUndefined$1(o) ? isFunction$2(s) ? s(l, {
		isLeaf: a,
		level: c
	}) : s ?? !1 : o
}

function generateNode(o) {
	var s, a;
	const {
		treeNodeData: l,
		parentNode: c,
		isTail: d = !0,
		treeProps: f
	} = o, {
		fieldNames: m
	} = f || {}, g = mapObject$1(l, m), v = f.loadMore ? !!g.isLeaf : !((s = g.children) != null && s.length), y = c ? c
		.level + 1 : 0, b = {
			...omit(g, ["children"]),
			key: (a = g.key) != null ? a : generateKey(),
			selectable: getEnableResult({
				subEnable: g.selectable,
				superEnable: f == null ? void 0 : f.selectable,
				isLeaf: v,
				level: y,
				treeNodeData: l
			}),
			disabled: !!g.disabled,
			disableCheckbox: !!g.disableCheckbox,
			checkable: getEnableResult({
				subEnable: g.checkable,
				superEnable: f == null ? void 0 : f.checkable,
				isLeaf: v,
				level: y,
				treeNodeData: l
			}),
			isLeaf: v,
			isTail: d,
			blockNode: !!(f != null && f.blockNode),
			showLine: !!(f != null && f.showLine),
			level: y,
			lineless: c ? [...c.lineless, c.isTail] : [],
			draggable: getBoolean(g.draggable, f == null ? void 0 : f.draggable)
		};
	return {
		...b,
		treeNodeProps: b,
		treeNodeData: l,
		parent: c,
		parentKey: c == null ? void 0 : c.key,
		pathParentKeys: c ? [...c.pathParentKeys, c.key] : []
	}
}

function generateTreeData(o, s) {
	function a(l, c) {
		if (!l) return;
		const {
			fieldNames: d
		} = s, f = [];
		return l.forEach((m, g) => {
			const v = generateNode({
				treeNodeData: m,
				treeProps: s,
				parentNode: c,
				isTail: g === l.length - 1
			});
			v.children = a(m[(d == null ? void 0 : d.children) || "children"], v), f.push(v)
		}), f
	}
	return a(o)
}

function useNodeKey() {
	const o = getCurrentInstance(),
		s = () => {
			var l;
			return (l = o == null ? void 0 : o.vnode.key) != null ? l : generateKey()
		},
		a = ref(s());
	return onUpdated(() => {
		a.value = s()
	}), a
}

function useDraggable(o) {
	const {
		key: s,
		refTitle: a
	} = toRefs(o), l = useTreeContext(), c = ref(!1), d = ref(!1), f = ref(!1), m = ref(0), g = throttleByRaf(v => {
		if (!a.value) return;
		const y = a.value.getBoundingClientRect(),
			b = window.pageYOffset + y.top,
			{
				pageY: C
			} = v,
			_ = y.height / 4,
			S = C - b;
		m.value = S < _ ? -1 : S < y.height - _ ? 0 : 1, f.value = l.allowDrop ? l.allowDrop(s.value, m.value) :
			!0
	});
	return {
		isDragOver: c,
		isDragging: d,
		isAllowDrop: f,
		dropPosition: m,
		setDragStatus(v, y) {
			switch (v) {
				case "dragStart":
					d.value = !0, m.value = 0, l.onDragStart && l.onDragStart(s.value, y);
					break;
				case "dragEnd":
					d.value = !1, c.value = !1, m.value = 0, g.cancel(), l.onDragEnd && l.onDragEnd(s.value, y);
					break;
				case "dragOver":
					c.value = !0, g(y), l.onDragOver && l.onDragOver(s.value, y);
					break;
				case "dragLeave":
					c.value = !1, m.value = 0, g.cancel(), l.onDragLeave && l.onDragLeave(s.value, y);
					break;
				case "drop":
					l.onDrop && l.onDrop(s.value, m.value, y), c.value = !1, m.value = 0, g.cancel();
					break
			}
		}
	}
}

function toArray(o) {
	return isArray$2(o) ? o : [o]
}
const _sfc_main$x = defineComponent({
		name: "BaseTreeNode",
		components: {
			NodeSwitcher: _sfc_main$y,
			Checkbox,
			RenderFunction,
			IconDragDotVertical
		},
		props: {
			title: {
				type: String
			},
			selectable: {
				type: Boolean
			},
			disabled: {
				type: Boolean
			},
			disableCheckbox: {
				type: Boolean
			},
			checkable: {
				type: Boolean
			},
			draggable: {
				type: Boolean
			},
			isLeaf: {
				type: Boolean
			},
			icon: {
				type: Function
			},
			switcherIcon: {
				type: Function
			},
			loadingIcon: {
				type: Function
			},
			dragIcon: {
				type: Function
			},
			isTail: {
				type: Boolean
			},
			blockNode: {
				type: Boolean
			},
			showLine: {
				type: Boolean
			},
			level: {
				type: Number,
				default: 0
			},
			lineless: {
				type: Array,
				default: () => []
			}
		},
		setup(o) {
			const s = useNodeKey(),
				a = getPrefixCls("tree-node"),
				l = useTreeContext(),
				c = computed(() => {
					var fe;
					return (fe = l.key2TreeNode) == null ? void 0 : fe.get(s.value)
				}),
				d = computed(() => c.value.treeNodeData),
				f = computed(() => c.value.children),
				m = computed(() => {
					var fe;
					const q = (fe = l.treeProps) == null ? void 0 : fe.actionOnNodeClick;
					return q ? toArray(q) : []
				}),
				{
					isLeaf: g,
					isTail: v,
					selectable: y,
					disabled: b,
					disableCheckbox: C,
					draggable: _
				} = toRefs(o),
				S = computed(() => {
					var fe;
					return [`${a}`, {
						[`${a}-selected`]: U.value,
						[`${a}-is-leaf`]: g.value,
						[`${a}-is-tail`]: v.value,
						[`${a}-expanded`]: V.value,
						[`${a}-disabled-selectable`]: !y.value && !((fe = l.treeProps) != null && fe
							.disableSelectActionOnly),
						[`${a}-disabled`]: b.value
					}]
				}),
				w = ref(),
				{
					isDragOver: T,
					isDragging: A,
					isAllowDrop: k,
					dropPosition: M,
					setDragStatus: D
				} = useDraggable(reactive({
					key: s,
					refTitle: w
				})),
				F = computed(() => [`${a}-title`, {
					[`${a}-title-draggable`]: _.value,
					[`${a}-title-gap-top`]: T.value && k.value && M.value < 0,
					[`${a}-title-gap-bottom`]: T.value && k.value && M.value > 0,
					[`${a}-title-highlight`]: !A.value && T.value && k.value && M.value === 0,
					[`${a}-title-dragging`]: A.value,
					[`${a}-title-block`]: c.value.blockNode
				}]),
				R = computed(() => {
					var fe, q;
					return (q = (fe = l.checkedKeys) == null ? void 0 : fe.includes) == null ? void 0 : q.call(
						fe, s.value)
				}),
				O = computed(() => {
					var fe, q;
					return (q = (fe = l.indeterminateKeys) == null ? void 0 : fe.includes) == null ? void 0 : q
						.call(fe, s.value)
				}),
				U = computed(() => {
					var fe, q;
					return (q = (fe = l.selectedKeys) == null ? void 0 : fe.includes) == null ? void 0 : q.call(
						fe, s.value)
				}),
				V = computed(() => {
					var fe, q;
					return (q = (fe = l.expandedKeys) == null ? void 0 : fe.includes) == null ? void 0 : q.call(
						fe, s.value)
				}),
				z = computed(() => {
					var fe, q;
					return (q = (fe = l.loadingKeys) == null ? void 0 : fe.includes) == null ? void 0 : q.call(
						fe, s.value)
				}),
				j = computed(() => l.dragIcon),
				ge = computed(() => l.nodeIcon);

			function me(fe) {
				var q, le;
				g.value || (!((q = f.value) != null && q.length) && isFunction$2(l.onLoadMore) ? l.onLoadMore(s
					.value) : (le = l == null ? void 0 : l.onExpand) == null || le.call(l, !V.value, s
					.value, fe))
			}
			const he = reactive({
					loading: z,
					checked: R,
					selected: U,
					indeterminate: O,
					expanded: V,
					isLeaf: g
				}),
				ce = computed(() => l.nodeTitle ? () => {
					var fe;
					return (fe = l.nodeTitle) == null ? void 0 : fe.call(l, d.value, he)
				} : void 0),
				ae = computed(() => l.nodeExtra ? () => {
					var fe;
					return (fe = l.nodeExtra) == null ? void 0 : fe.call(l, d.value, he)
				} : void 0);
			return {
				nodekey: s,
				refTitle: w,
				prefixCls: a,
				classNames: S,
				titleClassNames: F,
				indeterminate: O,
				checked: R,
				expanded: V,
				selected: U,
				treeTitle: ce,
				treeNodeData: d,
				loading: z,
				treeDragIcon: j,
				treeNodeIcon: ge,
				extra: ae,
				nodeStatus: he,
				onCheckboxChange(fe, q) {
					var le;
					C.value || b.value || (le = l.onCheck) == null || le.call(l, fe, s.value, q)
				},
				onTitleClick(fe) {
					var q;
					m.value.includes("expand") && me(fe), !(!y.value || b.value) && ((q = l.onSelect) == null || q
						.call(l, s.value, fe))
				},
				onSwitcherClick: me,
				onDragStart(fe) {
					var q;
					if (_.value) {
						fe.stopPropagation(), D("dragStart", fe);
						try {
							(q = fe.dataTransfer) == null || q.setData("text/plain", "")
						} catch {}
					}
				},
				onDragEnd(fe) {
					_.value && (fe.stopPropagation(), D("dragEnd", fe))
				},
				onDragOver(fe) {
					_ && (fe.stopPropagation(), fe.preventDefault(), D("dragOver", fe))
				},
				onDragLeave(fe) {
					_.value && (fe.stopPropagation(), D("dragLeave", fe))
				},
				onDrop(fe) {
					!_.value || !k.value || (fe.stopPropagation(), fe.preventDefault(), D("drop", fe))
				}
			}
		}
	}),
	_hoisted_1$a = ["data-level", "data-key"],
	_hoisted_2$1 = ["draggable"];

function _sfc_render$g(o, s, a, l, c, d) {
	const f = resolveComponent("NodeSwitcher"),
		m = resolveComponent("Checkbox"),
		g = resolveComponent("RenderFunction"),
		v = resolveComponent("IconDragDotVertical");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames),
		"data-level": o.level,
		"data-key": o.nodekey
	}, [createCommentVNode(" 缩进 "), createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-indent`)
		}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.level, y => (openBlock(),
			createElementBlock("span", {
				key: y,
				class: normalizeClass([`${o.prefixCls}-indent-block`, {
					[`${o.prefixCls}-indent-block-lineless`]: o.lineless[y -
						1]
				}])
			}, null, 2))), 128))], 2), createCommentVNode(" switcher "), createBaseVNode("span", {
			class: normalizeClass([`${o.prefixCls}-switcher`, {
				[`${o.prefixCls}-switcher-expanded`]: o.expanded
			}])
		}, [createVNode(f, {
			"prefix-cls": o.prefixCls,
			loading: o.loading,
			"show-line": o.showLine,
			"tree-node-data": o.treeNodeData,
			icons: {
				switcherIcon: o.switcherIcon,
				loadingIcon: o.loadingIcon
			},
			"node-status": o.nodeStatus,
			onClick: o.onSwitcherClick
		}, createSlots({
			_: 2
		}, [o.$slots["switcher-icon"] ? {
			name: "switcher-icon",
			fn: withCtx(() => [createCommentVNode(" @slot 定制 switcher 图标，会覆盖 Tree 的配置 "),
				renderSlot(o.$slots, "switcher-icon")
			]),
			key: "0"
		} : void 0, o.$slots["loading-icon"] ? {
			name: "loading-icon",
			fn: withCtx(() => [createCommentVNode(" @slot 定制 loading 图标，会覆盖 Tree 的配置 "),
				renderSlot(o.$slots, "loading-icon")
			]),
			key: "1"
		} : void 0]), 1032, ["prefix-cls", "loading", "show-line", "tree-node-data", "icons",
			"node-status", "onClick"
		])], 2), createCommentVNode(" checkbox "), o.checkable ? (openBlock(), createBlock(m, {
			key: 0,
			disabled: o.disableCheckbox || o.disabled,
			"model-value": o.checked,
			indeterminate: o.indeterminate,
			"uninject-group-context": "",
			onChange: o.onCheckboxChange
		}, null, 8, ["disabled", "model-value", "indeterminate", "onChange"])) : createCommentVNode("v-if", !0),
		createCommentVNode(" 内容 "), createBaseVNode("span", {
			ref: "refTitle",
			class: normalizeClass(o.titleClassNames),
			draggable: o.draggable,
			onDragstart: s[0] || (s[0] = (...y) => o.onDragStart && o.onDragStart(...y)),
			onDragend: s[1] || (s[1] = (...y) => o.onDragEnd && o.onDragEnd(...y)),
			onDragover: s[2] || (s[2] = (...y) => o.onDragOver && o.onDragOver(...y)),
			onDragleave: s[3] || (s[3] = (...y) => o.onDragLeave && o.onDragLeave(...y)),
			onDrop: s[4] || (s[4] = (...y) => o.onDrop && o.onDrop(...y)),
			onClick: s[5] || (s[5] = (...y) => o.onTitleClick && o.onTitleClick(...y))
		}, [o.$slots.icon || o.icon || o.treeNodeIcon ? (openBlock(), createElementBlock("span", {
			key: 0,
			class: normalizeClass([`${o.prefixCls}-icon`, `${o.prefixCls}-custom-icon`])
		}, [createCommentVNode(" 节点图标 "), o.$slots.icon ? renderSlot(o.$slots, "icon",
			normalizeProps(mergeProps({
				key: 0
			}, o.nodeStatus))) : o.icon ? (openBlock(), createBlock(g, mergeProps({
			key: 1,
			"render-func": o.icon
		}, o.nodeStatus), null, 16, ["render-func"])) : o.treeNodeIcon ? (openBlock(),
			createBlock(g, mergeProps({
				key: 2,
				"render-func": o.treeNodeIcon,
				node: o.treeNodeData
			}, o.nodeStatus), null, 16, ["render-func", "node"])) : createCommentVNode(
			"v-if", !0)], 2)) : createCommentVNode("v-if", !0), createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-title-text`)
		}, [o.treeTitle ? (openBlock(), createBlock(g, {
			key: 0,
			"render-func": o.treeTitle
		}, null, 8, ["render-func"])) : (openBlock(), createElementBlock(Fragment, {
			key: 1
		}, [createCommentVNode(" 标题，treeTitle 优先级高于节点的 title "), renderSlot(o.$slots,
			"title", {
				title: o.title
			}, () => [createTextVNode(toDisplayString(o.title), 1)])], 2112)), o.draggable ? (
			openBlock(), createElementBlock("span", {
				key: 2,
				class: normalizeClass([`${o.prefixCls}-icon`, `${o.prefixCls}-drag-icon`])
			}, [createCommentVNode(" 拖拽图标 "), o.$slots["drag-icon"] ? renderSlot(o.$slots,
				"drag-icon", normalizeProps(mergeProps({
					key: 0
				}, o.nodeStatus))) : o.dragIcon ? (openBlock(), createBlock(g,
				mergeProps({
					key: 1,
					"render-func": o.dragIcon
				}, o.nodeStatus), null, 16, ["render-func"])) : o.treeDragIcon ? (
				openBlock(), createBlock(g, mergeProps({
					key: 2,
					"render-func": o.treeDragIcon,
					node: o.treeNodeData
				}, o.nodeStatus), null, 16, ["render-func", "node"])) : (openBlock(),
				createBlock(v, {
					key: 3
				}))], 2)) : createCommentVNode("v-if", !0)], 2)], 42, _hoisted_2$1), createCommentVNode(" 额外 "),
		o.extra ? (openBlock(), createBlock(g, {
			key: 1,
			"render-func": o.extra
		}, null, 8, ["render-func"])) : createCommentVNode("v-if", !0)
	], 10, _hoisted_1$a)
}
var BaseTreeNode = _export_sfc$1(_sfc_main$x, [
	["render", _sfc_render$g]
]);
const _sfc_main$w = defineComponent({
	name: "ExpandTransition",
	props: {
		expanded: Boolean
	},
	emits: ["end"],
	setup(o, {
		emit: s
	}) {
		return {
			onEnter(a) {
				const l = `${a.scrollHeight}px`;
				a.style.height = o.expanded ? "0" : l, a.offsetHeight, a.style.height = o.expanded ? l : "0"
			},
			onAfterEnter(a) {
				a.style.height = o.expanded ? "" : "0", s("end")
			},
			onBeforeLeave(a) {
				a.style.display = "none"
			}
		}
	}
});

function _sfc_render$f(o, s, a, l, c, d) {
	return openBlock(), createBlock(Transition, {
		onEnter: o.onEnter,
		onAfterEnter: o.onAfterEnter,
		onBeforeLeave: o.onBeforeLeave
	}, {
		default: withCtx(() => [renderSlot(o.$slots, "default")]),
		_: 3
	}, 8, ["onEnter", "onAfterEnter", "onBeforeLeave"])
}
var ExpandTransition = _export_sfc$1(_sfc_main$w, [
	["render", _sfc_render$f]
]);
const _sfc_main$v = defineComponent({
	name: "TransitionNodeList",
	components: {
		ExpandTransition,
		BaseTreeNode
	},
	props: {
		nodeKey: {
			type: [String, Number],
			required: !0
		}
	},
	setup(o) {
		const a = [`${getPrefixCls("tree")}-node-list`],
			l = useTreeContext(),
			{
				nodeKey: c
			} = toRefs(o),
			d = computed(() => {
				var g, v;
				return (v = (g = l.expandedKeys) == null ? void 0 : g.includes) == null ? void 0 : v.call(g,
					c.value)
			}),
			f = computed(() => {
				var g;
				const v = new Set(l.expandedKeys || []),
					y = (g = l.flattenTreeData) == null ? void 0 : g.filter(b => {
						var C, _;
						return (C = b.pathParentKeys) != null && C.includes(c.value) ? !l
							.filterTreeNode || ((_ = l.filterTreeNode) == null ? void 0 : _.call(l, b
								.treeNodeData)) : !1
					});
				return y == null ? void 0 : y.filter(b => {
					var C;
					if (d.value) return (C = b.pathParentKeys) == null ? void 0 : C.every(S => v
						.has(S));
					const _ = b.pathParentKeys.indexOf(c.value);
					return b.pathParentKeys.slice(_ + 1).every(S => v.has(S))
				})
			}),
			m = computed(() => {
				var g, v;
				return ((g = l.currentExpandKeys) == null ? void 0 : g.includes(c.value)) && ((v = f
					.value) == null ? void 0 : v.length)
			});
		return {
			classNames: a,
			visibleNodeList: f,
			show: m,
			expanded: d,
			onTransitionEnd() {
				var g;
				(g = l.onExpandEnd) == null || g.call(l, c.value)
			}
		}
	}
});

function _sfc_render$e(o, s, a, l, c, d) {
	const f = resolveComponent("BaseTreeNode"),
		m = resolveComponent("ExpandTransition");
	return openBlock(), createBlock(m, {
		expanded: o.expanded,
		onEnd: o.onTransitionEnd
	}, {
		default: withCtx(() => [o.show ? (openBlock(), createElementBlock("div", {
			key: 0,
			class: normalizeClass(o.classNames)
		}, [(openBlock(!0), createElementBlock(Fragment, null, renderList(o.visibleNodeList,
			g => (openBlock(), createBlock(f, mergeProps({
				key: g.key,
				ref_for: !0
			}, g.treeNodeProps), null, 16))), 128))], 2)) : createCommentVNode("v-if", !0)]),
		_: 1
	}, 8, ["expanded", "onEnd"])
}
var TransitionNodeList = _export_sfc$1(_sfc_main$v, [
		["render", _sfc_render$e]
	]),
	TreeNode = defineComponent({
		name: "TreeNode",
		inheritAttrs: !1,
		props: {
			...BaseTreeNode.props
		},
		setup(o, {
			slots: s,
			attrs: a
		}) {
			const l = useNodeKey();
			return () => createVNode(Fragment, null, [createVNode(BaseTreeNode, mergeProps(o, a, {
				key: l.value
			}), s), createVNode(TransitionNodeList, {
				key: l.value,
				nodeKey: l.value
			}, null)])
		}
	});

function useCheckedState(o) {
	const {
		defaultCheckedKeys: s,
		checkedKeys: a,
		key2TreeNode: l,
		checkStrictly: c,
		halfCheckedKeys: d,
		onlyCheckLeaf: f
	} = toRefs(o), m = ref(!1), g = ref([]), v = ref([]), y = ref(), b = ref(), C = S => getCheckedStateByInitKeys({
		initCheckedKeys: S,
		key2TreeNode: l.value,
		checkStrictly: c.value,
		onlyCheckLeaf: f.value
	}), _ = S => {
		const w = C(S);
		[g.value, v.value] = w
	};
	return _(a.value || (s == null ? void 0 : s.value) || []), watchEffect(() => {
		a.value ? [y.value, b.value] = C(a.value) : m.value && (y.value = void 0, b.value = void 0, g
		.value = [], v.value = []), m.value || (m.value = !0)
	}), {
		checkedKeys: computed(() => y.value || g.value),
		indeterminateKeys: computed(() => c.value && d.value ? d.value : b.value || v.value),
		setCheckedState(S, w, T = !1) {
			return T ? _(S) : (g.value = S, v.value = w), [g.value, v.value]
		}
	}
}

function useTreeData(o) {
	const {
		treeData: s,
		fieldNames: a,
		selectable: l,
		showLine: c,
		blockNode: d,
		checkable: f,
		loadMore: m,
		draggable: g
	} = toRefs(o), v = ref([]);
	watchEffect(() => {
		var C, _;
		v.value = generateTreeData(s.value || [], {
			selectable: (C = l == null ? void 0 : l.value) != null ? C : !1,
			showLine: !!(c != null && c.value),
			blockNode: !!(d != null && d.value),
			checkable: (_ = f == null ? void 0 : f.value) != null ? _ : !1,
			fieldNames: a == null ? void 0 : a.value,
			loadMore: !!(m != null && m.value),
			draggable: !!(g != null && g.value)
		})
	});
	const y = computed(() => getFlattenTreeData(v.value)),
		b = computed(() => getKey2TreeNode(y.value));
	return {
		treeData: v,
		flattenTreeData: y,
		key2TreeNode: b
	}
}
const _sfc_main$u = defineComponent({
	name: "Tree",
	components: {
		VirtualList,
		TreeNode
	},
	props: {
		size: {
			type: String,
			default: "medium"
		},
		blockNode: {
			type: Boolean
		},
		defaultExpandAll: {
			type: Boolean,
			default: !0
		},
		multiple: {
			type: Boolean
		},
		checkable: {
			type: [Boolean, String, Function],
			default: !1
		},
		selectable: {
			type: [Boolean, Function],
			default: !0
		},
		checkStrictly: {
			type: Boolean
		},
		checkedStrategy: {
			type: String,
			default: "all"
		},
		defaultSelectedKeys: {
			type: Array
		},
		selectedKeys: {
			type: Array
		},
		defaultCheckedKeys: {
			type: Array
		},
		checkedKeys: {
			type: Array
		},
		defaultExpandedKeys: {
			type: Array
		},
		expandedKeys: {
			type: Array
		},
		data: {
			type: Array,
			default: () => []
		},
		fieldNames: {
			type: Object
		},
		showLine: {
			type: Boolean
		},
		loadMore: {
			type: Function
		},
		draggable: {
			type: Boolean
		},
		allowDrop: {
			type: Function
		},
		filterTreeNode: {
			type: Function
		},
		searchValue: {
			type: String,
			default: ""
		},
		virtualListProps: {
			type: Object
		},
		defaultExpandSelected: {
			type: Boolean
		},
		defaultExpandChecked: {
			type: Boolean
		},
		autoExpandParent: {
			type: Boolean,
			default: !0
		},
		halfCheckedKeys: {
			type: Array
		},
		onlyCheckLeaf: {
			type: Boolean,
			default: !1
		},
		animation: {
			type: Boolean,
			default: !0
		},
		actionOnNodeClick: {
			type: String
		},
		disableSelectActionOnly: {
			type: Boolean,
			default: !1
		}
	},
	emits: {
		select: (o, s) => !0,
		"update:selectedKeys": o => !0,
		check: (o, s) => !0,
		"update:checkedKeys": o => !0,
		"update:halfCheckedKeys": o => !0,
		expand: (o, s) => !0,
		"update:expandedKeys": o => !0,
		dragStart: (o, s) => !0,
		dragEnd: (o, s) => !0,
		dragOver: (o, s) => !0,
		dragLeave: (o, s) => !0,
		drop: o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const {
			data: l,
			showLine: c,
			multiple: d,
			loadMore: f,
			checkStrictly: m,
			checkedKeys: g,
			defaultCheckedKeys: v,
			selectedKeys: y,
			defaultSelectedKeys: b,
			expandedKeys: C,
			defaultExpandedKeys: _,
			checkedStrategy: S,
			selectable: w,
			checkable: T,
			blockNode: A,
			fieldNames: k,
			size: M,
			defaultExpandAll: D,
			filterTreeNode: F,
			draggable: R,
			allowDrop: O,
			defaultExpandSelected: U,
			defaultExpandChecked: V,
			autoExpandParent: z,
			halfCheckedKeys: j,
			onlyCheckLeaf: ge,
			animation: me
		} = toRefs(o), he = getPrefixCls("tree"), ce = computed(() => [`${he}`, {
				[`${he}-checkable`]: T.value,
				[`${he}-show-line`]: c.value
			}, `${he}-size-${M.value}`]), ae = usePickSlots(a, "switcher-icon"), fe = usePickSlots(a,
				"loading-icon"), q = usePickSlots(a, "drag-icon"), le = usePickSlots(a, "icon"), de =
			usePickSlots(a, "title"), _e = usePickSlots(a, "extra"), {
				treeData: ke,
				flattenTreeData: De,
				key2TreeNode: Se
			} = useTreeData(reactive({
				treeData: l,
				selectable: w,
				showLine: c,
				blockNode: A,
				checkable: T,
				fieldNames: k,
				loadMore: f,
				draggable: R
			})), {
				checkedKeys: be,
				indeterminateKeys: Me,
				setCheckedState: Ve
			} = useCheckedState(reactive({
				defaultCheckedKeys: v,
				checkedKeys: g,
				checkStrictly: m,
				key2TreeNode: Se,
				halfCheckedKeys: j,
				onlyCheckLeaf: ge
			})), [it, pt] = useMergeState((b == null ? void 0 : b.value) || [], reactive({
				value: y
			})), dt = ref([]), He = ref();

		function Ae() {
			if (_ != null && _.value) {
				const Ze = new Set([]);
				return _.value.forEach(Ye => {
					if (Ze.has(Ye)) return;
					const ct = Se.value.get(Ye);
					ct && [...z.value ? ct.pathParentKeys : [], Ye].forEach(yt => Ze.add(yt))
				}), [...Ze]
			}
			if (D.value) return De.value.filter(Ze => Ze.children && Ze.children.length).map(Ze => Ze.key);
			if (U.value || V.value) {
				const Ze = new Set([]),
					Ye = ct => {
						ct.forEach(yt => {
							const wt = Se.value.get(yt);
							wt && (wt.pathParentKeys || []).forEach(Qe => Ze.add(Qe))
						})
					};
				return U.value && Ye(it.value), V.value && Ye(be.value), [...Ze]
			}
			return []
		}
		const [xe, ye] = useMergeState(Ae(), reactive({
			value: C
		})), Le = ref([]), Ue = computed(() => {
			const Ze = new Set(xe.value),
				Ye = new Set(Le.value);
			return De.value.filter(ct => {
				var yt;
				if (!(!F || !F.value || (F == null ? void 0 : F.value(ct.treeNodeData))))
				return !1;
				const Qe = isUndefined$1(ct.parentKey),
					At = (yt = ct.pathParentKeys) == null ? void 0 : yt.every(Ct => Ze.has(
						Ct) && !Ye.has(Ct));
				return Qe || At
			})
		});

		function nt(Ze, Ye = S.value) {
			let ct = [...Ze];
			return Ye === "parent" ? ct = Ze.filter(yt => {
				const wt = Se.value.get(yt);
				return wt && !(!isUndefined$1(wt.parentKey) && Ze.includes(wt.parentKey))
			}) : Ye === "child" && (ct = Ze.filter(yt => {
				var wt, Qe;
				return !((Qe = (wt = Se.value.get(yt)) == null ? void 0 : wt.children) != null && Qe
					.length)
			})), ct
		}

		function ot(Ze) {
			return Ze.map(Ye => {
				var ct;
				return ((ct = Se.value.get(Ye)) == null ? void 0 : ct.treeNodeData) || void 0
			}).filter(Boolean)
		}

		function at(Ze) {
			const {
				targetKey: Ye,
				targetChecked: ct,
				newCheckedKeys: yt,
				newIndeterminateKeys: wt,
				event: Qe
			} = Ze, At = Ye ? Se.value.get(Ye) : void 0, Ct = nt(yt);
			s("update:checkedKeys", Ct), s("update:halfCheckedKeys", wt), s("check", Ct, {
				checked: ct,
				node: At == null ? void 0 : At.treeNodeData,
				checkedNodes: ot(Ct),
				halfCheckedKeys: wt,
				halfCheckedNodes: ot(wt),
				e: Qe
			})
		}

		function Je(Ze) {
			const {
				targetKey: Ye,
				targetSelected: ct,
				newSelectedKeys: yt,
				event: wt
			} = Ze, Qe = Ye ? Se.value.get(Ye) : void 0;
			s("update:selectedKeys", yt), s("select", yt, {
				selected: ct,
				node: Qe == null ? void 0 : Qe.treeNodeData,
				selectedNodes: ot(yt),
				e: wt
			})
		}

		function Ne(Ze) {
			const {
				targetKey: Ye,
				targetExpanded: ct,
				newExpandedKeys: yt,
				event: wt
			} = Ze, Qe = Ye ? Se.value.get(Ye) : void 0;
			s("expand", yt, {
				expanded: ct,
				node: Qe == null ? void 0 : Qe.treeNodeData,
				expandedNodes: ot(yt),
				e: wt
			}), s("update:expandedKeys", yt)
		}

		function we(Ze) {
			const [Ye, ct] = Ve(Ze, [], !0);
			at({
				newCheckedKeys: Ye,
				newIndeterminateKeys: ct
			})
		}

		function Ce(Ze) {
			let Ye = Ze;
			!d.value && Ze.length > 1 && (Ye = [Ze[0]]), pt(Ye), Je({
				newSelectedKeys: Ye
			})
		}

		function $e(Ze) {
			Le.value = [], ye(Ze), Ne({
				newExpandedKeys: Ze
			})
		}

		function Fe(Ze, Ye, ct) {
			if (!Ze.length) return;
			let yt = [...be.value],
				wt = [...Me.value];
			Ze.forEach(Qe => {
				const At = Se.value.get(Qe);
				At && ([yt, wt] = getCheckedStateByCheck({
					node: At,
					checked: Ye,
					checkedKeys: [...yt],
					indeterminateKeys: [...wt],
					checkStrictly: m.value
				}))
			}), Ve(yt, wt), at({
				targetKey: ct,
				targetChecked: isUndefined$1(ct) ? void 0 : Ye,
				newCheckedKeys: yt,
				newIndeterminateKeys: wt
			})
		}

		function Ge(Ze, Ye, ct) {
			if (!Ze.length) return;
			let yt;
			if (d.value) {
				const wt = new Set(it.value);
				Ze.forEach(Qe => {
					Ye ? wt.add(Qe) : wt.delete(Qe)
				}), yt = [...wt]
			} else yt = Ye ? [Ze[0]] : [];
			pt(yt), Je({
				targetKey: ct,
				targetSelected: isUndefined$1(ct) ? void 0 : Ye,
				newSelectedKeys: yt
			})
		}

		function ze(Ze, Ye, ct) {
			const yt = new Set(xe.value);
			Ze.forEach(Qe => {
				Ye ? yt.add(Qe) : yt.delete(Qe), ut(Qe)
			});
			const wt = [...yt];
			ye(wt), Ne({
				targetKey: ct,
				targetExpanded: isUndefined$1(ct) ? void 0 : Ye,
				newExpandedKeys: wt
			})
		}

		function Oe(Ze, Ye, ct) {
			const yt = Se.value.get(Ye);
			if (!yt) return;
			const [wt, Qe] = getCheckedStateByCheck({
				node: yt,
				checked: Ze,
				checkedKeys: be.value,
				indeterminateKeys: Me.value,
				checkStrictly: m.value
			});
			Ve(wt, Qe), at({
				targetKey: Ye,
				targetChecked: Ze,
				newCheckedKeys: wt,
				newIndeterminateKeys: Qe,
				event: ct
			})
		}

		function Xe(Ze, Ye) {
			if (!Se.value.get(Ze)) return;
			let yt, wt;
			if (d.value) {
				const Qe = new Set(it.value);
				wt = !Qe.has(Ze), wt ? Qe.add(Ze) : Qe.delete(Ze), yt = [...Qe]
			} else wt = !0, yt = [Ze];
			pt(yt), Je({
				targetKey: Ze,
				targetSelected: wt,
				newSelectedKeys: yt,
				event: Ye
			})
		}

		function rt(Ze, Ye, ct) {
			if (Le.value.includes(Ye) || !Se.value.get(Ye)) return;
			const wt = new Set(xe.value);
			Ze ? wt.add(Ye) : wt.delete(Ye);
			const Qe = [...wt];
			ye(Qe), me.value && Le.value.push(Ye), Ne({
				targetKey: Ye,
				targetExpanded: Ze,
				newExpandedKeys: Qe,
				event: ct
			})
		}

		function ut(Ze) {
			const Ye = Le.value.indexOf(Ze);
			Le.value.splice(Ye, 1)
		}
		const gt = computed(() => f != null && f.value ? async Ze => {
				if (!isFunction$2(f.value)) return;
				const Ye = Se.value.get(Ze);
				if (!Ye) return;
				const {
					treeNodeData: ct
				} = Ye;
				dt.value = [...new Set([...dt.value, Ze])];
				try {
					await f.value(ct), dt.value = dt.value.filter(yt => yt !== Ze), rt(!0, Ze), be.value
						.includes(Ze) && Oe(!0, Ze)
				} catch (yt) {
					dt.value = dt.value.filter(wt => wt !== Ze), console.error(
						"[tree]load data error: ", yt)
				}
			}: void 0),
			Et = reactive({
				treeProps: o,
				switcherIcon: ae,
				loadingIcon: fe,
				dragIcon: q,
				nodeIcon: le,
				nodeTitle: de,
				nodeExtra: _e,
				treeData: ke,
				flattenTreeData: De,
				key2TreeNode: Se,
				checkedKeys: be,
				indeterminateKeys: Me,
				selectedKeys: it,
				expandedKeys: xe,
				loadingKeys: dt,
				currentExpandKeys: Le,
				onLoadMore: gt,
				filterTreeNode: F,
				onCheck: Oe,
				onSelect: Xe,
				onExpand: rt,
				onExpandEnd: ut,
				allowDrop(Ze, Ye) {
					const ct = Se.value.get(Ze);
					return ct && isFunction$2(O.value) ? !!O.value({
						dropNode: ct.treeNodeData,
						dropPosition: Ye
					}) : !0
				},
				onDragStart(Ze, Ye) {
					const ct = Se.value.get(Ze);
					He.value = ct, ct && s("dragStart", Ye, ct.treeNodeData)
				},
				onDragEnd(Ze, Ye) {
					const ct = Se.value.get(Ze);
					He.value = void 0, ct && s("dragEnd", Ye, ct.treeNodeData)
				},
				onDragOver(Ze, Ye) {
					const ct = Se.value.get(Ze);
					ct && s("dragOver", Ye, ct.treeNodeData)
				},
				onDragLeave(Ze, Ye) {
					const ct = Se.value.get(Ze);
					ct && s("dragLeave", Ye, ct.treeNodeData)
				},
				onDrop(Ze, Ye, ct) {
					const yt = Se.value.get(Ze);
					He.value && yt && !(yt.key === He.value.key || yt.pathParentKeys.includes(He.value
						.key || "")) && s("drop", {
						e: ct,
						dragNode: He.value.treeNodeData,
						dropNode: yt.treeNodeData,
						dropPosition: Ye
					})
				}
			});
		return provide(TreeInjectionKey, Et), {
			classNames: ce,
			visibleTreeNodeList: Ue,
			treeContext: Et,
			virtualListRef: ref(),
			computedSelectedKeys: it,
			computedExpandedKeys: xe,
			computedCheckedKeys: be,
			computedIndeterminateKeys: Me,
			getPublicCheckedKeys: nt,
			getNodes: ot,
			internalCheckNodes: Fe,
			internalSetCheckedKeys: we,
			internalSelectNodes: Ge,
			internalSetSelectedKeys: Ce,
			internalExpandNodes: ze,
			internalSetExpandedKeys: $e
		}
	},
	methods: {
		toggleCheck(o, s) {
			const {
				key2TreeNode: a,
				onCheck: l,
				checkedKeys: c
			} = this.treeContext, d = !c.includes(o), f = a.get(o);
			f && isNodeCheckable(f) && l(d, o, s)
		},
		scrollIntoView(o) {
			this.virtualListRef && this.virtualListRef.scrollTo(o)
		},
		getSelectedNodes() {
			return this.getNodes(this.computedSelectedKeys)
		},
		getCheckedNodes(o = {}) {
			const {
				checkedStrategy: s,
				includeHalfChecked: a
			} = o, l = this.getPublicCheckedKeys(this.computedCheckedKeys, s);
			return [...this.getNodes(l), ...a ? this.getHalfCheckedNodes() : []]
		},
		getHalfCheckedNodes() {
			return this.getNodes(this.computedIndeterminateKeys)
		},
		getExpandedNodes() {
			return this.getNodes(this.computedExpandedKeys)
		},
		checkAll(o = !0) {
			const {
				key2TreeNode: s
			} = this.treeContext, a = o ? [...s.keys()].filter(l => {
				const c = s.get(l);
				return c && isNodeCheckable(c)
			}) : [];
			this.internalSetCheckedKeys(a)
		},
		checkNode(o, s = !0, a = !1) {
			const {
				checkStrictly: l,
				treeContext: c
			} = this, {
				key2TreeNode: d
			} = c, f = isArray$2(o), m = (f ? o : [o]).filter(g => {
				const v = d.get(g);
				return v && isNodeCheckable(v) && (l || !a || isLeafNode(v))
			});
			this.internalCheckNodes(m, s, f ? void 0 : o)
		},
		selectAll(o = !0) {
			const {
				key2TreeNode: s
			} = this.treeContext, a = o ? [...s.keys()].filter(l => {
				const c = s.get(l);
				return c && isNodeSelectable(c)
			}) : [];
			this.internalSetSelectedKeys(a)
		},
		selectNode(o, s = !0) {
			const {
				key2TreeNode: a
			} = this.treeContext, l = isArray$2(o), c = (l ? o : [o]).filter(d => {
				const f = a.get(d);
				return f && isNodeSelectable(f)
			});
			this.internalSelectNodes(c, s, l ? void 0 : o)
		},
		expandAll(o = !0) {
			const {
				key2TreeNode: s
			} = this.treeContext, a = o ? [...s.keys()].filter(l => {
				const c = s.get(l);
				return c && isNodeExpandable(c)
			}) : [];
			this.internalSetExpandedKeys(a)
		},
		expandNode(o, s = !0) {
			const {
				key2TreeNode: a
			} = this.treeContext, l = isArray$2(o), c = (l ? o : [o]).filter(d => {
				const f = a.get(d);
				return f && isNodeExpandable(f)
			});
			this.internalExpandNodes(c, s, l ? void 0 : o)
		}
	}
});

function _sfc_render$d(o, s, a, l, c, d) {
	const f = resolveComponent("TreeNode"),
		m = resolveComponent("VirtualList");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [o.virtualListProps ? (openBlock(), createBlock(m, mergeProps({
		key: 0,
		ref: "virtualListRef"
	}, o.virtualListProps, {
		data: o.visibleTreeNodeList
	}), {
		item: withCtx(({
			item: g
		}) => [(openBlock(), createBlock(f, mergeProps({
			key: `${o.searchValue}-${g.key}`
		}, g.treeNodeProps), null, 16))]),
		_: 1
	}, 16, ["data"])) : (openBlock(!0), createElementBlock(Fragment, {
		key: 1
	}, renderList(o.visibleTreeNodeList, g => (openBlock(), createBlock(f, mergeProps({
		key: g.key,
		ref_for: !0
	}, g.treeNodeProps), null, 16))), 128))], 2)
}
var _Tree = _export_sfc$1(_sfc_main$u, [
	["render", _sfc_render$d]
]);
const Tree = Object.assign(_Tree, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Tree.name, _Tree)
		}
	}),
	_sfc_main$t = defineComponent({
		name: "Typography",
		setup() {
			return {
				classNames: [getPrefixCls("typography")]
			}
		}
	});

function _sfc_render$c(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("article", {
		class: normalizeClass(o.classNames)
	}, [renderSlot(o.$slots, "default")], 2)
}
var _Typography = _export_sfc$1(_sfc_main$t, [
	["render", _sfc_render$c]
]);
const _sfc_main$s = defineComponent({
	name: "TypographyEditContent",
	components: {
		Input
	},
	props: {
		text: {
			type: String,
			required: !0
		}
	},
	emits: ["change", "end", "update:text"],
	setup(o, {
		emit: s
	}) {
		const l = [`${getPrefixCls("typography")}-edit-content`],
			c = ref();

		function d(m) {
			s("update:text", m), s("change", m)
		}

		function f() {
			s("end")
		}
		return onMounted(() => {
			if (!c.value || !c.value.$el) return;
			const m = c.value.$el.querySelector("input");
			if (!m) return;
			m.focus && m.focus();
			const {
				length: g
			} = m.value;
			m.setSelectionRange(g, g)
		}), {
			classNames: l,
			inputRef: c,
			onBlur: f,
			onChange: d,
			onEnd: f
		}
	}
});

function _sfc_render$b(o, s, a, l, c, d) {
	const f = resolveComponent("Input");
	return openBlock(), createElementBlock("div", {
		class: normalizeClass(o.classNames)
	}, [createVNode(f, {
		ref: "inputRef",
		"auto-size": "",
		"model-value": o.text,
		onBlur: o.onBlur,
		onInput: o.onChange,
		onKeydown: withKeys(o.onEnd, ["enter"])
	}, null, 8, ["model-value", "onBlur", "onInput", "onKeydown"])], 2)
}
var EditContent = _export_sfc$1(_sfc_main$s, [
	["render", _sfc_render$b]
]);
const _sfc_main$r = defineComponent({
		name: "IconCopy",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-copy`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$9 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$a(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M20 6h18a2 2 0 0 1 2 2v22M8 16v24c0 1.105.891 2 1.996 2h20.007A1.99 1.99 0 0 0 32 40.008V15.997A1.997 1.997 0 0 0 30 14H10a2 2 0 0 0-2 2Z"
	}, null, -1)]), 14, _hoisted_1$9)
}
var _IconCopy = _export_sfc$1(_sfc_main$r, [
	["render", _sfc_render$a]
]);
const IconCopy = Object.assign(_IconCopy, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconCopy.name, _IconCopy)
		}
	}),
	_sfc_main$q = defineComponent({
		name: "IconEdit",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-edit`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$8 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$9(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "m30.48 19.038 5.733-5.734a1 1 0 0 0 0-1.414l-5.586-5.586a1 1 0 0 0-1.414 0l-5.734 5.734m7 7L15.763 33.754a1 1 0 0 1-.59.286l-6.048.708a1 1 0 0 1-1.113-1.069l.477-6.31a1 1 0 0 1 .29-.631l14.7-14.7m7 7-7-7M6 42h36"
	}, null, -1)]), 14, _hoisted_1$8)
}
var _IconEdit = _export_sfc$1(_sfc_main$q, [
	["render", _sfc_render$9]
]);
const IconEdit = Object.assign(_IconEdit, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconEdit.name, _IconEdit)
		}
	}),
	_sfc_main$p = defineComponent({
		name: "TypographyOperations",
		components: {
			Tooltip,
			IconCheckCircleFill,
			IconCopy,
			IconEdit
		},
		props: {
			editable: Boolean,
			copyable: Boolean,
			expandable: Boolean,
			isCopied: Boolean,
			isEllipsis: Boolean,
			expanded: Boolean,
			forceRenderExpand: Boolean,
			editTooltipProps: Object,
			copyTooltipProps: Object
		},
		emits: {
			edit: () => !0,
			copy: () => !0,
			expand: () => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("typography"),
				l = computed(() => o.forceRenderExpand || o.expandable && o.isEllipsis),
				{
					t: c
				} = useI18n();
			return {
				prefixCls: a,
				showExpand: l,
				t: c,
				onEditClick() {
					s("edit")
				},
				onCopyClick() {
					s("copy")
				},
				onExpandClick() {
					s("expand")
				}
			}
		}
	});

function _sfc_render$8(o, s, a, l, c, d) {
	const f = resolveComponent("IconEdit"),
		m = resolveComponent("Tooltip"),
		g = resolveComponent("IconCheckCircleFill"),
		v = resolveComponent("IconCopy");
	return openBlock(), createElementBlock(Fragment, null, [o.editable ? (openBlock(), createBlock(m, mergeProps({
		key: 0,
		content: o.t("typography.edit")
	}, o.editTooltipProps), {
		default: withCtx(() => [createBaseVNode("span", {
			class: normalizeClass(`${o.prefixCls}-operation-edit`),
			onClick: s[0] || (s[0] = withModifiers((...y) => o.onEditClick && o
				.onEditClick(...y), ["stop"]))
		}, [createVNode(f)], 2)]),
		_: 1
	}, 16, ["content"])) : createCommentVNode("v-if", !0), o.copyable ? (openBlock(), createBlock(m,
		normalizeProps(mergeProps({
			key: 1
		}, o.copyTooltipProps)), {
			content: withCtx(() => [renderSlot(o.$slots, "copy-tooltip", {
				copied: o.isCopied
			}, () => [createTextVNode(toDisplayString(o.isCopied ? o.t(
				"typography.copied") : o.t("typography.copy")), 1)])]),
			default: withCtx(() => [createBaseVNode("span", {
				class: normalizeClass({
					[`${o.prefixCls}-operation-copied`]: o.isCopied,
					[`${o.prefixCls}-operation-copy`]: !o.isCopied
				}),
				onClick: s[1] || (s[1] = withModifiers((...y) => o.onCopyClick && o
					.onCopyClick(...y), ["stop"]))
			}, [renderSlot(o.$slots, "copy-icon", {
				copied: o.isCopied
			}, () => [o.isCopied ? (openBlock(), createBlock(g, {
				key: 0
			})) : (openBlock(), createBlock(v, {
				key: 1
			}))])], 2)]),
			_: 3
		}, 16)) : createCommentVNode("v-if", !0), o.showExpand ? (openBlock(), createElementBlock("a", {
		key: 2,
		class: normalizeClass(`${o.prefixCls}-operation-expand`),
		onClick: s[2] || (s[2] = withModifiers((...y) => o.onExpandClick && o.onExpandClick(...y), [
			"stop"
		]))
	}, [renderSlot(o.$slots, "expand-node", {
		expanded: o.expanded
	}, () => [createTextVNode(toDisplayString(o.expanded ? o.t("typography.collapse") : o.t(
		"typography.expand")), 1)])], 2)) : createCommentVNode("v-if", !0)], 64)
}
var Operations = _export_sfc$1(_sfc_main$p, [
	["render", _sfc_render$8]
]);
let ellipsisContainer;

function styleToString$1(o) {
	return Array.prototype.slice.apply(o).map(a => `${a}: ${o.getPropertyValue(a)};`).join("")
}

function pxToNumber(o) {
	if (!o) return 0;
	const s = o.match(/^\d*(\.\d*)?/);
	return s ? Number(s[0]) : 0
}
var measure = (o, s, a, l) => {
	ellipsisContainer || (ellipsisContainer = document.createElement("div"), document.body.appendChild(
		ellipsisContainer));
	const {
		rows: c,
		suffix: d,
		ellipsisStr: f
	} = s, m = window.getComputedStyle(o), g = styleToString$1(m), v = pxToNumber(m.lineHeight), y = Math.round(v *
		c + pxToNumber(m.paddingTop) + pxToNumber(m.paddingBottom));
	ellipsisContainer.setAttribute("style", g), ellipsisContainer.setAttribute("aria-hidden", "true"),
		ellipsisContainer.style.height = "auto", ellipsisContainer.style.minHeight = "auto", ellipsisContainer.style
		.maxHeight = "auto", ellipsisContainer.style.position = "fixed", ellipsisContainer.style.left = "0",
		ellipsisContainer.style.top = "-99999999px", ellipsisContainer.style.zIndex = "-200", ellipsisContainer
		.style.whiteSpace = "normal";
	const b = createApp({
		render() {
			return createVNode("span", null, [a])
		}
	});
	b.mount(ellipsisContainer);
	const C = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].cloneNode(!0).childNodes);
	b.unmount(), ellipsisContainer.innerHTML = "";
	const _ = document.createTextNode(`${f}${d}`);
	ellipsisContainer.appendChild(_), C.forEach(A => {
		ellipsisContainer.appendChild(A)
	});
	const S = document.createTextNode(l);
	ellipsisContainer.insertBefore(S, _);

	function w() {
		return ellipsisContainer.offsetHeight <= y
	}
	if (w()) return {
		ellipsis: !1,
		text: l
	};

	function T(A, k = 0, M = l.length, D = 0) {
		const F = Math.floor((k + M) / 2),
			R = l.slice(0, F);
		if (A.textContent = R, k >= M - 1)
			for (let O = M; O >= k; O -= 1) {
				const U = l.slice(0, O);
				if (A.textContent = U, w() || !U) return
			}
		w() ? T(A, F, M, F) : T(A, k, F, D)
	}
	return T(S), {
		text: S.textContent,
		ellipsis: !0
	}
};
const clipboard = async o => {
	var s;
	if ((s = navigator.clipboard) != null && s.writeText) try {
		await navigator.clipboard.writeText(o);
		return
	} catch (d) {
		console.error(d ?? new DOMException("The request is not allowed", "NotAllowedError"))
	}
	const a = document.createElement("span");
	a.textContent = o, a.style.whiteSpace = "pre", document.body.appendChild(a);
	const l = window.getSelection(),
		c = window.document.createRange();
	l == null || l.removeAllRanges(), c.selectNode(a), l == null || l.addRange(c);
	try {
		window.document.execCommand("copy")
	} catch (d) {
		console.error(`execCommand Error: ${d}`)
	}
	l == null || l.removeAllRanges(), window.document.body.removeChild(a)
};
let container;

function getInnerText(o) {
	if (!o) return "";
	container || (container = document.createElement("div"), container.setAttribute("aria-hidden", "true"), document
		.body.appendChild(container));
	const s = createApp({
		render() {
			return createVNode("div", null, [o])
		}
	});
	s.mount(container);
	const a = container.innerText;
	return s.unmount(), a
}

function _isSlot$1(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}

function getComponentTags(o) {
	const {
		bold: s,
		mark: a,
		underline: l,
		delete: c,
		code: d
	} = o, f = [];
	return s && f.push("b"), l && f.push("u"), c && f.push("del"), d && f.push("code"), a && f.push("mark"), f
}

function Wrap(o, s) {
	const {
		mark: a
	} = o, l = getComponentTags(o), c = isObject$2(a) && a.color ? {
		backgroundColor: a.color
	} : {};
	return l.reduce((d, f) => createVNode(f, f === "mark" ? {
		style: c
	} : {}, _isSlot$1(d) ? d : {
		default: () => [d]
	}), s)
}

function normalizeEllipsisConfig(o) {
	const s = !!o.showTooltip,
		a = isObject$2(o.showTooltip) && o.showTooltip.type === "popover" ? Popover : Tooltip,
		l = isObject$2(o.showTooltip) && o.showTooltip.props || {};
	return {
		rows: 1,
		suffix: "",
		ellipsisStr: "...",
		expandable: !1,
		css: !1,
		...omit(o, ["showTooltip"]),
		showTooltip: s,
		TooltipComponent: a,
		tooltipProps: l
	}
}
var Base = defineComponent({
		name: "TypographyBase",
		inheritAttrs: !1,
		props: {
			component: {
				type: String,
				required: !0
			},
			type: {
				type: String
			},
			bold: {
				type: Boolean
			},
			mark: {
				type: [Boolean, Object],
				default: !1
			},
			underline: {
				type: Boolean
			},
			delete: {
				type: Boolean
			},
			code: {
				type: Boolean
			},
			disabled: {
				type: Boolean
			},
			editable: {
				type: Boolean
			},
			editing: {
				type: Boolean,
				default: void 0
			},
			defaultEditing: {
				type: Boolean
			},
			editText: {
				type: String
			},
			copyable: {
				type: Boolean
			},
			copyText: {
				type: String
			},
			copyDelay: {
				type: Number,
				default: 3e3
			},
			ellipsis: {
				type: [Boolean, Object],
				default: !1
			},
			editTooltipProps: {
				type: Object
			},
			copyTooltipProps: {
				type: Object
			}
		},
		emits: {
			editStart: () => !0,
			change: o => !0,
			"update:editText": o => !0,
			editEnd: () => !0,
			"update:editing": o => !0,
			copy: o => !0,
			ellipsis: o => !0,
			expand: o => !0
		},
		setup(o, {
			slots: s,
			emit: a,
			attrs: l
		}) {
			const {
				editing: c,
				defaultEditing: d,
				ellipsis: f,
				copyable: m,
				editable: g,
				copyText: v,
				editText: y,
				copyDelay: b,
				component: C
			} = toRefs(o), _ = getPrefixCls("typography"), S = computed(() => [_, {
				[`${_}-${o.type}`]: o.type,
				[`${_}-disabled`]: o.disabled
			}]), w = ref(), T = ref(""), [A, k] = useMergeState(d.value, reactive({
				value: c
			})), M = computed(() => g.value && A.value);

			function D() {
				a("update:editing", !0), a("editStart"), k(!0)
			}

			function F(be) {
				a("update:editText", be), a("change", be)
			}

			function R() {
				A.value && (a("update:editing", !1), a("editEnd"), k(!1))
			}
			const O = ref(!1);
			let U = null;

			function V() {
				var be;
				const Me = (be = v.value) != null ? be : T.value;
				clipboard(Me || ""), O.value = !0, a("copy", Me), U = setTimeout(() => {
					O.value = !1
				}, b.value)
			}
			onUnmounted(() => {
				U && clearTimeout(U), U = null
			});
			const z = ref(!1),
				j = ref(!1),
				ge = ref(""),
				me = computed(() => normalizeEllipsisConfig(isObject$2(f.value) && f.value || {}));
			let he = null;

			function ce() {
				const be = !j.value;
				j.value = be, a("expand", be)
			}

			function ae(be = !1) {
				return me.value.css ? createVNode(Operations, {
					editable: g.value,
					copyable: m.value,
					expandable: me.value.expandable,
					isCopied: O.value,
					isEllipsis: ke.value,
					expanded: j.value,
					forceRenderExpand: be || j.value,
					editTooltipProps: o.editTooltipProps,
					copyTooltipProps: o.copyTooltipProps,
					onEdit: D,
					onCopy: V,
					onExpand: ce
				}, {
					"copy-tooltip": s["copy-tooltip"],
					"copy-icon": s["copy-icon"],
					"expand-node": s["expand-node"]
				}) : createVNode(Operations, {
					editable: g.value,
					copyable: m.value,
					expandable: me.value.expandable,
					isCopied: O.value,
					isEllipsis: z.value,
					expanded: j.value,
					forceRenderExpand: be,
					editTooltipProps: o.editTooltipProps,
					copyTooltipProps: o.copyTooltipProps,
					onEdit: D,
					onCopy: V,
					onExpand: ce
				}, {
					"copy-tooltip": s["copy-tooltip"],
					"copy-icon": s["copy-icon"],
					"expand-node": s["expand-node"]
				})
			}

			function fe() {
				if (!w.value) return;
				const {
					ellipsis: be,
					text: Me
				} = measure(w.value, me.value, ae(!!me.value.expandable), T.value);
				z.value !== be && (z.value = be, me.value.css || a("ellipsis", be)), ge.value !== Me && (ge.value =
					Me || "")
			}

			function q() {
				f.value && !j.value && (caf(he), he = raf(() => {
					fe()
				}))
			}
			onUnmounted(() => {
				caf(he)
			}), watch(() => me.value.rows, () => {
				q()
			}), watch(f, be => {
				be ? q() : z.value = !1
			});
			let le = [];
			const de = () => {
				if (f.value || m.value || g.value) {
					const be = getInnerText(le);
					be !== T.value && (T.value = be, q())
				}
			};
			onMounted(de), onUpdated(de);
			const _e = ref(),
				ke = ref(!1),
				De = () => {
					if (w.value && _e.value) {
						const be = _e.value.offsetHeight > w.value.offsetHeight;
						be !== ke.value && (ke.value = be, a("ellipsis", be))
					}
				},
				Se = computed(() => j.value ? {} : {
					overflow: "hidden",
					"text-overflow": "ellipsis",
					display: "-webkit-box",
					"-webkit-line-clamp": me.value.rows,
					"-webkit-box-orient": "vertical"
				});
			return () => {
				var be, Me;
				if (le = ((be = s.default) == null ? void 0 : be.call(s)) || [], M.value) {
					const Ue = (Me = y.value) != null ? Me : T.value;
					return createVNode(EditContent, {
						text: Ue,
						onChange: nt => {
							nt !== Ue && F(nt)
						},
						onEnd: R
					}, null)
				}
				const {
					suffix: Ve,
					ellipsisStr: it,
					showTooltip: pt,
					tooltipProps: dt,
					TooltipComponent: He
				} = me.value, Ae = z.value && !j.value, xe = Ae && !pt ? {
					title: T.value
				} : {}, ye = C.value;
				if (me.value.css) {
					const Ue = Wrap(o, le),
						nt = createVNode(ye, mergeProps({
							class: S.value,
							ref: w,
							style: Se.value
						}, xe, l), {
							default: () => [createVNode("span", {
								ref: _e
							}, [Ue])]
						});
					return ke.value ? createVNode(He, mergeProps(dt, {
						onResize: () => De()
					}), {
						default: () => [nt],
						content: () => T.value
					}) : createVNode(ResizeObserver$2, {
						onResize: () => {
							De()
						}
					}, _isSlot$1(nt) ? nt : {
						default: () => [nt]
					})
				}
				const Le = Wrap(o, Ae ? ge.value : le);
				return createVNode(ResizeObserver$2, {
					onResize: () => q()
				}, {
					default: () => [createVNode(ye, mergeProps({
						class: S.value,
						ref: w
					}, xe, l), {
						default: () => [Ae && pt ? createVNode(He, dt, {
							default: () => [createVNode("span", null, [Le])],
							content: () => T.value
						}) : Le, Ae ? it : null, Ve, ae()]
					})]
				})
			}
		}
	}),
	TypographyParagraph = defineComponent({
		name: "TypographyParagraph",
		inheritAttrs: !1,
		props: {
			blockquote: {
				type: Boolean
			},
			spacing: {
				type: String,
				default: "default"
			}
		},
		setup(o) {
			const {
				blockquote: s,
				spacing: a
			} = toRefs(o), l = getPrefixCls("typography"), c = computed(() => s != null && s.value ? "blockquote" :
				"div"), d = computed(() => [{
				[`${l}-spacing-close`]: (a == null ? void 0 : a.value) === "close"
			}]);
			return {
				component: c,
				classNames: d
			}
		},
		render() {
			const {
				component: o,
				classNames: s
			} = this;
			return createVNode(Base, mergeProps({
				class: s
			}, this.$attrs, {
				component: o
			}), this.$slots)
		}
	}),
	TypographyTitle = defineComponent({
		name: "TypographyTitle",
		inheritAttrs: !1,
		props: {
			heading: {
				type: Number,
				default: 1
			}
		},
		setup(o) {
			const {
				heading: s
			} = toRefs(o);
			return {
				component: computed(() => `h${s==null?void 0:s.value}`)
			}
		},
		render() {
			const {
				component: o
			} = this;
			return createVNode(Base, mergeProps(this.$attrs, {
				component: o
			}), this.$slots)
		}
	}),
	TypographyText = defineComponent({
		name: "TypographyText",
		inheritAttrs: !1,
		props: {
			ellipsis: {
				type: [Boolean, Object],
				default: !1
			}
		},
		setup(o) {
			const {
				ellipsis: s
			} = toRefs(o);
			return {
				component: computed(() => s != null && s.value ? "div" : "span")
			}
		},
		render() {
			const {
				ellipsis: o,
				component: s
			} = this;
			return createVNode(Base, mergeProps(this.$attrs, {
				ellipsis: o,
				component: s
			}), this.$slots)
		}
	});
const Typography = Object.assign(_Typography, {
		Paragraph: TypographyParagraph,
		Title: TypographyTitle,
		Text: TypographyText,
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _Typography.name, _Typography), o.component(a + TypographyParagraph.name,
				TypographyParagraph), o.component(a + TypographyTitle.name, TypographyTitle), o.component(
				a + TypographyText.name, TypographyText)
		}
	}),
	getResponse = o => {
		const s = o.responseText || o.response;
		if (!s) return;
		const a = o.getResponseHeader("Content-Type");
		if (a && a.includes("json")) try {
			return JSON.parse(s)
		} catch {
			return s
		}
		return s
	},
	getProgressStatus = o => {
		switch (o) {
			case "done":
				return "success";
			case "error":
				return "danger";
			default:
				return "normal"
		}
	},
	getValue = (o, s) => isFunction$2(o) ? o(s) : o,
	uploadRequest = ({
		fileItem: o,
		action: s,
		name: a,
		data: l,
		headers: c = {},
		withCredentials: d = !1,
		onProgress: f = NOOP,
		onSuccess: m = NOOP,
		onError: g = NOOP
	}) => {
		const v = getValue(a, o) || "file",
			y = getValue(l, o),
			b = new XMLHttpRequest;
		d && (b.withCredentials = !0), b.upload.onprogress = _ => {
			const S = _.total > 0 ? index.round(_.loaded / _.total, 2) : 0;
			f(S, _)
		}, b.onerror = function(S) {
			g(S)
		}, b.onload = () => {
			if (b.status < 200 || b.status >= 300) {
				g(getResponse(b));
				return
			}
			m(getResponse(b))
		};
		const C = new FormData;
		if (y)
			for (const _ of Object.keys(y)) C.append(_, y[_]);
		o.file && C.append(v, o.file), b.open("post", s ?? "", !0);
		for (const _ of Object.keys(c)) b.setRequestHeader(_, c[_]);
		return b.send(C), {
			abort() {
				b.abort()
			}
		}
	},
	isAcceptFile = (o, s) => {
		if (s && o) {
			const a = isArray$2(s) ? s : s.split(",").map(c => c.trim()).filter(c => c),
				l = (o.name.indexOf(".") > -1 ? `.${o.name.split(".").pop()}` : "").toLowerCase();
			return a.some(c => {
				const d = c && c.toLowerCase(),
					f = (o.type || "").toLowerCase(),
					m = f.split("/")[0];
				if (d === f || `${m}${l.replace(".","/")}` === d || /^\*(\/\*)?$/.test(d)) return !0;
				if (/\/\*/.test(d)) return f.replace(/\/.*$/, "") === d.replace(/\/.*$/, "");
				if (/\..*/.test(d)) {
					let g = [d];
					return (d === ".jpg" || d === ".jpeg") && (g = [".jpg", ".jpeg"]), g.indexOf(l) > -1
				}
				return !1
			})
		}
		return !!o
	},
	loopDirectory = (o, s, a) => {
		const l = [];
		let c = 0;
		const d = () => {
				!c && a(l)
			},
			f = m => {
				if (c += 1, m != null && m.isFile) {
					m.file(g => {
						c -= 1, isAcceptFile(g, s) && (Object.defineProperty(g, "webkitRelativePath", {
							value: m.fullPath.replace(/^\//, "")
						}), l.push(g)), d()
					});
					return
				}
				if (m != null && m.isDirectory) {
					const g = m.createReader();
					let v = !1;
					const y = () => {
						g.readEntries(b => {
							v || (c -= 1, v = !0), b.length === 0 ? d() : (y(), b.forEach(f))
						})
					};
					y();
					return
				}
				c -= 1, d()
			};
		[].slice.call(o).forEach(m => m.webkitGetAsEntry && f(m.webkitGetAsEntry()))
	},
	isImage = o => {
		var s;
		return (s = o.type) == null ? void 0 : s.includes("image")
	},
	getFiles = (o, s) => {
		if (!o) return [];
		const a = Array.from(o);
		return s ? a.filter(l => isAcceptFile(l, s)) : a
	},
	_sfc_main$o = defineComponent({
		name: "IconUpload",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-upload`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$7 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$7(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M14.93 17.071 24.001 8l9.071 9.071m-9.07 16.071v-25M40 35v6H8v-6"
	}, null, -1)]), 14, _hoisted_1$7)
}
var _IconUpload = _export_sfc$1(_sfc_main$o, [
	["render", _sfc_render$7]
]);
const IconUpload = Object.assign(_IconUpload, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconUpload.name, _IconUpload)
	}
});
var UploadButton = defineComponent({
	name: "UploadButton",
	props: {
		disabled: {
			type: Boolean,
			default: !1
		},
		directory: {
			type: Boolean,
			default: !1
		},
		accept: String,
		listType: {
			type: String
		},
		tip: String,
		draggable: {
			type: Boolean,
			default: !1
		},
		multiple: {
			type: Boolean,
			default: !1
		},
		uploadFiles: {
			type: Function,
			required: !0
		},
		hide: Boolean,
		onButtonClick: {
			type: Function
		}
	},
	setup(o, {
		slots: s
	}) {
		const a = getPrefixCls("upload"),
			{
				t: l
			} = useI18n(),
			c = ref(!1),
			d = ref(null),
			f = ref(null),
			m = ref(0),
			g = T => {
				T === "subtract" ? m.value -= 1 : T === "add" ? m.value += 1 : T === "reset" && (m.value = 0)
			},
			v = T => {
				if (!o.disabled) {
					if (isFunction$2(o.onButtonClick)) {
						const A = o.onButtonClick(T);
						if (isPromise(A)) {
							A.then(k => {
								o.uploadFiles(getFiles(k))
							});
							return
						}
					}
					d.value && d.value.click()
				}
			},
			y = T => {
				const A = T.target;
				A.files && o.uploadFiles(getFiles(A.files)), A.value = ""
			},
			b = T => {
				var A, k;
				if (T.preventDefault(), c.value = !1, g("reset"), !o.disabled)
					if (o.directory && ((A = T.dataTransfer) != null && A.items)) loopDirectory(T.dataTransfer
						.items, o.accept, M => {
							o.uploadFiles(M)
						});
					else {
						const M = getFiles((k = T.dataTransfer) == null ? void 0 : k.files, o.accept);
						o.uploadFiles(o.multiple ? M : M.slice(0, 1))
					}
			},
			C = T => {
				T.preventDefault(), g("subtract"), m.value === 0 && (c.value = !1, g("reset"))
			},
			_ = T => {
				T.preventDefault(), !o.disabled && !c.value && (c.value = !0)
			},
			S = () => s.default ? createVNode("span", null, [s.default()]) : o.listType === "picture-card" ?
			createVNode("div", {
				class: `${a}-picture-card`
			}, [createVNode("div", {
				class: `${a}-picture-card-text`
			}, [createVNode(IconPlus, null, null)]), o.tip && createVNode("div", {
				class: `${a}-tip`
			}, [o.tip])]) : o.draggable ? createVNode("div", {
				class: [`${a}-drag`, {
					[`${a}-drag-active`]: c.value
				}]
			}, [createVNode("div", null, [createVNode(IconPlus, null, null)]), createVNode("div", {
				class: `${a}-drag-text`
			}, [c.value ? l("upload.dragHover") : l("upload.drag")]), o.tip && createVNode("div", {
				class: `${a}-tip`
			}, [o.tip])]) : createVNode(Button, {
				type: "primary",
				disabled: o.disabled
			}, {
				default: () => [l("upload.buttonText")],
				icon: () => createVNode(IconUpload, null, null)
			}),
			w = computed(() => [a, {
				[`${a}-type-picture-card`]: o.listType === "picture-card",
				[`${a}-draggable`]: o.draggable,
				[`${a}-disabled`]: o.disabled,
				[`${a}-hide`]: o.hide
			}]);
		return () => createVNode("span", {
			ref: f,
			class: w.value,
			onClick: v,
			onDragenter: () => {
				g("add")
			},
			onDrop: b,
			onDragover: _,
			onDragleave: C
		}, [createVNode("input", mergeProps({
			ref: d,
			type: "file",
			style: {
				display: "none"
			},
			disabled: o.disabled,
			accept: o.accept,
			multiple: o.multiple
		}, o.directory ? {
			webkitdirectory: "webkitdirectory"
		} : {}, {
			onChange: y
		}), null), S()])
	}
});
const _sfc_main$n = defineComponent({
		name: "IconPause",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-pause`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$6 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$6(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M14 12h4v24h-4zM30 12h4v24h-4z"
	}, null, -1), createBaseVNode("path", {
		fill: "currentColor",
		stroke: "none",
		d: "M14 12h4v24h-4zM30 12h4v24h-4z"
	}, null, -1)]), 14, _hoisted_1$6)
}
var _IconPause = _export_sfc$1(_sfc_main$n, [
	["render", _sfc_render$6]
]);
const IconPause = Object.assign(_IconPause, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconPause.name, _IconPause)
		}
	}),
	_sfc_main$m = defineComponent({
		name: "IconPlayArrowFill",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-play-arrow-fill`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$5 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$5(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M17.533 10.974a1 1 0 0 0-1.537.844v24.356a1 1 0 0 0 1.537.844L36.67 24.84a1 1 0 0 0 0-1.688L17.533 10.974Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1)]), 14, _hoisted_1$5)
}
var _IconPlayArrowFill = _export_sfc$1(_sfc_main$m, [
	["render", _sfc_render$5]
]);
const IconPlayArrowFill = Object.assign(_IconPlayArrowFill, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconPlayArrowFill.name, _IconPlayArrowFill)
		}
	}),
	uploadInjectionKey = Symbol("ArcoUpload");
var UploadProgress = defineComponent({
	name: "UploadProgress",
	props: {
		file: {
			type: Object,
			required: !0
		},
		listType: {
			type: String,
			required: !0
		}
	},
	setup(o) {
		const s = getPrefixCls("upload-progress"),
			{
				t: a
			} = useI18n(),
			l = inject(uploadInjectionKey, void 0),
			c = () => {
				var f, m, g, v, y, b, C, _, S, w, T;
				return o.file.status === "error" ? createVNode("span", {
					class: [l == null ? void 0 : l.iconCls, `${l==null?void 0:l.iconCls}-upload`],
					onClick: () => l == null ? void 0 : l.onUpload(o.file)
				}, [l != null && l.showRetryButton && ((y = (m = l == null ? void 0 : (f = l.slots)[
							"retry-icon"]) == null ? void 0 : m.call(f)) != null ? y : (v = (g = l ==
							null ? void 0 : l.customIcon) == null ? void 0 : g.retryIcon) != null && v
						.call(g)) || o.listType === "picture-card" ? createVNode(IconUpload, null,
					null) : a("upload.retry")
				]) : o.file.status === "done" ? createVNode("span", {
					class: [l == null ? void 0 : l.iconCls, `${l==null?void 0:l.iconCls}-success`]
				}, [(T = (w = (C = l == null ? void 0 : (b = l.slots)["success-icon"]) == null ?
						void 0 : C.call(b)) != null ? w : (S = (_ = l == null ? void 0 : l
						.customIcon) == null ? void 0 : _.successIcon) == null ? void 0 : S.call(_)) !=
					null ? T : createVNode(IconCheck, null, null)
				]) : o.file.status === "init" ? createVNode(Tooltip, {
					content: a("upload.start")
				}, {
					default: () => {
						var A, k, M, D, F, R;
						return [createVNode("span", {
							class: [l == null ? void 0 : l.iconCls,
								`${l==null?void 0:l.iconCls}-start`
							],
							onClick: () => l == null ? void 0 : l.onUpload(o.file)
						}, [(R = (F = (k = l == null ? void 0 : (A = l.slots)[
								"start-icon"]) == null ? void 0 : k.call(A)) !=
							null ? F : (D = (M = l == null ? void 0 : l
								.customIcon) == null ? void 0 : M.startIcon) ==
							null ? void 0 : D.call(M)) != null ? R : createVNode(
							IconPlayArrowFill, null, null)])]
					}
				}) : (l == null ? void 0 : l.showCancelButton) && createVNode(Tooltip, {
					content: a("upload.cancel")
				}, {
					default: () => {
						var A, k, M, D, F, R;
						return [createVNode("span", {
							class: [l == null ? void 0 : l.iconCls,
								`${l==null?void 0:l.iconCls}-cancel`
							],
							onClick: () => l == null ? void 0 : l.onAbort(o.file)
						}, [(R = (F = (k = l == null ? void 0 : (A = l.slots)[
								"cancel-icon"]) == null ? void 0 : k.call(A)) !=
							null ? F : (D = (M = l == null ? void 0 : l
								.customIcon) == null ? void 0 : M.cancelIcon) ==
							null ? void 0 : D.call(M)) != null ? R : createVNode(
							IconPause, null, null)])]
					}
				})
			},
			d = () => {
				var f;
				if (["init", "uploading"].includes((f = o.file.status) != null ? f : "")) {
					const m = getProgressStatus(o.file.status);
					return createVNode(Progress, {
						type: "circle",
						size: "mini",
						showText: !1,
						status: m,
						percent: o.file.percent
					}, null)
				}
				return null
			};
		return () => createVNode("span", {
			class: s
		}, [d(), c()])
	}
});
const _sfc_main$l = defineComponent({
		name: "IconFilePdf",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-file-pdf`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$4 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$4(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M11 42h26a2 2 0 0 0 2-2V13.828a2 2 0 0 0-.586-1.414l-5.828-5.828A2 2 0 0 0 31.172 6H11a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2Z"
	}, null, -1), createBaseVNode("path", {
		d: "M22.305 21.028c.874 1.939 3.506 6.265 4.903 8.055 1.747 2.237 3.494 2.685 4.368 2.237.873-.447 1.21-4.548-7.425-2.685-7.523 1.623-7.424 3.58-6.988 4.476.728 1.193 2.522 2.627 5.678-6.266C25.699 18.79 24.489 17 23.277 17c-1.409 0-2.538.805-.972 4.028Z"
	}, null, -1)]), 14, _hoisted_1$4)
}
var _IconFilePdf = _export_sfc$1(_sfc_main$l, [
	["render", _sfc_render$4]
]);
const IconFilePdf = Object.assign(_IconFilePdf, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconFilePdf.name, _IconFilePdf)
		}
	}),
	_sfc_main$k = defineComponent({
		name: "IconFileImage",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-file-image`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$3 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$3(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "m26 33 5-6v6h-5Zm0 0-3-4-4 4h7Zm11 9H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2ZM17 19h1v1h-1v-1Z"
	}, null, -1)]), 14, _hoisted_1$3)
}
var _IconFileImage = _export_sfc$1(_sfc_main$k, [
	["render", _sfc_render$3]
]);
const IconFileImage = Object.assign(_IconFileImage, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconFileImage.name, _IconFileImage)
		}
	}),
	_sfc_main$j = defineComponent({
		name: "IconFileVideo",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-file-video`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$2 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$2(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z"
	}, null, -1), createBaseVNode("path", {
		d: "M22 27.796v-6l5 3-5 3Z"
	}, null, -1)]), 14, _hoisted_1$2)
}
var _IconFileVideo = _export_sfc$1(_sfc_main$j, [
	["render", _sfc_render$2]
]);
const IconFileVideo = Object.assign(_IconFileVideo, {
		install: (o, s) => {
			var a;
			const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
			o.component(l + _IconFileVideo.name, _IconFileVideo)
		}
	}),
	_sfc_main$i = defineComponent({
		name: "IconFileAudio",
		props: {
			size: {
				type: [Number, String]
			},
			strokeWidth: {
				type: Number,
				default: 4
			},
			strokeLinecap: {
				type: String,
				default: "butt",
				validator: o => ["butt", "round", "square"].includes(o)
			},
			strokeLinejoin: {
				type: String,
				default: "miter",
				validator: o => ["arcs", "bevel", "miter", "miter-clip", "round"].includes(o)
			},
			rotate: Number,
			spin: Boolean
		},
		emits: {
			click: o => !0
		},
		setup(o, {
			emit: s
		}) {
			const a = getPrefixCls("icon"),
				l = computed(() => [a, `${a}-file-audio`, {
					[`${a}-spin`]: o.spin
				}]),
				c = computed(() => {
					const f = {};
					return o.size && (f.fontSize = isNumber$2(o.size) ? `${o.size}px` : o.size), o.rotate && (f
						.transform = `rotate(${o.rotate}deg)`), f
				});
			return {
				cls: l,
				innerStyle: c,
				onClick: f => {
					s("click", f)
				}
			}
		}
	}),
	_hoisted_1$1 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];

function _sfc_render$1(o, s, a, l, c, d) {
	return openBlock(), createElementBlock("svg", {
		viewBox: "0 0 48 48",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		stroke: "currentColor",
		class: normalizeClass(o.cls),
		style: normalizeStyle(o.innerStyle),
		"stroke-width": o.strokeWidth,
		"stroke-linecap": o.strokeLinecap,
		"stroke-linejoin": o.strokeLinejoin,
		onClick: s[0] || (s[0] = (...f) => o.onClick && o.onClick(...f))
	}, s[1] || (s[1] = [createBaseVNode("path", {
		d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z"
	}, null, -1), createBaseVNode("path", {
		d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z",
		fill: "currentColor",
		stroke: "none"
	}, null, -1), createBaseVNode("path", {
		d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm0 0-.951-12.363a.5.5 0 0 1 .58-.532L30 18"
	}, null, -1)]), 14, _hoisted_1$1)
}
var _IconFileAudio = _export_sfc$1(_sfc_main$i, [
	["render", _sfc_render$1]
]);
const IconFileAudio = Object.assign(_IconFileAudio, {
	install: (o, s) => {
		var a;
		const l = (a = s == null ? void 0 : s.iconPrefix) != null ? a : "";
		o.component(l + _IconFileAudio.name, _IconFileAudio)
	}
});
var UploadListItem = defineComponent({
		name: "UploadListItem",
		props: {
			file: {
				type: Object,
				required: !0
			},
			listType: {
				type: String,
				required: !0
			}
		},
		setup(o) {
			const a = `${getPrefixCls("upload-list")}-item`,
				{
					t: l
				} = useI18n(),
				c = inject(uploadInjectionKey, void 0),
				d = () => {
					var f, m;
					let g = "";
					if (o.file.file && o.file.file.type) g = o.file.file.type;
					else {
						const v = (m = (f = o.file.name) == null ? void 0 : f.split(".")[1]) != null ? m : "";
						["png", "jpg", "jpeg", "bmp", "gif", "webp"].includes(v) ? g = "image" : ["mp4", "m2v",
								"mkv", "m4v", "mov"
							].includes(v) ? g = "video" : ["mp3", "wav", "wmv", "m4a", "acc", "flac"].includes(v) &&
							(g = "audio")
					}
					return g.includes("image") ? createVNode(IconFileImage, null, null) : g.includes("pdf") ?
						createVNode(IconFilePdf, null, null) : g.includes("audio") ? createVNode(IconFileAudio,
							null, null) : g.includes("video") ? createVNode(IconFileVideo, null, null) :
						createVNode(IconFile, null, null)
				};
			return () => {
				var f, m, g, v, y, b, C, _, S, w, T, A, k, M, D, F, R, O, U, V, z, j, ge;
				return createVNode("div", {
					class: [a, `${a}-${o.file.status}`]
				}, [createVNode("div", {
						class: `${a}-content`
					}, [(c == null ? void 0 : c.listType) === "picture" && createVNode("span", {
						class: `${a}-thumbnail`
					}, [(g = (m = c == null ? void 0 : (f = c.slots).image) == null ?
						void 0 : m.call(f, {
							fileItem: o.file
						})) != null ? g : createVNode("img", mergeProps({
						src: o.file.url,
						alt: o.file.name
					}, c != null && c.imageLoading ? {
						loading: c.imageLoading
					} : void 0), null)]), createVNode("div", {
						class: `${a}-name`
					}, [(c == null ? void 0 : c.listType) === "text" && createVNode(
						"span", {
							class: `${a}-file-icon`
						}, [(S = (_ = (y = c == null ? void 0 : (v = c.slots)[
								"file-icon"]) == null ? void 0 : y.call(v, {
								fileItem: o.file
							})) != null ? _ : (C = (b = c == null ? void 0 : c
								.customIcon) == null ? void 0 : b.fileIcon) ==
							null ? void 0 : C.call(b, o.file)) != null ? S : d()]), c !=
						null && c.showLink && o.file.url ? createVNode("a", mergeProps({
							class: `${a}-name-link`,
							target: "_blank",
							href: o.file.url
						}, c != null && c.download ? {
							download: o.file.name
						} : void 0), [(D = (M = (T = c == null ? void 0 : (w = c.slots)[
									"file-name"]) == null ? void 0 : T.call(w, {
									fileItem: o.file
								})) != null ? M : (k = (A = c == null ? void 0 : c
									.customIcon) == null ? void 0 : A.fileName) ==
								null ? void 0 : k.call(A, o.file)) != null ? D : o.file
							.name
						]) : createVNode("span", {
							class: `${a}-name-text`,
							onClick: () => c == null ? void 0 : c.onPreview(o.file)
						}, [(z = (V = (R = c == null ? void 0 : (F = c.slots)[
									"file-name"]) == null ? void 0 : R.call(F, {
									fileItem: o.file
								})) != null ? V : (U = (O = c == null ? void 0 : c
									.customIcon) == null ? void 0 : O.fileName) ==
								null ? void 0 : U.call(O, o.file)) != null ? z : o.file
							.name
						]), o.file.status === "error" && createVNode(Tooltip, {
							content: l("upload.error")
						}, {
							default: () => {
								var me, he, ce, ae, fe, q;
								return [createVNode("span", {
									class: [c == null ? void 0 : c
										.iconCls,
										`${c==null?void 0:c.iconCls}-error`
									]
								}, [(q = (fe = (he = c == null ?
												void 0 : (me = c.slots)[
													"error-icon"]) ==
											null ? void 0 : he.call(me)
											) != null ? fe : (ae = (ce =
												c == null ? void 0 : c
												.customIcon) == null ?
											void 0 : ce.errorIcon) ==
										null ? void 0 : ae.call(ce)) !=
									null ? q : createVNode(
										IconExclamationCircleFill, null,
										null)
								])]
							}
						})
					]), createVNode(UploadProgress, {
						file: o.file,
						listType: o.listType
					}, null)]), (c == null ? void 0 : c.showRemoveButton) && createVNode("span", {
						class: `${a}-operation`
					}, [createVNode(IconHover, {
						onClick: () => {
							var me;
							return (me = c == null ? void 0 : c.onRemove) == null ?
								void 0 : me.call(c, o.file)
						}
					}, {
						default: () => {
							var me, he, ce, ae, fe, q;
							return [createVNode("span", {
								class: [c == null ? void 0 : c.iconCls,
									`${c==null?void 0:c.iconCls}-remove`
								]
							}, [(q = (fe = (he = c == null ? void 0 : (me =
											c.slots)["remove-icon"]) ==
										null ? void 0 : he.call(me)) !=
									null ? fe : (ae = (ce = c == null ?
											void 0 : c.customIcon) == null ?
										void 0 : ce.removeIcon) == null ?
									void 0 : ae.call(ce)) != null ? q :
								createVNode(IconDelete, null, null)
							])]
						}
					})]), (ge = c == null ? void 0 : (j = c.slots)["extra-button"]) == null ? void 0 :
					ge.call(j, {
						fileItem: o.file
					})
				])
			}
		}
	}),
	UploadPictureItem = defineComponent({
		name: "UploadPictureItem",
		props: {
			file: {
				type: Object,
				required: !0
			},
			disabled: {
				type: Boolean,
				default: !1
			}
		},
		setup(o) {
			const a = `${getPrefixCls("upload-list")}-picture`,
				l = computed(() => [a, {
					[`${a}-status-error`]: o.file.status === "error"
				}]),
				c = inject(uploadInjectionKey, void 0),
				d = () => {
					var f, m, g, v, y, b, C, _, S, w, T, A, k, M, D, F, R, O, U, V, z, j, ge, me, he, ce, ae, fe, q;
					return o.file.status === "uploading" ? createVNode(UploadProgress, {
						file: o.file,
						listType: "picture-card"
					}, null) : createVNode(Fragment, null, [(g = (m = c == null ? void 0 : (f = c.slots)
						.image) == null ? void 0 : m.call(f, {
							fileItem: o.file
						})) != null ? g : createVNode("img", mergeProps({
						src: o.file.url,
						alt: o.file.name
					}, c != null && c.imageLoading ? {
						loading: c.imageLoading
					} : void 0), null), createVNode("div", {
						class: `${a}-mask`
					}, [o.file.status === "error" && (c == null ? void 0 : c.showCancelButton) &&
						createVNode("div", {
							class: `${a}-error-tip`
						}, [createVNode("span", {
							class: [c == null ? void 0 : c.iconCls,
								`${c==null?void 0:c.iconCls}-error`
							]
						}, [(S = (_ = (y = c == null ? void 0 : (v = c.slots)[
								"error-icon"]) == null ? void 0 : y.call(v)) !=
							null ? _ : (C = (b = c == null ? void 0 : c
								.customIcon) == null ? void 0 : b.errorIcon) ==
							null ? void 0 : C.call(b)) != null ? S : createVNode(
							IconImageClose, null, null)])]), createVNode("div", {
							class: `${a}-operation`
						}, [o.file.status !== "error" && (c == null ? void 0 : c
								.showPreviewButton) && createVNode("span", {
								class: [c == null ? void 0 : c.iconCls,
									`${c==null?void 0:c.iconCls}-preview`
								],
								onClick: () => c == null ? void 0 : c.onPreview(o.file)
							}, [(D = (M = (T = c == null ? void 0 : (w = c.slots)[
									"preview-icon"]) == null ? void 0 : T.call(w)) !=
								null ? M : (k = (A = c == null ? void 0 : c
									.customIcon) == null ? void 0 : A.previewIcon) ==
								null ? void 0 : k.call(A)) != null ? D : createVNode(
								IconEye, null, null)]), ["init", "error"].includes(o.file
								.status) && (c == null ? void 0 : c.showRetryButton) &&
							createVNode("span", {
								class: [c == null ? void 0 : c.iconCls,
									`${c==null?void 0:c.iconCls}-upload`
								],
								onClick: () => c == null ? void 0 : c.onUpload(o.file)
							}, [(z = (V = (R = c == null ? void 0 : (F = c.slots)[
									"retry-icon"]) == null ? void 0 : R.call(F)) !=
								null ? V : (U = (O = c == null ? void 0 : c
									.customIcon) == null ? void 0 : O.retryIcon) ==
								null ? void 0 : U.call(O)) != null ? z : createVNode(
								IconUpload, null, null)]), !(c != null && c.disabled) && (c ==
								null ? void 0 : c.showRemoveButton) && createVNode("span", {
								class: [c == null ? void 0 : c.iconCls,
									`${c==null?void 0:c.iconCls}-remove`
								],
								onClick: () => c == null ? void 0 : c.onRemove(o.file)
							}, [(ae = (ce = (ge = c == null ? void 0 : (j = c.slots)[
									"remove-icon"]) == null ? void 0 : ge.call(j)) !=
								null ? ce : (he = (me = c == null ? void 0 : c
									.customIcon) == null ? void 0 : me.removeIcon) ==
								null ? void 0 : he.call(me)) != null ? ae : createVNode(
								IconDelete, null, null)]), (q = c == null ? void 0 : (fe = c
								.slots)["extra-button"]) == null ? void 0 : q.call(fe, o.file)
						])
					])])
				};
			return () => createVNode("span", {
				class: l.value
			}, [d()])
		}
	}),
	UploadList = defineComponent({
		name: "UploadList",
		components: {
			UploadListItem,
			UploadPictureItem
		},
		props: {
			fileList: {
				type: Array,
				required: !0
			},
			listType: {
				type: String,
				required: !0
			}
		},
		setup(o, {
			slots: s
		}) {
			const a = getPrefixCls("upload"),
				l = computed(() => [`${a}-list`, `${a}-list-type-${o.listType}`]),
				c = (d, f) => isFunction$2(s["upload-item"]) ? s["upload-item"]({
					fileItem: d,
					index: f
				}) : o.listType === "picture-card" ? createVNode(UploadPictureItem, {
					file: d,
					key: `item-${f}`
				}, null) : createVNode(UploadListItem, {
					file: d,
					listType: o.listType,
					key: `item-${f}`
				}, null);
			return () => createVNode(TransitionGroup, {
				tag: "div",
				class: l.value
			}, {
				default: () => {
					var d;
					return [...o.fileList.map((f, m) => c(f, m)), o.listType === "picture-card" && ((d =
						s["upload-button"]) == null ? void 0 : d.call(s))]
				}
			})
		}
	}),
	_Upload = defineComponent({
		name: "Upload",
		props: {
			fileList: {
				type: Array,
				default: void 0
			},
			defaultFileList: {
				type: Array,
				default: () => []
			},
			accept: String,
			action: String,
			disabled: {
				type: Boolean,
				default: !1
			},
			multiple: {
				type: Boolean,
				default: !1
			},
			directory: {
				type: Boolean,
				default: !1
			},
			draggable: {
				type: Boolean,
				default: !1
			},
			tip: String,
			headers: {
				type: Object
			},
			data: {
				type: [Object, Function]
			},
			name: {
				type: [String, Function]
			},
			withCredentials: {
				type: Boolean,
				default: !1
			},
			customRequest: {
				type: Function
			},
			limit: {
				type: Number,
				default: 0
			},
			autoUpload: {
				type: Boolean,
				default: !0
			},
			showFileList: {
				type: Boolean,
				default: !0
			},
			showRemoveButton: {
				type: Boolean,
				default: !0
			},
			showRetryButton: {
				type: Boolean,
				default: !0
			},
			showCancelButton: {
				type: Boolean,
				default: !0
			},
			showUploadButton: {
				type: [Boolean, Object],
				default: !0
			},
			showPreviewButton: {
				type: Boolean,
				default: !0
			},
			download: {
				type: Boolean,
				default: !1
			},
			showLink: {
				type: Boolean,
				default: !0
			},
			imageLoading: {
				type: String
			},
			listType: {
				type: String,
				default: "text"
			},
			responseUrlKey: {
				type: [String, Function]
			},
			customIcon: {
				type: Object
			},
			imagePreview: {
				type: Boolean,
				default: !1
			},
			onBeforeUpload: {
				type: Function
			},
			onBeforeRemove: {
				type: Function
			},
			onButtonClick: {
				type: Function
			}
		},
		emits: {
			"update:fileList": o => !0,
			exceedLimit: (o, s) => !0,
			change: (o, s) => !0,
			progress: (o, s) => !0,
			preview: o => !0,
			success: o => !0,
			error: o => !0
		},
		setup(o, {
			emit: s,
			slots: a
		}) {
			const {
				fileList: l,
				disabled: c,
				listType: d,
				customIcon: f,
				showRetryButton: m,
				showCancelButton: g,
				showRemoveButton: v,
				showPreviewButton: y,
				imageLoading: b,
				download: C,
				showLink: _
			} = toRefs(o), S = getPrefixCls("upload"), {
				mergedDisabled: w,
				eventHandlers: T
			} = useFormItem({
				disabled: c
			}), A = ref([]), k = new Map, M = new Map, D = computed(() => o.limit > 0 && A.value.length >= o
				.limit), F = Se => {
				k.clear();
				const be = Se == null ? void 0 : Se.map((Me, Ve) => {
					var it, pt, dt;
					const He = (it = Me.status) != null ? it : "done",
						Ae = reactive({
							...Me,
							uid: (pt = Me.uid) != null ? pt : `${Date.now()}${Ve}`,
							status: He,
							percent: (dt = Me.percent) != null ? dt : ["error", "init"].indexOf(
								He) > -1 ? 0 : 1
						});
					return k.set(Ae.uid, Ae), Ae
				});
				A.value = be ?? []
			};
			F(o.defaultFileList), watch(l, Se => {
				Se && F(Se)
			}, {
				immediate: !0,
				deep: !0
			});
			const R = Se => {
					var be, Me;
					s("update:fileList", A.value), s("change", A.value, Se), (Me = (be = T.value) == null ? void 0 :
						be.onChange) == null || Me.call(be)
				},
				O = (Se, be) => {
					for (const Me of A.value)
						if (Me.uid === Se) {
							Me.file = be, R(Me);
							break
						}
				},
				U = Se => {
					const be = (dt, He) => {
							const Ae = k.get(Se.uid);
							Ae && (Ae.status = "uploading", Ae.percent = dt, s("progress", Ae, He), R(Ae))
						},
						Me = dt => {
							const He = k.get(Se.uid);
							He && (He.status = "done", He.percent = 1, He.response = dt, o.responseUrlKey && (
									isFunction$2(o.responseUrlKey) ? He.url = o.responseUrlKey(He) : dt[o
										.responseUrlKey] && (He.url = dt[o.responseUrlKey])), M.delete(He.uid),
								s("success", He), R(He))
						},
						Ve = dt => {
							const He = k.get(Se.uid);
							He && (He.status = "error", He.percent = 0, He.response = dt, M.delete(He.uid), s(
								"error", He), R(He))
						},
						it = {
							fileItem: Se,
							action: o.action,
							name: o.name,
							data: o.data,
							headers: o.headers,
							withCredentials: o.withCredentials,
							onProgress: be,
							onSuccess: Me,
							onError: Ve
						};
					Se.status = "uploading", Se.percent = 0;
					const pt = isFunction$2(o.customRequest) ? o.customRequest(it) : uploadRequest(it);
					M.set(Se.uid, pt), R(Se)
				},
				V = Se => {
					var be;
					const Me = M.get(Se.uid);
					if (Me) {
						(be = Me.abort) == null || be.call(Me), M.delete(Se.uid);
						const Ve = k.get(Se.uid);
						Ve && (Ve.status = "error", Ve.percent = 0, R(Ve))
					}
				},
				z = Se => {
					if (Se) {
						const be = k.get(Se.uid);
						be && U(be)
					} else
						for (const be of A.value) be.status === "init" && U(be)
				},
				j = async (Se, be) => {
					const Me = `${Date.now()}-${be}`,
						Ve = isImage(Se) ? URL.createObjectURL(Se) : void 0,
						it = reactive({
							uid: Me,
							file: Se,
							url: Ve,
							name: Se.name,
							status: "init",
							percent: 0
						});
					k.set(Me, it), A.value = [...A.value, it], R(it), o.autoUpload && U(it)
				}, ge = Se => {
					if (o.limit > 0 && A.value.length + Se.length > o.limit) {
						s("exceedLimit", A.value, Se);
						return
					}
					for (let be = 0; be < Se.length; be++) {
						const Me = Se[be];
						isFunction$2(o.onBeforeUpload) ? Promise.resolve(o.onBeforeUpload(Me)).then(Ve => {
							Ve && j(isBoolean$2(Ve) ? Me : Ve, be)
						}).catch(Ve => {
							console.error(Ve)
						}) : j(Me, be)
					}
				}, me = Se => {
					A.value = A.value.filter(be => be.uid !== Se.uid), R(Se)
				}, he = Se => {
					isFunction$2(o.onBeforeRemove) ? Promise.resolve(o.onBeforeRemove(Se)).then(be => {
						be && me(Se)
					}).catch(be => {
						console.error(be)
					}) : me(Se)
				}, ce = Se => {
					if (o.imagePreview && Se.url) {
						const be = ke.value.indexOf(Se.url);
						be > -1 && (le.value = be, q.value = !0)
					}
					s("preview", Se)
				};
			provide(uploadInjectionKey, reactive({
				disabled: w,
				listType: d,
				iconCls: `${S}-icon`,
				showRemoveButton: v,
				showRetryButton: m,
				showCancelButton: g,
				showPreviewButton: y,
				showLink: _,
				imageLoading: b,
				download: C,
				customIcon: f,
				slots: a,
				onUpload: U,
				onAbort: V,
				onRemove: he,
				onPreview: ce
			}));
			const ae = computed(() => {
					if (o.accept) return o.accept;
					if (o.listType === "picture" || o.listType === "picture-card") return "image/*"
				}),
				fe = () => {
					const Se = createVNode(UploadButton, {
						key: "arco-upload-button",
						disabled: w.value,
						draggable: o.draggable,
						listType: o.listType,
						uploadFiles: ge,
						multiple: o.multiple,
						directory: o.directory,
						tip: o.tip,
						hide: !o.showUploadButton || D.value && !(isObject$2(o.showUploadButton) && o
							.showUploadButton.showOnExceedLimit),
						accept: ae.value,
						onButtonClick: o.onButtonClick
					}, {
						default: a["upload-button"]
					});
					return o.tip && o.listType !== "picture-card" && !o.draggable ? createVNode("span", null, [Se,
						createVNode("div", {
							class: `${S}-tip`
						}, [o.tip])
					]) : Se
				},
				q = ref(!1),
				le = ref(0),
				de = Se => {
					le.value = Se
				},
				_e = Se => {
					q.value = Se
				},
				ke = computed(() => A.value.filter(Se => !!Se.url).map(Se => Se.url));
			return {
				prefixCls: S,
				render: () => o.showFileList ? createVNode("div", {
					class: [`${S}-wrapper`, `${S}-wrapper-type-${o.listType}`]
				}, [o.imagePreview && ke.value.length > 0 && createVNode(ImagePreviewGroup, {
					srcList: ke.value,
					visible: q.value,
					current: le.value,
					onChange: de,
					onVisibleChange: _e
				}, null), o.listType !== "picture-card" && o.showUploadButton && fe(), createVNode(
					UploadList, {
						fileList: A.value,
						listType: o.listType
					}, {
						"upload-button": fe,
						"upload-item": a["upload-item"]
					})]) : o.showUploadButton && fe(),
				innerSubmit: z,
				innerAbort: V,
				innerUpdateFile: O,
				innerUpload: ge
			}
		},
		methods: {
			submit(o) {
				return this.innerSubmit(o)
			},
			abort(o) {
				return this.innerAbort(o)
			},
			updateFile(o, s) {
				return this.innerUpdateFile(o, s)
			},
			upload(o) {
				return this.innerUpload(o)
			}
		},
		render() {
			return this.render()
		}
	});
const Upload = Object.assign(_Upload, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Upload.name, _Upload)
	}
});
var _OverflowList = defineComponent({
	name: "OverflowList",
	props: {
		min: {
			type: Number,
			default: 0
		},
		margin: {
			type: Number,
			default: 8
		},
		from: {
			type: String,
			default: "end"
		}
	},
	emits: {
		change: o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		const l = getPrefixCls("overflow-list"),
			c = ref(),
			d = ref(),
			f = ref(),
			m = {},
			g = [],
			v = ref(0),
			y = ref(0),
			b = computed(() => y.value > 0),
			C = ref(0),
			_ = computed(() => o.from === "start");
		watch(v, (T, A) => {
			y.value > 0 && (y.value += T - A, y.value < 0 && (y.value = 0))
		}), watch(y, T => {
			s("change", T)
		});
		const S = () => {
			var T, A, k;
			if (c.value && m.value && f.value) {
				const M = f.value.offsetWidth;
				if (M > 1 && (y.value === 0 || M < C.value)) return;
				for (let O = 0; O < m.value.length; O++) {
					const U = m.value[O].el;
					U && U.offsetWidth && (g[O] = U.offsetWidth + o.margin)
				}
				let D = c.value.clientWidth - ((A = (T = d.value) == null ? void 0 : T.offsetWidth) !=
					null ? A : 0) - (_.value ? o.margin : 0);
				const F = _.value ? getReverse(g) : g;
				let R = 0;
				for (let O = 0; O < F.length; O++) {
					const U = (k = F[O]) != null ? k : 0;
					if (U < D - 1) D -= U, R += 1;
					else {
						C.value = U;
						break
					}
				}
				R < o.min && o.min < v.value && (R = o.min), y.value !== v.value - R && (y.value = v.value -
					R)
			}
		};
		watch(b, () => S(), {
			flush: "post"
		}), onMounted(() => {
			f.value && f.value.offsetWidth < 1 && S()
		});
		const w = () => {
			var T, A;
			const k = _.value ? {
				marginRight: `${o.margin}px`
			} : void 0;
			return createVNode("div", {
				ref: d,
				class: `${l}-overflow`,
				style: k
			}, [(A = (T = a.overflow) == null ? void 0 : T.call(a, {
				number: y.value
			})) != null ? A : createVNode(Tag, null, {
				default: () => [createTextVNode("+"), y.value]
			})])
		};
		return () => {
			var T, A;
			m.value = getAllElements((T = a.default) == null ? void 0 : T.call(a)), v.value !== m.value
				.length && (v.value = m.value.length, g.length = v.value);
			let k = m.value;
			y.value > 0 && (k = _.value ? m.value.slice(y.value) : m.value.slice(0, -y.value));
			const M = y.value === 0 || _.value ? k.length - 1 : k.length;
			for (let D = 0; D < M; D++) k[D].props = mergeProps((A = k[D].props) != null ? A : {}, {
				style: {
					marginRight: `${o.margin}px`
				}
			});
			return createVNode("div", {
				ref: c,
				class: l
			}, [_.value && y.value > 0 && w(), k, !_.value && y.value > 0 && w(), createVNode(
				ResizeObserver$1, {
					onResize: S
				}, {
					default: () => [createVNode("div", {
						ref: f,
						class: `${l}-spacer`
					}, null)]
				})])
		}
	}
});
const OverflowList = Object.assign(_OverflowList, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _OverflowList.name, _OverflowList)
	}
});
var _VerificationCode = defineComponent({
	name: "VerificationCode",
	props: {
		modelValue: String,
		defaultValue: {
			type: String,
			default: ""
		},
		length: {
			type: Number,
			default: 6
		},
		size: {
			type: String
		},
		disabled: Boolean,
		masked: Boolean,
		readonly: Boolean,
		error: {
			type: Boolean,
			default: !1
		},
		separator: {
			type: Function
		},
		formatter: {
			type: Function
		}
	},
	emits: {
		"update:modelValue": o => !0,
		change: o => !0,
		finish: o => !0,
		input: (o, s, a) => !0
	},
	setup(o, {
		emit: s
	}) {
		const a = getPrefixCls("verification-code"),
			l = getPrefixCls("input"),
			c = ref([]),
			d = computed(() => {
				var T;
				return (T = o.modelValue) != null ? T : o.defaultValue
			}),
			f = computed(() => o.masked ? "password" : "text"),
			m = computed(() => [l, {
				[`${l}-size-${o.size}`]: o.size
			}]),
			g = computed(() => {
				const T = String(d.value).split("");
				return new Array(o.length).fill("").map((A, k) => isExist(T[k]) ? String(T[k]) : "")
			}),
			v = ref(g.value);
		watch(d, () => {
			v.value = g.value
		});
		const y = () => {
				const T = v.value.join("").trim();
				s("update:modelValue", T), s("change", T), T.length === o.length && s("finish", T), C()
			},
			b = T => c == null ? void 0 : c.value[T].focus(),
			C = T => {
				if (!(isExist(T) && v.value[T])) {
					for (let A = 0; A < v.value.length; A++)
						if (!v.value[A]) {
							b(A);
							break
						}
				}
			},
			_ = (T, A) => {
				T.preventDefault();
				const {
					clipboardData: k
				} = T, M = k == null ? void 0 : k.getData("text");
				M && (M.split("").forEach((D, F) => {
					if (!(A + F >= o.length)) {
						if (isFunction$2(o.formatter)) {
							const R = o.formatter(D, A + F, v.value.join(""));
							if (R === !1) {
								A -= 1;
								return
							}
							isString$2(R) && (D = R.charAt(0))
						}
						v.value[A + F] = D
					}
				}), y())
			},
			S = (T, A) => {
				const k = A.code || A.key;
				k === Backspace.code && !v.value[T] ? (A.preventDefault(), v.value[Math.max(T - 1, 0)] = "",
					y()) : k === ArrowLeft.code && T > 0 ? (A.preventDefault(), b(T - 1)) : k === ArrowRight
					.code && v.value[T] && T < o.length - 1 && (A.preventDefault(), b(T + 1))
			},
			w = (T, A, k) => {
				let M = (A || "").trim().charAt(A.length - 1);
				if (s("input", M, T, k), isFunction$2(o.formatter)) {
					const D = o.formatter(M, T, v.value.join(""));
					if (D === !1) return;
					isString$2(D) && (M = D.charAt(0))
				}
				v.value[T] = M, y()
			};
		return () => createVNode("div", {
			class: a
		}, [v.value.map((T, A) => {
			var k;
			return createVNode(Fragment, null, [createVNode(Input, {
				key: A,
				ref: M => c.value[A] = M,
				type: f.value,
				class: m.value,
				modelValue: T,
				size: o.size,
				error: o.error,
				disabled: o.disabled,
				readonly: o.readonly,
				onFocus: () => C(A),
				onInput: (M, D) => w(A, M, D),
				onKeydown: M => S(A, M),
				onPaste: M => _(M, A)
			}, null), (k = o.separator) == null ? void 0 : k.call(o, A, T)])
		})])
	}
});
const VerificationCode = Object.assign(_VerificationCode, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _VerificationCode.name, _VerificationCode)
		}
	}),
	defaultWindow = typeof window < "u" ? window : void 0;

function unrefElement(o) {
	var s;
	const a = unref(o);
	return (s = a == null ? void 0 : a.$el) != null ? s : a
}

function tryOnScopeDispose(o) {
	return getCurrentScope() ? (onScopeDispose(o), !0) : !1
}

function useMutationObserver(o, s, a = {}) {
	const {
		window: l = defaultWindow,
		...c
	} = a, d = l && "MutationObserver" in l;
	let f;
	const m = () => {
			f && (f.disconnect(), f = void 0)
		},
		g = watch(() => unrefElement(o), y => {
			m(), d && l && y && (f = new MutationObserver(s), f.observe(y, c))
		}, {
			immediate: !0
		}),
		v = () => {
			m(), g()
		};
	return tryOnScopeDispose(v), {
		isSupported: d,
		stop: v
	}
}
const THEME_TOKEN = "arco-theme",
	Theme = {
		Dark: "dark",
		Light: "light"
	},
	useTheme = o => {
		const s = ref(Theme.Light),
			a = c => {
				s.value = c
			},
			l = c => c.getAttribute(THEME_TOKEN) === Theme.Dark ? Theme.Dark : Theme.Light;
		return useMutationObserver(document.body, c => {
			for (const d of c)
				if (d.type === "attributes" && d.attributeName === THEME_TOKEN) {
					a(l(d.target)), o == null || o();
					break
				}
		}, {
			attributes: !0,
			attributeFilter: [THEME_TOKEN],
			subtree: !1,
			childList: !1,
			characterData: !1
		}), a(l(document.body)), {
			theme: s,
			setTheme: a
		}
	};

function camelToKebab(o) {
	return o.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
}

function styleToString(o) {
	return Object.entries(o).map(([s, a]) => `${camelToKebab(s)}:${a}`).join(";")
}

function canvasToGray(o) {
	const s = o.getContext("2d");
	if (!s) return;
	const a = s.getImageData(0, 0, o.width, o.height),
		{
			data: l
		} = a;
	for (let c = 0; c < l.length; c += 4) {
		const d = (l[c] + l[c + 1] + l[c + 2]) / 3;
		l[c] = d, l[c + 1] = d, l[c + 2] = d
	}
	s.putImageData(a, 0, 0)
}
var _Watermark = defineComponent({
	name: "Watermark",
	props: {
		content: {
			type: [String, Array]
		},
		image: {
			type: String
		},
		width: {
			type: Number
		},
		height: {
			type: Number
		},
		gap: {
			type: Array,
			default: () => [90, 90]
		},
		offset: {
			type: Array
		},
		rotate: {
			type: Number,
			default: -22
		},
		font: {
			type: Object
		},
		zIndex: {
			type: Number,
			default: 6
		},
		alpha: {
			type: Number,
			default: 1
		},
		antiTamper: {
			type: Boolean,
			default: !0
		},
		grayscale: {
			type: Boolean,
			default: !1
		},
		repeat: {
			type: Boolean,
			default: !0
		},
		staggered: {
			type: Boolean,
			default: !0
		}
	},
	setup(o, {
		slots: s,
		attrs: a
	}) {
		const {
			width: l,
			height: c,
			image: d,
			rotate: f,
			alpha: m,
			repeat: g,
			grayscale: v
		} = toRefs(o), y = getPrefixCls("watermark"), b = window.devicePixelRatio || 1, C = shallowRef(), _ =
			ref(new Map), S = computed(() => {
				var le, de;
				return (de = (le = o.font) == null ? void 0 : le.fontSize) != null ? de : 16
			}), w = computed(() => {
				var le, de;
				return (de = (le = o.font) == null ? void 0 : le.fontWeight) != null ? de : "normal"
			}), T = computed(() => {
				var le, de;
				return (de = (le = o.font) == null ? void 0 : le.fontStyle) != null ? de : "normal"
			}), A = computed(() => {
				var le, de;
				return (de = (le = o.font) == null ? void 0 : le.fontFamily) != null ? de : "sans-serif"
			}), k = computed(() => {
				var le, de;
				return (de = (le = o.font) == null ? void 0 : le.textAlign) != null ? de : "center"
			}), M = computed(() => isArray$2(o.content) ? o.content : [o.content]), D = computed(() => {
				var le, de;
				return (de = (le = o.font) == null ? void 0 : le.color) != null ? de : q.value === "dark" ?
					"rgba(255, 255, 255, 0.15)" : "rgba(0, 0, 0, 0.15)"
			}), F = computed(() => {
				var le, de;
				return (de = (le = o.gap) == null ? void 0 : le[0]) != null ? de : 90
			}), R = computed(() => {
				var le, de;
				return (de = (le = o.gap) == null ? void 0 : le[1]) != null ? de : 90
			}), O = computed(() => F.value / 2), U = computed(() => R.value / 2), V = computed(() => {
				var le, de;
				return (de = (le = o.offset) == null ? void 0 : le[0]) != null ? de : O.value
			}), z = computed(() => {
				var le, de;
				return (de = (le = o.offset) == null ? void 0 : le[1]) != null ? de : U.value
			}), j = computed(() => {
				var le;
				const de = V.value - O.value,
					_e = z.value - U.value;
				return {
					position: "absolute",
					left: de > 0 ? `${de}px` : 0,
					top: _e > 0 ? `${_e}px` : 0,
					width: de > 0 ? `calc(100% - ${de}px)` : "100%",
					height: _e > 0 ? `calc(100% - ${_e}px)` : "100%",
					pointerEvents: "none",
					backgroundRepeat: o.repeat ? "repeat" : "no-repeat",
					backgroundPosition: `${de>0?0:de}px ${_e>0?0:_e}px`,
					zIndex: (le = o.zIndex) != null ? le : 6
				}
			}), ge = computed(() => o.repeat && o.staggered), me = (le, de) => {
				var _e;
				if (C.value) {
					const ke = _.value.get(C.value);
					ke && (C.value.contains(ke) && C.value.removeChild(ke), _.value.delete(C.value));
					const De = document.createElement("div");
					De.setAttribute("style", styleToString({
						...j.value,
						backgroundImage: `url('${le}')`,
						backgroundSize: `${de}px`
					})), (_e = C.value) == null || _e.append(De), _.value.set(C.value, De)
				}
			}, he = le => {
				var de, _e;
				let ke = 120,
					De = 28;
				if (!d.value && le.measureText) {
					le.font = `${S.value}px ${A.value}`;
					const Se = M.value.map(be => le.measureText(be).width);
					ke = Math.ceil(Math.max(...Se)), De = S.value * M.value.length + (M.value.length - 1) * 3
				}
				return [(de = l.value) != null ? de : ke, (_e = c.value) != null ? _e : De]
			}, ce = () => {
				var le;
				const de = document.createElement("canvas"),
					_e = de.getContext("2d");
				if (!_e) return;
				const [ke, De] = he(_e), Se = ke * b, be = De * b, Me = (F.value + ke) * b, Ve = (R.value +
					De) * b, it = F.value / 2 * b, pt = R.value / 2 * b, dt = Me / 2, He = Ve / 2, Ae = ge
					.value ? 2 : 1, xe = (F.value + ke) * Ae;
				de.width = Me * Ae, de.height = Ve * Ae, _e.globalAlpha = m.value, _e.save(), _e.translate(dt,
					He), _e.rotate(Math.PI / 180 * f.value), _e.translate(-dt, -He);
				const ye = () => {
					_e.restore(), ge.value && _e.drawImage(de, 0, 0, Me, Ve, Me, Ve, Me, Ve), v.value &&
						canvasToGray(de), me(de.toDataURL(), xe)
				};
				if (d.value) {
					const Le = new Image;
					Le.onload = () => {
						_e.drawImage(Le, it, pt, Se, be), ye()
					}, Le.crossOrigin = "anonymous", Le.referrerPolicy = "no-referrer", Le.src = d.value
				} else {
					const Le = Number(S.value) * b;
					_e.font = `${T.value} normal ${w.value} ${Le}px/${De}px ${A.value}`, _e.fillStyle = D.value,
						_e.textAlign = k.value, _e.textBaseline = "top", _e.translate(Se / 2, 0), (le = M
						.value) == null || le.forEach((Ue, nt) => {
							_e.fillText(Ue ?? "", it, pt + nt * (Le + 3 * b))
						}), ye()
				}
			}, ae = le => Array.from(_.value.values()).includes(le), fe = le => {
				if (o.antiTamper)
					for (const de of le) {
						const _e = Array.from(de.removedNodes).some(De => ae(De)),
							ke = de.type === "attributes" && ae(de.target);
						if (_e || ke) {
							ce();
							break
						}
					}
			}, {
				theme: q
			} = useTheme(ce);
		return onMounted(() => {
			ce(), useMutationObserver(C.value, fe, {
				attributes: !0,
				childList: !0,
				characterData: !0,
				subtree: !0
			})
		}), watch(o, ce, {
			deep: !0,
			flush: "post"
		}), () => {
			var le;
			return createVNode("div", mergeProps({
				ref: C,
				class: y,
				style: {
					position: "relative",
					overflow: "hidden"
				}
			}, a), [(le = s.default) == null ? void 0 : le.call(s)])
		}
	}
});
const Watermark = Object.assign(_Watermark, {
	install: (o, s) => {
		setGlobalConfig(o, s);
		const a = getComponentPrefix(s);
		o.component(a + _Watermark.name, _Watermark)
	}
});

function _isSlot(o) {
	return typeof o == "function" || Object.prototype.toString.call(o) === "[object Object]" && !isVNode(o)
}
var Panel = defineComponent({
	name: "TreeSelectPanel",
	components: {
		Tree
	},
	props: {
		treeProps: {
			type: Object,
			default: () => ({})
		},
		selectedKeys: {
			type: Array
		},
		showCheckable: {
			type: Boolean
		},
		treeSlots: {
			type: Object,
			default: () => ({})
		},
		scrollbar: {
			type: [Boolean, Object],
			default: !0
		}
	},
	emits: ["change"],
	setup(o, {
		emit: s
	}) {
		const {
			showCheckable: a,
			selectedKeys: l,
			treeProps: c,
			scrollbar: d
		} = toRefs(o), {
			displayScrollbar: f,
			scrollbarProps: m
		} = useScrollbar(d), g = getPrefixCls("tree-select"), v = ref(), y = computed(() => ({
			...c.value,
			disableSelectActionOnly: !0,
			checkedKeys: a.value ? l.value : [],
			selectedKeys: a.value ? [] : l.value
		})), b = (S, w) => {
			var T, A;
			a.value ? (A = (T = v.value) == null ? void 0 : T.toggleCheck) == null || A.call(T, S[0], w) :
				s("change", S)
		}, C = S => {
			s("change", S)
		}, _ = () => createVNode(Tree, mergeProps({
			ref: v
		}, y.value, {
			onSelect: b,
			onCheck: C
		}), o.treeSlots);
		return () => {
			if (f.value) {
				let S;
				return createVNode(Scrollbar, mergeProps({
					class: `${g}-tree-wrapper`
				}, m.value), _isSlot(S = _()) ? S : {
					default: () => [S]
				})
			}
			return createVNode("div", {
				class: `${g}-tree-wrapper`
			}, [_()])
		}
	}
});

function isLabelValue(o) {
	return isObject$2(o)
}

function isValidKey(o) {
	return o != null && o !== ""
}

function getKey(o) {
	return isLabelValue(o) ? o.value : o
}

function getLabel(o) {
	return isLabelValue(o) ? o.label : void 0
}

function isValidValue(o) {
	const s = getKey(o);
	return isValidKey(s)
}

function getKeys(o) {
	return o.map(getKey).filter(isValidKey)
}

function useSelectedState(o) {
	var s;
	const {
		defaultValue: a,
		modelValue: l,
		key2TreeNode: c,
		multiple: d,
		treeCheckable: f,
		fallbackOption: m,
		fieldNames: g
	} = toRefs(o);

	function v(D) {
		const F = (isArray$2(D) ? D : [D]).filter(isValidValue);
		return d != null && d.value || f != null && f.value ? F : F.slice(0, 1)
	}

	function y(D, F) {
		const R = [],
			O = D ? D.filter(isValidValue) : [];
		if (O.length) {
			const U = new Map;
			F == null || F.forEach(V => {
				U.set(V.value, V)
			}), O.forEach(V => {
				var z, j, ge, me, he;
				const ce = getKey(V),
					ae = U.get(ce),
					fe = c.value.get(ce);
				let q = null;
				const le = ((z = g == null ? void 0 : g.value) == null ? void 0 : z.title) || "title";
				if (!fe) {
					const de = isFunction$2(m == null ? void 0 : m.value) ? m == null ? void 0 : m.value(ce) :
						m == null ? void 0 : m.value;
					if (de === !1) return;
					isObject$2(de) && (q = de)
				}
				R.push({
					...isLabelValue(V) ? V : {},
					...ae || {},
					value: ce,
					label: (he = (me = (ge = (j = getLabel(V)) != null ? j : fe == null ? void 0 : fe
							.title) != null ? ge : ae == null ? void 0 : ae.label) != null ? me :
						q == null ? void 0 : q[le]) != null ? he : ce
				})
			})
		}
		return R
	}
	const b = ref(),
		C = ref();
	watchEffect(() => {
		var D;
		const F = (l == null ? void 0 : l.value) !== void 0,
			R = v((D = l == null ? void 0 : l.value) != null ? D : []),
			O = getKeys(R);
		C.value = F ? y(O, y(R)) : void 0, b.value = F ? O : void 0
	});
	const _ = v((s = a == null ? void 0 : a.value) != null ? s : []),
		S = getKeys(_),
		w = y(S, y(_)),
		T = ref(S || []),
		A = ref(w);
	watch(T, () => {
		A.value = y(T.value, w)
	}), watch([b, C], ([D, F]) => {
		T.value = D || [], A.value = F || []
	});
	const k = computed(() => {
			var D;
			return (D = b.value) != null ? D : T.value
		}),
		M = computed(() => {
			var D;
			return (D = C.value) != null ? D : A.value
		});
	return {
		selectedKeys: k,
		selectedValue: M,
		setLocalSelectedKeys(D) {
			T.value = D
		},
		localSelectedKeys: T,
		localSelectedValue: A
	}
}

function useFilterTreeNode(o) {
	const {
		searchValue: s,
		flattenTreeData: a,
		filterMethod: l,
		disableFilter: c,
		fieldNames: d
	} = toRefs(o), f = computed(() => {
			var S;
			return ((S = d.value) == null ? void 0 : S.key) || "key"
		}), m = (S, w) => {
			const T = w[f.value];
			return !isUndefined$1(T) && String(T).indexOf(S) > -1
		}, g = computed(() => (l == null ? void 0 : l.value) || m), v = ref(), y = computed(() => !!s.value), b =
		computed(() => !(c != null && c.value) && y.value && v.value && v.value.size === 0), C = computed(() => c !=
			null && c.value ? void 0 : S => {
				var w, T;
				if (!y.value) return !0;
				const A = S[f.value];
				return (T = (w = v.value) == null ? void 0 : w.has(A || "")) != null ? T : !1
			}), _ = debounce$1((S, w) => {
			const T = S.filter(k => g.value(w, k.treeNodeData)),
				A = new Set;
			T.forEach(k => {
				A.add(k.key), k.pathParentKeys.forEach(M => {
					A.add(M)
				})
			}), v.value = A
		}, 100);
	return watchEffect(() => {
		c != null && c.value ? v.value = void 0 : _(a.value, s.value)
	}), {
		isEmptyFilterResult: b,
		filterTreeNode: C
	}
}

function pickSubCompSlots(o, s) {
	const a = `${s}-slot-`;
	return Object.keys(o).reduce((c, d) => {
		if (d.startsWith(a)) {
			const f = d.slice(a.length);
			f && (c[f] = o[d])
		}
		return c
	}, {})
}
const _sfc_main$h = defineComponent({
	name: "TreeSelect",
	components: {
		Trigger,
		SelectView,
		Panel,
		Empty,
		Spin
	},
	inheritAttrs: !1,
	props: {
		disabled: {
			type: Boolean
		},
		loading: {
			type: Boolean
		},
		error: {
			type: Boolean
		},
		size: {
			type: String
		},
		border: {
			type: Boolean,
			default: !0
		},
		allowSearch: {
			type: [Boolean, Object],
			default: o => !!o.multiple
		},
		allowClear: {
			type: Boolean
		},
		placeholder: {
			type: String
		},
		maxTagCount: {
			type: Number
		},
		multiple: {
			type: Boolean
		},
		defaultValue: {
			type: [String, Number, Array, Object]
		},
		modelValue: {
			type: [String, Number, Array, Object]
		},
		fieldNames: {
			type: Object
		},
		data: {
			type: Array,
			default: () => []
		},
		labelInValue: {
			type: Boolean
		},
		treeCheckable: {
			type: Boolean
		},
		treeCheckStrictly: {
			type: Boolean
		},
		treeCheckedStrategy: {
			type: String,
			default: "all"
		},
		treeProps: {
			type: Object
		},
		triggerProps: {
			type: Object
		},
		popupVisible: {
			type: Boolean,
			default: void 0
		},
		defaultPopupVisible: {
			type: Boolean
		},
		dropdownStyle: {
			type: Object
		},
		dropdownClassName: {
			type: [String, Array]
		},
		filterTreeNode: {
			type: Function
		},
		loadMore: {
			type: Function
		},
		disableFilter: {
			type: Boolean
		},
		popupContainer: {
			type: [String, Object]
		},
		fallbackOption: {
			type: [Boolean, Function],
			default: !0
		},
		selectable: {
			type: [Boolean, String, Function],
			default: !0
		},
		scrollbar: {
			type: [Boolean, Object],
			default: !0
		},
		showHeaderOnEmpty: {
			type: Boolean,
			default: !1
		},
		showFooterOnEmpty: {
			type: Boolean,
			default: !1
		},
		inputValue: {
			type: String
		},
		defaultInputValue: {
			type: String,
			default: ""
		}
	},
	emits: {
		change: o => !0,
		"update:modelValue": o => !0,
		"update:inputValue": o => !0,
		"popup-visible-change": o => !0,
		"update:popupVisible": o => !0,
		search: o => !0,
		clear: () => !0,
		inputValueChange: o => !0
	},
	setup(o, {
		emit: s,
		slots: a
	}) {
		var l, c, d;
		const {
			defaultValue: f,
			modelValue: m,
			multiple: g,
			popupVisible: v,
			defaultPopupVisible: y,
			treeCheckable: b,
			treeCheckStrictly: C,
			data: _,
			fieldNames: S,
			disabled: w,
			labelInValue: T,
			filterTreeNode: A,
			disableFilter: k,
			dropdownStyle: M,
			treeProps: D,
			fallbackOption: F,
			selectable: R,
			dropdownClassName: O
		} = toRefs(o), {
			mergedDisabled: U,
			eventHandlers: V
		} = useFormItem({
			disabled: w
		}), z = getPrefixCls("tree-select"), j = inject(configProviderInjectionKey, void 0), ge = (d = (c =
			j == null ? void 0 : (l = j.slots).empty) == null ? void 0 : c.call(l, {
			component: "tree-select"
		})) == null ? void 0 : d[0], me = computed(() => g.value || b.value), he = (Je, Ne) => {
			var we;
			return R.value === "leaf" ? Ne.isLeaf : isFunction$2(R.value) ? R.value(Je, Ne) : (we = R
				.value) != null ? we : !1
		}, ce = computed(() => b.value ? he : !1), ae = computed(() => isObject$2(o.allowSearch) && !!o
			.allowSearch.retainInputValue), {
			flattenTreeData: fe,
			key2TreeNode: q
		} = useTreeData(reactive({
			treeData: _,
			fieldNames: S,
			selectable: he,
			checkable: ce
		})), {
			selectedKeys: le,
			selectedValue: de,
			setLocalSelectedKeys: _e,
			localSelectedKeys: ke,
			localSelectedValue: De
		} = useSelectedState(reactive({
			defaultValue: f,
			modelValue: m,
			key2TreeNode: q,
			multiple: g,
			treeCheckable: b,
			treeCheckStrictly: C,
			fallbackOption: F,
			fieldNames: S
		}));

		function Se(Je) {
			return b.value ? isNodeCheckable(Je) : isNodeSelectable(Je)
		}
		const be = computed(() => isUndefined$1(de.value) ? [] : me.value && !U.value ? de.value.map(Je => {
				const Ne = q.value.get(Je.value);
				return {
					...Je,
					closable: !Ne || Se(Ne)
				}
			}) : de.value),
			Me = Je => {
				_e(Je), nextTick(() => {
					var Ne, we;
					const Ce = (T.value ? De.value : ke.value) || [],
						$e = me.value ? Ce : Ce[0];
					s("update:modelValue", $e), s("change", $e), (we = (Ne = V.value) == null ? void 0 :
						Ne.onChange) == null || we.call(Ne)
				})
			},
			Ve = ref(o.defaultInputValue),
			it = computed(() => {
				var Je;
				return (Je = o.inputValue) != null ? Je : Ve.value
			}),
			pt = Je => {
				Ve.value = Je, s("update:inputValue", Je), s("inputValueChange", Je)
			},
			dt = Je => {
				Je !== it.value && (xe(!0), pt(Je), o.allowSearch && s("search", Je))
			},
			[He, Ae] = useMergeState(y.value, reactive({
				value: v
			})),
			xe = Je => {
				Je !== He.value && (Ae(Je), s("popup-visible-change", Je), s("update:popupVisible", Je)), Je ||
					nt.value && nt.value.blur && nt.value.blur()
			},
			{
				isEmptyFilterResult: ye,
				filterTreeNode: Le
			} = useFilterTreeNode(reactive({
				searchValue: it,
				flattenTreeData: fe,
				filterMethod: A,
				disableFilter: k,
				fieldNames: S
			})),
			Ue = computed(() => !fe.value.length || ye.value),
			nt = ref(),
			ot = computed(() => {
				var Je;
				return [(M == null ? void 0 : M.value) || {}, (Je = D == null ? void 0 : D.value) != null &&
					Je.virtualListProps ? {
						"max-height": "unset"
					} : {}
				]
			});
		return {
			refSelectView: nt,
			prefixCls: z,
			TreeSelectEmpty: ge,
			selectedValue: de,
			selectedKeys: le,
			mergedDisabled: U,
			searchValue: it,
			panelVisible: He,
			isEmpty: Ue,
			computedFilterTreeNode: Le,
			isMultiple: me,
			selectViewValue: be,
			computedDropdownStyle: ot,
			onSearchValueChange: dt,
			onSelectChange(Je) {
				Me(Je), !ae.value && it.value && pt(""), me.value || xe(!1)
			},
			onVisibleChange: xe,
			onInnerClear() {
				Me([]), s("clear")
			},
			pickSubCompSlots,
			isSelectable: he,
			isCheckable: ce,
			onBlur: () => {
				!ae.value && it.value && pt("")
			},
			onItemRemove(Je) {
				if (U.value) return;
				const Ne = q.value.get(Je);
				if (b.value && Ne) {
					if (Se(Ne)) {
						const [we] = getCheckedStateByCheck({
							node: Ne,
							checked: !1,
							checkedKeys: le.value,
							indeterminateKeys: [],
							checkStrictly: C.value
						});
						Me(we)
					}
				} else {
					const we = le.value.filter(Ce => Ce !== Je);
					Me(we)
				}
			}
		}
	}
});

function _sfc_render(o, s, a, l, c, d) {
	const f = resolveComponent("SelectView"),
		m = resolveComponent("Spin"),
		g = resolveComponent("Panel"),
		v = resolveComponent("Trigger");
	return openBlock(), createBlock(v, mergeProps({
		class: `${o.prefixCls}-trigger`,
		"auto-fit-popup-min-width": "",
		trigger: "click",
		position: "bl",
		"popup-offset": 4,
		"animation-name": "slide-dynamic-origin",
		"prevent-focus": !0
	}, o.triggerProps, {
		disabled: o.mergedDisabled,
		"popup-visible": o.panelVisible,
		"popup-container": o.popupContainer,
		"click-to-close": !o.allowSearch,
		"auto-fit-transform-origin": "",
		onPopupVisibleChange: o.onVisibleChange
	}), {
		content: withCtx(() => [createBaseVNode("div", {
			class: normalizeClass([`${o.prefixCls}-popup`, {
				[`${o.prefixCls}-has-header`]: !!o.$slots.header,
				[`${o.prefixCls}-has-footer`]: !!o.$slots.footer
			}, o.dropdownClassName]),
			style: normalizeStyle(o.computedDropdownStyle)
		}, [o.$slots.header && (!o.isEmpty || o.showHeaderOnEmpty) ? (openBlock(),
				createElementBlock("div", {
					key: 0,
					class: normalizeClass(`${o.prefixCls}-header`)
				}, [renderSlot(o.$slots, "header")], 2)) : createCommentVNode("v-if", !0), o
			.loading ? renderSlot(o.$slots, "loader", {
				key: 1
			}, () => [createVNode(m)]) : o.isEmpty ? renderSlot(o.$slots, "empty", {
				key: 2
			}, () => [(openBlock(), createBlock(resolveDynamicComponent(o.TreeSelectEmpty ?
				o.TreeSelectEmpty : "Empty")))]) : (openBlock(), createBlock(g, {
				key: 3,
				"selected-keys": o.selectedKeys,
				"show-checkable": o.treeCheckable,
				scrollbar: o.scrollbar,
				"tree-props": {
					actionOnNodeClick: o.selectable === "leaf" ? "expand" : void 0,
					blockNode: !0,
					...o.treeProps,
					data: o.data,
					checkStrictly: o.treeCheckStrictly,
					checkedStrategy: o.treeCheckedStrategy,
					fieldNames: o.fieldNames,
					multiple: o.multiple,
					loadMore: o.loadMore,
					filterTreeNode: o.computedFilterTreeNode,
					size: o.size,
					checkable: o.isCheckable,
					selectable: o.isSelectable,
					searchValue: o.searchValue
				},
				"tree-slots": o.pickSubCompSlots(o.$slots, "tree"),
				onChange: o.onSelectChange
			}, null, 8, ["selected-keys", "show-checkable", "scrollbar", "tree-props",
				"tree-slots", "onChange"
			])), o.$slots.footer && (!o.isEmpty || o.showFooterOnEmpty) ? (openBlock(),
				createElementBlock("div", {
					key: 4,
					class: normalizeClass(`${o.prefixCls}-footer`)
				}, [renderSlot(o.$slots, "footer")], 2)) : createCommentVNode("v-if", !0)
		], 6)]),
		default: withCtx(() => [renderSlot(o.$slots, "trigger", {}, () => [createVNode(f, mergeProps({
			ref: "refSelectView",
			"model-value": o.selectViewValue,
			"input-value": o.searchValue,
			"allow-search": !!o.allowSearch,
			"allow-clear": o.allowClear,
			loading: o.loading,
			size: o.size,
			"max-tag-count": o.maxTagCount,
			disabled: o.mergedDisabled,
			opened: o.panelVisible,
			error: o.error,
			bordered: o.border,
			placeholder: o.placeholder,
			multiple: o.isMultiple
		}, o.$attrs, {
			onInputValueChange: o.onSearchValueChange,
			onClear: o.onInnerClear,
			onRemove: o.onItemRemove,
			onBlur: o.onBlur
		}), createSlots({
			_: 2
		}, [o.$slots.prefix ? {
			name: "prefix",
			fn: withCtx(() => [renderSlot(o.$slots, "prefix")]),
			key: "0"
		} : void 0, o.$slots.label ? {
			name: "label",
			fn: withCtx(y => [renderSlot(o.$slots, "label", normalizeProps(
				guardReactiveProps(y)))]),
			key: "1"
		} : void 0]), 1040, ["model-value", "input-value", "allow-search",
			"allow-clear", "loading", "size", "max-tag-count", "disabled", "opened",
			"error", "bordered", "placeholder", "multiple", "onInputValueChange",
			"onClear", "onRemove", "onBlur"
		])])]),
		_: 3
	}, 16, ["class", "disabled", "popup-visible", "popup-container", "click-to-close", "onPopupVisibleChange"])
}
var _TreeSelect = _export_sfc$1(_sfc_main$h, [
	["render", _sfc_render]
]);
const TreeSelect = Object.assign(_TreeSelect, {
		install: (o, s) => {
			setGlobalConfig(o, s);
			const a = getComponentPrefix(s);
			o.component(a + _TreeSelect.name, _TreeSelect)
		}
	}),
	components = {
		Button,
		Link,
		Typography,
		Divider,
		Grid: Grid$1,
		Layout,
		Space,
		Avatar,
		Badge,
		Calendar,
		Card,
		Carousel,
		Collapse,
		Comment,
		ColorPicker,
		Descriptions,
		Empty,
		Image: Image$2,
		Scrollbar,
		List,
		Popover,
		Statistic,
		Table,
		Tabs,
		Tag,
		Timeline,
		Tooltip,
		AutoComplete,
		Cascader,
		Checkbox,
		DatePicker,
		Form,
		Input,
		InputNumber,
		InputTag,
		Mention,
		Radio,
		Rate,
		Select,
		Slider,
		Switch,
		Textarea,
		TimePicker,
		Transfer,
		Tree,
		Upload,
		TreeSelect,
		Alert,
		Drawer,
		Message,
		Modal,
		Notification,
		Popconfirm,
		Progress,
		Result,
		Spin,
		Skeleton: Skeleton$1,
		Breadcrumb,
		Dropdown,
		Menu,
		PageHeader,
		Pagination,
		Steps,
		Affix,
		Anchor,
		BackTop,
		ConfigProvider,
		ResizeBox,
		Trigger,
		Split,
		Icon: Icon$1,
		OverflowList,
		Watermark,
		VerificationCode
	},
	install = (o, s) => {
		for (const a of Object.keys(components)) o.use(components[a], s)
	},
	ArcoVue = {
		...components,
		Alter: Alert,
		AnchorLink,
		AvatarGroup,
		BreadcrumbItem,
		ButtonGroup,
		Calendar,
		CardMeta,
		CardGrid,
		CarouselItem,
		CascaderPanel,
		CheckboxGroup,
		CollapseItem,
		DescriptionsItem,
		WeekPicker,
		MonthPicker,
		YearPicker,
		QuarterPicker,
		RangePicker,
		Doption,
		Dgroup,
		Dsubmenu,
		DropdownButton,
		FormItem,
		Row,
		Col,
		GridItem,
		ImagePreview,
		ImagePreviewAction,
		ImagePreviewGroup,
		InputGroup,
		InputSearch,
		InputPassword,
		LayoutHeader,
		LayoutContent,
		LayoutFooter,
		LayoutSider,
		ListItem,
		ListItemMeta,
		MenuItem,
		MenuItemGroup,
		SubMenu,
		RadioGroup,
		Option,
		Optgroup,
		SkeletonLine,
		SkeletonShape,
		Countdown,
		Step,
		Thead,
		Td,
		Th,
		Tr,
		Tbody,
		TableColumn,
		TabPane,
		TimelineItem,
		TypographyParagraph,
		TypographyTitle,
		TypographyText,
		install,
		addI18nMessages,
		useLocale,
		getLocale,
		useFormItem
	};
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = o => o.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	"stroke-width": 2,
	"stroke-linecap": "round",
	"stroke-linejoin": "round"
};
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = ({
	size: o,
	strokeWidth: s = 2,
	absoluteStrokeWidth: a,
	color: l,
	iconNode: c,
	name: d,
	class: f,
	...m
}, {
	slots: g
}) => h("svg", {
	...defaultAttributes,
	width: o || defaultAttributes.width,
	height: o || defaultAttributes.height,
	stroke: l || defaultAttributes.stroke,
	"stroke-width": a ? Number(s) * 24 / Number(o) : s,
	class: ["lucide", `lucide-${toKebabCase(d??"icon")}`],
	...m
}, [...c.map(v => h(...v)), ...g.default ? [g.default()] : []]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (o, s) => (a, {
	slots: l
}) => h(Icon, {
	...a,
	iconNode: s,
	name: o
}, l);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ArrowUpRight = createLucideIcon("ArrowUpRightIcon", [
	["path", {
		d: "M7 7h10v10",
		key: "1tivn9"
	}],
	["path", {
		d: "M7 17 17 7",
		key: "1vkiza"
	}]
]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EyeOff = createLucideIcon("EyeOffIcon", [
	["path", {
		d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
		key: "ct8e1f"
	}],
	["path", {
		d: "M14.084 14.158a3 3 0 0 1-4.242-4.242",
		key: "151rxh"
	}],
	["path", {
		d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
		key: "13bj9a"
	}],
	["path", {
		d: "m2 2 20 20",
		key: "1ooewy"
	}]
]);
/**
 * @license lucide-vue-next v0.477.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Eye = createLucideIcon("EyeIcon", [
		["path", {
			d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
			key: "1nclc0"
		}],
		["circle", {
			cx: "12",
			cy: "12",
			r: "3",
			key: "1v7zrd"
		}]
	]),
	_sfc_main$g = defineComponent({
		__name: "GridOptions",
		props: {
			name: {},
			show: {
				type: Boolean
			},
			modelValue: {},
			index: {},
			fixedFrames: {},
			fixedFrame: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-input-number"),
					v = resolveComponent("a-color-picker"),
					y = resolveComponent("a-form"),
					b = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(b, {
					header: a.name,
					key: `grid_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(y, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Reference Frame"
						}, {
							default: withCtx(() => [createVNode(f, {
								"model-value": a
									.modelValue
									.frameId ?? a
									.fixedFrame,
								onChange: l[1] || (l[
									1] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											frameId: C
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												a
												.fixedFrames,
												C =>
												(openBlock(),
													createBlock(
														d, {
															key: C,
															value: C
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			C
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											128)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Plane Cell Count"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue
									.numCells,
								min: 1,
								onChange: l[2] || (l[
									2] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											numCells: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Cell Size"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue
									.cellSize,
								min: 1,
								onChange: l[3] || (l[
									3] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											cellSize: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(v, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[4] || (l[
									4] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$f = defineComponent({
		__name: "AxesOptions",
		props: {
			name: {},
			show: {
				type: Boolean
			},
			modelValue: {},
			index: {},
			fixedFrames: {},
			fixedFrame: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-form"),
					v = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(v, {
					header: a.name,
					key: `axes_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(g, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Reference Frame"
						}, {
							default: withCtx(() => [createVNode(f, {
								"model-value": a
									.modelValue
									.frameId ?? a
									.fixedFrame,
								onChange: l[1] || (l[
									1] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											frameId: y
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												a
												.fixedFrames,
												y =>
												(openBlock(),
													createBlock(
														d, {
															key: y,
															value: y
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			y
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											128)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Line Type"
						}, {
							default: withCtx(() => [createVNode(f, {
								"model-value": a
									.modelValue
									.lineType,
								onChange: l[2] || (l[
									2] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											lineType: y
										}))
							}, {
								default: withCtx(() => [
									createVNode(
										d, {
											value: "dashed"
										}, {
											default: withCtx(
												() =>
												l[
													3] ||
												(l[3] = [
													createTextVNode(
														"dashed"
														)
												])
												),
											_: 1
										}),
									createVNode(
										d, {
											value: "full"
										}, {
											default: withCtx(
												() =>
												l[
													4] ||
												(l[4] = [
													createTextVNode(
														"full"
														)
												])
												),
											_: 1
										})
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$e = defineComponent({
		__name: "TFOptions",
		props: {
			name: {},
			show: {
				type: Boolean
			},
			modelValue: {},
			index: {},
			fixedFrames: {},
			fixedFrame: {},
			tfTree: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-color-picker"),
					f = resolveComponent("a-form-item"),
					m = resolveComponent("a-switch"),
					g = resolveComponent("a-form"),
					v = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(v, {
					header: a.name,
					key: `axes_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(g, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(f, {
							label: "Line Color"
						}, {
							default: withCtx(() => [createVNode(d, {
								"model-value": a
									.modelValue
									.lineColor,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[1] || (l[
									1] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											lineColor: y
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(f, {
							label: "Show Line"
						}, {
							default: withCtx(() => [createVNode(m, {
								"model-value": a
									.modelValue
									.showLines,
								onChange: l[2] || (l[
									2] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											showLines: y
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(f, {
							label: "Show Label"
						}, {
							default: withCtx(() => [createVNode(m, {
								"model-value": a
									.modelValue
									.showLabels,
								onChange: l[3] || (l[
									3] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											showLabels: y
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), (openBlock(!0), createElementBlock(Fragment,
							null, renderList(a.fixedFrames, y => (
								openBlock(), createBlock(f, {
									label: y,
									key: y
								}, {
									default: withCtx(() => [
										createVNode(m, {
												"model-value": a
													.modelValue
													.frameVisible[
														y
														],
												"default-checked":
													!0,
												onChange: b =>
													a
													.$emit(
														"update:modelValue", {
															...
															s
															.modelValue,
															frameVisible: {
																...
																s
																.modelValue
																.frameVisible,
																[
																	y]: b
															}
														}
														)
											}, null, 8,
											["model-value",
												"onChange"
											])
									]),
									_: 2
								}, 1032, ["label"]))), 128))]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$d = defineComponent({
		__name: "MarkerArrayOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-form"),
					v = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(v, {
					header: a.name,
					key: `laser_scan_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(g, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: y
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													y =>
													y
													.schemaName ===
													"visualization_msgs/MarkerArray" ||
													y
													.schemaName ===
													"visualization_msgs/msg/MarkerArray"
													),
												y =>
												(openBlock(),
													createBlock(
														d, {
															value: y
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			y
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$c = defineComponent({
		__name: "ImageOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-form"),
					v = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(v, {
					header: a.name,
					key: `image_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(g, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: y
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													y =>
													y
													.schemaName ===
													"sensor_msgs/Image" ||
													y
													.schemaName ===
													"sensor_msgs/msg/Image"
													),
												y =>
												(openBlock(),
													createBlock(
														d, {
															value: y
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			y
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$b = defineComponent({
		__name: "PointCloud2Options",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-input-number"),
					v = resolveComponent("a-color-picker"),
					y = resolveComponent("a-form"),
					b = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(b, {
					header: a.name,
					key: `point_cloud2_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(y, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: C
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													C =>
													C
													.schemaName ===
													"sensor_msgs/PointCloud2" ||
													C
													.schemaName ===
													"sensor_msgs/msg/PointCloud2"
													),
												C =>
												(openBlock(),
													createBlock(
														d, {
															value: C
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			C
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Size"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.size,
								min: .01,
								step: .01,
								onChange: l[2] || (l[
									2] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											size: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Decay Time"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue
									.decayTime,
								min: 0,
								onChange: l[3] || (l[
									3] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											decayTime: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Max Point Count"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue
									.max_point_count,
								min: 0,
								step: 1e4,
								onChange: l[4] || (l[
									4] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											max_point_count: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), a.modelValue.colorType === "FlatColor" ? (
							openBlock(), createBlock(m, {
								key: 0,
								label: "Color"
							}, {
								default: withCtx(() => [createVNode(v, {
									"model-value": a
										.modelValue
										.color,
									format: "hex",
									"disabled-alpha": "",
									onChange: l[5] || (
										l[5] = C =>
										a.$emit(
											"update:modelValue", {
												...s
												.modelValue,
												color: C
											}))
								}, null, 8, [
									"model-value"
								])]),
								_: 1
							})) : createCommentVNode("", !0), createVNode(
						m, {
							label: "Color Scheme"
						}, {
							default: withCtx(() => [createVNode(f, {
								"model-value": a
									.modelValue
									.colorType,
								onChange: l[6] || (l[
									6] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											colorType: C
										}))
							}, {
								default: withCtx(() => [
									createVNode(
										d, {
											value: "FlatColor"
										}, {
											default: withCtx(
												() =>
												l[
													7] ||
												(l[7] = [
													createTextVNode(
														"FlatColor"
														)
												])
												),
											_: 1
										}),
									createVNode(
										d, {
											value: "RGB8"
										}, {
											default: withCtx(
												() =>
												l[
													8] ||
												(l[8] = [
													createTextVNode(
														"RGB8"
														)
												])
												),
											_: 1
										})
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$a = defineComponent({
		__name: "OccupancyGridOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-input-number"),
					v = resolveComponent("a-form"),
					y = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(y, {
					header: a.name,
					key: `laser_scan_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(v, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: b
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													b =>
													b
													.schemaName ===
													"nav_msgs/OccupancyGrid" ||
													b
													.schemaName ===
													"nav_msgs/msg/OccupancyGrid"
													),
												b =>
												(openBlock(),
													createBlock(
														d, {
															value: b
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			b
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Opacity"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.opacity,
								min: .1,
								step: .1,
								onChange: l[2] || (l[
									2] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											opacity: b
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color Scheme"
						}, {
							default: withCtx(() => [createVNode(f, {
								"model-value": a
									.modelValue.type,
								onChange: l[3] || (l[
									3] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											type: b
										}))
							}, {
								default: withCtx(() => [
									createVNode(
										d, {
											value: "map"
										}, {
											default: withCtx(
												() =>
												l[
													4] ||
												(l[4] = [
													createTextVNode(
														"map"
														)
												])
												),
											_: 1
										}),
									createVNode(
										d, {
											value: "costmap"
										}, {
											default: withCtx(
												() =>
												l[
													5] ||
												(l[5] = [
													createTextVNode(
														"costmap"
														)
												])
												),
											_: 1
										}),
									createVNode(
										d, {
											value: "raw"
										}, {
											default: withCtx(
												() =>
												l[
													6] ||
												(l[6] = [
													createTextVNode(
														"raw"
														)
												])
												),
											_: 1
										})
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$9 = defineComponent({
		__name: "PathOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-color-picker"),
					v = resolveComponent("a-form"),
					y = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(y, {
					header: a.name,
					key: `path_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(v, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: b
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													b =>
													b
													.schemaName ===
													"nav_msgs/Path" ||
													b
													.schemaName ===
													"nav_msgs/msg/Path"
													),
												b =>
												(openBlock(),
													createBlock(
														d, {
															value: b
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			b
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[2] || (l[
									2] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: b
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$8 = defineComponent({
		__name: "PointStampedOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-color-picker"),
					v = resolveComponent("a-input-number"),
					y = resolveComponent("a-form"),
					b = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(b, {
					header: a.name,
					key: `point_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(y, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: C
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													C =>
													C
													.schemaName ===
													"nav_msgs/Path" ||
													C
													.schemaName ===
													"nav_msgs/msg/Path"
													),
												C =>
												(openBlock(),
													createBlock(
														d, {
															value: C
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			C
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[2] || (l[
									2] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Radius"
						}, {
							default: withCtx(() => [createVNode(v, {
								"model-value": a
									.modelValue.radius,
								min: .1,
								step: .1,
								onChange: l[3] || (l[
									3] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											radius: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Offset Z"
						}, {
							default: withCtx(() => [createVNode(v, {
								"model-value": a
									.modelValue.offsetZ,
								min: .01,
								step: .1,
								onChange: l[4] || (l[
									4] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											offsetZ: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$7 = defineComponent({
		__name: "PolygonStampedOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-color-picker"),
					v = resolveComponent("a-form"),
					y = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(y, {
					header: a.name,
					key: `polygon_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(v, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: b
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													b =>
													b
													.schemaName ===
													"geometry_msgs/PolygonStamped" ||
													b
													.schemaName ===
													"geometry_msgs/msg/PolygonStamped"
													),
												b =>
												(openBlock(),
													createBlock(
														d, {
															value: b
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			b
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[2] || (l[
									2] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: b
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$6 = defineComponent({
		__name: "PoseStampedOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-color-picker"),
					v = resolveComponent("a-form"),
					y = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(y, {
					header: a.name,
					key: `pose_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(v, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: b
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													b =>
													b
													.schemaName ===
													"nav_msgs/Path" ||
													b
													.schemaName ===
													"nav_msgs/msg/Path"
													),
												b =>
												(openBlock(),
													createBlock(
														d, {
															value: b
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			b
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[2] || (l[
									2] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: b
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$5 = defineComponent({
		__name: "PoseArrayOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-color-picker"),
					v = resolveComponent("a-input-number"),
					y = resolveComponent("a-form"),
					b = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(b, {
					header: a.name,
					key: `pose_array_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(y, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: C
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													C =>
													C
													.schemaName ===
													"nav_msgs/Path" ||
													C
													.schemaName ===
													"nav_msgs/msg/Path"
													),
												C =>
												(openBlock(),
													createBlock(
														d, {
															value: C
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			C
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[2] || (l[
									2] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Length"
						}, {
							default: withCtx(() => [createVNode(v, {
								"model-value": a
									.modelValue.length,
								min: .1,
								step: .1,
								onChange: l[3] || (l[
									3] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											length: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$4 = defineComponent({
		__name: "PoseWithCovarianceStampedOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-color-picker"),
					v = resolveComponent("a-form"),
					y = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(y, {
					header: a.name,
					key: `pose_with_covariance_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(v, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: b
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													b =>
													b
													.schemaName ===
													"nav_msgs/Path" ||
													b
													.schemaName ===
													"nav_msgs/msg/Path"
													),
												b =>
												(openBlock(),
													createBlock(
														d, {
															value: b
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			b
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[2] || (l[
									2] = b => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: b
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$3 = defineComponent({
		__name: "URDFOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			return (s, a) => {
				const l = resolveComponent("a-button"),
					c = resolveComponent("a-form"),
					d = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(d, {
					header: s.name,
					key: `urdf_${s.index}`
				}, {
					extra: withCtx(() => [createVNode(l, {
						type: "text",
						size: "mini",
						onClick: a[0] || (a[0] = withModifiers(() => s.$emit(
							"update:show", !s.show), ["stop"]))
					}, {
						icon: withCtx(() => [s.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(c, {
						model: s.modelValue,
						"auto-label-width": ""
					}, null, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	_sfc_main$2 = defineComponent({
		__name: "LaserScanOptions",
		props: {
			show: {
				type: Boolean
			},
			topics: {},
			name: {},
			modelValue: {},
			index: {}
		},
		emits: ["update:modelValue", "update:show"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-button"),
					d = resolveComponent("a-option"),
					f = resolveComponent("a-select"),
					m = resolveComponent("a-form-item"),
					g = resolveComponent("a-input-number"),
					v = resolveComponent("a-color-picker"),
					y = resolveComponent("a-form"),
					b = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(b, {
					header: a.name,
					key: `laser_scan_${a.index}`
				}, {
					extra: withCtx(() => [createVNode(c, {
						type: "text",
						size: "mini",
						onClick: l[0] || (l[0] = withModifiers(() => a.$emit(
							"update:show", !a.show), ["stop"]))
					}, {
						icon: withCtx(() => [a.show ? (openBlock(), createBlock(unref(
							Eye), {
							key: 0,
							size: 16
						})) : (openBlock(), createBlock(unref(EyeOff), {
							key: 1,
							size: 16
						}))]),
						_: 1
					})]),
					default: withCtx(() => [createVNode(y, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(m, {
							label: "Topic"
						}, {
							default: withCtx(() => [createVNode(f, {
								disabled: "",
								"trigger-props": {
									autoFitPopupMinWidth:
										!0
								},
								"model-value": a
									.modelValue.topic,
								onChange: l[1] || (l[
									1] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											topic: C
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												Object
												.values(
													a
													.topics
													)
												.filter(
													C =>
													C
													.schemaName ===
													"sensor_msgs/LaserScan" ||
													C
													.schemaName ===
													"sensor_msgs/msg/LaserScan"
													),
												C =>
												(openBlock(),
													createBlock(
														d, {
															value: C
																.topic
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			C
																			.topic
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											256)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Size"
						}, {
							default: withCtx(() => [createVNode(g, {
								"model-value": a
									.modelValue.size,
								min: .01,
								step: .01,
								onChange: l[2] || (l[
									2] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											size: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						}), createVNode(m, {
							label: "Color"
						}, {
							default: withCtx(() => [createVNode(v, {
								"model-value": a
									.modelValue.color,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[3] || (l[
									3] = C => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											color: C
										}))
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				}, 8, ["header"])
			}
		}
	}),
	OptionComponents = {
		Grid: _sfc_main$g,
		Axes: _sfc_main$f,
		TF: _sfc_main$e,
		URDF: _sfc_main$3,
		MarkerArray: _sfc_main$d,
		Image: _sfc_main$c,
		LaserScan: _sfc_main$2,
		PointCloud2: _sfc_main$b,
		OccupancyGrid: _sfc_main$a,
		Path: _sfc_main$9,
		PointStamped: _sfc_main$8,
		PolygonStamped: _sfc_main$7,
		PoseStamped: _sfc_main$6,
		PoseArray: _sfc_main$5,
		PoseWithCovarianceStamped: _sfc_main$4
	};
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "176",
	MOUSE = {
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	},
	TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	},
	CullFaceNone = 0,
	CullFaceBack = 1,
	CullFaceFront = 2,
	PCFShadowMap = 1,
	PCFSoftShadowMap = 2,
	VSMShadowMap = 3,
	FrontSide = 0,
	BackSide = 1,
	DoubleSide = 2,
	NoBlending = 0,
	NormalBlending = 1,
	AdditiveBlending = 2,
	SubtractiveBlending = 3,
	MultiplyBlending = 4,
	CustomBlending = 5,
	AddEquation = 100,
	SubtractEquation = 101,
	ReverseSubtractEquation = 102,
	MinEquation = 103,
	MaxEquation = 104,
	ZeroFactor = 200,
	OneFactor = 201,
	SrcColorFactor = 202,
	OneMinusSrcColorFactor = 203,
	SrcAlphaFactor = 204,
	OneMinusSrcAlphaFactor = 205,
	DstAlphaFactor = 206,
	OneMinusDstAlphaFactor = 207,
	DstColorFactor = 208,
	OneMinusDstColorFactor = 209,
	SrcAlphaSaturateFactor = 210,
	ConstantColorFactor = 211,
	OneMinusConstantColorFactor = 212,
	ConstantAlphaFactor = 213,
	OneMinusConstantAlphaFactor = 214,
	NeverDepth = 0,
	AlwaysDepth = 1,
	LessDepth = 2,
	LessEqualDepth = 3,
	EqualDepth = 4,
	GreaterEqualDepth = 5,
	GreaterDepth = 6,
	NotEqualDepth = 7,
	MultiplyOperation = 0,
	MixOperation = 1,
	AddOperation = 2,
	NoToneMapping = 0,
	LinearToneMapping = 1,
	ReinhardToneMapping = 2,
	CineonToneMapping = 3,
	ACESFilmicToneMapping = 4,
	CustomToneMapping = 5,
	AgXToneMapping = 6,
	NeutralToneMapping = 7,
	AttachedBindMode = "attached",
	DetachedBindMode = "detached",
	UVMapping = 300,
	CubeReflectionMapping = 301,
	CubeRefractionMapping = 302,
	EquirectangularReflectionMapping = 303,
	EquirectangularRefractionMapping = 304,
	CubeUVReflectionMapping = 306,
	RepeatWrapping = 1e3,
	ClampToEdgeWrapping = 1001,
	MirroredRepeatWrapping = 1002,
	NearestFilter = 1003,
	NearestMipmapNearestFilter = 1004,
	NearestMipmapLinearFilter = 1005,
	LinearFilter = 1006,
	LinearMipmapNearestFilter = 1007,
	LinearMipmapLinearFilter = 1008,
	UnsignedByteType = 1009,
	ByteType = 1010,
	ShortType = 1011,
	UnsignedShortType = 1012,
	IntType = 1013,
	UnsignedIntType = 1014,
	FloatType = 1015,
	HalfFloatType = 1016,
	UnsignedShort4444Type = 1017,
	UnsignedShort5551Type = 1018,
	UnsignedInt248Type = 1020,
	UnsignedInt5999Type = 35902,
	AlphaFormat = 1021,
	RGBFormat = 1022,
	RGBAFormat = 1023,
	DepthFormat = 1026,
	DepthStencilFormat = 1027,
	RedFormat = 1028,
	RedIntegerFormat = 1029,
	RGFormat = 1030,
	RGIntegerFormat = 1031,
	RGBAIntegerFormat = 1033,
	RGB_S3TC_DXT1_Format = 33776,
	RGBA_S3TC_DXT1_Format = 33777,
	RGBA_S3TC_DXT3_Format = 33778,
	RGBA_S3TC_DXT5_Format = 33779,
	RGB_PVRTC_4BPPV1_Format = 35840,
	RGB_PVRTC_2BPPV1_Format = 35841,
	RGBA_PVRTC_4BPPV1_Format = 35842,
	RGBA_PVRTC_2BPPV1_Format = 35843,
	RGB_ETC1_Format = 36196,
	RGB_ETC2_Format = 37492,
	RGBA_ETC2_EAC_Format = 37496,
	RGBA_ASTC_4x4_Format = 37808,
	RGBA_ASTC_5x4_Format = 37809,
	RGBA_ASTC_5x5_Format = 37810,
	RGBA_ASTC_6x5_Format = 37811,
	RGBA_ASTC_6x6_Format = 37812,
	RGBA_ASTC_8x5_Format = 37813,
	RGBA_ASTC_8x6_Format = 37814,
	RGBA_ASTC_8x8_Format = 37815,
	RGBA_ASTC_10x5_Format = 37816,
	RGBA_ASTC_10x6_Format = 37817,
	RGBA_ASTC_10x8_Format = 37818,
	RGBA_ASTC_10x10_Format = 37819,
	RGBA_ASTC_12x10_Format = 37820,
	RGBA_ASTC_12x12_Format = 37821,
	RGBA_BPTC_Format = 36492,
	RGB_BPTC_SIGNED_Format = 36494,
	RGB_BPTC_UNSIGNED_Format = 36495,
	RED_RGTC1_Format = 36283,
	SIGNED_RED_RGTC1_Format = 36284,
	RED_GREEN_RGTC2_Format = 36285,
	SIGNED_RED_GREEN_RGTC2_Format = 36286,
	InterpolateDiscrete = 2300,
	InterpolateLinear = 2301,
	InterpolateSmooth = 2302,
	ZeroCurvatureEnding = 2400,
	ZeroSlopeEnding = 2401,
	WrapAroundEnding = 2402,
	NormalAnimationBlendMode = 2500,
	BasicDepthPacking = 3200,
	RGBADepthPacking = 3201,
	TangentSpaceNormalMap = 0,
	ObjectSpaceNormalMap = 1,
	NoColorSpace = "",
	SRGBColorSpace = "srgb",
	LinearSRGBColorSpace = "srgb-linear",
	LinearTransfer = "linear",
	SRGBTransfer = "srgb",
	KeepStencilOp = 7680,
	AlwaysStencilFunc = 519,
	NeverCompare = 512,
	LessCompare = 513,
	EqualCompare = 514,
	LessEqualCompare = 515,
	GreaterCompare = 516,
	NotEqualCompare = 517,
	GreaterEqualCompare = 518,
	AlwaysCompare = 519,
	StaticDrawUsage = 35044,
	GLSL3 = "300 es",
	WebGLCoordinateSystem = 2e3,
	WebGPUCoordinateSystem = 2001;
class EventDispatcher {
	addEventListener(s, a) {
		this._listeners === void 0 && (this._listeners = {});
		const l = this._listeners;
		l[s] === void 0 && (l[s] = []), l[s].indexOf(a) === -1 && l[s].push(a)
	}
	hasEventListener(s, a) {
		const l = this._listeners;
		return l === void 0 ? !1 : l[s] !== void 0 && l[s].indexOf(a) !== -1
	}
	removeEventListener(s, a) {
		const l = this._listeners;
		if (l === void 0) return;
		const c = l[s];
		if (c !== void 0) {
			const d = c.indexOf(a);
			d !== -1 && c.splice(d, 1)
		}
	}
	dispatchEvent(s) {
		const a = this._listeners;
		if (a === void 0) return;
		const l = a[s.type];
		if (l !== void 0) {
			s.target = this;
			const c = l.slice(0);
			for (let d = 0, f = c.length; d < f; d++) c[d].call(this, s);
			s.target = null
		}
	}
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10",
	"11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22",
	"23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34",
	"35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46",
	"47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58",
	"59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a",
	"6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c",
	"7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e",
	"8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0",
	"a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2",
	"b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4",
	"c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6",
	"d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8",
	"e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa",
	"fb", "fc", "fd", "fe", "ff"
];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180,
	RAD2DEG = 180 / Math.PI;

function generateUUID() {
	const o = Math.random() * 4294967295 | 0,
		s = Math.random() * 4294967295 | 0,
		a = Math.random() * 4294967295 | 0,
		l = Math.random() * 4294967295 | 0;
	return (_lut[o & 255] + _lut[o >> 8 & 255] + _lut[o >> 16 & 255] + _lut[o >> 24 & 255] + "-" + _lut[s & 255] + _lut[
			s >> 8 & 255] + "-" + _lut[s >> 16 & 15 | 64] + _lut[s >> 24 & 255] + "-" + _lut[a & 63 | 128] + _lut[
			a >> 8 & 255] + "-" + _lut[a >> 16 & 255] + _lut[a >> 24 & 255] + _lut[l & 255] + _lut[l >> 8 & 255] +
		_lut[l >> 16 & 255] + _lut[l >> 24 & 255]).toLowerCase()
}

function clamp$1(o, s, a) {
	return Math.max(s, Math.min(a, o))
}

function euclideanModulo(o, s) {
	return (o % s + s) % s
}

function mapLinear(o, s, a, l, c) {
	return l + (o - s) * (c - l) / (a - s)
}

function inverseLerp(o, s, a) {
	return o !== s ? (a - o) / (s - o) : 0
}

function lerp(o, s, a) {
	return (1 - a) * o + a * s
}

function damp(o, s, a, l) {
	return lerp(o, s, 1 - Math.exp(-a * l))
}

function pingpong(o, s = 1) {
	return s - Math.abs(euclideanModulo(o, s * 2) - s)
}

function smoothstep(o, s, a) {
	return o <= s ? 0 : o >= a ? 1 : (o = (o - s) / (a - s), o * o * (3 - 2 * o))
}

function smootherstep(o, s, a) {
	return o <= s ? 0 : o >= a ? 1 : (o = (o - s) / (a - s), o * o * o * (o * (o * 6 - 15) + 10))
}

function randInt(o, s) {
	return o + Math.floor(Math.random() * (s - o + 1))
}

function randFloat(o, s) {
	return o + Math.random() * (s - o)
}

function randFloatSpread(o) {
	return o * (.5 - Math.random())
}

function seededRandom(o) {
	o !== void 0 && (_seed = o);
	let s = _seed += 1831565813;
	return s = Math.imul(s ^ s >>> 15, s | 1), s ^= s + Math.imul(s ^ s >>> 7, s | 61), ((s ^ s >>> 14) >>> 0) /
		4294967296
}

function degToRad(o) {
	return o * DEG2RAD
}

function radToDeg(o) {
	return o * RAD2DEG
}

function isPowerOfTwo(o) {
	return (o & o - 1) === 0 && o !== 0
}

function ceilPowerOfTwo(o) {
	return Math.pow(2, Math.ceil(Math.log(o) / Math.LN2))
}

function floorPowerOfTwo(o) {
	return Math.pow(2, Math.floor(Math.log(o) / Math.LN2))
}

function setQuaternionFromProperEuler(o, s, a, l, c) {
	const d = Math.cos,
		f = Math.sin,
		m = d(a / 2),
		g = f(a / 2),
		v = d((s + l) / 2),
		y = f((s + l) / 2),
		b = d((s - l) / 2),
		C = f((s - l) / 2),
		_ = d((l - s) / 2),
		S = f((l - s) / 2);
	switch (c) {
		case "XYX":
			o.set(m * y, g * b, g * C, m * v);
			break;
		case "YZY":
			o.set(g * C, m * y, g * b, m * v);
			break;
		case "ZXZ":
			o.set(g * b, g * C, m * y, m * v);
			break;
		case "XZX":
			o.set(m * y, g * S, g * _, m * v);
			break;
		case "YXY":
			o.set(g * _, m * y, g * S, m * v);
			break;
		case "ZYZ":
			o.set(g * S, g * _, m * y, m * v);
			break;
		default:
			console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + c)
	}
}

function denormalize(o, s) {
	switch (s.constructor) {
		case Float32Array:
			return o;
		case Uint32Array:
			return o / 4294967295;
		case Uint16Array:
			return o / 65535;
		case Uint8Array:
			return o / 255;
		case Int32Array:
			return Math.max(o / 2147483647, -1);
		case Int16Array:
			return Math.max(o / 32767, -1);
		case Int8Array:
			return Math.max(o / 127, -1);
		default:
			throw new Error("Invalid component type.")
	}
}

function normalize(o, s) {
	switch (s.constructor) {
		case Float32Array:
			return o;
		case Uint32Array:
			return Math.round(o * 4294967295);
		case Uint16Array:
			return Math.round(o * 65535);
		case Uint8Array:
			return Math.round(o * 255);
		case Int32Array:
			return Math.round(o * 2147483647);
		case Int16Array:
			return Math.round(o * 32767);
		case Int8Array:
			return Math.round(o * 127);
		default:
			throw new Error("Invalid component type.")
	}
}
const MathUtils = {
	DEG2RAD,
	RAD2DEG,
	generateUUID,
	clamp: clamp$1,
	euclideanModulo,
	mapLinear,
	inverseLerp,
	lerp,
	damp,
	pingpong,
	smoothstep,
	smootherstep,
	randInt,
	randFloat,
	randFloatSpread,
	seededRandom,
	degToRad,
	radToDeg,
	isPowerOfTwo,
	ceilPowerOfTwo,
	floorPowerOfTwo,
	setQuaternionFromProperEuler,
	normalize,
	denormalize
};
class Vector2 {
	constructor(s = 0, a = 0) {
		Vector2.prototype.isVector2 = !0, this.x = s, this.y = a
	}
	get width() {
		return this.x
	}
	set width(s) {
		this.x = s
	}
	get height() {
		return this.y
	}
	set height(s) {
		this.y = s
	}
	set(s, a) {
		return this.x = s, this.y = a, this
	}
	setScalar(s) {
		return this.x = s, this.y = s, this
	}
	setX(s) {
		return this.x = s, this
	}
	setY(s) {
		return this.y = s, this
	}
	setComponent(s, a) {
		switch (s) {
			case 0:
				this.x = a;
				break;
			case 1:
				this.y = a;
				break;
			default:
				throw new Error("index is out of range: " + s)
		}
		return this
	}
	getComponent(s) {
		switch (s) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw new Error("index is out of range: " + s)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y)
	}
	copy(s) {
		return this.x = s.x, this.y = s.y, this
	}
	add(s) {
		return this.x += s.x, this.y += s.y, this
	}
	addScalar(s) {
		return this.x += s, this.y += s, this
	}
	addVectors(s, a) {
		return this.x = s.x + a.x, this.y = s.y + a.y, this
	}
	addScaledVector(s, a) {
		return this.x += s.x * a, this.y += s.y * a, this
	}
	sub(s) {
		return this.x -= s.x, this.y -= s.y, this
	}
	subScalar(s) {
		return this.x -= s, this.y -= s, this
	}
	subVectors(s, a) {
		return this.x = s.x - a.x, this.y = s.y - a.y, this
	}
	multiply(s) {
		return this.x *= s.x, this.y *= s.y, this
	}
	multiplyScalar(s) {
		return this.x *= s, this.y *= s, this
	}
	divide(s) {
		return this.x /= s.x, this.y /= s.y, this
	}
	divideScalar(s) {
		return this.multiplyScalar(1 / s)
	}
	applyMatrix3(s) {
		const a = this.x,
			l = this.y,
			c = s.elements;
		return this.x = c[0] * a + c[3] * l + c[6], this.y = c[1] * a + c[4] * l + c[7], this
	}
	min(s) {
		return this.x = Math.min(this.x, s.x), this.y = Math.min(this.y, s.y), this
	}
	max(s) {
		return this.x = Math.max(this.x, s.x), this.y = Math.max(this.y, s.y), this
	}
	clamp(s, a) {
		return this.x = clamp$1(this.x, s.x, a.x), this.y = clamp$1(this.y, s.y, a.y), this
	}
	clampScalar(s, a) {
		return this.x = clamp$1(this.x, s, a), this.y = clamp$1(this.y, s, a), this
	}
	clampLength(s, a) {
		const l = this.length();
		return this.divideScalar(l || 1).multiplyScalar(clamp$1(l, s, a))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this
	}
	dot(s) {
		return this.x * s.x + this.y * s.y
	}
	cross(s) {
		return this.x * s.y - this.y * s.x
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	angle() {
		return Math.atan2(-this.y, -this.x) + Math.PI
	}
	angleTo(s) {
		const a = Math.sqrt(this.lengthSq() * s.lengthSq());
		if (a === 0) return Math.PI / 2;
		const l = this.dot(s) / a;
		return Math.acos(clamp$1(l, -1, 1))
	}
	distanceTo(s) {
		return Math.sqrt(this.distanceToSquared(s))
	}
	distanceToSquared(s) {
		const a = this.x - s.x,
			l = this.y - s.y;
		return a * a + l * l
	}
	manhattanDistanceTo(s) {
		return Math.abs(this.x - s.x) + Math.abs(this.y - s.y)
	}
	setLength(s) {
		return this.normalize().multiplyScalar(s)
	}
	lerp(s, a) {
		return this.x += (s.x - this.x) * a, this.y += (s.y - this.y) * a, this
	}
	lerpVectors(s, a, l) {
		return this.x = s.x + (a.x - s.x) * l, this.y = s.y + (a.y - s.y) * l, this
	}
	equals(s) {
		return s.x === this.x && s.y === this.y
	}
	fromArray(s, a = 0) {
		return this.x = s[a], this.y = s[a + 1], this
	}
	toArray(s = [], a = 0) {
		return s[a] = this.x, s[a + 1] = this.y, s
	}
	fromBufferAttribute(s, a) {
		return this.x = s.getX(a), this.y = s.getY(a), this
	}
	rotateAround(s, a) {
		const l = Math.cos(a),
			c = Math.sin(a),
			d = this.x - s.x,
			f = this.y - s.y;
		return this.x = d * l - f * c + s.x, this.y = d * c + f * l + s.y, this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y
	}
}
class Matrix3 {
	constructor(s, a, l, c, d, f, m, g, v) {
		Matrix3.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], s !== void 0 && this.set(s,
			a, l, c, d, f, m, g, v)
	}
	set(s, a, l, c, d, f, m, g, v) {
		const y = this.elements;
		return y[0] = s, y[1] = c, y[2] = m, y[3] = a, y[4] = d, y[5] = g, y[6] = l, y[7] = f, y[8] = v, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
	}
	copy(s) {
		const a = this.elements,
			l = s.elements;
		return a[0] = l[0], a[1] = l[1], a[2] = l[2], a[3] = l[3], a[4] = l[4], a[5] = l[5], a[6] = l[6], a[7] = l[
			7], a[8] = l[8], this
	}
	extractBasis(s, a, l) {
		return s.setFromMatrix3Column(this, 0), a.setFromMatrix3Column(this, 1), l.setFromMatrix3Column(this, 2),
			this
	}
	setFromMatrix4(s) {
		const a = s.elements;
		return this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), this
	}
	multiply(s) {
		return this.multiplyMatrices(this, s)
	}
	premultiply(s) {
		return this.multiplyMatrices(s, this)
	}
	multiplyMatrices(s, a) {
		const l = s.elements,
			c = a.elements,
			d = this.elements,
			f = l[0],
			m = l[3],
			g = l[6],
			v = l[1],
			y = l[4],
			b = l[7],
			C = l[2],
			_ = l[5],
			S = l[8],
			w = c[0],
			T = c[3],
			A = c[6],
			k = c[1],
			M = c[4],
			D = c[7],
			F = c[2],
			R = c[5],
			O = c[8];
		return d[0] = f * w + m * k + g * F, d[3] = f * T + m * M + g * R, d[6] = f * A + m * D + g * O, d[1] = v *
			w + y * k + b * F, d[4] = v * T + y * M + b * R, d[7] = v * A + y * D + b * O, d[2] = C * w + _ * k +
			S * F, d[5] = C * T + _ * M + S * R, d[8] = C * A + _ * D + S * O, this
	}
	multiplyScalar(s) {
		const a = this.elements;
		return a[0] *= s, a[3] *= s, a[6] *= s, a[1] *= s, a[4] *= s, a[7] *= s, a[2] *= s, a[5] *= s, a[8] *= s,
			this
	}
	determinant() {
		const s = this.elements,
			a = s[0],
			l = s[1],
			c = s[2],
			d = s[3],
			f = s[4],
			m = s[5],
			g = s[6],
			v = s[7],
			y = s[8];
		return a * f * y - a * m * v - l * d * y + l * m * g + c * d * v - c * f * g
	}
	invert() {
		const s = this.elements,
			a = s[0],
			l = s[1],
			c = s[2],
			d = s[3],
			f = s[4],
			m = s[5],
			g = s[6],
			v = s[7],
			y = s[8],
			b = y * f - m * v,
			C = m * g - y * d,
			_ = v * d - f * g,
			S = a * b + l * C + c * _;
		if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const w = 1 / S;
		return s[0] = b * w, s[1] = (c * v - y * l) * w, s[2] = (m * l - c * f) * w, s[3] = C * w, s[4] = (y * a -
			c * g) * w, s[5] = (c * d - m * a) * w, s[6] = _ * w, s[7] = (l * g - v * a) * w, s[8] = (f * a -
			l * d) * w, this
	}
	transpose() {
		let s;
		const a = this.elements;
		return s = a[1], a[1] = a[3], a[3] = s, s = a[2], a[2] = a[6], a[6] = s, s = a[5], a[5] = a[7], a[7] = s,
			this
	}
	getNormalMatrix(s) {
		return this.setFromMatrix4(s).invert().transpose()
	}
	transposeIntoArray(s) {
		const a = this.elements;
		return s[0] = a[0], s[1] = a[3], s[2] = a[6], s[3] = a[1], s[4] = a[4], s[5] = a[7], s[6] = a[2], s[7] = a[
			5], s[8] = a[8], this
	}
	setUvTransform(s, a, l, c, d, f, m) {
		const g = Math.cos(d),
			v = Math.sin(d);
		return this.set(l * g, l * v, -l * (g * f + v * m) + f + s, -c * v, c * g, -c * (-v * f + g * m) + m + a, 0,
			0, 1), this
	}
	scale(s, a) {
		return this.premultiply(_m3.makeScale(s, a)), this
	}
	rotate(s) {
		return this.premultiply(_m3.makeRotation(-s)), this
	}
	translate(s, a) {
		return this.premultiply(_m3.makeTranslation(s, a)), this
	}
	makeTranslation(s, a) {
		return s.isVector2 ? this.set(1, 0, s.x, 0, 1, s.y, 0, 0, 1) : this.set(1, 0, s, 0, 1, a, 0, 0, 1), this
	}
	makeRotation(s) {
		const a = Math.cos(s),
			l = Math.sin(s);
		return this.set(a, -l, 0, l, a, 0, 0, 0, 1), this
	}
	makeScale(s, a) {
		return this.set(s, 0, 0, 0, a, 0, 0, 0, 1), this
	}
	equals(s) {
		const a = this.elements,
			l = s.elements;
		for (let c = 0; c < 9; c++)
			if (a[c] !== l[c]) return !1;
		return !0
	}
	fromArray(s, a = 0) {
		for (let l = 0; l < 9; l++) this.elements[l] = s[l + a];
		return this
	}
	toArray(s = [], a = 0) {
		const l = this.elements;
		return s[a] = l[0], s[a + 1] = l[1], s[a + 2] = l[2], s[a + 3] = l[3], s[a + 4] = l[4], s[a + 5] = l[5], s[
			a + 6] = l[6], s[a + 7] = l[7], s[a + 8] = l[8], s
	}
	clone() {
		return new this.constructor().fromArray(this.elements)
	}
}
const _m3 = new Matrix3;

function arrayNeedsUint32(o) {
	for (let s = o.length - 1; s >= 0; --s)
		if (o[s] >= 65535) return !0;
	return !1
}

function createElementNS(o) {
	return document.createElementNS("http://www.w3.org/1999/xhtml", o)
}

function createCanvasElement() {
	const o = createElementNS("canvas");
	return o.style.display = "block", o
}
const _cache = {};

function warnOnce(o) {
	o in _cache || (_cache[o] = !0, console.warn(o))
}

function probeAsync(o, s, a) {
	return new Promise(function(l, c) {
		function d() {
			switch (o.clientWaitSync(s, o.SYNC_FLUSH_COMMANDS_BIT, 0)) {
				case o.WAIT_FAILED:
					c();
					break;
				case o.TIMEOUT_EXPIRED:
					setTimeout(d, a);
					break;
				default:
					l()
			}
		}
		setTimeout(d, a)
	})
}

function toNormalizedProjectionMatrix(o) {
	const s = o.elements;
	s[2] = .5 * s[2] + .5 * s[3], s[6] = .5 * s[6] + .5 * s[7], s[10] = .5 * s[10] + .5 * s[11], s[14] = .5 * s[14] +
		.5 * s[15]
}

function toReversedProjectionMatrix(o) {
	const s = o.elements;
	s[11] === -1 ? (s[10] = -s[10] - 1, s[14] = -s[14]) : (s[10] = -s[10], s[14] = -s[14] + 1)
}
const LINEAR_REC709_TO_XYZ = new Matrix3().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308,
		.1191948, .9505322),
	XYZ_TO_LINEAR_REC709 = new Matrix3().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301,
		-.203977, 1.0569715);

function createColorManagement() {
	const o = {
			enabled: !0,
			workingColorSpace: LinearSRGBColorSpace,
			spaces: {},
			convert: function(c, d, f) {
				return this.enabled === !1 || d === f || !d || !f || (this.spaces[d].transfer === SRGBTransfer && (c
					.r = SRGBToLinear(c.r), c.g = SRGBToLinear(c.g), c.b = SRGBToLinear(c.b)), this.spaces[
					d].primaries !== this.spaces[f].primaries && (c.applyMatrix3(this.spaces[d].toXYZ), c
					.applyMatrix3(this.spaces[f].fromXYZ)), this.spaces[f].transfer === SRGBTransfer && (c
					.r = LinearToSRGB(c.r), c.g = LinearToSRGB(c.g), c.b = LinearToSRGB(c.b))), c
			},
			fromWorkingColorSpace: function(c, d) {
				return this.convert(c, this.workingColorSpace, d)
			},
			toWorkingColorSpace: function(c, d) {
				return this.convert(c, d, this.workingColorSpace)
			},
			getPrimaries: function(c) {
				return this.spaces[c].primaries
			},
			getTransfer: function(c) {
				return c === NoColorSpace ? LinearTransfer : this.spaces[c].transfer
			},
			getLuminanceCoefficients: function(c, d = this.workingColorSpace) {
				return c.fromArray(this.spaces[d].luminanceCoefficients)
			},
			define: function(c) {
				Object.assign(this.spaces, c)
			},
			_getMatrix: function(c, d, f) {
				return c.copy(this.spaces[d].toXYZ).multiply(this.spaces[f].fromXYZ)
			},
			_getDrawingBufferColorSpace: function(c) {
				return this.spaces[c].outputColorSpaceConfig.drawingBufferColorSpace
			},
			_getUnpackColorSpace: function(c = this.workingColorSpace) {
				return this.spaces[c].workingColorSpaceConfig.unpackColorSpace
			}
		},
		s = [.64, .33, .3, .6, .15, .06],
		a = [.2126, .7152, .0722],
		l = [.3127, .329];
	return o.define({
		[LinearSRGBColorSpace]: {
			primaries: s,
			whitePoint: l,
			transfer: LinearTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: a,
			workingColorSpaceConfig: {
				unpackColorSpace: SRGBColorSpace
			},
			outputColorSpaceConfig: {
				drawingBufferColorSpace: SRGBColorSpace
			}
		},
		[SRGBColorSpace]: {
			primaries: s,
			whitePoint: l,
			transfer: SRGBTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: a,
			outputColorSpaceConfig: {
				drawingBufferColorSpace: SRGBColorSpace
			}
		}
	}), o
}
const ColorManagement = createColorManagement();

function SRGBToLinear(o) {
	return o < .04045 ? o * .0773993808 : Math.pow(o * .9478672986 + .0521327014, 2.4)
}

function LinearToSRGB(o) {
	return o < .0031308 ? o * 12.92 : 1.055 * Math.pow(o, .41666) - .055
}
let _canvas;
class ImageUtils {
	static getDataURL(s, a = "image/png") {
		if (/^data:/i.test(s.src) || typeof HTMLCanvasElement > "u") return s.src;
		let l;
		if (s instanceof HTMLCanvasElement) l = s;
		else {
			_canvas === void 0 && (_canvas = createElementNS("canvas")), _canvas.width = s.width, _canvas.height = s
				.height;
			const c = _canvas.getContext("2d");
			s instanceof ImageData ? c.putImageData(s, 0, 0) : c.drawImage(s, 0, 0, s.width, s.height), l = _canvas
		}
		return l.toDataURL(a)
	}
	static sRGBToLinear(s) {
		if (typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" &&
			s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap) {
			const a = createElementNS("canvas");
			a.width = s.width, a.height = s.height;
			const l = a.getContext("2d");
			l.drawImage(s, 0, 0, s.width, s.height);
			const c = l.getImageData(0, 0, s.width, s.height),
				d = c.data;
			for (let f = 0; f < d.length; f++) d[f] = SRGBToLinear(d[f] / 255) * 255;
			return l.putImageData(c, 0, 0), a
		} else if (s.data) {
			const a = s.data.slice(0);
			for (let l = 0; l < a.length; l++) a instanceof Uint8Array || a instanceof Uint8ClampedArray ? a[l] =
				Math.floor(SRGBToLinear(a[l] / 255) * 255) : a[l] = SRGBToLinear(a[l]);
			return {
				data: a,
				width: s.width,
				height: s.height
			}
		} else return console.warn(
				"THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
			s
	}
}
let _sourceId = 0;
class Source {
	constructor(s = null) {
		this.isSource = !0, Object.defineProperty(this, "id", {
			value: _sourceId++
		}), this.uuid = generateUUID(), this.data = s, this.dataReady = !0, this.version = 0
	}
	set needsUpdate(s) {
		s === !0 && this.version++
	}
	toJSON(s) {
		const a = s === void 0 || typeof s == "string";
		if (!a && s.images[this.uuid] !== void 0) return s.images[this.uuid];
		const l = {
				uuid: this.uuid,
				url: ""
			},
			c = this.data;
		if (c !== null) {
			let d;
			if (Array.isArray(c)) {
				d = [];
				for (let f = 0, m = c.length; f < m; f++) c[f].isDataTexture ? d.push(serializeImage(c[f].image)) :
					d.push(serializeImage(c[f]))
			} else d = serializeImage(c);
			l.url = d
		}
		return a || (s.images[this.uuid] = l), l
	}
}

function serializeImage(o) {
	return typeof HTMLImageElement < "u" && o instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" &&
		o instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && o instanceof ImageBitmap ? ImageUtils.getDataURL(
			o) : o.data ? {
			data: Array.from(o.data),
			width: o.width,
			height: o.height,
			type: o.data.constructor.name
		} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let _textureId = 0;
class Texture extends EventDispatcher {
	constructor(s = Texture.DEFAULT_IMAGE, a = Texture.DEFAULT_MAPPING, l = ClampToEdgeWrapping, c =
		ClampToEdgeWrapping, d = LinearFilter, f = LinearMipmapLinearFilter, m = RGBAFormat, g = UnsignedByteType,
		v = Texture.DEFAULT_ANISOTROPY, y = NoColorSpace) {
		super(), this.isTexture = !0, Object.defineProperty(this, "id", {
				value: _textureId++
			}), this.uuid = generateUUID(), this.name = "", this.source = new Source(s), this.mipmaps = [], this
			.mapping = a, this.channel = 0, this.wrapS = l, this.wrapT = c, this.magFilter = d, this.minFilter = f,
			this.anisotropy = v, this.format = m, this.internalFormat = null, this.type = g, this.offset =
			new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0,
			this.matrixAutoUpdate = !0, this.matrix = new Matrix3, this.generateMipmaps = !0, this
			.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = y, this
			.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this
			.isRenderTargetTexture = !1, this.isTextureArray = !1, this.pmremVersion = 0
	}
	get image() {
		return this.source.data
	}
	set image(s = null) {
		this.source.data = s
	}
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this
			.center.x, this.center.y)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(s) {
		return this.name = s.name, this.source = s.source, this.mipmaps = s.mipmaps.slice(0), this.mapping = s
			.mapping, this.channel = s.channel, this.wrapS = s.wrapS, this.wrapT = s.wrapT, this.magFilter = s
			.magFilter, this.minFilter = s.minFilter, this.anisotropy = s.anisotropy, this.format = s.format, this
			.internalFormat = s.internalFormat, this.type = s.type, this.offset.copy(s.offset), this.repeat.copy(s
				.repeat), this.center.copy(s.center), this.rotation = s.rotation, this.matrixAutoUpdate = s
			.matrixAutoUpdate, this.matrix.copy(s.matrix), this.generateMipmaps = s.generateMipmaps, this
			.premultiplyAlpha = s.premultiplyAlpha, this.flipY = s.flipY, this.unpackAlignment = s.unpackAlignment,
			this.colorSpace = s.colorSpace, this.renderTarget = s.renderTarget, this.isRenderTargetTexture = s
			.isRenderTargetTexture, this.isTextureArray = s.isTextureArray, this.userData = JSON.parse(JSON
				.stringify(s.userData)), this.needsUpdate = !0, this
	}
	toJSON(s) {
		const a = s === void 0 || typeof s == "string";
		if (!a && s.textures[this.uuid] !== void 0) return s.textures[this.uuid];
		const l = {
			metadata: {
				version: 4.6,
				type: "Texture",
				generator: "Texture.toJSON"
			},
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(s).uuid,
			mapping: this.mapping,
			channel: this.channel,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		return Object.keys(this.userData).length > 0 && (l.userData = this.userData), a || (s.textures[this.uuid] =
			l), l
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	transformUv(s) {
		if (this.mapping !== UVMapping) return s;
		if (s.applyMatrix3(this.matrix), s.x < 0 || s.x > 1) switch (this.wrapS) {
			case RepeatWrapping:
				s.x = s.x - Math.floor(s.x);
				break;
			case ClampToEdgeWrapping:
				s.x = s.x < 0 ? 0 : 1;
				break;
			case MirroredRepeatWrapping:
				Math.abs(Math.floor(s.x) % 2) === 1 ? s.x = Math.ceil(s.x) - s.x : s.x = s.x - Math.floor(s.x);
				break
		}
		if (s.y < 0 || s.y > 1) switch (this.wrapT) {
			case RepeatWrapping:
				s.y = s.y - Math.floor(s.y);
				break;
			case ClampToEdgeWrapping:
				s.y = s.y < 0 ? 0 : 1;
				break;
			case MirroredRepeatWrapping:
				Math.abs(Math.floor(s.y) % 2) === 1 ? s.y = Math.ceil(s.y) - s.y : s.y = s.y - Math.floor(s.y);
				break
		}
		return this.flipY && (s.y = 1 - s.y), s
	}
	set needsUpdate(s) {
		s === !0 && (this.version++, this.source.needsUpdate = !0)
	}
	set needsPMREMUpdate(s) {
		s === !0 && this.pmremVersion++
	}
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
	constructor(s = 0, a = 0, l = 0, c = 1) {
		Vector4.prototype.isVector4 = !0, this.x = s, this.y = a, this.z = l, this.w = c
	}
	get width() {
		return this.z
	}
	set width(s) {
		this.z = s
	}
	get height() {
		return this.w
	}
	set height(s) {
		this.w = s
	}
	set(s, a, l, c) {
		return this.x = s, this.y = a, this.z = l, this.w = c, this
	}
	setScalar(s) {
		return this.x = s, this.y = s, this.z = s, this.w = s, this
	}
	setX(s) {
		return this.x = s, this
	}
	setY(s) {
		return this.y = s, this
	}
	setZ(s) {
		return this.z = s, this
	}
	setW(s) {
		return this.w = s, this
	}
	setComponent(s, a) {
		switch (s) {
			case 0:
				this.x = a;
				break;
			case 1:
				this.y = a;
				break;
			case 2:
				this.z = a;
				break;
			case 3:
				this.w = a;
				break;
			default:
				throw new Error("index is out of range: " + s)
		}
		return this
	}
	getComponent(s) {
		switch (s) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw new Error("index is out of range: " + s)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w)
	}
	copy(s) {
		return this.x = s.x, this.y = s.y, this.z = s.z, this.w = s.w !== void 0 ? s.w : 1, this
	}
	add(s) {
		return this.x += s.x, this.y += s.y, this.z += s.z, this.w += s.w, this
	}
	addScalar(s) {
		return this.x += s, this.y += s, this.z += s, this.w += s, this
	}
	addVectors(s, a) {
		return this.x = s.x + a.x, this.y = s.y + a.y, this.z = s.z + a.z, this.w = s.w + a.w, this
	}
	addScaledVector(s, a) {
		return this.x += s.x * a, this.y += s.y * a, this.z += s.z * a, this.w += s.w * a, this
	}
	sub(s) {
		return this.x -= s.x, this.y -= s.y, this.z -= s.z, this.w -= s.w, this
	}
	subScalar(s) {
		return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this
	}
	subVectors(s, a) {
		return this.x = s.x - a.x, this.y = s.y - a.y, this.z = s.z - a.z, this.w = s.w - a.w, this
	}
	multiply(s) {
		return this.x *= s.x, this.y *= s.y, this.z *= s.z, this.w *= s.w, this
	}
	multiplyScalar(s) {
		return this.x *= s, this.y *= s, this.z *= s, this.w *= s, this
	}
	applyMatrix4(s) {
		const a = this.x,
			l = this.y,
			c = this.z,
			d = this.w,
			f = s.elements;
		return this.x = f[0] * a + f[4] * l + f[8] * c + f[12] * d, this.y = f[1] * a + f[5] * l + f[9] * c + f[
			13] * d, this.z = f[2] * a + f[6] * l + f[10] * c + f[14] * d, this.w = f[3] * a + f[7] * l + f[11] *
			c + f[15] * d, this
	}
	divide(s) {
		return this.x /= s.x, this.y /= s.y, this.z /= s.z, this.w /= s.w, this
	}
	divideScalar(s) {
		return this.multiplyScalar(1 / s)
	}
	setAxisAngleFromQuaternion(s) {
		this.w = 2 * Math.acos(s.w);
		const a = Math.sqrt(1 - s.w * s.w);
		return a < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = s.x / a, this.y = s.y / a, this.z = s.z /
			a), this
	}
	setAxisAngleFromRotationMatrix(s) {
		let a, l, c, d;
		const g = s.elements,
			v = g[0],
			y = g[4],
			b = g[8],
			C = g[1],
			_ = g[5],
			S = g[9],
			w = g[2],
			T = g[6],
			A = g[10];
		if (Math.abs(y - C) < .01 && Math.abs(b - w) < .01 && Math.abs(S - T) < .01) {
			if (Math.abs(y + C) < .1 && Math.abs(b + w) < .1 && Math.abs(S + T) < .1 && Math.abs(v + _ + A - 3) <
				.1) return this.set(1, 0, 0, 0), this;
			a = Math.PI;
			const M = (v + 1) / 2,
				D = (_ + 1) / 2,
				F = (A + 1) / 2,
				R = (y + C) / 4,
				O = (b + w) / 4,
				U = (S + T) / 4;
			return M > D && M > F ? M < .01 ? (l = 0, c = .707106781, d = .707106781) : (l = Math.sqrt(M), c = R /
				l, d = O / l) : D > F ? D < .01 ? (l = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(D),
				l = R / c, d = U / c) : F < .01 ? (l = .707106781, c = .707106781, d = 0) : (d = Math.sqrt(F),
				l = O / d, c = U / d), this.set(l, c, d, a), this
		}
		let k = Math.sqrt((T - S) * (T - S) + (b - w) * (b - w) + (C - y) * (C - y));
		return Math.abs(k) < .001 && (k = 1), this.x = (T - S) / k, this.y = (b - w) / k, this.z = (C - y) / k, this
			.w = Math.acos((v + _ + A - 1) / 2), this
	}
	setFromMatrixPosition(s) {
		const a = s.elements;
		return this.x = a[12], this.y = a[13], this.z = a[14], this.w = a[15], this
	}
	min(s) {
		return this.x = Math.min(this.x, s.x), this.y = Math.min(this.y, s.y), this.z = Math.min(this.z, s.z), this
			.w = Math.min(this.w, s.w), this
	}
	max(s) {
		return this.x = Math.max(this.x, s.x), this.y = Math.max(this.y, s.y), this.z = Math.max(this.z, s.z), this
			.w = Math.max(this.w, s.w), this
	}
	clamp(s, a) {
		return this.x = clamp$1(this.x, s.x, a.x), this.y = clamp$1(this.y, s.y, a.y), this.z = clamp$1(this.z, s.z,
			a.z), this.w = clamp$1(this.w, s.w, a.w), this
	}
	clampScalar(s, a) {
		return this.x = clamp$1(this.x, s, a), this.y = clamp$1(this.y, s, a), this.z = clamp$1(this.z, s, a), this
			.w = clamp$1(this.w, s, a), this
	}
	clampLength(s, a) {
		const l = this.length();
		return this.divideScalar(l || 1).multiplyScalar(clamp$1(l, s, a))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math
			.floor(this.w), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math
			.ceil(this.w), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math
			.round(this.w), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math
			.trunc(this.w), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
	}
	dot(s) {
		return this.x * s.x + this.y * s.y + this.z * s.z + this.w * s.w
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	setLength(s) {
		return this.normalize().multiplyScalar(s)
	}
	lerp(s, a) {
		return this.x += (s.x - this.x) * a, this.y += (s.y - this.y) * a, this.z += (s.z - this.z) * a, this.w += (
			s.w - this.w) * a, this
	}
	lerpVectors(s, a, l) {
		return this.x = s.x + (a.x - s.x) * l, this.y = s.y + (a.y - s.y) * l, this.z = s.z + (a.z - s.z) * l, this
			.w = s.w + (a.w - s.w) * l, this
	}
	equals(s) {
		return s.x === this.x && s.y === this.y && s.z === this.z && s.w === this.w
	}
	fromArray(s, a = 0) {
		return this.x = s[a], this.y = s[a + 1], this.z = s[a + 2], this.w = s[a + 3], this
	}
	toArray(s = [], a = 0) {
		return s[a] = this.x, s[a + 1] = this.y, s[a + 2] = this.z, s[a + 3] = this.w, s
	}
	fromBufferAttribute(s, a) {
		return this.x = s.getX(a), this.y = s.getY(a), this.z = s.getZ(a), this.w = s.getW(a), this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z, yield this.w
	}
}
class RenderTarget extends EventDispatcher {
	constructor(s = 1, a = 1, l = {}) {
		super(), this.isRenderTarget = !0, this.width = s, this.height = a, this.depth = l.depth ? l.depth : 1, this
			.scissor = new Vector4(0, 0, s, a), this.scissorTest = !1, this.viewport = new Vector4(0, 0, s, a);
		const c = {
			width: s,
			height: a,
			depth: this.depth
		};
		l = Object.assign({
			generateMipmaps: !1,
			internalFormat: null,
			minFilter: LinearFilter,
			depthBuffer: !0,
			stencilBuffer: !1,
			resolveDepthBuffer: !0,
			resolveStencilBuffer: !0,
			depthTexture: null,
			samples: 0,
			count: 1,
			multiview: !1
		}, l);
		const d = new Texture(c, l.mapping, l.wrapS, l.wrapT, l.magFilter, l.minFilter, l.format, l.type, l
			.anisotropy, l.colorSpace);
		d.flipY = !1, d.generateMipmaps = l.generateMipmaps, d.internalFormat = l.internalFormat, this
	.textures = [];
		const f = l.count;
		for (let m = 0; m < f; m++) this.textures[m] = d.clone(), this.textures[m].isRenderTargetTexture = !0, this
			.textures[m].renderTarget = this;
		this.depthBuffer = l.depthBuffer, this.stencilBuffer = l.stencilBuffer, this.resolveDepthBuffer = l
			.resolveDepthBuffer, this.resolveStencilBuffer = l.resolveStencilBuffer, this._depthTexture = null, this
			.depthTexture = l.depthTexture, this.samples = l.samples, this.multiview = l.multiview
	}
	get texture() {
		return this.textures[0]
	}
	set texture(s) {
		this.textures[0] = s
	}
	set depthTexture(s) {
		this._depthTexture !== null && (this._depthTexture.renderTarget = null), s !== null && (s.renderTarget =
			this), this._depthTexture = s
	}
	get depthTexture() {
		return this._depthTexture
	}
	setSize(s, a, l = 1) {
		if (this.width !== s || this.height !== a || this.depth !== l) {
			this.width = s, this.height = a, this.depth = l;
			for (let c = 0, d = this.textures.length; c < d; c++) this.textures[c].image.width = s, this.textures[c]
				.image.height = a, this.textures[c].image.depth = l;
			this.dispose()
		}
		this.viewport.set(0, 0, s, a), this.scissor.set(0, 0, s, a)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(s) {
		this.width = s.width, this.height = s.height, this.depth = s.depth, this.scissor.copy(s.scissor), this
			.scissorTest = s.scissorTest, this.viewport.copy(s.viewport), this.textures.length = 0;
		for (let a = 0, l = s.textures.length; a < l; a++) {
			this.textures[a] = s.textures[a].clone(), this.textures[a].isRenderTargetTexture = !0, this.textures[a]
				.renderTarget = this;
			const c = Object.assign({}, s.textures[a].image);
			this.textures[a].source = new Source(c)
		}
		return this.depthBuffer = s.depthBuffer, this.stencilBuffer = s.stencilBuffer, this.resolveDepthBuffer = s
			.resolveDepthBuffer, this.resolveStencilBuffer = s.resolveStencilBuffer, s.depthTexture !== null && (
				this.depthTexture = s.depthTexture.clone()), this.samples = s.samples, this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
class WebGLRenderTarget extends RenderTarget {
	constructor(s = 1, a = 1, l = {}) {
		super(s, a, l), this.isWebGLRenderTarget = !0
	}
}
class DataArrayTexture extends Texture {
	constructor(s = null, a = 1, l = 1, c = 1) {
		super(null), this.isDataArrayTexture = !0, this.image = {
				data: s,
				width: a,
				height: l,
				depth: c
			}, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping,
			this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
	}
	addLayerUpdate(s) {
		this.layerUpdates.add(s)
	}
	clearLayerUpdates() {
		this.layerUpdates.clear()
	}
}
class Data3DTexture extends Texture {
	constructor(s = null, a = 1, l = 1, c = 1) {
		super(null), this.isData3DTexture = !0, this.image = {
				data: s,
				width: a,
				height: l,
				depth: c
			}, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping,
			this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
let Quaternion$1 = class {
		constructor(s = 0, a = 0, l = 0, c = 1) {
			this.isQuaternion = !0, this._x = s, this._y = a, this._z = l, this._w = c
		}
		static slerpFlat(s, a, l, c, d, f, m) {
			let g = l[c + 0],
				v = l[c + 1],
				y = l[c + 2],
				b = l[c + 3];
			const C = d[f + 0],
				_ = d[f + 1],
				S = d[f + 2],
				w = d[f + 3];
			if (m === 0) {
				s[a + 0] = g, s[a + 1] = v, s[a + 2] = y, s[a + 3] = b;
				return
			}
			if (m === 1) {
				s[a + 0] = C, s[a + 1] = _, s[a + 2] = S, s[a + 3] = w;
				return
			}
			if (b !== w || g !== C || v !== _ || y !== S) {
				let T = 1 - m;
				const A = g * C + v * _ + y * S + b * w,
					k = A >= 0 ? 1 : -1,
					M = 1 - A * A;
				if (M > Number.EPSILON) {
					const F = Math.sqrt(M),
						R = Math.atan2(F, A * k);
					T = Math.sin(T * R) / F, m = Math.sin(m * R) / F
				}
				const D = m * k;
				if (g = g * T + C * D, v = v * T + _ * D, y = y * T + S * D, b = b * T + w * D, T === 1 - m) {
					const F = 1 / Math.sqrt(g * g + v * v + y * y + b * b);
					g *= F, v *= F, y *= F, b *= F
				}
			}
			s[a] = g, s[a + 1] = v, s[a + 2] = y, s[a + 3] = b
		}
		static multiplyQuaternionsFlat(s, a, l, c, d, f) {
			const m = l[c],
				g = l[c + 1],
				v = l[c + 2],
				y = l[c + 3],
				b = d[f],
				C = d[f + 1],
				_ = d[f + 2],
				S = d[f + 3];
			return s[a] = m * S + y * b + g * _ - v * C, s[a + 1] = g * S + y * C + v * b - m * _, s[a + 2] = v *
				S + y * _ + m * C - g * b, s[a + 3] = y * S - m * b - g * C - v * _, s
		}
		get x() {
			return this._x
		}
		set x(s) {
			this._x = s, this._onChangeCallback()
		}
		get y() {
			return this._y
		}
		set y(s) {
			this._y = s, this._onChangeCallback()
		}
		get z() {
			return this._z
		}
		set z(s) {
			this._z = s, this._onChangeCallback()
		}
		get w() {
			return this._w
		}
		set w(s) {
			this._w = s, this._onChangeCallback()
		}
		set(s, a, l, c) {
			return this._x = s, this._y = a, this._z = l, this._w = c, this._onChangeCallback(), this
		}
		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w)
		}
		copy(s) {
			return this._x = s.x, this._y = s.y, this._z = s.z, this._w = s.w, this._onChangeCallback(), this
		}
		setFromEuler(s, a = !0) {
			const l = s._x,
				c = s._y,
				d = s._z,
				f = s._order,
				m = Math.cos,
				g = Math.sin,
				v = m(l / 2),
				y = m(c / 2),
				b = m(d / 2),
				C = g(l / 2),
				_ = g(c / 2),
				S = g(d / 2);
			switch (f) {
				case "XYZ":
					this._x = C * y * b + v * _ * S, this._y = v * _ * b - C * y * S, this._z = v * y * S + C * _ *
						b, this._w = v * y * b - C * _ * S;
					break;
				case "YXZ":
					this._x = C * y * b + v * _ * S, this._y = v * _ * b - C * y * S, this._z = v * y * S - C * _ *
						b, this._w = v * y * b + C * _ * S;
					break;
				case "ZXY":
					this._x = C * y * b - v * _ * S, this._y = v * _ * b + C * y * S, this._z = v * y * S + C * _ *
						b, this._w = v * y * b - C * _ * S;
					break;
				case "ZYX":
					this._x = C * y * b - v * _ * S, this._y = v * _ * b + C * y * S, this._z = v * y * S - C * _ *
						b, this._w = v * y * b + C * _ * S;
					break;
				case "YZX":
					this._x = C * y * b + v * _ * S, this._y = v * _ * b + C * y * S, this._z = v * y * S - C * _ *
						b, this._w = v * y * b - C * _ * S;
					break;
				case "XZY":
					this._x = C * y * b - v * _ * S, this._y = v * _ * b - C * y * S, this._z = v * y * S + C * _ *
						b, this._w = v * y * b + C * _ * S;
					break;
				default:
					console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + f)
			}
			return a === !0 && this._onChangeCallback(), this
		}
		setFromAxisAngle(s, a) {
			const l = a / 2,
				c = Math.sin(l);
			return this._x = s.x * c, this._y = s.y * c, this._z = s.z * c, this._w = Math.cos(l), this
				._onChangeCallback(), this
		}
		setFromRotationMatrix(s) {
			const a = s.elements,
				l = a[0],
				c = a[4],
				d = a[8],
				f = a[1],
				m = a[5],
				g = a[9],
				v = a[2],
				y = a[6],
				b = a[10],
				C = l + m + b;
			if (C > 0) {
				const _ = .5 / Math.sqrt(C + 1);
				this._w = .25 / _, this._x = (y - g) * _, this._y = (d - v) * _, this._z = (f - c) * _
			} else if (l > m && l > b) {
				const _ = 2 * Math.sqrt(1 + l - m - b);
				this._w = (y - g) / _, this._x = .25 * _, this._y = (c + f) / _, this._z = (d + v) / _
			} else if (m > b) {
				const _ = 2 * Math.sqrt(1 + m - l - b);
				this._w = (d - v) / _, this._x = (c + f) / _, this._y = .25 * _, this._z = (g + y) / _
			} else {
				const _ = 2 * Math.sqrt(1 + b - l - m);
				this._w = (f - c) / _, this._x = (d + v) / _, this._y = (g + y) / _, this._z = .25 * _
			}
			return this._onChangeCallback(), this
		}
		setFromUnitVectors(s, a) {
			let l = s.dot(a) + 1;
			return l < Number.EPSILON ? (l = 0, Math.abs(s.x) > Math.abs(s.z) ? (this._x = -s.y, this._y = s.x, this
				._z = 0, this._w = l) : (this._x = 0, this._y = -s.z, this._z = s.y, this._w = l)) : (this._x =
				s.y * a.z - s.z * a.y, this._y = s.z * a.x - s.x * a.z, this._z = s.x * a.y - s.y * a.x, this
				._w = l), this.normalize()
		}
		angleTo(s) {
			return 2 * Math.acos(Math.abs(clamp$1(this.dot(s), -1, 1)))
		}
		rotateTowards(s, a) {
			const l = this.angleTo(s);
			if (l === 0) return this;
			const c = Math.min(1, a / l);
			return this.slerp(s, c), this
		}
		identity() {
			return this.set(0, 0, 0, 1)
		}
		invert() {
			return this.conjugate()
		}
		conjugate() {
			return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
		}
		dot(s) {
			return this._x * s._x + this._y * s._y + this._z * s._z + this._w * s._w
		}
		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
		}
		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
		}
		normalize() {
			let s = this.length();
			return s === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (s = 1 / s, this._x = this._x *
				s, this._y = this._y * s, this._z = this._z * s, this._w = this._w * s), this
			._onChangeCallback(), this
		}
		multiply(s) {
			return this.multiplyQuaternions(this, s)
		}
		premultiply(s) {
			return this.multiplyQuaternions(s, this)
		}
		multiplyQuaternions(s, a) {
			const l = s._x,
				c = s._y,
				d = s._z,
				f = s._w,
				m = a._x,
				g = a._y,
				v = a._z,
				y = a._w;
			return this._x = l * y + f * m + c * v - d * g, this._y = c * y + f * g + d * m - l * v, this._z = d *
				y + f * v + l * g - c * m, this._w = f * y - l * m - c * g - d * v, this._onChangeCallback(), this
		}
		slerp(s, a) {
			if (a === 0) return this;
			if (a === 1) return this.copy(s);
			const l = this._x,
				c = this._y,
				d = this._z,
				f = this._w;
			let m = f * s._w + l * s._x + c * s._y + d * s._z;
			if (m < 0 ? (this._w = -s._w, this._x = -s._x, this._y = -s._y, this._z = -s._z, m = -m) : this.copy(s),
				m >= 1) return this._w = f, this._x = l, this._y = c, this._z = d, this;
			const g = 1 - m * m;
			if (g <= Number.EPSILON) {
				const _ = 1 - a;
				return this._w = _ * f + a * this._w, this._x = _ * l + a * this._x, this._y = _ * c + a * this._y,
					this._z = _ * d + a * this._z, this.normalize(), this
			}
			const v = Math.sqrt(g),
				y = Math.atan2(v, m),
				b = Math.sin((1 - a) * y) / v,
				C = Math.sin(a * y) / v;
			return this._w = f * b + this._w * C, this._x = l * b + this._x * C, this._y = c * b + this._y * C, this
				._z = d * b + this._z * C, this._onChangeCallback(), this
		}
		slerpQuaternions(s, a, l) {
			return this.copy(s).slerp(a, l)
		}
		random() {
			const s = 2 * Math.PI * Math.random(),
				a = 2 * Math.PI * Math.random(),
				l = Math.random(),
				c = Math.sqrt(1 - l),
				d = Math.sqrt(l);
			return this.set(c * Math.sin(s), c * Math.cos(s), d * Math.sin(a), d * Math.cos(a))
		}
		equals(s) {
			return s._x === this._x && s._y === this._y && s._z === this._z && s._w === this._w
		}
		fromArray(s, a = 0) {
			return this._x = s[a], this._y = s[a + 1], this._z = s[a + 2], this._w = s[a + 3], this
				._onChangeCallback(), this
		}
		toArray(s = [], a = 0) {
			return s[a] = this._x, s[a + 1] = this._y, s[a + 2] = this._z, s[a + 3] = this._w, s
		}
		fromBufferAttribute(s, a) {
			return this._x = s.getX(a), this._y = s.getY(a), this._z = s.getZ(a), this._w = s.getW(a), this
				._onChangeCallback(), this
		}
		toJSON() {
			return this.toArray()
		}
		_onChange(s) {
			return this._onChangeCallback = s, this
		}
		_onChangeCallback() {}*[Symbol.iterator]() {
			yield this._x, yield this._y, yield this._z, yield this._w
		}
	},
	Vector3$1 = class vr {
		constructor(s = 0, a = 0, l = 0) {
			vr.prototype.isVector3 = !0, this.x = s, this.y = a, this.z = l
		}
		set(s, a, l) {
			return l === void 0 && (l = this.z), this.x = s, this.y = a, this.z = l, this
		}
		setScalar(s) {
			return this.x = s, this.y = s, this.z = s, this
		}
		setX(s) {
			return this.x = s, this
		}
		setY(s) {
			return this.y = s, this
		}
		setZ(s) {
			return this.z = s, this
		}
		setComponent(s, a) {
			switch (s) {
				case 0:
					this.x = a;
					break;
				case 1:
					this.y = a;
					break;
				case 2:
					this.z = a;
					break;
				default:
					throw new Error("index is out of range: " + s)
			}
			return this
		}
		getComponent(s) {
			switch (s) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw new Error("index is out of range: " + s)
			}
		}
		clone() {
			return new this.constructor(this.x, this.y, this.z)
		}
		copy(s) {
			return this.x = s.x, this.y = s.y, this.z = s.z, this
		}
		add(s) {
			return this.x += s.x, this.y += s.y, this.z += s.z, this
		}
		addScalar(s) {
			return this.x += s, this.y += s, this.z += s, this
		}
		addVectors(s, a) {
			return this.x = s.x + a.x, this.y = s.y + a.y, this.z = s.z + a.z, this
		}
		addScaledVector(s, a) {
			return this.x += s.x * a, this.y += s.y * a, this.z += s.z * a, this
		}
		sub(s) {
			return this.x -= s.x, this.y -= s.y, this.z -= s.z, this
		}
		subScalar(s) {
			return this.x -= s, this.y -= s, this.z -= s, this
		}
		subVectors(s, a) {
			return this.x = s.x - a.x, this.y = s.y - a.y, this.z = s.z - a.z, this
		}
		multiply(s) {
			return this.x *= s.x, this.y *= s.y, this.z *= s.z, this
		}
		multiplyScalar(s) {
			return this.x *= s, this.y *= s, this.z *= s, this
		}
		multiplyVectors(s, a) {
			return this.x = s.x * a.x, this.y = s.y * a.y, this.z = s.z * a.z, this
		}
		applyEuler(s) {
			return this.applyQuaternion(_quaternion$4.setFromEuler(s))
		}
		applyAxisAngle(s, a) {
			return this.applyQuaternion(_quaternion$4.setFromAxisAngle(s, a))
		}
		applyMatrix3(s) {
			const a = this.x,
				l = this.y,
				c = this.z,
				d = s.elements;
			return this.x = d[0] * a + d[3] * l + d[6] * c, this.y = d[1] * a + d[4] * l + d[7] * c, this.z = d[2] *
				a + d[5] * l + d[8] * c, this
		}
		applyNormalMatrix(s) {
			return this.applyMatrix3(s).normalize()
		}
		applyMatrix4(s) {
			const a = this.x,
				l = this.y,
				c = this.z,
				d = s.elements,
				f = 1 / (d[3] * a + d[7] * l + d[11] * c + d[15]);
			return this.x = (d[0] * a + d[4] * l + d[8] * c + d[12]) * f, this.y = (d[1] * a + d[5] * l + d[9] * c +
				d[13]) * f, this.z = (d[2] * a + d[6] * l + d[10] * c + d[14]) * f, this
		}
		applyQuaternion(s) {
			const a = this.x,
				l = this.y,
				c = this.z,
				d = s.x,
				f = s.y,
				m = s.z,
				g = s.w,
				v = 2 * (f * c - m * l),
				y = 2 * (m * a - d * c),
				b = 2 * (d * l - f * a);
			return this.x = a + g * v + f * b - m * y, this.y = l + g * y + m * v - d * b, this.z = c + g * b + d *
				y - f * v, this
		}
		project(s) {
			return this.applyMatrix4(s.matrixWorldInverse).applyMatrix4(s.projectionMatrix)
		}
		unproject(s) {
			return this.applyMatrix4(s.projectionMatrixInverse).applyMatrix4(s.matrixWorld)
		}
		transformDirection(s) {
			const a = this.x,
				l = this.y,
				c = this.z,
				d = s.elements;
			return this.x = d[0] * a + d[4] * l + d[8] * c, this.y = d[1] * a + d[5] * l + d[9] * c, this.z = d[2] *
				a + d[6] * l + d[10] * c, this.normalize()
		}
		divide(s) {
			return this.x /= s.x, this.y /= s.y, this.z /= s.z, this
		}
		divideScalar(s) {
			return this.multiplyScalar(1 / s)
		}
		min(s) {
			return this.x = Math.min(this.x, s.x), this.y = Math.min(this.y, s.y), this.z = Math.min(this.z, s.z),
				this
		}
		max(s) {
			return this.x = Math.max(this.x, s.x), this.y = Math.max(this.y, s.y), this.z = Math.max(this.z, s.z),
				this
		}
		clamp(s, a) {
			return this.x = clamp$1(this.x, s.x, a.x), this.y = clamp$1(this.y, s.y, a.y), this.z = clamp$1(this.z,
				s.z, a.z), this
		}
		clampScalar(s, a) {
			return this.x = clamp$1(this.x, s, a), this.y = clamp$1(this.y, s, a), this.z = clamp$1(this.z, s, a),
				this
		}
		clampLength(s, a) {
			const l = this.length();
			return this.divideScalar(l || 1).multiplyScalar(clamp$1(l, s, a))
		}
		floor() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
		}
		ceil() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
		}
		round() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
		}
		roundToZero() {
			return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
		}
		negate() {
			return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
		}
		dot(s) {
			return this.x * s.x + this.y * s.y + this.z * s.z
		}
		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		}
		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
		}
		normalize() {
			return this.divideScalar(this.length() || 1)
		}
		setLength(s) {
			return this.normalize().multiplyScalar(s)
		}
		lerp(s, a) {
			return this.x += (s.x - this.x) * a, this.y += (s.y - this.y) * a, this.z += (s.z - this.z) * a, this
		}
		lerpVectors(s, a, l) {
			return this.x = s.x + (a.x - s.x) * l, this.y = s.y + (a.y - s.y) * l, this.z = s.z + (a.z - s.z) * l,
				this
		}
		cross(s) {
			return this.crossVectors(this, s)
		}
		crossVectors(s, a) {
			const l = s.x,
				c = s.y,
				d = s.z,
				f = a.x,
				m = a.y,
				g = a.z;
			return this.x = c * g - d * m, this.y = d * f - l * g, this.z = l * m - c * f, this
		}
		projectOnVector(s) {
			const a = s.lengthSq();
			if (a === 0) return this.set(0, 0, 0);
			const l = s.dot(this) / a;
			return this.copy(s).multiplyScalar(l)
		}
		projectOnPlane(s) {
			return _vector$c.copy(this).projectOnVector(s), this.sub(_vector$c)
		}
		reflect(s) {
			return this.sub(_vector$c.copy(s).multiplyScalar(2 * this.dot(s)))
		}
		angleTo(s) {
			const a = Math.sqrt(this.lengthSq() * s.lengthSq());
			if (a === 0) return Math.PI / 2;
			const l = this.dot(s) / a;
			return Math.acos(clamp$1(l, -1, 1))
		}
		distanceTo(s) {
			return Math.sqrt(this.distanceToSquared(s))
		}
		distanceToSquared(s) {
			const a = this.x - s.x,
				l = this.y - s.y,
				c = this.z - s.z;
			return a * a + l * l + c * c
		}
		manhattanDistanceTo(s) {
			return Math.abs(this.x - s.x) + Math.abs(this.y - s.y) + Math.abs(this.z - s.z)
		}
		setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta)
		}
		setFromSphericalCoords(s, a, l) {
			const c = Math.sin(a) * s;
			return this.x = c * Math.sin(l), this.y = Math.cos(a) * s, this.z = c * Math.cos(l), this
		}
		setFromCylindrical(s) {
			return this.setFromCylindricalCoords(s.radius, s.theta, s.y)
		}
		setFromCylindricalCoords(s, a, l) {
			return this.x = s * Math.sin(a), this.y = l, this.z = s * Math.cos(a), this
		}
		setFromMatrixPosition(s) {
			const a = s.elements;
			return this.x = a[12], this.y = a[13], this.z = a[14], this
		}
		setFromMatrixScale(s) {
			const a = this.setFromMatrixColumn(s, 0).length(),
				l = this.setFromMatrixColumn(s, 1).length(),
				c = this.setFromMatrixColumn(s, 2).length();
			return this.x = a, this.y = l, this.z = c, this
		}
		setFromMatrixColumn(s, a) {
			return this.fromArray(s.elements, a * 4)
		}
		setFromMatrix3Column(s, a) {
			return this.fromArray(s.elements, a * 3)
		}
		setFromEuler(s) {
			return this.x = s._x, this.y = s._y, this.z = s._z, this
		}
		setFromColor(s) {
			return this.x = s.r, this.y = s.g, this.z = s.b, this
		}
		equals(s) {
			return s.x === this.x && s.y === this.y && s.z === this.z
		}
		fromArray(s, a = 0) {
			return this.x = s[a], this.y = s[a + 1], this.z = s[a + 2], this
		}
		toArray(s = [], a = 0) {
			return s[a] = this.x, s[a + 1] = this.y, s[a + 2] = this.z, s
		}
		fromBufferAttribute(s, a) {
			return this.x = s.getX(a), this.y = s.getY(a), this.z = s.getZ(a), this
		}
		random() {
			return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
		}
		randomDirection() {
			const s = Math.random() * Math.PI * 2,
				a = Math.random() * 2 - 1,
				l = Math.sqrt(1 - a * a);
			return this.x = l * Math.cos(s), this.y = a, this.z = l * Math.sin(s), this
		}*[Symbol.iterator]() {
			yield this.x, yield this.y, yield this.z
		}
	};
const _vector$c = new Vector3$1,
	_quaternion$4 = new Quaternion$1;
class Box3 {
	constructor(s = new Vector3$1(1 / 0, 1 / 0, 1 / 0), a = new Vector3$1(-1 / 0, -1 / 0, -1 / 0)) {
		this.isBox3 = !0, this.min = s, this.max = a
	}
	set(s, a) {
		return this.min.copy(s), this.max.copy(a), this
	}
	setFromArray(s) {
		this.makeEmpty();
		for (let a = 0, l = s.length; a < l; a += 3) this.expandByPoint(_vector$b.fromArray(s, a));
		return this
	}
	setFromBufferAttribute(s) {
		this.makeEmpty();
		for (let a = 0, l = s.count; a < l; a++) this.expandByPoint(_vector$b.fromBufferAttribute(s, a));
		return this
	}
	setFromPoints(s) {
		this.makeEmpty();
		for (let a = 0, l = s.length; a < l; a++) this.expandByPoint(s[a]);
		return this
	}
	setFromCenterAndSize(s, a) {
		const l = _vector$b.copy(a).multiplyScalar(.5);
		return this.min.copy(s).sub(l), this.max.copy(s).add(l), this
	}
	setFromObject(s, a = !1) {
		return this.makeEmpty(), this.expandByObject(s, a)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(s) {
		return this.min.copy(s.min), this.max.copy(s.max), this
	}
	makeEmpty() {
		return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
	}
	isEmpty() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
	}
	getCenter(s) {
		return this.isEmpty() ? s.set(0, 0, 0) : s.addVectors(this.min, this.max).multiplyScalar(.5)
	}
	getSize(s) {
		return this.isEmpty() ? s.set(0, 0, 0) : s.subVectors(this.max, this.min)
	}
	expandByPoint(s) {
		return this.min.min(s), this.max.max(s), this
	}
	expandByVector(s) {
		return this.min.sub(s), this.max.add(s), this
	}
	expandByScalar(s) {
		return this.min.addScalar(-s), this.max.addScalar(s), this
	}
	expandByObject(s, a = !1) {
		s.updateWorldMatrix(!1, !1);
		const l = s.geometry;
		if (l !== void 0) {
			const d = l.getAttribute("position");
			if (a === !0 && d !== void 0 && s.isInstancedMesh !== !0)
				for (let f = 0, m = d.count; f < m; f++) s.isMesh === !0 ? s.getVertexPosition(f, _vector$b) :
					_vector$b.fromBufferAttribute(d, f), _vector$b.applyMatrix4(s.matrixWorld), this.expandByPoint(
						_vector$b);
			else s.boundingBox !== void 0 ? (s.boundingBox === null && s.computeBoundingBox(), _box$4.copy(s
					.boundingBox)) : (l.boundingBox === null && l.computeBoundingBox(), _box$4.copy(l.boundingBox)),
				_box$4.applyMatrix4(s.matrixWorld), this.union(_box$4)
		}
		const c = s.children;
		for (let d = 0, f = c.length; d < f; d++) this.expandByObject(c[d], a);
		return this
	}
	containsPoint(s) {
		return s.x >= this.min.x && s.x <= this.max.x && s.y >= this.min.y && s.y <= this.max.y && s.z >= this.min
			.z && s.z <= this.max.z
	}
	containsBox(s) {
		return this.min.x <= s.min.x && s.max.x <= this.max.x && this.min.y <= s.min.y && s.max.y <= this.max.y &&
			this.min.z <= s.min.z && s.max.z <= this.max.z
	}
	getParameter(s, a) {
		return a.set((s.x - this.min.x) / (this.max.x - this.min.x), (s.y - this.min.y) / (this.max.y - this.min.y),
			(s.z - this.min.z) / (this.max.z - this.min.z))
	}
	intersectsBox(s) {
		return s.max.x >= this.min.x && s.min.x <= this.max.x && s.max.y >= this.min.y && s.min.y <= this.max.y && s
			.max.z >= this.min.z && s.min.z <= this.max.z
	}
	intersectsSphere(s) {
		return this.clampPoint(s.center, _vector$b), _vector$b.distanceToSquared(s.center) <= s.radius * s.radius
	}
	intersectsPlane(s) {
		let a, l;
		return s.normal.x > 0 ? (a = s.normal.x * this.min.x, l = s.normal.x * this.max.x) : (a = s.normal.x * this
			.max.x, l = s.normal.x * this.min.x), s.normal.y > 0 ? (a += s.normal.y * this.min.y, l += s.normal
			.y * this.max.y) : (a += s.normal.y * this.max.y, l += s.normal.y * this.min.y), s.normal.z > 0 ? (
			a += s.normal.z * this.min.z, l += s.normal.z * this.max.z) : (a += s.normal.z * this.max.z, l += s
			.normal.z * this.min.z), a <= -s.constant && l >= -s.constant
	}
	intersectsTriangle(s) {
		if (this.isEmpty()) return !1;
		this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(s.a, _center), _v1$7
			.subVectors(s.b, _center), _v2$4.subVectors(s.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(
				_v2$4, _v1$7), _f2.subVectors(_v0$2, _v2$4);
		let a = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0,
			-_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0
		];
		return !satForAxes(a, _v0$2, _v1$7, _v2$4, _extents) || (a = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(a,
			_v0$2, _v1$7, _v2$4, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), a = [_triangleNormal
			.x, _triangleNormal.y, _triangleNormal.z
		], satForAxes(a, _v0$2, _v1$7, _v2$4, _extents))
	}
	clampPoint(s, a) {
		return a.copy(s).clamp(this.min, this.max)
	}
	distanceToPoint(s) {
		return this.clampPoint(s, _vector$b).distanceTo(s)
	}
	getBoundingSphere(s) {
		return this.isEmpty() ? s.makeEmpty() : (this.getCenter(s.center), s.radius = this.getSize(_vector$b)
			.length() * .5), s
	}
	intersect(s) {
		return this.min.max(s.min), this.max.min(s.max), this.isEmpty() && this.makeEmpty(), this
	}
	union(s) {
		return this.min.min(s.min), this.max.max(s.max), this
	}
	applyMatrix4(s) {
		return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(s), _points[
				1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(s), _points[2].set(this.min.x, this.max
				.y, this.min.z).applyMatrix4(s), _points[3].set(this.min.x, this.max.y, this.max.z)
			.applyMatrix4(s), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(s), _points[5]
			.set(this.max.x, this.min.y, this.max.z).applyMatrix4(s), _points[6].set(this.max.x, this.max.y,
				this.min.z).applyMatrix4(s), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(s),
			this.setFromPoints(_points), this)
	}
	translate(s) {
		return this.min.add(s), this.max.add(s), this
	}
	equals(s) {
		return s.min.equals(this.min) && s.max.equals(this.max)
	}
}
const _points = [new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1, new Vector3$1,
		new Vector3$1, new Vector3$1
	],
	_vector$b = new Vector3$1,
	_box$4 = new Box3,
	_v0$2 = new Vector3$1,
	_v1$7 = new Vector3$1,
	_v2$4 = new Vector3$1,
	_f0 = new Vector3$1,
	_f1 = new Vector3$1,
	_f2 = new Vector3$1,
	_center = new Vector3$1,
	_extents = new Vector3$1,
	_triangleNormal = new Vector3$1,
	_testAxis = new Vector3$1;

function satForAxes(o, s, a, l, c) {
	for (let d = 0, f = o.length - 3; d <= f; d += 3) {
		_testAxis.fromArray(o, d);
		const m = c.x * Math.abs(_testAxis.x) + c.y * Math.abs(_testAxis.y) + c.z * Math.abs(_testAxis.z),
			g = s.dot(_testAxis),
			v = a.dot(_testAxis),
			y = l.dot(_testAxis);
		if (Math.max(-Math.max(g, v, y), Math.min(g, v, y)) > m) return !1
	}
	return !0
}
const _box$3 = new Box3,
	_v1$6 = new Vector3$1,
	_v2$3 = new Vector3$1;
class Sphere {
	constructor(s = new Vector3$1, a = -1) {
		this.isSphere = !0, this.center = s, this.radius = a
	}
	set(s, a) {
		return this.center.copy(s), this.radius = a, this
	}
	setFromPoints(s, a) {
		const l = this.center;
		a !== void 0 ? l.copy(a) : _box$3.setFromPoints(s).getCenter(l);
		let c = 0;
		for (let d = 0, f = s.length; d < f; d++) c = Math.max(c, l.distanceToSquared(s[d]));
		return this.radius = Math.sqrt(c), this
	}
	copy(s) {
		return this.center.copy(s.center), this.radius = s.radius, this
	}
	isEmpty() {
		return this.radius < 0
	}
	makeEmpty() {
		return this.center.set(0, 0, 0), this.radius = -1, this
	}
	containsPoint(s) {
		return s.distanceToSquared(this.center) <= this.radius * this.radius
	}
	distanceToPoint(s) {
		return s.distanceTo(this.center) - this.radius
	}
	intersectsSphere(s) {
		const a = this.radius + s.radius;
		return s.center.distanceToSquared(this.center) <= a * a
	}
	intersectsBox(s) {
		return s.intersectsSphere(this)
	}
	intersectsPlane(s) {
		return Math.abs(s.distanceToPoint(this.center)) <= this.radius
	}
	clampPoint(s, a) {
		const l = this.center.distanceToSquared(s);
		return a.copy(s), l > this.radius * this.radius && (a.sub(this.center).normalize(), a.multiplyScalar(this
			.radius).add(this.center)), a
	}
	getBoundingBox(s) {
		return this.isEmpty() ? (s.makeEmpty(), s) : (s.set(this.center, this.center), s.expandByScalar(this
			.radius), s)
	}
	applyMatrix4(s) {
		return this.center.applyMatrix4(s), this.radius = this.radius * s.getMaxScaleOnAxis(), this
	}
	translate(s) {
		return this.center.add(s), this
	}
	expandByPoint(s) {
		if (this.isEmpty()) return this.center.copy(s), this.radius = 0, this;
		_v1$6.subVectors(s, this.center);
		const a = _v1$6.lengthSq();
		if (a > this.radius * this.radius) {
			const l = Math.sqrt(a),
				c = (l - this.radius) * .5;
			this.center.addScaledVector(_v1$6, c / l), this.radius += c
		}
		return this
	}
	union(s) {
		return s.isEmpty() ? this : this.isEmpty() ? (this.copy(s), this) : (this.center.equals(s.center) === !0 ?
			this.radius = Math.max(this.radius, s.radius) : (_v2$3.subVectors(s.center, this.center).setLength(s
				.radius), this.expandByPoint(_v1$6.copy(s.center).add(_v2$3)), this.expandByPoint(_v1$6
				.copy(s.center).sub(_v2$3))), this)
	}
	equals(s) {
		return s.center.equals(this.center) && s.radius === this.radius
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
const _vector$a = new Vector3$1,
	_segCenter = new Vector3$1,
	_segDir = new Vector3$1,
	_diff = new Vector3$1,
	_edge1 = new Vector3$1,
	_edge2 = new Vector3$1,
	_normal$1 = new Vector3$1;
class Ray {
	constructor(s = new Vector3$1, a = new Vector3$1(0, 0, -1)) {
		this.origin = s, this.direction = a
	}
	set(s, a) {
		return this.origin.copy(s), this.direction.copy(a), this
	}
	copy(s) {
		return this.origin.copy(s.origin), this.direction.copy(s.direction), this
	}
	at(s, a) {
		return a.copy(this.origin).addScaledVector(this.direction, s)
	}
	lookAt(s) {
		return this.direction.copy(s).sub(this.origin).normalize(), this
	}
	recast(s) {
		return this.origin.copy(this.at(s, _vector$a)), this
	}
	closestPointToPoint(s, a) {
		a.subVectors(s, this.origin);
		const l = a.dot(this.direction);
		return l < 0 ? a.copy(this.origin) : a.copy(this.origin).addScaledVector(this.direction, l)
	}
	distanceToPoint(s) {
		return Math.sqrt(this.distanceSqToPoint(s))
	}
	distanceSqToPoint(s) {
		const a = _vector$a.subVectors(s, this.origin).dot(this.direction);
		return a < 0 ? this.origin.distanceToSquared(s) : (_vector$a.copy(this.origin).addScaledVector(this
			.direction, a), _vector$a.distanceToSquared(s))
	}
	distanceSqToSegment(s, a, l, c) {
		_segCenter.copy(s).add(a).multiplyScalar(.5), _segDir.copy(a).sub(s).normalize(), _diff.copy(this.origin)
			.sub(_segCenter);
		const d = s.distanceTo(a) * .5,
			f = -this.direction.dot(_segDir),
			m = _diff.dot(this.direction),
			g = -_diff.dot(_segDir),
			v = _diff.lengthSq(),
			y = Math.abs(1 - f * f);
		let b, C, _, S;
		if (y > 0)
			if (b = f * g - m, C = f * m - g, S = d * y, b >= 0)
				if (C >= -S)
					if (C <= S) {
						const w = 1 / y;
						b *= w, C *= w, _ = b * (b + f * C + 2 * m) + C * (f * b + C + 2 * g) + v
					} else C = d, b = Math.max(0, -(f * C + m)), _ = -b * b + C * (C + 2 * g) + v;
		else C = -d, b = Math.max(0, -(f * C + m)), _ = -b * b + C * (C + 2 * g) + v;
		else C <= -S ? (b = Math.max(0, -(-f * d + m)), C = b > 0 ? -d : Math.min(Math.max(-d, -g), d), _ = -b * b +
				C * (C + 2 * g) + v) : C <= S ? (b = 0, C = Math.min(Math.max(-d, -g), d), _ = C * (C + 2 * g) +
			v) : (b = Math.max(0, -(f * d + m)), C = b > 0 ? d : Math.min(Math.max(-d, -g), d), _ = -b * b + C * (
				C + 2 * g) + v);
		else C = f > 0 ? -d : d, b = Math.max(0, -(f * C + m)), _ = -b * b + C * (C + 2 * g) + v;
		return l && l.copy(this.origin).addScaledVector(this.direction, b), c && c.copy(_segCenter).addScaledVector(
			_segDir, C), _
	}
	intersectSphere(s, a) {
		_vector$a.subVectors(s.center, this.origin);
		const l = _vector$a.dot(this.direction),
			c = _vector$a.dot(_vector$a) - l * l,
			d = s.radius * s.radius;
		if (c > d) return null;
		const f = Math.sqrt(d - c),
			m = l - f,
			g = l + f;
		return g < 0 ? null : m < 0 ? this.at(g, a) : this.at(m, a)
	}
	intersectsSphere(s) {
		return this.distanceSqToPoint(s.center) <= s.radius * s.radius
	}
	distanceToPlane(s) {
		const a = s.normal.dot(this.direction);
		if (a === 0) return s.distanceToPoint(this.origin) === 0 ? 0 : null;
		const l = -(this.origin.dot(s.normal) + s.constant) / a;
		return l >= 0 ? l : null
	}
	intersectPlane(s, a) {
		const l = this.distanceToPlane(s);
		return l === null ? null : this.at(l, a)
	}
	intersectsPlane(s) {
		const a = s.distanceToPoint(this.origin);
		return a === 0 || s.normal.dot(this.direction) * a < 0
	}
	intersectBox(s, a) {
		let l, c, d, f, m, g;
		const v = 1 / this.direction.x,
			y = 1 / this.direction.y,
			b = 1 / this.direction.z,
			C = this.origin;
		return v >= 0 ? (l = (s.min.x - C.x) * v, c = (s.max.x - C.x) * v) : (l = (s.max.x - C.x) * v, c = (s.min
			.x - C.x) * v), y >= 0 ? (d = (s.min.y - C.y) * y, f = (s.max.y - C.y) * y) : (d = (s.max.y - C.y) *
			y, f = (s.min.y - C.y) * y), l > f || d > c || ((d > l || isNaN(l)) && (l = d), (f < c || isNaN(
			c)) && (c = f), b >= 0 ? (m = (s.min.z - C.z) * b, g = (s.max.z - C.z) * b) : (m = (s.max.z - C.z) *
				b, g = (s.min.z - C.z) * b), l > g || m > c) || ((m > l || l !== l) && (l = m), (g < c || c !==
			c) && (c = g), c < 0) ? null : this.at(l >= 0 ? l : c, a)
	}
	intersectsBox(s) {
		return this.intersectBox(s, _vector$a) !== null
	}
	intersectTriangle(s, a, l, c, d) {
		_edge1.subVectors(a, s), _edge2.subVectors(l, s), _normal$1.crossVectors(_edge1, _edge2);
		let f = this.direction.dot(_normal$1),
			m;
		if (f > 0) {
			if (c) return null;
			m = 1
		} else if (f < 0) m = -1, f = -f;
		else return null;
		_diff.subVectors(this.origin, s);
		const g = m * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
		if (g < 0) return null;
		const v = m * this.direction.dot(_edge1.cross(_diff));
		if (v < 0 || g + v > f) return null;
		const y = -m * _diff.dot(_normal$1);
		return y < 0 ? null : this.at(y / f, d)
	}
	applyMatrix4(s) {
		return this.origin.applyMatrix4(s), this.direction.transformDirection(s), this
	}
	equals(s) {
		return s.origin.equals(this.origin) && s.direction.equals(this.direction)
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
class Matrix4 {
	constructor(s, a, l, c, d, f, m, g, v, y, b, C, _, S, w, T) {
		Matrix4.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], s !==
			void 0 && this.set(s, a, l, c, d, f, m, g, v, y, b, C, _, S, w, T)
	}
	set(s, a, l, c, d, f, m, g, v, y, b, C, _, S, w, T) {
		const A = this.elements;
		return A[0] = s, A[4] = a, A[8] = l, A[12] = c, A[1] = d, A[5] = f, A[9] = m, A[13] = g, A[2] = v, A[6] = y,
			A[10] = b, A[14] = C, A[3] = _, A[7] = S, A[11] = w, A[15] = T, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	clone() {
		return new Matrix4().fromArray(this.elements)
	}
	copy(s) {
		const a = this.elements,
			l = s.elements;
		return a[0] = l[0], a[1] = l[1], a[2] = l[2], a[3] = l[3], a[4] = l[4], a[5] = l[5], a[6] = l[6], a[7] = l[
			7], a[8] = l[8], a[9] = l[9], a[10] = l[10], a[11] = l[11], a[12] = l[12], a[13] = l[13], a[14] = l[
			14], a[15] = l[15], this
	}
	copyPosition(s) {
		const a = this.elements,
			l = s.elements;
		return a[12] = l[12], a[13] = l[13], a[14] = l[14], this
	}
	setFromMatrix3(s) {
		const a = s.elements;
		return this.set(a[0], a[3], a[6], 0, a[1], a[4], a[7], 0, a[2], a[5], a[8], 0, 0, 0, 0, 1), this
	}
	extractBasis(s, a, l) {
		return s.setFromMatrixColumn(this, 0), a.setFromMatrixColumn(this, 1), l.setFromMatrixColumn(this, 2), this
	}
	makeBasis(s, a, l) {
		return this.set(s.x, a.x, l.x, 0, s.y, a.y, l.y, 0, s.z, a.z, l.z, 0, 0, 0, 0, 1), this
	}
	extractRotation(s) {
		const a = this.elements,
			l = s.elements,
			c = 1 / _v1$5.setFromMatrixColumn(s, 0).length(),
			d = 1 / _v1$5.setFromMatrixColumn(s, 1).length(),
			f = 1 / _v1$5.setFromMatrixColumn(s, 2).length();
		return a[0] = l[0] * c, a[1] = l[1] * c, a[2] = l[2] * c, a[3] = 0, a[4] = l[4] * d, a[5] = l[5] * d, a[6] =
			l[6] * d, a[7] = 0, a[8] = l[8] * f, a[9] = l[9] * f, a[10] = l[10] * f, a[11] = 0, a[12] = 0, a[13] =
			0, a[14] = 0, a[15] = 1, this
	}
	makeRotationFromEuler(s) {
		const a = this.elements,
			l = s.x,
			c = s.y,
			d = s.z,
			f = Math.cos(l),
			m = Math.sin(l),
			g = Math.cos(c),
			v = Math.sin(c),
			y = Math.cos(d),
			b = Math.sin(d);
		if (s.order === "XYZ") {
			const C = f * y,
				_ = f * b,
				S = m * y,
				w = m * b;
			a[0] = g * y, a[4] = -g * b, a[8] = v, a[1] = _ + S * v, a[5] = C - w * v, a[9] = -m * g, a[2] = w - C *
				v, a[6] = S + _ * v, a[10] = f * g
		} else if (s.order === "YXZ") {
			const C = g * y,
				_ = g * b,
				S = v * y,
				w = v * b;
			a[0] = C + w * m, a[4] = S * m - _, a[8] = f * v, a[1] = f * b, a[5] = f * y, a[9] = -m, a[2] = _ * m -
				S, a[6] = w + C * m, a[10] = f * g
		} else if (s.order === "ZXY") {
			const C = g * y,
				_ = g * b,
				S = v * y,
				w = v * b;
			a[0] = C - w * m, a[4] = -f * b, a[8] = S + _ * m, a[1] = _ + S * m, a[5] = f * y, a[9] = w - C * m, a[
				2] = -f * v, a[6] = m, a[10] = f * g
		} else if (s.order === "ZYX") {
			const C = f * y,
				_ = f * b,
				S = m * y,
				w = m * b;
			a[0] = g * y, a[4] = S * v - _, a[8] = C * v + w, a[1] = g * b, a[5] = w * v + C, a[9] = _ * v - S, a[
				2] = -v, a[6] = m * g, a[10] = f * g
		} else if (s.order === "YZX") {
			const C = f * g,
				_ = f * v,
				S = m * g,
				w = m * v;
			a[0] = g * y, a[4] = w - C * b, a[8] = S * b + _, a[1] = b, a[5] = f * y, a[9] = -m * y, a[2] = -v * y,
				a[6] = _ * b + S, a[10] = C - w * b
		} else if (s.order === "XZY") {
			const C = f * g,
				_ = f * v,
				S = m * g,
				w = m * v;
			a[0] = g * y, a[4] = -b, a[8] = v * y, a[1] = C * b + w, a[5] = f * y, a[9] = _ * b - S, a[2] = S * b -
				_, a[6] = m * y, a[10] = w * b + C
		}
		return a[3] = 0, a[7] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, this
	}
	makeRotationFromQuaternion(s) {
		return this.compose(_zero, s, _one)
	}
	lookAt(s, a, l) {
		const c = this.elements;
		return _z.subVectors(s, a), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(l, _z), _x
			.lengthSq() === 0 && (Math.abs(l.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x
				.crossVectors(l, _z)), _x.normalize(), _y.crossVectors(_z, _x), c[0] = _x.x, c[4] = _y.x, c[8] = _z
			.x, c[1] = _x.y, c[5] = _y.y, c[9] = _z.y, c[2] = _x.z, c[6] = _y.z, c[10] = _z.z, this
	}
	multiply(s) {
		return this.multiplyMatrices(this, s)
	}
	premultiply(s) {
		return this.multiplyMatrices(s, this)
	}
	multiplyMatrices(s, a) {
		const l = s.elements,
			c = a.elements,
			d = this.elements,
			f = l[0],
			m = l[4],
			g = l[8],
			v = l[12],
			y = l[1],
			b = l[5],
			C = l[9],
			_ = l[13],
			S = l[2],
			w = l[6],
			T = l[10],
			A = l[14],
			k = l[3],
			M = l[7],
			D = l[11],
			F = l[15],
			R = c[0],
			O = c[4],
			U = c[8],
			V = c[12],
			z = c[1],
			j = c[5],
			ge = c[9],
			me = c[13],
			he = c[2],
			ce = c[6],
			ae = c[10],
			fe = c[14],
			q = c[3],
			le = c[7],
			de = c[11],
			_e = c[15];
		return d[0] = f * R + m * z + g * he + v * q, d[4] = f * O + m * j + g * ce + v * le, d[8] = f * U + m *
			ge + g * ae + v * de, d[12] = f * V + m * me + g * fe + v * _e, d[1] = y * R + b * z + C * he + _ * q,
			d[5] = y * O + b * j + C * ce + _ * le, d[9] = y * U + b * ge + C * ae + _ * de, d[13] = y * V + b *
			me + C * fe + _ * _e, d[2] = S * R + w * z + T * he + A * q, d[6] = S * O + w * j + T * ce + A * le, d[
				10] = S * U + w * ge + T * ae + A * de, d[14] = S * V + w * me + T * fe + A * _e, d[3] = k * R + M *
			z + D * he + F * q, d[7] = k * O + M * j + D * ce + F * le, d[11] = k * U + M * ge + D * ae + F * de, d[
				15] = k * V + M * me + D * fe + F * _e, this
	}
	multiplyScalar(s) {
		const a = this.elements;
		return a[0] *= s, a[4] *= s, a[8] *= s, a[12] *= s, a[1] *= s, a[5] *= s, a[9] *= s, a[13] *= s, a[2] *= s,
			a[6] *= s, a[10] *= s, a[14] *= s, a[3] *= s, a[7] *= s, a[11] *= s, a[15] *= s, this
	}
	determinant() {
		const s = this.elements,
			a = s[0],
			l = s[4],
			c = s[8],
			d = s[12],
			f = s[1],
			m = s[5],
			g = s[9],
			v = s[13],
			y = s[2],
			b = s[6],
			C = s[10],
			_ = s[14],
			S = s[3],
			w = s[7],
			T = s[11],
			A = s[15];
		return S * (+d * g * b - c * v * b - d * m * C + l * v * C + c * m * _ - l * g * _) + w * (+a * g * _ - a *
			v * C + d * f * C - c * f * _ + c * v * y - d * g * y) + T * (+a * v * b - a * m * _ - d * f * b +
			l * f * _ + d * m * y - l * v * y) + A * (-c * m * y - a * g * b + a * m * C + c * f * b - l * f *
			C + l * g * y)
	}
	transpose() {
		const s = this.elements;
		let a;
		return a = s[1], s[1] = s[4], s[4] = a, a = s[2], s[2] = s[8], s[8] = a, a = s[6], s[6] = s[9], s[9] = a,
			a = s[3], s[3] = s[12], s[12] = a, a = s[7], s[7] = s[13], s[13] = a, a = s[11], s[11] = s[14], s[14] =
			a, this
	}
	setPosition(s, a, l) {
		const c = this.elements;
		return s.isVector3 ? (c[12] = s.x, c[13] = s.y, c[14] = s.z) : (c[12] = s, c[13] = a, c[14] = l), this
	}
	invert() {
		const s = this.elements,
			a = s[0],
			l = s[1],
			c = s[2],
			d = s[3],
			f = s[4],
			m = s[5],
			g = s[6],
			v = s[7],
			y = s[8],
			b = s[9],
			C = s[10],
			_ = s[11],
			S = s[12],
			w = s[13],
			T = s[14],
			A = s[15],
			k = b * T * v - w * C * v + w * g * _ - m * T * _ - b * g * A + m * C * A,
			M = S * C * v - y * T * v - S * g * _ + f * T * _ + y * g * A - f * C * A,
			D = y * w * v - S * b * v + S * m * _ - f * w * _ - y * m * A + f * b * A,
			F = S * b * g - y * w * g - S * m * C + f * w * C + y * m * T - f * b * T,
			R = a * k + l * M + c * D + d * F;
		if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const O = 1 / R;
		return s[0] = k * O, s[1] = (w * C * d - b * T * d - w * c * _ + l * T * _ + b * c * A - l * C * A) * O, s[
				2] = (m * T * d - w * g * d + w * c * v - l * T * v - m * c * A + l * g * A) * O, s[3] = (b * g *
				d - m * C * d - b * c * v + l * C * v + m * c * _ - l * g * _) * O, s[4] = M * O, s[5] = (y * T *
				d - S * C * d + S * c * _ - a * T * _ - y * c * A + a * C * A) * O, s[6] = (S * g * d - f * T * d -
				S * c * v + a * T * v + f * c * A - a * g * A) * O, s[7] = (f * C * d - y * g * d + y * c * v - a *
				C * v - f * c * _ + a * g * _) * O, s[8] = D * O, s[9] = (S * b * d - y * w * d - S * l * _ + a *
				w * _ + y * l * A - a * b * A) * O, s[10] = (f * w * d - S * m * d + S * l * v - a * w * v - f * l *
				A + a * m * A) * O, s[11] = (y * m * d - f * b * d - y * l * v + a * b * v + f * l * _ - a * m *
			_) * O, s[12] = F * O, s[13] = (y * w * c - S * b * c + S * l * C - a * w * C - y * l * T + a * b * T) *
			O, s[14] = (S * m * c - f * w * c - S * l * g + a * w * g + f * l * T - a * m * T) * O, s[15] = (f * b *
				c - y * m * c + y * l * g - a * b * g - f * l * C + a * m * C) * O, this
	}
	scale(s) {
		const a = this.elements,
			l = s.x,
			c = s.y,
			d = s.z;
		return a[0] *= l, a[4] *= c, a[8] *= d, a[1] *= l, a[5] *= c, a[9] *= d, a[2] *= l, a[6] *= c, a[10] *= d,
			a[3] *= l, a[7] *= c, a[11] *= d, this
	}
	getMaxScaleOnAxis() {
		const s = this.elements,
			a = s[0] * s[0] + s[1] * s[1] + s[2] * s[2],
			l = s[4] * s[4] + s[5] * s[5] + s[6] * s[6],
			c = s[8] * s[8] + s[9] * s[9] + s[10] * s[10];
		return Math.sqrt(Math.max(a, l, c))
	}
	makeTranslation(s, a, l) {
		return s.isVector3 ? this.set(1, 0, 0, s.x, 0, 1, 0, s.y, 0, 0, 1, s.z, 0, 0, 0, 1) : this.set(1, 0, 0, s,
			0, 1, 0, a, 0, 0, 1, l, 0, 0, 0, 1), this
	}
	makeRotationX(s) {
		const a = Math.cos(s),
			l = Math.sin(s);
		return this.set(1, 0, 0, 0, 0, a, -l, 0, 0, l, a, 0, 0, 0, 0, 1), this
	}
	makeRotationY(s) {
		const a = Math.cos(s),
			l = Math.sin(s);
		return this.set(a, 0, l, 0, 0, 1, 0, 0, -l, 0, a, 0, 0, 0, 0, 1), this
	}
	makeRotationZ(s) {
		const a = Math.cos(s),
			l = Math.sin(s);
		return this.set(a, -l, 0, 0, l, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	makeRotationAxis(s, a) {
		const l = Math.cos(a),
			c = Math.sin(a),
			d = 1 - l,
			f = s.x,
			m = s.y,
			g = s.z,
			v = d * f,
			y = d * m;
		return this.set(v * f + l, v * m - c * g, v * g + c * m, 0, v * m + c * g, y * m + l, y * g - c * f, 0, v *
			g - c * m, y * g + c * f, d * g * g + l, 0, 0, 0, 0, 1), this
	}
	makeScale(s, a, l) {
		return this.set(s, 0, 0, 0, 0, a, 0, 0, 0, 0, l, 0, 0, 0, 0, 1), this
	}
	makeShear(s, a, l, c, d, f) {
		return this.set(1, l, d, 0, s, 1, f, 0, a, c, 1, 0, 0, 0, 0, 1), this
	}
	compose(s, a, l) {
		const c = this.elements,
			d = a._x,
			f = a._y,
			m = a._z,
			g = a._w,
			v = d + d,
			y = f + f,
			b = m + m,
			C = d * v,
			_ = d * y,
			S = d * b,
			w = f * y,
			T = f * b,
			A = m * b,
			k = g * v,
			M = g * y,
			D = g * b,
			F = l.x,
			R = l.y,
			O = l.z;
		return c[0] = (1 - (w + A)) * F, c[1] = (_ + D) * F, c[2] = (S - M) * F, c[3] = 0, c[4] = (_ - D) * R, c[
			5] = (1 - (C + A)) * R, c[6] = (T + k) * R, c[7] = 0, c[8] = (S + M) * O, c[9] = (T - k) * O, c[10] = (
				1 - (C + w)) * O, c[11] = 0, c[12] = s.x, c[13] = s.y, c[14] = s.z, c[15] = 1, this
	}
	decompose(s, a, l) {
		const c = this.elements;
		let d = _v1$5.set(c[0], c[1], c[2]).length();
		const f = _v1$5.set(c[4], c[5], c[6]).length(),
			m = _v1$5.set(c[8], c[9], c[10]).length();
		this.determinant() < 0 && (d = -d), s.x = c[12], s.y = c[13], s.z = c[14], _m1$2.copy(this);
		const v = 1 / d,
			y = 1 / f,
			b = 1 / m;
		return _m1$2.elements[0] *= v, _m1$2.elements[1] *= v, _m1$2.elements[2] *= v, _m1$2.elements[4] *= y, _m1$2
			.elements[5] *= y, _m1$2.elements[6] *= y, _m1$2.elements[8] *= b, _m1$2.elements[9] *= b, _m1$2
			.elements[10] *= b, a.setFromRotationMatrix(_m1$2), l.x = d, l.y = f, l.z = m, this
	}
	makePerspective(s, a, l, c, d, f, m = WebGLCoordinateSystem) {
		const g = this.elements,
			v = 2 * d / (a - s),
			y = 2 * d / (l - c),
			b = (a + s) / (a - s),
			C = (l + c) / (l - c);
		let _, S;
		if (m === WebGLCoordinateSystem) _ = -(f + d) / (f - d), S = -2 * f * d / (f - d);
		else if (m === WebGPUCoordinateSystem) _ = -f / (f - d), S = -f * d / (f - d);
		else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + m);
		return g[0] = v, g[4] = 0, g[8] = b, g[12] = 0, g[1] = 0, g[5] = y, g[9] = C, g[13] = 0, g[2] = 0, g[6] = 0,
			g[10] = _, g[14] = S, g[3] = 0, g[7] = 0, g[11] = -1, g[15] = 0, this
	}
	makeOrthographic(s, a, l, c, d, f, m = WebGLCoordinateSystem) {
		const g = this.elements,
			v = 1 / (a - s),
			y = 1 / (l - c),
			b = 1 / (f - d),
			C = (a + s) * v,
			_ = (l + c) * y;
		let S, w;
		if (m === WebGLCoordinateSystem) S = (f + d) * b, w = -2 * b;
		else if (m === WebGPUCoordinateSystem) S = d * b, w = -1 * b;
		else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + m);
		return g[0] = 2 * v, g[4] = 0, g[8] = 0, g[12] = -C, g[1] = 0, g[5] = 2 * y, g[9] = 0, g[13] = -_, g[2] = 0,
			g[6] = 0, g[10] = w, g[14] = -S, g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this
	}
	equals(s) {
		const a = this.elements,
			l = s.elements;
		for (let c = 0; c < 16; c++)
			if (a[c] !== l[c]) return !1;
		return !0
	}
	fromArray(s, a = 0) {
		for (let l = 0; l < 16; l++) this.elements[l] = s[l + a];
		return this
	}
	toArray(s = [], a = 0) {
		const l = this.elements;
		return s[a] = l[0], s[a + 1] = l[1], s[a + 2] = l[2], s[a + 3] = l[3], s[a + 4] = l[4], s[a + 5] = l[5], s[
			a + 6] = l[6], s[a + 7] = l[7], s[a + 8] = l[8], s[a + 9] = l[9], s[a + 10] = l[10], s[a + 11] = l[
			11], s[a + 12] = l[12], s[a + 13] = l[13], s[a + 14] = l[14], s[a + 15] = l[15], s
	}
}
const _v1$5 = new Vector3$1,
	_m1$2 = new Matrix4,
	_zero = new Vector3$1(0, 0, 0),
	_one = new Vector3$1(1, 1, 1),
	_x = new Vector3$1,
	_y = new Vector3$1,
	_z = new Vector3$1,
	_matrix$2 = new Matrix4,
	_quaternion$3 = new Quaternion$1;
class Euler {
	constructor(s = 0, a = 0, l = 0, c = Euler.DEFAULT_ORDER) {
		this.isEuler = !0, this._x = s, this._y = a, this._z = l, this._order = c
	}
	get x() {
		return this._x
	}
	set x(s) {
		this._x = s, this._onChangeCallback()
	}
	get y() {
		return this._y
	}
	set y(s) {
		this._y = s, this._onChangeCallback()
	}
	get z() {
		return this._z
	}
	set z(s) {
		this._z = s, this._onChangeCallback()
	}
	get order() {
		return this._order
	}
	set order(s) {
		this._order = s, this._onChangeCallback()
	}
	set(s, a, l, c = this._order) {
		return this._x = s, this._y = a, this._z = l, this._order = c, this._onChangeCallback(), this
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order)
	}
	copy(s) {
		return this._x = s._x, this._y = s._y, this._z = s._z, this._order = s._order, this._onChangeCallback(),
			this
	}
	setFromRotationMatrix(s, a = this._order, l = !0) {
		const c = s.elements,
			d = c[0],
			f = c[4],
			m = c[8],
			g = c[1],
			v = c[5],
			y = c[9],
			b = c[2],
			C = c[6],
			_ = c[10];
		switch (a) {
			case "XYZ":
				this._y = Math.asin(clamp$1(m, -1, 1)), Math.abs(m) < .9999999 ? (this._x = Math.atan2(-y, _), this
					._z = Math.atan2(-f, d)) : (this._x = Math.atan2(C, v), this._z = 0);
				break;
			case "YXZ":
				this._x = Math.asin(-clamp$1(y, -1, 1)), Math.abs(y) < .9999999 ? (this._y = Math.atan2(m, _), this
					._z = Math.atan2(g, v)) : (this._y = Math.atan2(-b, d), this._z = 0);
				break;
			case "ZXY":
				this._x = Math.asin(clamp$1(C, -1, 1)), Math.abs(C) < .9999999 ? (this._y = Math.atan2(-b, _), this
					._z = Math.atan2(-f, v)) : (this._y = 0, this._z = Math.atan2(g, d));
				break;
			case "ZYX":
				this._y = Math.asin(-clamp$1(b, -1, 1)), Math.abs(b) < .9999999 ? (this._x = Math.atan2(C, _), this
					._z = Math.atan2(g, d)) : (this._x = 0, this._z = Math.atan2(-f, v));
				break;
			case "YZX":
				this._z = Math.asin(clamp$1(g, -1, 1)), Math.abs(g) < .9999999 ? (this._x = Math.atan2(-y, v), this
					._y = Math.atan2(-b, d)) : (this._x = 0, this._y = Math.atan2(m, _));
				break;
			case "XZY":
				this._z = Math.asin(-clamp$1(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(C, v), this
					._y = Math.atan2(m, d)) : (this._x = Math.atan2(-y, _), this._y = 0);
				break;
			default:
				console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + a)
		}
		return this._order = a, l === !0 && this._onChangeCallback(), this
	}
	setFromQuaternion(s, a, l) {
		return _matrix$2.makeRotationFromQuaternion(s), this.setFromRotationMatrix(_matrix$2, a, l)
	}
	setFromVector3(s, a = this._order) {
		return this.set(s.x, s.y, s.z, a)
	}
	reorder(s) {
		return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, s)
	}
	equals(s) {
		return s._x === this._x && s._y === this._y && s._z === this._z && s._order === this._order
	}
	fromArray(s) {
		return this._x = s[0], this._y = s[1], this._z = s[2], s[3] !== void 0 && (this._order = s[3]), this
			._onChangeCallback(), this
	}
	toArray(s = [], a = 0) {
		return s[a] = this._x, s[a + 1] = this._y, s[a + 2] = this._z, s[a + 3] = this._order, s
	}
	_onChange(s) {
		return this._onChangeCallback = s, this
	}
	_onChangeCallback() {}*[Symbol.iterator]() {
		yield this._x, yield this._y, yield this._z, yield this._order
	}
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
	constructor() {
		this.mask = 1
	}
	set(s) {
		this.mask = (1 << s | 0) >>> 0
	}
	enable(s) {
		this.mask |= 1 << s | 0
	}
	enableAll() {
		this.mask = -1
	}
	toggle(s) {
		this.mask ^= 1 << s | 0
	}
	disable(s) {
		this.mask &= ~(1 << s | 0)
	}
	disableAll() {
		this.mask = 0
	}
	test(s) {
		return (this.mask & s.mask) !== 0
	}
	isEnabled(s) {
		return (this.mask & (1 << s | 0)) !== 0
	}
}
let _object3DId = 0;
const _v1$4 = new Vector3$1,
	_q1 = new Quaternion$1,
	_m1$1$1 = new Matrix4,
	_target = new Vector3$1,
	_position$3 = new Vector3$1,
	_scale$2 = new Vector3$1,
	_quaternion$2 = new Quaternion$1,
	_xAxis = new Vector3$1(1, 0, 0),
	_yAxis = new Vector3$1(0, 1, 0),
	_zAxis = new Vector3$1(0, 0, 1),
	_addedEvent = {
		type: "added"
	},
	_removedEvent = {
		type: "removed"
	},
	_childaddedEvent = {
		type: "childadded",
		child: null
	},
	_childremovedEvent = {
		type: "childremoved",
		child: null
	};
class Object3D extends EventDispatcher {
	constructor() {
		super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
				value: _object3DId++
			}), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this
			.children = [], this.up = Object3D.DEFAULT_UP.clone();
		const s = new Vector3$1,
			a = new Euler,
			l = new Quaternion$1,
			c = new Vector3$1(1, 1, 1);

		function d() {
			l.setFromEuler(a, !1)
		}

		function f() {
			a.setFromQuaternion(l, void 0, !1)
		}
		a._onChange(d), l._onChange(f), Object.defineProperties(this, {
				position: {
					configurable: !0,
					enumerable: !0,
					value: s
				},
				rotation: {
					configurable: !0,
					enumerable: !0,
					value: a
				},
				quaternion: {
					configurable: !0,
					enumerable: !0,
					value: l
				},
				scale: {
					configurable: !0,
					enumerable: !0,
					value: c
				},
				modelViewMatrix: {
					value: new Matrix4
				},
				normalMatrix: {
					value: new Matrix3
				}
			}), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D
			.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
			this.matrixWorldNeedsUpdate = !1, this.layers = new Layers, this.visible = !0, this.castShadow = !1,
			this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this
			.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {}
	}
	onBeforeShadow() {}
	onAfterShadow() {}
	onBeforeRender() {}
	onAfterRender() {}
	applyMatrix4(s) {
		this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(s), this.matrix.decompose(this
			.position, this.quaternion, this.scale)
	}
	applyQuaternion(s) {
		return this.quaternion.premultiply(s), this
	}
	setRotationFromAxisAngle(s, a) {
		this.quaternion.setFromAxisAngle(s, a)
	}
	setRotationFromEuler(s) {
		this.quaternion.setFromEuler(s, !0)
	}
	setRotationFromMatrix(s) {
		this.quaternion.setFromRotationMatrix(s)
	}
	setRotationFromQuaternion(s) {
		this.quaternion.copy(s)
	}
	rotateOnAxis(s, a) {
		return _q1.setFromAxisAngle(s, a), this.quaternion.multiply(_q1), this
	}
	rotateOnWorldAxis(s, a) {
		return _q1.setFromAxisAngle(s, a), this.quaternion.premultiply(_q1), this
	}
	rotateX(s) {
		return this.rotateOnAxis(_xAxis, s)
	}
	rotateY(s) {
		return this.rotateOnAxis(_yAxis, s)
	}
	rotateZ(s) {
		return this.rotateOnAxis(_zAxis, s)
	}
	translateOnAxis(s, a) {
		return _v1$4.copy(s).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(a)), this
	}
	translateX(s) {
		return this.translateOnAxis(_xAxis, s)
	}
	translateY(s) {
		return this.translateOnAxis(_yAxis, s)
	}
	translateZ(s) {
		return this.translateOnAxis(_zAxis, s)
	}
	localToWorld(s) {
		return this.updateWorldMatrix(!0, !1), s.applyMatrix4(this.matrixWorld)
	}
	worldToLocal(s) {
		return this.updateWorldMatrix(!0, !1), s.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert())
	}
	lookAt(s, a, l) {
		s.isVector3 ? _target.copy(s) : _target.set(s, a, l);
		const c = this.parent;
		this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this
			.isLight ? _m1$1$1.lookAt(_position$3, _target, this.up) : _m1$1$1.lookAt(_target, _position$3, this
			.up), this.quaternion.setFromRotationMatrix(_m1$1$1), c && (_m1$1$1.extractRotation(c.matrixWorld), _q1
				.setFromRotationMatrix(_m1$1$1), this.quaternion.premultiply(_q1.invert()))
	}
	add(s) {
		if (arguments.length > 1) {
			for (let a = 0; a < arguments.length; a++) this.add(arguments[a]);
			return this
		}
		return s === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", s),
			this) : (s && s.isObject3D ? (s.removeFromParent(), s.parent = this, this.children.push(s), s
			.dispatchEvent(_addedEvent), _childaddedEvent.child = s, this.dispatchEvent(_childaddedEvent),
			_childaddedEvent.child = null) : console.error(
			"THREE.Object3D.add: object not an instance of THREE.Object3D.", s), this)
	}
	remove(s) {
		if (arguments.length > 1) {
			for (let l = 0; l < arguments.length; l++) this.remove(arguments[l]);
			return this
		}
		const a = this.children.indexOf(s);
		return a !== -1 && (s.parent = null, this.children.splice(a, 1), s.dispatchEvent(_removedEvent),
			_childremovedEvent.child = s, this.dispatchEvent(_childremovedEvent), _childremovedEvent.child =
			null), this
	}
	removeFromParent() {
		const s = this.parent;
		return s !== null && s.remove(this), this
	}
	clear() {
		return this.remove(...this.children)
	}
	attach(s) {
		return this.updateWorldMatrix(!0, !1), _m1$1$1.copy(this.matrixWorld).invert(), s.parent !== null && (s
				.parent.updateWorldMatrix(!0, !1), _m1$1$1.multiply(s.parent.matrixWorld)), s.applyMatrix4(_m1$1$1),
			s.removeFromParent(), s.parent = this, this.children.push(s), s.updateWorldMatrix(!1, !0), s
			.dispatchEvent(_addedEvent), _childaddedEvent.child = s, this.dispatchEvent(_childaddedEvent),
			_childaddedEvent.child = null, this
	}
	getObjectById(s) {
		return this.getObjectByProperty("id", s)
	}
	getObjectByName(s) {
		return this.getObjectByProperty("name", s)
	}
	getObjectByProperty(s, a) {
		if (this[s] === a) return this;
		for (let l = 0, c = this.children.length; l < c; l++) {
			const f = this.children[l].getObjectByProperty(s, a);
			if (f !== void 0) return f
		}
	}
	getObjectsByProperty(s, a, l = []) {
		this[s] === a && l.push(this);
		const c = this.children;
		for (let d = 0, f = c.length; d < f; d++) c[d].getObjectsByProperty(s, a, l);
		return l
	}
	getWorldPosition(s) {
		return this.updateWorldMatrix(!0, !1), s.setFromMatrixPosition(this.matrixWorld)
	}
	getWorldQuaternion(s) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, s, _scale$2), s
	}
	getWorldScale(s) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, s), s
	}
	getWorldDirection(s) {
		this.updateWorldMatrix(!0, !1);
		const a = this.matrixWorld.elements;
		return s.set(a[8], a[9], a[10]).normalize()
	}
	raycast() {}
	traverse(s) {
		s(this);
		const a = this.children;
		for (let l = 0, c = a.length; l < c; l++) a[l].traverse(s)
	}
	traverseVisible(s) {
		if (this.visible === !1) return;
		s(this);
		const a = this.children;
		for (let l = 0, c = a.length; l < c; l++) a[l].traverseVisible(s)
	}
	traverseAncestors(s) {
		const a = this.parent;
		a !== null && (s(a), a.traverseAncestors(s))
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
	}
	updateMatrixWorld(s) {
		this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || s) && (this
			.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this
				.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this
			.matrixWorldNeedsUpdate = !1, s = !0);
		const a = this.children;
		for (let l = 0, c = a.length; l < c; l++) a[l].updateMatrixWorld(s)
	}
	updateWorldMatrix(s, a) {
		const l = this.parent;
		if (s === !0 && l !== null && l.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(),
			this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this
				.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), a === !0) {
			const c = this.children;
			for (let d = 0, f = c.length; d < f; d++) c[d].updateWorldMatrix(!1, !0)
		}
	}
	toJSON(s) {
		const a = s === void 0 || typeof s == "string",
			l = {};
		a && (s = {
			geometries: {},
			materials: {},
			textures: {},
			images: {},
			shapes: {},
			skeletons: {},
			animations: {},
			nodes: {}
		}, l.metadata = {
			version: 4.6,
			type: "Object",
			generator: "Object3D.toJSON"
		});
		const c = {};
		c.uuid = this.uuid, c.type = this.type, this.name !== "" && (c.name = this.name), this.castShadow === !0 &&
			(c.castShadow = !0), this.receiveShadow === !0 && (c.receiveShadow = !0), this.visible === !1 && (c
				.visible = !1), this.frustumCulled === !1 && (c.frustumCulled = !1), this.renderOrder !== 0 && (c
				.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (c.userData = this
				.userData), c.layers = this.layers.mask, c.matrix = this.matrix.toArray(), c.up = this.up.toArray(),
			this.matrixAutoUpdate === !1 && (c.matrixAutoUpdate = !1), this.isInstancedMesh && (c.type =
				"InstancedMesh", c.count = this.count, c.instanceMatrix = this.instanceMatrix.toJSON(), this
				.instanceColor !== null && (c.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (
				c.type = "BatchedMesh", c.perObjectFrustumCulled = this.perObjectFrustumCulled, c.sortObjects = this
				.sortObjects, c.drawRanges = this._drawRanges, c.reservedRanges = this._reservedRanges, c
				.geometryInfo = this._geometryInfo.map(m => ({
					...m,
					boundingBox: m.boundingBox ? {
						min: m.boundingBox.min.toArray(),
						max: m.boundingBox.max.toArray()
					} : void 0,
					boundingSphere: m.boundingSphere ? {
						radius: m.boundingSphere.radius,
						center: m.boundingSphere.center.toArray()
					} : void 0
				})), c.instanceInfo = this._instanceInfo.map(m => ({
					...m
				})), c.availableInstanceIds = this._availableInstanceIds.slice(), c.availableGeometryIds = this
				._availableGeometryIds.slice(), c.nextIndexStart = this._nextIndexStart, c.nextVertexStart = this
				._nextVertexStart, c.geometryCount = this._geometryCount, c.maxInstanceCount = this
				._maxInstanceCount, c.maxVertexCount = this._maxVertexCount, c.maxIndexCount = this._maxIndexCount,
				c.geometryInitialized = this._geometryInitialized, c.matricesTexture = this._matricesTexture.toJSON(
					s), c.indirectTexture = this._indirectTexture.toJSON(s), this._colorsTexture !== null && (c
					.colorsTexture = this._colorsTexture.toJSON(s)), this.boundingSphere !== null && (c
					.boundingSphere = {
						center: this.boundingSphere.center.toArray(),
						radius: this.boundingSphere.radius
					}), this.boundingBox !== null && (c.boundingBox = {
					min: this.boundingBox.min.toArray(),
					max: this.boundingBox.max.toArray()
				}));

		function d(m, g) {
			return m[g.uuid] === void 0 && (m[g.uuid] = g.toJSON(s)), g.uuid
		}
		if (this.isScene) this.background && (this.background.isColor ? c.background = this.background.toJSON() :
				this.background.isTexture && (c.background = this.background.toJSON(s).uuid)), this.environment &&
			this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (c.environment = this
				.environment.toJSON(s).uuid);
		else if (this.isMesh || this.isLine || this.isPoints) {
			c.geometry = d(s.geometries, this.geometry);
			const m = this.geometry.parameters;
			if (m !== void 0 && m.shapes !== void 0) {
				const g = m.shapes;
				if (Array.isArray(g))
					for (let v = 0, y = g.length; v < y; v++) {
						const b = g[v];
						d(s.shapes, b)
					} else d(s.shapes, g)
			}
		}
		if (this.isSkinnedMesh && (c.bindMode = this.bindMode, c.bindMatrix = this.bindMatrix.toArray(), this
				.skeleton !== void 0 && (d(s.skeletons, this.skeleton), c.skeleton = this.skeleton.uuid)), this
			.material !== void 0)
			if (Array.isArray(this.material)) {
				const m = [];
				for (let g = 0, v = this.material.length; g < v; g++) m.push(d(s.materials, this.material[g]));
				c.material = m
			} else c.material = d(s.materials, this.material);
		if (this.children.length > 0) {
			c.children = [];
			for (let m = 0; m < this.children.length; m++) c.children.push(this.children[m].toJSON(s).object)
		}
		if (this.animations.length > 0) {
			c.animations = [];
			for (let m = 0; m < this.animations.length; m++) {
				const g = this.animations[m];
				c.animations.push(d(s.animations, g))
			}
		}
		if (a) {
			const m = f(s.geometries),
				g = f(s.materials),
				v = f(s.textures),
				y = f(s.images),
				b = f(s.shapes),
				C = f(s.skeletons),
				_ = f(s.animations),
				S = f(s.nodes);
			m.length > 0 && (l.geometries = m), g.length > 0 && (l.materials = g), v.length > 0 && (l.textures = v),
				y.length > 0 && (l.images = y), b.length > 0 && (l.shapes = b), C.length > 0 && (l.skeletons = C), _
				.length > 0 && (l.animations = _), S.length > 0 && (l.nodes = S)
		}
		return l.object = c, l;

		function f(m) {
			const g = [];
			for (const v in m) {
				const y = m[v];
				delete y.metadata, g.push(y)
			}
			return g
		}
	}
	clone(s) {
		return new this.constructor().copy(this, s)
	}
	copy(s, a = !0) {
		if (this.name = s.name, this.up.copy(s.up), this.position.copy(s.position), this.rotation.order = s.rotation
			.order, this.quaternion.copy(s.quaternion), this.scale.copy(s.scale), this.matrix.copy(s.matrix), this
			.matrixWorld.copy(s.matrixWorld), this.matrixAutoUpdate = s.matrixAutoUpdate, this
			.matrixWorldAutoUpdate = s.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = s
			.matrixWorldNeedsUpdate, this.layers.mask = s.layers.mask, this.visible = s.visible, this.castShadow = s
			.castShadow, this.receiveShadow = s.receiveShadow, this.frustumCulled = s.frustumCulled, this
			.renderOrder = s.renderOrder, this.animations = s.animations.slice(), this.userData = JSON.parse(JSON
				.stringify(s.userData)), a === !0)
			for (let l = 0; l < s.children.length; l++) {
				const c = s.children[l];
				this.add(c.clone())
			}
		return this
	}
}
Object3D.DEFAULT_UP = new Vector3$1(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const _v0$1 = new Vector3$1,
	_v1$3 = new Vector3$1,
	_v2$2 = new Vector3$1,
	_v3$2 = new Vector3$1,
	_vab = new Vector3$1,
	_vac = new Vector3$1,
	_vbc = new Vector3$1,
	_vap = new Vector3$1,
	_vbp = new Vector3$1,
	_vcp = new Vector3$1,
	_v40 = new Vector4,
	_v41 = new Vector4,
	_v42 = new Vector4;
class Triangle {
	constructor(s = new Vector3$1, a = new Vector3$1, l = new Vector3$1) {
		this.a = s, this.b = a, this.c = l
	}
	static getNormal(s, a, l, c) {
		c.subVectors(l, a), _v0$1.subVectors(s, a), c.cross(_v0$1);
		const d = c.lengthSq();
		return d > 0 ? c.multiplyScalar(1 / Math.sqrt(d)) : c.set(0, 0, 0)
	}
	static getBarycoord(s, a, l, c, d) {
		_v0$1.subVectors(c, a), _v1$3.subVectors(l, a), _v2$2.subVectors(s, a);
		const f = _v0$1.dot(_v0$1),
			m = _v0$1.dot(_v1$3),
			g = _v0$1.dot(_v2$2),
			v = _v1$3.dot(_v1$3),
			y = _v1$3.dot(_v2$2),
			b = f * v - m * m;
		if (b === 0) return d.set(0, 0, 0), null;
		const C = 1 / b,
			_ = (v * g - m * y) * C,
			S = (f * y - m * g) * C;
		return d.set(1 - _ - S, S, _)
	}
	static containsPoint(s, a, l, c) {
		return this.getBarycoord(s, a, l, c, _v3$2) === null ? !1 : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2
			.y <= 1
	}
	static getInterpolation(s, a, l, c, d, f, m, g) {
		return this.getBarycoord(s, a, l, c, _v3$2) === null ? (g.x = 0, g.y = 0, "z" in g && (g.z = 0), "w" in g &&
			(g.w = 0), null) : (g.setScalar(0), g.addScaledVector(d, _v3$2.x), g.addScaledVector(f, _v3$2.y), g
			.addScaledVector(m, _v3$2.z), g)
	}
	static getInterpolatedAttribute(s, a, l, c, d, f) {
		return _v40.setScalar(0), _v41.setScalar(0), _v42.setScalar(0), _v40.fromBufferAttribute(s, a), _v41
			.fromBufferAttribute(s, l), _v42.fromBufferAttribute(s, c), f.setScalar(0), f.addScaledVector(_v40, d
			.x), f.addScaledVector(_v41, d.y), f.addScaledVector(_v42, d.z), f
	}
	static isFrontFacing(s, a, l, c) {
		return _v0$1.subVectors(l, a), _v1$3.subVectors(s, a), _v0$1.cross(_v1$3).dot(c) < 0
	}
	set(s, a, l) {
		return this.a.copy(s), this.b.copy(a), this.c.copy(l), this
	}
	setFromPointsAndIndices(s, a, l, c) {
		return this.a.copy(s[a]), this.b.copy(s[l]), this.c.copy(s[c]), this
	}
	setFromAttributeAndIndices(s, a, l, c) {
		return this.a.fromBufferAttribute(s, a), this.b.fromBufferAttribute(s, l), this.c.fromBufferAttribute(s, c),
			this
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(s) {
		return this.a.copy(s.a), this.b.copy(s.b), this.c.copy(s.c), this
	}
	getArea() {
		return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), _v0$1.cross(_v1$3).length() * .5
	}
	getMidpoint(s) {
		return s.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
	}
	getNormal(s) {
		return Triangle.getNormal(this.a, this.b, this.c, s)
	}
	getPlane(s) {
		return s.setFromCoplanarPoints(this.a, this.b, this.c)
	}
	getBarycoord(s, a) {
		return Triangle.getBarycoord(s, this.a, this.b, this.c, a)
	}
	getInterpolation(s, a, l, c, d) {
		return Triangle.getInterpolation(s, this.a, this.b, this.c, a, l, c, d)
	}
	containsPoint(s) {
		return Triangle.containsPoint(s, this.a, this.b, this.c)
	}
	isFrontFacing(s) {
		return Triangle.isFrontFacing(this.a, this.b, this.c, s)
	}
	intersectsBox(s) {
		return s.intersectsTriangle(this)
	}
	closestPointToPoint(s, a) {
		const l = this.a,
			c = this.b,
			d = this.c;
		let f, m;
		_vab.subVectors(c, l), _vac.subVectors(d, l), _vap.subVectors(s, l);
		const g = _vab.dot(_vap),
			v = _vac.dot(_vap);
		if (g <= 0 && v <= 0) return a.copy(l);
		_vbp.subVectors(s, c);
		const y = _vab.dot(_vbp),
			b = _vac.dot(_vbp);
		if (y >= 0 && b <= y) return a.copy(c);
		const C = g * b - y * v;
		if (C <= 0 && g >= 0 && y <= 0) return f = g / (g - y), a.copy(l).addScaledVector(_vab, f);
		_vcp.subVectors(s, d);
		const _ = _vab.dot(_vcp),
			S = _vac.dot(_vcp);
		if (S >= 0 && _ <= S) return a.copy(d);
		const w = _ * v - g * S;
		if (w <= 0 && v >= 0 && S <= 0) return m = v / (v - S), a.copy(l).addScaledVector(_vac, m);
		const T = y * S - _ * b;
		if (T <= 0 && b - y >= 0 && _ - S >= 0) return _vbc.subVectors(d, c), m = (b - y) / (b - y + (_ - S)), a
			.copy(c).addScaledVector(_vbc, m);
		const A = 1 / (T + w + C);
		return f = w * A, m = C * A, a.copy(l).addScaledVector(_vab, f).addScaledVector(_vac, m)
	}
	equals(s) {
		return s.a.equals(this.a) && s.b.equals(this.b) && s.c.equals(this.c)
	}
}
const _colorKeywords = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		rebeccapurple: 6697881,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	},
	_hslA = {
		h: 0,
		s: 0,
		l: 0
	},
	_hslB = {
		h: 0,
		s: 0,
		l: 0
	};

function hue2rgb(o, s, a) {
	return a < 0 && (a += 1), a > 1 && (a -= 1), a < 1 / 6 ? o + (s - o) * 6 * a : a < 1 / 2 ? s : a < 2 / 3 ? o + (s -
		o) * 6 * (2 / 3 - a) : o
}
class Color {
	constructor(s, a, l) {
		return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(s, a, l)
	}
	set(s, a, l) {
		if (a === void 0 && l === void 0) {
			const c = s;
			c && c.isColor ? this.copy(c) : typeof c == "number" ? this.setHex(c) : typeof c == "string" && this
				.setStyle(c)
		} else this.setRGB(s, a, l);
		return this
	}
	setScalar(s) {
		return this.r = s, this.g = s, this.b = s, this
	}
	setHex(s, a = SRGBColorSpace) {
		return s = Math.floor(s), this.r = (s >> 16 & 255) / 255, this.g = (s >> 8 & 255) / 255, this.b = (s &
			255) / 255, ColorManagement.toWorkingColorSpace(this, a), this
	}
	setRGB(s, a, l, c = ColorManagement.workingColorSpace) {
		return this.r = s, this.g = a, this.b = l, ColorManagement.toWorkingColorSpace(this, c), this
	}
	setHSL(s, a, l, c = ColorManagement.workingColorSpace) {
		if (s = euclideanModulo(s, 1), a = clamp$1(a, 0, 1), l = clamp$1(l, 0, 1), a === 0) this.r = this.g = this
			.b = l;
		else {
			const d = l <= .5 ? l * (1 + a) : l + a - l * a,
				f = 2 * l - d;
			this.r = hue2rgb(f, d, s + 1 / 3), this.g = hue2rgb(f, d, s), this.b = hue2rgb(f, d, s - 1 / 3)
		}
		return ColorManagement.toWorkingColorSpace(this, c), this
	}
	setStyle(s, a = SRGBColorSpace) {
		function l(d) {
			d !== void 0 && parseFloat(d) < 1 && console.warn("THREE.Color: Alpha component of " + s +
				" will be ignored.")
		}
		let c;
		if (c = /^(\w+)\(([^\)]*)\)/.exec(s)) {
			let d;
			const f = c[1],
				m = c[2];
			switch (f) {
				case "rgb":
				case "rgba":
					if (d = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(m)) return l(d[4]),
						this.setRGB(Math.min(255, parseInt(d[1], 10)) / 255, Math.min(255, parseInt(d[2], 10)) /
							255, Math.min(255, parseInt(d[3], 10)) / 255, a);
					if (d = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(m)) return l(
						d[4]), this.setRGB(Math.min(100, parseInt(d[1], 10)) / 100, Math.min(100, parseInt(
						d[2], 10)) / 100, Math.min(100, parseInt(d[3], 10)) / 100, a);
					break;
				case "hsl":
				case "hsla":
					if (d = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/
						.exec(m)) return l(d[4]), this.setHSL(parseFloat(d[1]) / 360, parseFloat(d[2]) / 100,
						parseFloat(d[3]) / 100, a);
					break;
				default:
					console.warn("THREE.Color: Unknown color model " + s)
			}
		} else if (c = /^\#([A-Fa-f\d]+)$/.exec(s)) {
			const d = c[1],
				f = d.length;
			if (f === 3) return this.setRGB(parseInt(d.charAt(0), 16) / 15, parseInt(d.charAt(1), 16) / 15,
				parseInt(d.charAt(2), 16) / 15, a);
			if (f === 6) return this.setHex(parseInt(d, 16), a);
			console.warn("THREE.Color: Invalid hex color " + s)
		} else if (s && s.length > 0) return this.setColorName(s, a);
		return this
	}
	setColorName(s, a = SRGBColorSpace) {
		const l = _colorKeywords[s.toLowerCase()];
		return l !== void 0 ? this.setHex(l, a) : console.warn("THREE.Color: Unknown color " + s), this
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b)
	}
	copy(s) {
		return this.r = s.r, this.g = s.g, this.b = s.b, this
	}
	copySRGBToLinear(s) {
		return this.r = SRGBToLinear(s.r), this.g = SRGBToLinear(s.g), this.b = SRGBToLinear(s.b), this
	}
	copyLinearToSRGB(s) {
		return this.r = LinearToSRGB(s.r), this.g = LinearToSRGB(s.g), this.b = LinearToSRGB(s.b), this
	}
	convertSRGBToLinear() {
		return this.copySRGBToLinear(this), this
	}
	convertLinearToSRGB() {
		return this.copyLinearToSRGB(this), this
	}
	getHex(s = SRGBColorSpace) {
		return ColorManagement.fromWorkingColorSpace(_color$1.copy(this), s), Math.round(clamp$1(_color$1.r * 255,
			0, 255)) * 65536 + Math.round(clamp$1(_color$1.g * 255, 0, 255)) * 256 + Math.round(clamp$1(_color$1
			.b * 255, 0, 255))
	}
	getHexString(s = SRGBColorSpace) {
		return ("000000" + this.getHex(s).toString(16)).slice(-6)
	}
	getHSL(s, a = ColorManagement.workingColorSpace) {
		ColorManagement.fromWorkingColorSpace(_color$1.copy(this), a);
		const l = _color$1.r,
			c = _color$1.g,
			d = _color$1.b,
			f = Math.max(l, c, d),
			m = Math.min(l, c, d);
		let g, v;
		const y = (m + f) / 2;
		if (m === f) g = 0, v = 0;
		else {
			const b = f - m;
			switch (v = y <= .5 ? b / (f + m) : b / (2 - f - m), f) {
				case l:
					g = (c - d) / b + (c < d ? 6 : 0);
					break;
				case c:
					g = (d - l) / b + 2;
					break;
				case d:
					g = (l - c) / b + 4;
					break
			}
			g /= 6
		}
		return s.h = g, s.s = v, s.l = y, s
	}
	getRGB(s, a = ColorManagement.workingColorSpace) {
		return ColorManagement.fromWorkingColorSpace(_color$1.copy(this), a), s.r = _color$1.r, s.g = _color$1.g, s
			.b = _color$1.b, s
	}
	getStyle(s = SRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(_color$1.copy(this), s);
		const a = _color$1.r,
			l = _color$1.g,
			c = _color$1.b;
		return s !== SRGBColorSpace ? `color(${s} ${a.toFixed(3)} ${l.toFixed(3)} ${c.toFixed(3)})` :
			`rgb(${Math.round(a*255)},${Math.round(l*255)},${Math.round(c*255)})`
	}
	offsetHSL(s, a, l) {
		return this.getHSL(_hslA), this.setHSL(_hslA.h + s, _hslA.s + a, _hslA.l + l)
	}
	add(s) {
		return this.r += s.r, this.g += s.g, this.b += s.b, this
	}
	addColors(s, a) {
		return this.r = s.r + a.r, this.g = s.g + a.g, this.b = s.b + a.b, this
	}
	addScalar(s) {
		return this.r += s, this.g += s, this.b += s, this
	}
	sub(s) {
		return this.r = Math.max(0, this.r - s.r), this.g = Math.max(0, this.g - s.g), this.b = Math.max(0, this.b -
			s.b), this
	}
	multiply(s) {
		return this.r *= s.r, this.g *= s.g, this.b *= s.b, this
	}
	multiplyScalar(s) {
		return this.r *= s, this.g *= s, this.b *= s, this
	}
	lerp(s, a) {
		return this.r += (s.r - this.r) * a, this.g += (s.g - this.g) * a, this.b += (s.b - this.b) * a, this
	}
	lerpColors(s, a, l) {
		return this.r = s.r + (a.r - s.r) * l, this.g = s.g + (a.g - s.g) * l, this.b = s.b + (a.b - s.b) * l, this
	}
	lerpHSL(s, a) {
		this.getHSL(_hslA), s.getHSL(_hslB);
		const l = lerp(_hslA.h, _hslB.h, a),
			c = lerp(_hslA.s, _hslB.s, a),
			d = lerp(_hslA.l, _hslB.l, a);
		return this.setHSL(l, c, d), this
	}
	setFromVector3(s) {
		return this.r = s.x, this.g = s.y, this.b = s.z, this
	}
	applyMatrix3(s) {
		const a = this.r,
			l = this.g,
			c = this.b,
			d = s.elements;
		return this.r = d[0] * a + d[3] * l + d[6] * c, this.g = d[1] * a + d[4] * l + d[7] * c, this.b = d[2] * a +
			d[5] * l + d[8] * c, this
	}
	equals(s) {
		return s.r === this.r && s.g === this.g && s.b === this.b
	}
	fromArray(s, a = 0) {
		return this.r = s[a], this.g = s[a + 1], this.b = s[a + 2], this
	}
	toArray(s = [], a = 0) {
		return s[a] = this.r, s[a + 1] = this.g, s[a + 2] = this.b, s
	}
	fromBufferAttribute(s, a) {
		return this.r = s.getX(a), this.g = s.getY(a), this.b = s.getZ(a), this
	}
	toJSON() {
		return this.getHex()
	}*[Symbol.iterator]() {
		yield this.r, yield this.g, yield this.b
	}
}
const _color$1 = new Color;
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
	constructor() {
		super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
				value: _materialId++
			}), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.blending = NormalBlending,
			this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this
			.alphaHash = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this
			.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this
			.blendEquationAlpha = null, this.blendColor = new Color(0, 0, 0), this.blendAlpha = 0, this.depthFunc =
			LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this
			.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail =
			KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this
			.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this
			.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this
			.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1,
			this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0,
			this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
	}
	get alphaTest() {
		return this._alphaTest
	}
	set alphaTest(s) {
		this._alphaTest > 0 != s > 0 && this.version++, this._alphaTest = s
	}
	onBeforeRender() {}
	onBeforeCompile() {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString()
	}
	setValues(s) {
		if (s !== void 0)
			for (const a in s) {
				const l = s[a];
				if (l === void 0) {
					console.warn(`THREE.Material: parameter '${a}' has value of undefined.`);
					continue
				}
				const c = this[a];
				if (c === void 0) {
					console.warn(`THREE.Material: '${a}' is not a property of THREE.${this.type}.`);
					continue
				}
				c && c.isColor ? c.set(l) : c && c.isVector3 && l && l.isVector3 ? c.copy(l) : this[a] = l
			}
	}
	toJSON(s) {
		const a = s === void 0 || typeof s == "string";
		a && (s = {
			textures: {},
			images: {}
		});
		const l = {
			metadata: {
				version: 4.6,
				type: "Material",
				generator: "Material.toJSON"
			}
		};
		l.uuid = this.uuid, l.type = this.type, this.name !== "" && (l.name = this.name), this.color && this.color
			.isColor && (l.color = this.color.getHex()), this.roughness !== void 0 && (l.roughness = this
			.roughness), this.metalness !== void 0 && (l.metalness = this.metalness), this.sheen !== void 0 && (l
				.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (l.sheenColor = this.sheenColor
				.getHex()), this.sheenRoughness !== void 0 && (l.sheenRoughness = this.sheenRoughness), this
			.emissive && this.emissive.isColor && (l.emissive = this.emissive.getHex()), this.emissiveIntensity !==
			void 0 && this.emissiveIntensity !== 1 && (l.emissiveIntensity = this.emissiveIntensity), this
			.specular && this.specular.isColor && (l.specular = this.specular.getHex()), this.specularIntensity !==
			void 0 && (l.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor
			.isColor && (l.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (l.shininess =
				this.shininess), this.clearcoat !== void 0 && (l.clearcoat = this.clearcoat), this
			.clearcoatRoughness !== void 0 && (l.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap &&
			this.clearcoatMap.isTexture && (l.clearcoatMap = this.clearcoatMap.toJSON(s).uuid), this
			.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (l.clearcoatRoughnessMap = this
				.clearcoatRoughnessMap.toJSON(s).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap
			.isTexture && (l.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(s).uuid, l.clearcoatNormalScale =
				this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (l.dispersion = this
			.dispersion), this.iridescence !== void 0 && (l.iridescence = this.iridescence), this.iridescenceIOR !==
			void 0 && (l.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (l
				.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this
			.iridescenceMap.isTexture && (l.iridescenceMap = this.iridescenceMap.toJSON(s).uuid), this
			.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (l.iridescenceThicknessMap = this
				.iridescenceThicknessMap.toJSON(s).uuid), this.anisotropy !== void 0 && (l.anisotropy = this
				.anisotropy), this.anisotropyRotation !== void 0 && (l.anisotropyRotation = this
			.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (l.anisotropyMap = this
				.anisotropyMap.toJSON(s).uuid), this.map && this.map.isTexture && (l.map = this.map.toJSON(s).uuid),
			this.matcap && this.matcap.isTexture && (l.matcap = this.matcap.toJSON(s).uuid), this.alphaMap && this
			.alphaMap.isTexture && (l.alphaMap = this.alphaMap.toJSON(s).uuid), this.lightMap && this.lightMap
			.isTexture && (l.lightMap = this.lightMap.toJSON(s).uuid, l.lightMapIntensity = this.lightMapIntensity),
			this.aoMap && this.aoMap.isTexture && (l.aoMap = this.aoMap.toJSON(s).uuid, l.aoMapIntensity = this
				.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (l.bumpMap = this.bumpMap.toJSON(s)
				.uuid, l.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (l.normalMap =
				this.normalMap.toJSON(s).uuid, l.normalMapType = this.normalMapType, l.normalScale = this
				.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (l
				.displacementMap = this.displacementMap.toJSON(s).uuid, l.displacementScale = this
				.displacementScale, l.displacementBias = this.displacementBias), this.roughnessMap && this
			.roughnessMap.isTexture && (l.roughnessMap = this.roughnessMap.toJSON(s).uuid), this.metalnessMap &&
			this.metalnessMap.isTexture && (l.metalnessMap = this.metalnessMap.toJSON(s).uuid), this.emissiveMap &&
			this.emissiveMap.isTexture && (l.emissiveMap = this.emissiveMap.toJSON(s).uuid), this.specularMap &&
			this.specularMap.isTexture && (l.specularMap = this.specularMap.toJSON(s).uuid), this
			.specularIntensityMap && this.specularIntensityMap.isTexture && (l.specularIntensityMap = this
				.specularIntensityMap.toJSON(s).uuid), this.specularColorMap && this.specularColorMap.isTexture && (
				l.specularColorMap = this.specularColorMap.toJSON(s).uuid), this.envMap && this.envMap.isTexture &&
			(l.envMap = this.envMap.toJSON(s).uuid, this.combine !== void 0 && (l.combine = this.combine)), this
			.envMapRotation !== void 0 && (l.envMapRotation = this.envMapRotation.toArray()), this
			.envMapIntensity !== void 0 && (l.envMapIntensity = this.envMapIntensity), this.reflectivity !==
			void 0 && (l.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (l.refractionRatio =
				this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (l.gradientMap = this
				.gradientMap.toJSON(s).uuid), this.transmission !== void 0 && (l.transmission = this.transmission),
			this.transmissionMap && this.transmissionMap.isTexture && (l.transmissionMap = this.transmissionMap
				.toJSON(s).uuid), this.thickness !== void 0 && (l.thickness = this.thickness), this.thicknessMap &&
			this.thicknessMap.isTexture && (l.thicknessMap = this.thicknessMap.toJSON(s).uuid), this
			.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (l.attenuationDistance = this
				.attenuationDistance), this.attenuationColor !== void 0 && (l.attenuationColor = this
				.attenuationColor.getHex()), this.size !== void 0 && (l.size = this.size), this.shadowSide !==
			null && (l.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (l.sizeAttenuation = this
				.sizeAttenuation), this.blending !== NormalBlending && (l.blending = this.blending), this.side !==
			FrontSide && (l.side = this.side), this.vertexColors === !0 && (l.vertexColors = !0), this.opacity <
			1 && (l.opacity = this.opacity), this.transparent === !0 && (l.transparent = !0), this.blendSrc !==
			SrcAlphaFactor && (l.blendSrc = this.blendSrc), this.blendDst !== OneMinusSrcAlphaFactor && (l
				.blendDst = this.blendDst), this.blendEquation !== AddEquation && (l.blendEquation = this
				.blendEquation), this.blendSrcAlpha !== null && (l.blendSrcAlpha = this.blendSrcAlpha), this
			.blendDstAlpha !== null && (l.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (
				l.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (l
				.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (l.blendAlpha = this.blendAlpha),
			this.depthFunc !== LessEqualDepth && (l.depthFunc = this.depthFunc), this.depthTest === !1 && (l
				.depthTest = this.depthTest), this.depthWrite === !1 && (l.depthWrite = this.depthWrite), this
			.colorWrite === !1 && (l.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (l
				.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== AlwaysStencilFunc && (l
				.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (l.stencilRef = this.stencilRef), this
			.stencilFuncMask !== 255 && (l.stencilFuncMask = this.stencilFuncMask), this.stencilFail !==
			KeepStencilOp && (l.stencilFail = this.stencilFail), this.stencilZFail !== KeepStencilOp && (l
				.stencilZFail = this.stencilZFail), this.stencilZPass !== KeepStencilOp && (l.stencilZPass = this
				.stencilZPass), this.stencilWrite === !0 && (l.stencilWrite = this.stencilWrite), this.rotation !==
			void 0 && this.rotation !== 0 && (l.rotation = this.rotation), this.polygonOffset === !0 && (l
				.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (l.polygonOffsetFactor = this
				.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (l.polygonOffsetUnits = this
				.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (l.linewidth = this
				.linewidth), this.dashSize !== void 0 && (l.dashSize = this.dashSize), this.gapSize !== void 0 && (l
				.gapSize = this.gapSize), this.scale !== void 0 && (l.scale = this.scale), this.dithering === !0 &&
			(l.dithering = !0), this.alphaTest > 0 && (l.alphaTest = this.alphaTest), this.alphaHash === !0 && (l
				.alphaHash = !0), this.alphaToCoverage === !0 && (l.alphaToCoverage = !0), this
			.premultipliedAlpha === !0 && (l.premultipliedAlpha = !0), this.forceSinglePass === !0 && (l
				.forceSinglePass = !0), this.wireframe === !0 && (l.wireframe = !0), this.wireframeLinewidth > 1 &&
			(l.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (l
				.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (l
				.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (l.flatShading = !0), this
			.visible === !1 && (l.visible = !1), this.toneMapped === !1 && (l.toneMapped = !1), this.fog === !1 && (
				l.fog = !1), Object.keys(this.userData).length > 0 && (l.userData = this.userData);

		function c(d) {
			const f = [];
			for (const m in d) {
				const g = d[m];
				delete g.metadata, f.push(g)
			}
			return f
		}
		if (a) {
			const d = c(s.textures),
				f = c(s.images);
			d.length > 0 && (l.textures = d), f.length > 0 && (l.images = f)
		}
		return l
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(s) {
		this.name = s.name, this.blending = s.blending, this.side = s.side, this.vertexColors = s.vertexColors, this
			.opacity = s.opacity, this.transparent = s.transparent, this.blendSrc = s.blendSrc, this.blendDst = s
			.blendDst, this.blendEquation = s.blendEquation, this.blendSrcAlpha = s.blendSrcAlpha, this
			.blendDstAlpha = s.blendDstAlpha, this.blendEquationAlpha = s.blendEquationAlpha, this.blendColor.copy(s
				.blendColor), this.blendAlpha = s.blendAlpha, this.depthFunc = s.depthFunc, this.depthTest = s
			.depthTest, this.depthWrite = s.depthWrite, this.stencilWriteMask = s.stencilWriteMask, this
			.stencilFunc = s.stencilFunc, this.stencilRef = s.stencilRef, this.stencilFuncMask = s.stencilFuncMask,
			this.stencilFail = s.stencilFail, this.stencilZFail = s.stencilZFail, this.stencilZPass = s
			.stencilZPass, this.stencilWrite = s.stencilWrite;
		const a = s.clippingPlanes;
		let l = null;
		if (a !== null) {
			const c = a.length;
			l = new Array(c);
			for (let d = 0; d !== c; ++d) l[d] = a[d].clone()
		}
		return this.clippingPlanes = l, this.clipIntersection = s.clipIntersection, this.clipShadows = s
			.clipShadows, this.shadowSide = s.shadowSide, this.colorWrite = s.colorWrite, this.precision = s
			.precision, this.polygonOffset = s.polygonOffset, this.polygonOffsetFactor = s.polygonOffsetFactor, this
			.polygonOffsetUnits = s.polygonOffsetUnits, this.dithering = s.dithering, this.alphaTest = s.alphaTest,
			this.alphaHash = s.alphaHash, this.alphaToCoverage = s.alphaToCoverage, this.premultipliedAlpha = s
			.premultipliedAlpha, this.forceSinglePass = s.forceSinglePass, this.visible = s.visible, this
			.toneMapped = s.toneMapped, this.userData = JSON.parse(JSON.stringify(s.userData)), this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	set needsUpdate(s) {
		s === !0 && this.version++
	}
}
class MeshBasicMaterial extends Material {
	constructor(s) {
		super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Color(16777215),
			this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this
			.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this
			.envMapRotation = new Euler, this.combine = MultiplyOperation, this.reflectivity = 1, this
			.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap =
			"round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.color.copy(s.color), this.map = s.map, this.lightMap = s.lightMap, this
			.lightMapIntensity = s.lightMapIntensity, this.aoMap = s.aoMap, this.aoMapIntensity = s.aoMapIntensity,
			this.specularMap = s.specularMap, this.alphaMap = s.alphaMap, this.envMap = s.envMap, this
			.envMapRotation.copy(s.envMapRotation), this.combine = s.combine, this.reflectivity = s.reflectivity,
			this.refractionRatio = s.refractionRatio, this.wireframe = s.wireframe, this.wireframeLinewidth = s
			.wireframeLinewidth, this.wireframeLinecap = s.wireframeLinecap, this.wireframeLinejoin = s
			.wireframeLinejoin, this.fog = s.fog, this
	}
}
const _vector$9 = new Vector3$1,
	_vector2$1 = new Vector2;
let _id$2 = 0;
class BufferAttribute {
	constructor(s, a, l = !1) {
		if (Array.isArray(s)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
				value: _id$2++
			}), this.name = "", this.array = s, this.itemSize = a, this.count = s !== void 0 ? s.length / a : 0,
			this.normalized = l, this.usage = StaticDrawUsage, this.updateRanges = [], this.gpuType = FloatType,
			this.version = 0
	}
	onUploadCallback() {}
	set needsUpdate(s) {
		s === !0 && this.version++
	}
	setUsage(s) {
		return this.usage = s, this
	}
	addUpdateRange(s, a) {
		this.updateRanges.push({
			start: s,
			count: a
		})
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0
	}
	copy(s) {
		return this.name = s.name, this.array = new s.array.constructor(s.array), this.itemSize = s.itemSize, this
			.count = s.count, this.normalized = s.normalized, this.usage = s.usage, this.gpuType = s.gpuType, this
	}
	copyAt(s, a, l) {
		s *= this.itemSize, l *= a.itemSize;
		for (let c = 0, d = this.itemSize; c < d; c++) this.array[s + c] = a.array[l + c];
		return this
	}
	copyArray(s) {
		return this.array.set(s), this
	}
	applyMatrix3(s) {
		if (this.itemSize === 2)
			for (let a = 0, l = this.count; a < l; a++) _vector2$1.fromBufferAttribute(this, a), _vector2$1
				.applyMatrix3(s), this.setXY(a, _vector2$1.x, _vector2$1.y);
		else if (this.itemSize === 3)
			for (let a = 0, l = this.count; a < l; a++) _vector$9.fromBufferAttribute(this, a), _vector$9
				.applyMatrix3(s), this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	applyMatrix4(s) {
		for (let a = 0, l = this.count; a < l; a++) _vector$9.fromBufferAttribute(this, a), _vector$9.applyMatrix4(
			s), this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	applyNormalMatrix(s) {
		for (let a = 0, l = this.count; a < l; a++) _vector$9.fromBufferAttribute(this, a), _vector$9
			.applyNormalMatrix(s), this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	transformDirection(s) {
		for (let a = 0, l = this.count; a < l; a++) _vector$9.fromBufferAttribute(this, a), _vector$9
			.transformDirection(s), this.setXYZ(a, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	set(s, a = 0) {
		return this.array.set(s, a), this
	}
	getComponent(s, a) {
		let l = this.array[s * this.itemSize + a];
		return this.normalized && (l = denormalize(l, this.array)), l
	}
	setComponent(s, a, l) {
		return this.normalized && (l = normalize(l, this.array)), this.array[s * this.itemSize + a] = l, this
	}
	getX(s) {
		let a = this.array[s * this.itemSize];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	setX(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.array[s * this.itemSize] = a, this
	}
	getY(s) {
		let a = this.array[s * this.itemSize + 1];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	setY(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.array[s * this.itemSize + 1] = a, this
	}
	getZ(s) {
		let a = this.array[s * this.itemSize + 2];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	setZ(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.array[s * this.itemSize + 2] = a, this
	}
	getW(s) {
		let a = this.array[s * this.itemSize + 3];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	setW(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.array[s * this.itemSize + 3] = a, this
	}
	setXY(s, a, l) {
		return s *= this.itemSize, this.normalized && (a = normalize(a, this.array), l = normalize(l, this.array)),
			this.array[s + 0] = a, this.array[s + 1] = l, this
	}
	setXYZ(s, a, l, c) {
		return s *= this.itemSize, this.normalized && (a = normalize(a, this.array), l = normalize(l, this.array),
				c = normalize(c, this.array)), this.array[s + 0] = a, this.array[s + 1] = l, this.array[s + 2] = c,
			this
	}
	setXYZW(s, a, l, c, d) {
		return s *= this.itemSize, this.normalized && (a = normalize(a, this.array), l = normalize(l, this.array),
			c = normalize(c, this.array), d = normalize(d, this.array)), this.array[s + 0] = a, this.array[s +
			1] = l, this.array[s + 2] = c, this.array[s + 3] = d, this
	}
	onUpload(s) {
		return this.onUploadCallback = s, this
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this)
	}
	toJSON() {
		const s = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from(this.array),
			normalized: this.normalized
		};
		return this.name !== "" && (s.name = this.name), this.usage !== StaticDrawUsage && (s.usage = this.usage), s
	}
}
class Uint8BufferAttribute extends BufferAttribute {
	constructor(s, a, l) {
		super(new Uint8Array(s), a, l)
	}
}
class Uint16BufferAttribute extends BufferAttribute {
	constructor(s, a, l) {
		super(new Uint16Array(s), a, l)
	}
}
class Uint32BufferAttribute extends BufferAttribute {
	constructor(s, a, l) {
		super(new Uint32Array(s), a, l)
	}
}
class Float32BufferAttribute extends BufferAttribute {
	constructor(s, a, l) {
		super(new Float32Array(s), a, l)
	}
}
let _id$1 = 0;
const _m1$3 = new Matrix4,
	_obj = new Object3D,
	_offset = new Vector3$1,
	_box$2 = new Box3,
	_boxMorphTargets = new Box3,
	_vector$8 = new Vector3$1;
class BufferGeometry extends EventDispatcher {
	constructor() {
		super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
				value: _id$1++
			}), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this
			.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this
			.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
				start: 0,
				count: 1 / 0
			}, this.userData = {}
	}
	getIndex() {
		return this.index
	}
	setIndex(s) {
		return Array.isArray(s) ? this.index = new(arrayNeedsUint32(s) ? Uint32BufferAttribute :
			Uint16BufferAttribute)(s, 1) : this.index = s, this
	}
	setIndirect(s) {
		return this.indirect = s, this
	}
	getIndirect() {
		return this.indirect
	}
	getAttribute(s) {
		return this.attributes[s]
	}
	setAttribute(s, a) {
		return this.attributes[s] = a, this
	}
	deleteAttribute(s) {
		return delete this.attributes[s], this
	}
	hasAttribute(s) {
		return this.attributes[s] !== void 0
	}
	addGroup(s, a, l = 0) {
		this.groups.push({
			start: s,
			count: a,
			materialIndex: l
		})
	}
	clearGroups() {
		this.groups = []
	}
	setDrawRange(s, a) {
		this.drawRange.start = s, this.drawRange.count = a
	}
	applyMatrix4(s) {
		const a = this.attributes.position;
		a !== void 0 && (a.applyMatrix4(s), a.needsUpdate = !0);
		const l = this.attributes.normal;
		if (l !== void 0) {
			const d = new Matrix3().getNormalMatrix(s);
			l.applyNormalMatrix(d), l.needsUpdate = !0
		}
		const c = this.attributes.tangent;
		return c !== void 0 && (c.transformDirection(s), c.needsUpdate = !0), this.boundingBox !== null && this
			.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
	}
	applyQuaternion(s) {
		return _m1$3.makeRotationFromQuaternion(s), this.applyMatrix4(_m1$3), this
	}
	rotateX(s) {
		return _m1$3.makeRotationX(s), this.applyMatrix4(_m1$3), this
	}
	rotateY(s) {
		return _m1$3.makeRotationY(s), this.applyMatrix4(_m1$3), this
	}
	rotateZ(s) {
		return _m1$3.makeRotationZ(s), this.applyMatrix4(_m1$3), this
	}
	translate(s, a, l) {
		return _m1$3.makeTranslation(s, a, l), this.applyMatrix4(_m1$3), this
	}
	scale(s, a, l) {
		return _m1$3.makeScale(s, a, l), this.applyMatrix4(_m1$3), this
	}
	lookAt(s) {
		return _obj.lookAt(s), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
	}
	center() {
		return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x,
			_offset.y, _offset.z), this
	}
	setFromPoints(s) {
		const a = this.getAttribute("position");
		if (a === void 0) {
			const l = [];
			for (let c = 0, d = s.length; c < d; c++) {
				const f = s[c];
				l.push(f.x, f.y, f.z || 0)
			}
			this.setAttribute("position", new Float32BufferAttribute(l, 3))
		} else {
			const l = Math.min(s.length, a.count);
			for (let c = 0; c < l; c++) {
				const d = s[c];
				a.setXYZ(c, d.x, d.y, d.z || 0)
			}
			s.length > a.count && console.warn(
				"THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
				), a.needsUpdate = !0
		}
		return this
	}
	computeBoundingBox() {
		this.boundingBox === null && (this.boundingBox = new Box3);
		const s = this.attributes.position,
			a = this.morphAttributes.position;
		if (s && s.isGLBufferAttribute) {
			console.error(
				"THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
				this), this.boundingBox.set(new Vector3$1(-1 / 0, -1 / 0, -1 / 0), new Vector3$1(1 / 0, 1 / 0,
				1 / 0));
			return
		}
		if (s !== void 0) {
			if (this.boundingBox.setFromBufferAttribute(s), a)
				for (let l = 0, c = a.length; l < c; l++) {
					const d = a[l];
					_box$2.setFromBufferAttribute(d), this.morphTargetsRelative ? (_vector$8.addVectors(this
							.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8
						.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)
						) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2
						.max))
				}
		} else this.boundingBox.makeEmpty();
		(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console
			.error(
				'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
				this)
	}
	computeBoundingSphere() {
		this.boundingSphere === null && (this.boundingSphere = new Sphere);
		const s = this.attributes.position,
			a = this.morphAttributes.position;
		if (s && s.isGLBufferAttribute) {
			console.error(
				"THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
				this), this.boundingSphere.set(new Vector3$1, 1 / 0);
			return
		}
		if (s) {
			const l = this.boundingSphere.center;
			if (_box$2.setFromBufferAttribute(s), a)
				for (let d = 0, f = a.length; d < f; d++) {
					const m = a[d];
					_boxMorphTargets.setFromBufferAttribute(m), this.morphTargetsRelative ? (_vector$8.addVectors(
							_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8
						.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (
						_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max))
				}
			_box$2.getCenter(l);
			let c = 0;
			for (let d = 0, f = s.count; d < f; d++) _vector$8.fromBufferAttribute(s, d), c = Math.max(c, l
				.distanceToSquared(_vector$8));
			if (a)
				for (let d = 0, f = a.length; d < f; d++) {
					const m = a[d],
						g = this.morphTargetsRelative;
					for (let v = 0, y = m.count; v < y; v++) _vector$8.fromBufferAttribute(m, v), g && (_offset
						.fromBufferAttribute(s, v), _vector$8.add(_offset)), c = Math.max(c, l
						.distanceToSquared(_vector$8))
				}
			this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error(
				'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
				this)
		}
	}
	computeTangents() {
		const s = this.index,
			a = this.attributes;
		if (s === null || a.position === void 0 || a.normal === void 0 || a.uv === void 0) {
			console.error(
				"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
				);
			return
		}
		const l = a.position,
			c = a.normal,
			d = a.uv;
		this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 *
			l.count), 4));
		const f = this.getAttribute("tangent"),
			m = [],
			g = [];
		for (let U = 0; U < l.count; U++) m[U] = new Vector3$1, g[U] = new Vector3$1;
		const v = new Vector3$1,
			y = new Vector3$1,
			b = new Vector3$1,
			C = new Vector2,
			_ = new Vector2,
			S = new Vector2,
			w = new Vector3$1,
			T = new Vector3$1;

		function A(U, V, z) {
			v.fromBufferAttribute(l, U), y.fromBufferAttribute(l, V), b.fromBufferAttribute(l, z), C
				.fromBufferAttribute(d, U), _.fromBufferAttribute(d, V), S.fromBufferAttribute(d, z), y.sub(v), b
				.sub(v), _.sub(C), S.sub(C);
			const j = 1 / (_.x * S.y - S.x * _.y);
			isFinite(j) && (w.copy(y).multiplyScalar(S.y).addScaledVector(b, -_.y).multiplyScalar(j), T.copy(b)
				.multiplyScalar(_.x).addScaledVector(y, -S.x).multiplyScalar(j), m[U].add(w), m[V].add(w), m[z]
				.add(w), g[U].add(T), g[V].add(T), g[z].add(T))
		}
		let k = this.groups;
		k.length === 0 && (k = [{
			start: 0,
			count: s.count
		}]);
		for (let U = 0, V = k.length; U < V; ++U) {
			const z = k[U],
				j = z.start,
				ge = z.count;
			for (let me = j, he = j + ge; me < he; me += 3) A(s.getX(me + 0), s.getX(me + 1), s.getX(me + 2))
		}
		const M = new Vector3$1,
			D = new Vector3$1,
			F = new Vector3$1,
			R = new Vector3$1;

		function O(U) {
			F.fromBufferAttribute(c, U), R.copy(F);
			const V = m[U];
			M.copy(V), M.sub(F.multiplyScalar(F.dot(V))).normalize(), D.crossVectors(R, V);
			const j = D.dot(g[U]) < 0 ? -1 : 1;
			f.setXYZW(U, M.x, M.y, M.z, j)
		}
		for (let U = 0, V = k.length; U < V; ++U) {
			const z = k[U],
				j = z.start,
				ge = z.count;
			for (let me = j, he = j + ge; me < he; me += 3) O(s.getX(me + 0)), O(s.getX(me + 1)), O(s.getX(me + 2))
		}
	}
	computeVertexNormals() {
		const s = this.index,
			a = this.getAttribute("position");
		if (a !== void 0) {
			let l = this.getAttribute("normal");
			if (l === void 0) l = new BufferAttribute(new Float32Array(a.count * 3), 3), this.setAttribute("normal",
				l);
			else
				for (let C = 0, _ = l.count; C < _; C++) l.setXYZ(C, 0, 0, 0);
			const c = new Vector3$1,
				d = new Vector3$1,
				f = new Vector3$1,
				m = new Vector3$1,
				g = new Vector3$1,
				v = new Vector3$1,
				y = new Vector3$1,
				b = new Vector3$1;
			if (s)
				for (let C = 0, _ = s.count; C < _; C += 3) {
					const S = s.getX(C + 0),
						w = s.getX(C + 1),
						T = s.getX(C + 2);
					c.fromBufferAttribute(a, S), d.fromBufferAttribute(a, w), f.fromBufferAttribute(a, T), y
						.subVectors(f, d), b.subVectors(c, d), y.cross(b), m.fromBufferAttribute(l, S), g
						.fromBufferAttribute(l, w), v.fromBufferAttribute(l, T), m.add(y), g.add(y), v.add(y), l
						.setXYZ(S, m.x, m.y, m.z), l.setXYZ(w, g.x, g.y, g.z), l.setXYZ(T, v.x, v.y, v.z)
				} else
					for (let C = 0, _ = a.count; C < _; C += 3) c.fromBufferAttribute(a, C + 0), d
						.fromBufferAttribute(a, C + 1), f.fromBufferAttribute(a, C + 2), y.subVectors(f, d), b
						.subVectors(c, d), y.cross(b), l.setXYZ(C + 0, y.x, y.y, y.z), l.setXYZ(C + 1, y.x, y.y, y
							.z), l.setXYZ(C + 2, y.x, y.y, y.z);
			this.normalizeNormals(), l.needsUpdate = !0
		}
	}
	normalizeNormals() {
		const s = this.attributes.normal;
		for (let a = 0, l = s.count; a < l; a++) _vector$8.fromBufferAttribute(s, a), _vector$8.normalize(), s
			.setXYZ(a, _vector$8.x, _vector$8.y, _vector$8.z)
	}
	toNonIndexed() {
		function s(m, g) {
			const v = m.array,
				y = m.itemSize,
				b = m.normalized,
				C = new v.constructor(g.length * y);
			let _ = 0,
				S = 0;
			for (let w = 0, T = g.length; w < T; w++) {
				m.isInterleavedBufferAttribute ? _ = g[w] * m.data.stride + m.offset : _ = g[w] * y;
				for (let A = 0; A < y; A++) C[S++] = v[_++]
			}
			return new BufferAttribute(C, y, b)
		}
		if (this.index === null) return console.warn(
			"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
		const a = new BufferGeometry,
			l = this.index.array,
			c = this.attributes;
		for (const m in c) {
			const g = c[m],
				v = s(g, l);
			a.setAttribute(m, v)
		}
		const d = this.morphAttributes;
		for (const m in d) {
			const g = [],
				v = d[m];
			for (let y = 0, b = v.length; y < b; y++) {
				const C = v[y],
					_ = s(C, l);
				g.push(_)
			}
			a.morphAttributes[m] = g
		}
		a.morphTargetsRelative = this.morphTargetsRelative;
		const f = this.groups;
		for (let m = 0, g = f.length; m < g; m++) {
			const v = f[m];
			a.addGroup(v.start, v.count, v.materialIndex)
		}
		return a
	}
	toJSON() {
		const s = {
			metadata: {
				version: 4.6,
				type: "BufferGeometry",
				generator: "BufferGeometry.toJSON"
			}
		};
		if (s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), Object.keys(this
				.userData).length > 0 && (s.userData = this.userData), this.parameters !== void 0) {
			const g = this.parameters;
			for (const v in g) g[v] !== void 0 && (s[v] = g[v]);
			return s
		}
		s.data = {
			attributes: {}
		};
		const a = this.index;
		a !== null && (s.data.index = {
			type: a.array.constructor.name,
			array: Array.prototype.slice.call(a.array)
		});
		const l = this.attributes;
		for (const g in l) {
			const v = l[g];
			s.data.attributes[g] = v.toJSON(s.data)
		}
		const c = {};
		let d = !1;
		for (const g in this.morphAttributes) {
			const v = this.morphAttributes[g],
				y = [];
			for (let b = 0, C = v.length; b < C; b++) {
				const _ = v[b];
				y.push(_.toJSON(s.data))
			}
			y.length > 0 && (c[g] = y, d = !0)
		}
		d && (s.data.morphAttributes = c, s.data.morphTargetsRelative = this.morphTargetsRelative);
		const f = this.groups;
		f.length > 0 && (s.data.groups = JSON.parse(JSON.stringify(f)));
		const m = this.boundingSphere;
		return m !== null && (s.data.boundingSphere = {
			center: m.center.toArray(),
			radius: m.radius
		}), s
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(s) {
		this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox =
			null, this.boundingSphere = null;
		const a = {};
		this.name = s.name;
		const l = s.index;
		l !== null && this.setIndex(l.clone());
		const c = s.attributes;
		for (const v in c) {
			const y = c[v];
			this.setAttribute(v, y.clone(a))
		}
		const d = s.morphAttributes;
		for (const v in d) {
			const y = [],
				b = d[v];
			for (let C = 0, _ = b.length; C < _; C++) y.push(b[C].clone(a));
			this.morphAttributes[v] = y
		}
		this.morphTargetsRelative = s.morphTargetsRelative;
		const f = s.groups;
		for (let v = 0, y = f.length; v < y; v++) {
			const b = f[v];
			this.addGroup(b.start, b.count, b.materialIndex)
		}
		const m = s.boundingBox;
		m !== null && (this.boundingBox = m.clone());
		const g = s.boundingSphere;
		return g !== null && (this.boundingSphere = g.clone()), this.drawRange.start = s.drawRange.start, this
			.drawRange.count = s.drawRange.count, this.userData = s.userData, this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
const _inverseMatrix$3 = new Matrix4,
	_ray$3 = new Ray,
	_sphere$6 = new Sphere,
	_sphereHitAt = new Vector3$1,
	_vA$1 = new Vector3$1,
	_vB$1 = new Vector3$1,
	_vC$1 = new Vector3$1,
	_tempA = new Vector3$1,
	_morphA = new Vector3$1,
	_intersectionPoint = new Vector3$1,
	_intersectionPointWorld = new Vector3$1;
class Mesh extends Object3D {
	constructor(s = new BufferGeometry, a = new MeshBasicMaterial) {
		super(), this.isMesh = !0, this.type = "Mesh", this.geometry = s, this.material = a, this
			.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
	}
	copy(s, a) {
		return super.copy(s, a), s.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = s
				.morphTargetInfluences.slice()), s.morphTargetDictionary !== void 0 && (this.morphTargetDictionary =
				Object.assign({}, s.morphTargetDictionary)), this.material = Array.isArray(s.material) ? s.material
			.slice() : s.material, this.geometry = s.geometry, this
	}
	updateMorphTargets() {
		const a = this.geometry.morphAttributes,
			l = Object.keys(a);
		if (l.length > 0) {
			const c = a[l[0]];
			if (c !== void 0) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let d = 0, f = c.length; d < f; d++) {
					const m = c[d].name || String(d);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[m] = d
				}
			}
		}
	}
	getVertexPosition(s, a) {
		const l = this.geometry,
			c = l.attributes.position,
			d = l.morphAttributes.position,
			f = l.morphTargetsRelative;
		a.fromBufferAttribute(c, s);
		const m = this.morphTargetInfluences;
		if (d && m) {
			_morphA.set(0, 0, 0);
			for (let g = 0, v = d.length; g < v; g++) {
				const y = m[g],
					b = d[g];
				y !== 0 && (_tempA.fromBufferAttribute(b, s), f ? _morphA.addScaledVector(_tempA, y) : _morphA
					.addScaledVector(_tempA.sub(a), y))
			}
			a.add(_morphA)
		}
		return a
	}
	raycast(s, a) {
		const l = this.geometry,
			c = this.material,
			d = this.matrixWorld;
		c !== void 0 && (l.boundingSphere === null && l.computeBoundingSphere(), _sphere$6.copy(l.boundingSphere),
			_sphere$6.applyMatrix4(d), _ray$3.copy(s.ray).recast(s.near), !(_sphere$6.containsPoint(_ray$3
				.origin) === !1 && (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null || _ray$3
				.origin.distanceToSquared(_sphereHitAt) > (s.far - s.near) ** 2)) && (_inverseMatrix$3.copy(d)
				.invert(), _ray$3.copy(s.ray).applyMatrix4(_inverseMatrix$3), !(l.boundingBox !== null && _ray$3
					.intersectsBox(l.boundingBox) === !1) && this._computeIntersections(s, a, _ray$3)))
	}
	_computeIntersections(s, a, l) {
		let c;
		const d = this.geometry,
			f = this.material,
			m = d.index,
			g = d.attributes.position,
			v = d.attributes.uv,
			y = d.attributes.uv1,
			b = d.attributes.normal,
			C = d.groups,
			_ = d.drawRange;
		if (m !== null)
			if (Array.isArray(f))
				for (let S = 0, w = C.length; S < w; S++) {
					const T = C[S],
						A = f[T.materialIndex],
						k = Math.max(T.start, _.start),
						M = Math.min(m.count, Math.min(T.start + T.count, _.start + _.count));
					for (let D = k, F = M; D < F; D += 3) {
						const R = m.getX(D),
							O = m.getX(D + 1),
							U = m.getX(D + 2);
						c = checkGeometryIntersection(this, A, s, l, v, y, b, R, O, U), c && (c.faceIndex = Math
							.floor(D / 3), c.face.materialIndex = T.materialIndex, a.push(c))
					}
				} else {
					const S = Math.max(0, _.start),
						w = Math.min(m.count, _.start + _.count);
					for (let T = S, A = w; T < A; T += 3) {
						const k = m.getX(T),
							M = m.getX(T + 1),
							D = m.getX(T + 2);
						c = checkGeometryIntersection(this, f, s, l, v, y, b, k, M, D), c && (c.faceIndex = Math
							.floor(T / 3), a.push(c))
					}
				} else if (g !== void 0)
					if (Array.isArray(f))
						for (let S = 0, w = C.length; S < w; S++) {
							const T = C[S],
								A = f[T.materialIndex],
								k = Math.max(T.start, _.start),
								M = Math.min(g.count, Math.min(T.start + T.count, _.start + _.count));
							for (let D = k, F = M; D < F; D += 3) {
								const R = D,
									O = D + 1,
									U = D + 2;
								c = checkGeometryIntersection(this, A, s, l, v, y, b, R, O, U), c && (c.faceIndex =
									Math.floor(D / 3), c.face.materialIndex = T.materialIndex, a.push(c))
							}
						} else {
							const S = Math.max(0, _.start),
								w = Math.min(g.count, _.start + _.count);
							for (let T = S, A = w; T < A; T += 3) {
								const k = T,
									M = T + 1,
									D = T + 2;
								c = checkGeometryIntersection(this, f, s, l, v, y, b, k, M, D), c && (c.faceIndex =
									Math.floor(T / 3), a.push(c))
							}
						}
	}
}

function checkIntersection$1(o, s, a, l, c, d, f, m) {
	let g;
	if (s.side === BackSide ? g = l.intersectTriangle(f, d, c, !0, m) : g = l.intersectTriangle(c, d, f, s.side ===
			FrontSide, m), g === null) return null;
	_intersectionPointWorld.copy(m), _intersectionPointWorld.applyMatrix4(o.matrixWorld);
	const v = a.ray.origin.distanceTo(_intersectionPointWorld);
	return v < a.near || v > a.far ? null : {
		distance: v,
		point: _intersectionPointWorld.clone(),
		object: o
	}
}

function checkGeometryIntersection(o, s, a, l, c, d, f, m, g, v) {
	o.getVertexPosition(m, _vA$1), o.getVertexPosition(g, _vB$1), o.getVertexPosition(v, _vC$1);
	const y = checkIntersection$1(o, s, a, l, _vA$1, _vB$1, _vC$1, _intersectionPoint);
	if (y) {
		const b = new Vector3$1;
		Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, b), c && (y.uv = Triangle
			.getInterpolatedAttribute(c, m, g, v, b, new Vector2)), d && (y.uv1 = Triangle.getInterpolatedAttribute(
			d, m, g, v, b, new Vector2)), f && (y.normal = Triangle.getInterpolatedAttribute(f, m, g, v, b,
			new Vector3$1), y.normal.dot(l.direction) > 0 && y.normal.multiplyScalar(-1));
		const C = {
			a: m,
			b: g,
			c: v,
			normal: new Vector3$1,
			materialIndex: 0
		};
		Triangle.getNormal(_vA$1, _vB$1, _vC$1, C.normal), y.face = C, y.barycoord = b
	}
	return y
}
class BoxGeometry extends BufferGeometry {
	constructor(s = 1, a = 1, l = 1, c = 1, d = 1, f = 1) {
		super(), this.type = "BoxGeometry", this.parameters = {
			width: s,
			height: a,
			depth: l,
			widthSegments: c,
			heightSegments: d,
			depthSegments: f
		};
		const m = this;
		c = Math.floor(c), d = Math.floor(d), f = Math.floor(f);
		const g = [],
			v = [],
			y = [],
			b = [];
		let C = 0,
			_ = 0;
		S("z", "y", "x", -1, -1, l, a, s, f, d, 0), S("z", "y", "x", 1, -1, l, a, -s, f, d, 1), S("x", "z", "y", 1,
			1, s, l, a, c, f, 2), S("x", "z", "y", 1, -1, s, l, -a, c, f, 3), S("x", "y", "z", 1, -1, s, a, l,
			c, d, 4), S("x", "y", "z", -1, -1, s, a, -l, c, d, 5), this.setIndex(g), this.setAttribute(
			"position", new Float32BufferAttribute(v, 3)), this.setAttribute("normal",
			new Float32BufferAttribute(y, 3)), this.setAttribute("uv", new Float32BufferAttribute(b, 2));

		function S(w, T, A, k, M, D, F, R, O, U, V) {
			const z = D / O,
				j = F / U,
				ge = D / 2,
				me = F / 2,
				he = R / 2,
				ce = O + 1,
				ae = U + 1;
			let fe = 0,
				q = 0;
			const le = new Vector3$1;
			for (let de = 0; de < ae; de++) {
				const _e = de * j - me;
				for (let ke = 0; ke < ce; ke++) {
					const De = ke * z - ge;
					le[w] = De * k, le[T] = _e * M, le[A] = he, v.push(le.x, le.y, le.z), le[w] = 0, le[T] = 0, le[
							A] = R > 0 ? 1 : -1, y.push(le.x, le.y, le.z), b.push(ke / O), b.push(1 - de / U), fe +=
						1
				}
			}
			for (let de = 0; de < U; de++)
				for (let _e = 0; _e < O; _e++) {
					const ke = C + _e + ce * de,
						De = C + _e + ce * (de + 1),
						Se = C + (_e + 1) + ce * (de + 1),
						be = C + (_e + 1) + ce * de;
					g.push(ke, De, be), g.push(De, Se, be), q += 6
				}
			m.addGroup(_, q, V), _ += q, C += fe
		}
	}
	copy(s) {
		return super.copy(s), this.parameters = Object.assign({}, s.parameters), this
	}
	static fromJSON(s) {
		return new BoxGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments)
	}
}

function cloneUniforms(o) {
	const s = {};
	for (const a in o) {
		s[a] = {};
		for (const l in o[a]) {
			const c = o[a][l];
			c && (c.isColor || c.isMatrix3 || c.isMatrix4 || c.isVector2 || c.isVector3 || c.isVector4 || c.isTexture ||
				c.isQuaternion) ? c.isRenderTargetTexture ? (console.warn(
				"UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
				), s[a][l] = null) : s[a][l] = c.clone() : Array.isArray(c) ? s[a][l] = c.slice() : s[a][l] = c
		}
	}
	return s
}

function mergeUniforms(o) {
	const s = {};
	for (let a = 0; a < o.length; a++) {
		const l = cloneUniforms(o[a]);
		for (const c in l) s[c] = l[c]
	}
	return s
}

function cloneUniformsGroups(o) {
	const s = [];
	for (let a = 0; a < o.length; a++) s.push(o[a].clone());
	return s
}

function getUnlitUniformColorSpace(o) {
	const s = o.getRenderTarget();
	return s === null ? o.outputColorSpace : s.isXRRenderTarget === !0 ? s.texture.colorSpace : ColorManagement
		.workingColorSpace
}
const UniformsUtils = {
	clone: cloneUniforms,
	merge: mergeUniforms
};
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
	default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ShaderMaterial extends Material {
	constructor(s) {
		super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {},
			this.uniformsGroups = [], this.vertexShader = default_vertex, this.fragmentShader = default_fragment,
			this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1,
			this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
				clipCullDistance: !1,
				multiDraw: !1
			}, this.defaultAttributeValues = {
				color: [1, 1, 1],
				uv: [0, 0],
				uv1: [0, 0]
			}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, s !==
			void 0 && this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.fragmentShader = s.fragmentShader, this.vertexShader = s.vertexShader, this
			.uniforms = cloneUniforms(s.uniforms), this.uniformsGroups = cloneUniformsGroups(s.uniformsGroups), this
			.defines = Object.assign({}, s.defines), this.wireframe = s.wireframe, this.wireframeLinewidth = s
			.wireframeLinewidth, this.fog = s.fog, this.lights = s.lights, this.clipping = s.clipping, this
			.extensions = Object.assign({}, s.extensions), this.glslVersion = s.glslVersion, this
	}
	toJSON(s) {
		const a = super.toJSON(s);
		a.glslVersion = this.glslVersion, a.uniforms = {};
		for (const c in this.uniforms) {
			const f = this.uniforms[c].value;
			f && f.isTexture ? a.uniforms[c] = {
				type: "t",
				value: f.toJSON(s).uuid
			} : f && f.isColor ? a.uniforms[c] = {
				type: "c",
				value: f.getHex()
			} : f && f.isVector2 ? a.uniforms[c] = {
				type: "v2",
				value: f.toArray()
			} : f && f.isVector3 ? a.uniforms[c] = {
				type: "v3",
				value: f.toArray()
			} : f && f.isVector4 ? a.uniforms[c] = {
				type: "v4",
				value: f.toArray()
			} : f && f.isMatrix3 ? a.uniforms[c] = {
				type: "m3",
				value: f.toArray()
			} : f && f.isMatrix4 ? a.uniforms[c] = {
				type: "m4",
				value: f.toArray()
			} : a.uniforms[c] = {
				value: f
			}
		}
		Object.keys(this.defines).length > 0 && (a.defines = this.defines), a.vertexShader = this.vertexShader, a
			.fragmentShader = this.fragmentShader, a.lights = this.lights, a.clipping = this.clipping;
		const l = {};
		for (const c in this.extensions) this.extensions[c] === !0 && (l[c] = !0);
		return Object.keys(l).length > 0 && (a.extensions = l), a
	}
}
class Camera extends Object3D {
	constructor() {
		super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Matrix4, this
			.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4, this.coordinateSystem =
			WebGLCoordinateSystem
	}
	copy(s, a) {
		return super.copy(s, a), this.matrixWorldInverse.copy(s.matrixWorldInverse), this.projectionMatrix.copy(s
				.projectionMatrix), this.projectionMatrixInverse.copy(s.projectionMatrixInverse), this
			.coordinateSystem = s.coordinateSystem, this
	}
	getWorldDirection(s) {
		return super.getWorldDirection(s).negate()
	}
	updateMatrixWorld(s) {
		super.updateMatrixWorld(s), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	updateWorldMatrix(s, a) {
		super.updateWorldMatrix(s, a), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
const _v3$1 = new Vector3$1,
	_minTarget = new Vector2,
	_maxTarget = new Vector2;
class PerspectiveCamera extends Camera {
	constructor(s = 50, a = 1, l = .1, c = 2e3) {
		super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = s, this.zoom = 1, this
			.near = l, this.far = c, this.focus = 10, this.aspect = a, this.view = null, this.filmGauge = 35, this
			.filmOffset = 0, this.updateProjectionMatrix()
	}
	copy(s, a) {
		return super.copy(s, a), this.fov = s.fov, this.zoom = s.zoom, this.near = s.near, this.far = s.far, this
			.focus = s.focus, this.aspect = s.aspect, this.view = s.view === null ? null : Object.assign({}, s
			.view), this.filmGauge = s.filmGauge, this.filmOffset = s.filmOffset, this
	}
	setFocalLength(s) {
		const a = .5 * this.getFilmHeight() / s;
		this.fov = RAD2DEG * 2 * Math.atan(a), this.updateProjectionMatrix()
	}
	getFocalLength() {
		const s = Math.tan(DEG2RAD * .5 * this.fov);
		return .5 * this.getFilmHeight() / s
	}
	getEffectiveFOV() {
		return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * .5 * this.fov) / this.zoom)
	}
	getFilmWidth() {
		return this.filmGauge * Math.min(this.aspect, 1)
	}
	getFilmHeight() {
		return this.filmGauge / Math.max(this.aspect, 1)
	}
	getViewBounds(s, a, l) {
		_v3$1.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), a.set(_v3$1.x, _v3$1.y).multiplyScalar(-
			s / _v3$1.z), _v3$1.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), l.set(_v3$1.x, _v3$1
			.y).multiplyScalar(-s / _v3$1.z)
	}
	getViewSize(s, a) {
		return this.getViewBounds(s, _minTarget, _maxTarget), a.subVectors(_maxTarget, _minTarget)
	}
	setViewOffset(s, a, l, c, d, f) {
		this.aspect = s / a, this.view === null && (this.view = {
				enabled: !0,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			}), this.view.enabled = !0, this.view.fullWidth = s, this.view.fullHeight = a, this.view.offsetX = l,
			this.view.offsetY = c, this.view.width = d, this.view.height = f, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		const s = this.near;
		let a = s * Math.tan(DEG2RAD * .5 * this.fov) / this.zoom,
			l = 2 * a,
			c = this.aspect * l,
			d = -.5 * c;
		const f = this.view;
		if (this.view !== null && this.view.enabled) {
			const g = f.fullWidth,
				v = f.fullHeight;
			d += f.offsetX * c / g, a -= f.offsetY * l / v, c *= f.width / g, l *= f.height / v
		}
		const m = this.filmOffset;
		m !== 0 && (d += s * m / this.getFilmWidth()), this.projectionMatrix.makePerspective(d, d + c, a, a - l, s,
			this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(s) {
		const a = super.toJSON(s);
		return a.object.fov = this.fov, a.object.zoom = this.zoom, a.object.near = this.near, a.object.far = this
			.far, a.object.focus = this.focus, a.object.aspect = this.aspect, this.view !== null && (a.object.view =
				Object.assign({}, this.view)), a.object.filmGauge = this.filmGauge, a.object.filmOffset = this
			.filmOffset, a
	}
}
const fov = -90,
	aspect = 1;
class CubeCamera extends Object3D {
	constructor(s, a, l) {
		super(), this.type = "CubeCamera", this.renderTarget = l, this.coordinateSystem = null, this
			.activeMipmapLevel = 0;
		const c = new PerspectiveCamera(fov, aspect, s, a);
		c.layers = this.layers, this.add(c);
		const d = new PerspectiveCamera(fov, aspect, s, a);
		d.layers = this.layers, this.add(d);
		const f = new PerspectiveCamera(fov, aspect, s, a);
		f.layers = this.layers, this.add(f);
		const m = new PerspectiveCamera(fov, aspect, s, a);
		m.layers = this.layers, this.add(m);
		const g = new PerspectiveCamera(fov, aspect, s, a);
		g.layers = this.layers, this.add(g);
		const v = new PerspectiveCamera(fov, aspect, s, a);
		v.layers = this.layers, this.add(v)
	}
	updateCoordinateSystem() {
		const s = this.coordinateSystem,
			a = this.children.concat(),
			[l, c, d, f, m, g] = a;
		for (const v of a) this.remove(v);
		if (s === WebGLCoordinateSystem) l.up.set(0, 1, 0), l.lookAt(1, 0, 0), c.up.set(0, 1, 0), c.lookAt(-1, 0,
			0), d.up.set(0, 0, -1), d.lookAt(0, 1, 0), f.up.set(0, 0, 1), f.lookAt(0, -1, 0), m.up.set(0, 1, 0), m
			.lookAt(0, 0, 1), g.up.set(0, 1, 0), g.lookAt(0, 0, -1);
		else if (s === WebGPUCoordinateSystem) l.up.set(0, -1, 0), l.lookAt(-1, 0, 0), c.up.set(0, -1, 0), c.lookAt(
			1, 0, 0), d.up.set(0, 0, 1), d.lookAt(0, 1, 0), f.up.set(0, 0, -1), f.lookAt(0, -1, 0), m.up.set(0,
			-1, 0), m.lookAt(0, 0, 1), g.up.set(0, -1, 0), g.lookAt(0, 0, -1);
		else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + s);
		for (const v of a) this.add(v), v.updateMatrixWorld()
	}
	update(s, a) {
		this.parent === null && this.updateMatrixWorld();
		const {
			renderTarget: l,
			activeMipmapLevel: c
		} = this;
		this.coordinateSystem !== s.coordinateSystem && (this.coordinateSystem = s.coordinateSystem, this
			.updateCoordinateSystem());
		const [d, f, m, g, v, y] = this.children, b = s.getRenderTarget(), C = s.getActiveCubeFace(), _ = s
			.getActiveMipmapLevel(), S = s.xr.enabled;
		s.xr.enabled = !1;
		const w = l.texture.generateMipmaps;
		l.texture.generateMipmaps = !1, s.setRenderTarget(l, 0, c), s.render(a, d), s.setRenderTarget(l, 1, c), s
			.render(a, f), s.setRenderTarget(l, 2, c), s.render(a, m), s.setRenderTarget(l, 3, c), s.render(a, g), s
			.setRenderTarget(l, 4, c), s.render(a, v), l.texture.generateMipmaps = w, s.setRenderTarget(l, 5, c), s
			.render(a, y), s.setRenderTarget(b, C, _), s.xr.enabled = S, l.texture.needsPMREMUpdate = !0
	}
}
class CubeTexture extends Texture {
	constructor(s = [], a = CubeReflectionMapping, l, c, d, f, m, g, v, y) {
		super(s, a, l, c, d, f, m, g, v, y), this.isCubeTexture = !0, this.flipY = !1
	}
	get images() {
		return this.image
	}
	set images(s) {
		this.image = s
	}
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(s = 1, a = {}) {
		super(s, s, a), this.isWebGLCubeRenderTarget = !0;
		const l = {
				width: s,
				height: s,
				depth: 1
			},
			c = [l, l, l, l, l, l];
		this.texture = new CubeTexture(c, a.mapping, a.wrapS, a.wrapT, a.magFilter, a.minFilter, a.format, a.type, a
				.anisotropy, a.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps =
			a.generateMipmaps !== void 0 ? a.generateMipmaps : !1, this.texture.minFilter = a.minFilter !== void 0 ?
			a.minFilter : LinearFilter
	}
	fromEquirectangularTexture(s, a) {
		this.texture.type = a.type, this.texture.colorSpace = a.colorSpace, this.texture.generateMipmaps = a
			.generateMipmaps, this.texture.minFilter = a.minFilter, this.texture.magFilter = a.magFilter;
		const l = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			},
			c = new BoxGeometry(5, 5, 5),
			d = new ShaderMaterial({
				name: "CubemapFromEquirect",
				uniforms: cloneUniforms(l.uniforms),
				vertexShader: l.vertexShader,
				fragmentShader: l.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
		d.uniforms.tEquirect.value = a;
		const f = new Mesh(c, d),
			m = a.minFilter;
		return a.minFilter === LinearMipmapLinearFilter && (a.minFilter = LinearFilter), new CubeCamera(1, 10, this)
			.update(s, f), a.minFilter = m, f.geometry.dispose(), f.material.dispose(), this
	}
	clear(s, a = !0, l = !0, c = !0) {
		const d = s.getRenderTarget();
		for (let f = 0; f < 6; f++) s.setRenderTarget(this, f), s.clear(a, l, c);
		s.setRenderTarget(d)
	}
}
class Group extends Object3D {
	constructor() {
		super(), this.isGroup = !0, this.type = "Group"
	}
}
const _moveEvent = {
	type: "move"
};
class WebXRController {
	constructor() {
		this._targetRay = null, this._grip = null, this._hand = null
	}
	getHandSpace() {
		return this._hand === null && (this._hand = new Group, this._hand.matrixAutoUpdate = !1, this._hand
			.visible = !1, this._hand.joints = {}, this._hand.inputState = {
				pinching: !1
			}), this._hand
	}
	getTargetRaySpace() {
		return this._targetRay === null && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = !1, this
			._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity =
			new Vector3$1, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity =
			new Vector3$1), this._targetRay
	}
	getGripSpace() {
		return this._grip === null && (this._grip = new Group, this._grip.matrixAutoUpdate = !1, this._grip
			.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3$1, this
			._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3$1), this._grip
	}
	dispatchEvent(s) {
		return this._targetRay !== null && this._targetRay.dispatchEvent(s), this._grip !== null && this._grip
			.dispatchEvent(s), this._hand !== null && this._hand.dispatchEvent(s), this
	}
	connect(s) {
		if (s && s.hand) {
			const a = this._hand;
			if (a)
				for (const l of s.hand.values()) this._getHandJoint(a, l)
		}
		return this.dispatchEvent({
			type: "connected",
			data: s
		}), this
	}
	disconnect(s) {
		return this.dispatchEvent({
			type: "disconnected",
			data: s
		}), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip
			.visible = !1), this._hand !== null && (this._hand.visible = !1), this
	}
	update(s, a, l) {
		let c = null,
			d = null,
			f = null;
		const m = this._targetRay,
			g = this._grip,
			v = this._hand;
		if (s && a.session.visibilityState !== "visible-blurred") {
			if (v && s.hand) {
				f = !0;
				for (const w of s.hand.values()) {
					const T = a.getJointPose(w, l),
						A = this._getHandJoint(v, w);
					T !== null && (A.matrix.fromArray(T.transform.matrix), A.matrix.decompose(A.position, A
							.rotation, A.scale), A.matrixWorldNeedsUpdate = !0, A.jointRadius = T.radius), A
						.visible = T !== null
				}
				const y = v.joints["index-finger-tip"],
					b = v.joints["thumb-tip"],
					C = y.position.distanceTo(b.position),
					_ = .02,
					S = .005;
				v.inputState.pinching && C > _ + S ? (v.inputState.pinching = !1, this.dispatchEvent({
					type: "pinchend",
					handedness: s.handedness,
					target: this
				})) : !v.inputState.pinching && C <= _ - S && (v.inputState.pinching = !0, this.dispatchEvent({
					type: "pinchstart",
					handedness: s.handedness,
					target: this
				}))
			} else g !== null && s.gripSpace && (d = a.getPose(s.gripSpace, l), d !== null && (g.matrix.fromArray(d
					.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g
				.matrixWorldNeedsUpdate = !0, d.linearVelocity ? (g.hasLinearVelocity = !0, g.linearVelocity
					.copy(d.linearVelocity)) : g.hasLinearVelocity = !1, d.angularVelocity ? (g
					.hasAngularVelocity = !0, g.angularVelocity.copy(d.angularVelocity)) : g
				.hasAngularVelocity = !1));
			m !== null && (c = a.getPose(s.targetRaySpace, l), c === null && d !== null && (c = d), c !== null && (m
				.matrix.fromArray(c.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale),
				m.matrixWorldNeedsUpdate = !0, c.linearVelocity ? (m.hasLinearVelocity = !0, m
					.linearVelocity.copy(c.linearVelocity)) : m.hasLinearVelocity = !1, c.angularVelocity ?
				(m.hasAngularVelocity = !0, m.angularVelocity.copy(c.angularVelocity)) : m
				.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent)))
		}
		return m !== null && (m.visible = c !== null), g !== null && (g.visible = d !== null), v !== null && (v
			.visible = f !== null), this
	}
	_getHandJoint(s, a) {
		if (s.joints[a.jointName] === void 0) {
			const l = new Group;
			l.matrixAutoUpdate = !1, l.visible = !1, s.joints[a.jointName] = l, s.add(l)
		}
		return s.joints[a.jointName]
	}
}
class Scene extends Object3D {
	constructor() {
		super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog =
			null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Euler,
			this.environmentIntensity = 1, this.environmentRotation = new Euler, this.overrideMaterial = null,
			typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
				detail: this
			}))
	}
	copy(s, a) {
		return super.copy(s, a), s.background !== null && (this.background = s.background.clone()), s
			.environment !== null && (this.environment = s.environment.clone()), s.fog !== null && (this.fog = s.fog
				.clone()), this.backgroundBlurriness = s.backgroundBlurriness, this.backgroundIntensity = s
			.backgroundIntensity, this.backgroundRotation.copy(s.backgroundRotation), this.environmentIntensity = s
			.environmentIntensity, this.environmentRotation.copy(s.environmentRotation), s.overrideMaterial !==
			null && (this.overrideMaterial = s.overrideMaterial.clone()), this.matrixAutoUpdate = s
			.matrixAutoUpdate, this
	}
	toJSON(s) {
		const a = super.toJSON(s);
		return this.fog !== null && (a.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (a.object
				.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (a.object
				.backgroundIntensity = this.backgroundIntensity), a.object.backgroundRotation = this
			.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (a.object.environmentIntensity = this
				.environmentIntensity), a.object.environmentRotation = this.environmentRotation.toArray(), a
	}
}
class InterleavedBuffer {
	constructor(s, a) {
		this.isInterleavedBuffer = !0, this.array = s, this.stride = a, this.count = s !== void 0 ? s.length / a :
			0, this.usage = StaticDrawUsage, this.updateRanges = [], this.version = 0, this.uuid = generateUUID()
	}
	onUploadCallback() {}
	set needsUpdate(s) {
		s === !0 && this.version++
	}
	setUsage(s) {
		return this.usage = s, this
	}
	addUpdateRange(s, a) {
		this.updateRanges.push({
			start: s,
			count: a
		})
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0
	}
	copy(s) {
		return this.array = new s.array.constructor(s.array), this.count = s.count, this.stride = s.stride, this
			.usage = s.usage, this
	}
	copyAt(s, a, l) {
		s *= this.stride, l *= a.stride;
		for (let c = 0, d = this.stride; c < d; c++) this.array[s + c] = a.array[l + c];
		return this
	}
	set(s, a = 0) {
		return this.array.set(s, a), this
	}
	clone(s) {
		s.arrayBuffers === void 0 && (s.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer
			._uuid = generateUUID()), s.arrayBuffers[this.array.buffer._uuid] === void 0 && (s.arrayBuffers[this
			.array.buffer._uuid] = this.array.slice(0).buffer);
		const a = new this.array.constructor(s.arrayBuffers[this.array.buffer._uuid]),
			l = new this.constructor(a, this.stride);
		return l.setUsage(this.usage), l
	}
	onUpload(s) {
		return this.onUploadCallback = s, this
	}
	toJSON(s) {
		return s.arrayBuffers === void 0 && (s.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array
			.buffer._uuid = generateUUID()), s.arrayBuffers[this.array.buffer._uuid] === void 0 && (s
			.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		}
	}
}
const _vector$7 = new Vector3$1;
class InterleavedBufferAttribute {
	constructor(s, a, l, c = !1) {
		this.isInterleavedBufferAttribute = !0, this.name = "", this.data = s, this.itemSize = a, this.offset = l,
			this.normalized = c
	}
	get count() {
		return this.data.count
	}
	get array() {
		return this.data.array
	}
	set needsUpdate(s) {
		this.data.needsUpdate = s
	}
	applyMatrix4(s) {
		for (let a = 0, l = this.data.count; a < l; a++) _vector$7.fromBufferAttribute(this, a), _vector$7
			.applyMatrix4(s), this.setXYZ(a, _vector$7.x, _vector$7.y, _vector$7.z);
		return this
	}
	applyNormalMatrix(s) {
		for (let a = 0, l = this.count; a < l; a++) _vector$7.fromBufferAttribute(this, a), _vector$7
			.applyNormalMatrix(s), this.setXYZ(a, _vector$7.x, _vector$7.y, _vector$7.z);
		return this
	}
	transformDirection(s) {
		for (let a = 0, l = this.count; a < l; a++) _vector$7.fromBufferAttribute(this, a), _vector$7
			.transformDirection(s), this.setXYZ(a, _vector$7.x, _vector$7.y, _vector$7.z);
		return this
	}
	getComponent(s, a) {
		let l = this.array[s * this.data.stride + this.offset + a];
		return this.normalized && (l = denormalize(l, this.array)), l
	}
	setComponent(s, a, l) {
		return this.normalized && (l = normalize(l, this.array)), this.data.array[s * this.data.stride + this
			.offset + a] = l, this
	}
	setX(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.data.array[s * this.data.stride + this
			.offset] = a, this
	}
	setY(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.data.array[s * this.data.stride + this
			.offset + 1] = a, this
	}
	setZ(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.data.array[s * this.data.stride + this
			.offset + 2] = a, this
	}
	setW(s, a) {
		return this.normalized && (a = normalize(a, this.array)), this.data.array[s * this.data.stride + this
			.offset + 3] = a, this
	}
	getX(s) {
		let a = this.data.array[s * this.data.stride + this.offset];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	getY(s) {
		let a = this.data.array[s * this.data.stride + this.offset + 1];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	getZ(s) {
		let a = this.data.array[s * this.data.stride + this.offset + 2];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	getW(s) {
		let a = this.data.array[s * this.data.stride + this.offset + 3];
		return this.normalized && (a = denormalize(a, this.array)), a
	}
	setXY(s, a, l) {
		return s = s * this.data.stride + this.offset, this.normalized && (a = normalize(a, this.array), l =
			normalize(l, this.array)), this.data.array[s + 0] = a, this.data.array[s + 1] = l, this
	}
	setXYZ(s, a, l, c) {
		return s = s * this.data.stride + this.offset, this.normalized && (a = normalize(a, this.array), l =
				normalize(l, this.array), c = normalize(c, this.array)), this.data.array[s + 0] = a, this.data
			.array[s + 1] = l, this.data.array[s + 2] = c, this
	}
	setXYZW(s, a, l, c, d) {
		return s = s * this.data.stride + this.offset, this.normalized && (a = normalize(a, this.array), l =
				normalize(l, this.array), c = normalize(c, this.array), d = normalize(d, this.array)), this.data
			.array[s + 0] = a, this.data.array[s + 1] = l, this.data.array[s + 2] = c, this.data.array[s + 3] = d,
			this
	}
	clone(s) {
		if (s === void 0) {
			console.log(
				"THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
				);
			const a = [];
			for (let l = 0; l < this.count; l++) {
				const c = l * this.data.stride + this.offset;
				for (let d = 0; d < this.itemSize; d++) a.push(this.data.array[c + d])
			}
			return new BufferAttribute(new this.array.constructor(a), this.itemSize, this.normalized)
		} else return s.interleavedBuffers === void 0 && (s.interleavedBuffers = {}), s.interleavedBuffers[this.data
				.uuid] === void 0 && (s.interleavedBuffers[this.data.uuid] = this.data.clone(s)),
			new InterleavedBufferAttribute(s.interleavedBuffers[this.data.uuid], this.itemSize, this.offset,
				this.normalized)
	}
	toJSON(s) {
		if (s === void 0) {
			console.log(
				"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
				);
			const a = [];
			for (let l = 0; l < this.count; l++) {
				const c = l * this.data.stride + this.offset;
				for (let d = 0; d < this.itemSize; d++) a.push(this.data.array[c + d])
			}
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: a,
				normalized: this.normalized
			}
		} else return s.interleavedBuffers === void 0 && (s.interleavedBuffers = {}), s.interleavedBuffers[this.data
			.uuid] === void 0 && (s.interleavedBuffers[this.data.uuid] = this.data.toJSON(s)), {
			isInterleavedBufferAttribute: !0,
			itemSize: this.itemSize,
			data: this.data.uuid,
			offset: this.offset,
			normalized: this.normalized
		}
	}
}
class SpriteMaterial extends Material {
	constructor(s) {
		super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Color(16777215), this
			.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0,
			this.fog = !0, this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.color.copy(s.color), this.map = s.map, this.alphaMap = s.alphaMap, this
			.rotation = s.rotation, this.sizeAttenuation = s.sizeAttenuation, this.fog = s.fog, this
	}
}
let _geometry;
const _intersectPoint = new Vector3$1,
	_worldScale = new Vector3$1,
	_mvPosition = new Vector3$1,
	_alignedPosition = new Vector2,
	_rotatedPosition = new Vector2,
	_viewWorldMatrix = new Matrix4,
	_vA$2 = new Vector3$1,
	_vB$2 = new Vector3$1,
	_vC$2 = new Vector3$1,
	_uvA = new Vector2,
	_uvB = new Vector2,
	_uvC = new Vector2;
class Sprite extends Object3D {
	constructor(s = new SpriteMaterial) {
		if (super(), this.isSprite = !0, this.type = "Sprite", _geometry === void 0) {
			_geometry = new BufferGeometry;
			const a = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
				l = new InterleavedBuffer(a, 5);
			_geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position",
				new InterleavedBufferAttribute(l, 3, 0, !1)), _geometry.setAttribute("uv",
				new InterleavedBufferAttribute(l, 2, 3, !1))
		}
		this.geometry = _geometry, this.material = s, this.center = new Vector2(.5, .5)
	}
	raycast(s, a) {
		s.camera === null && console.error(
				'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
			_worldScale.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(s.camera.matrixWorld), this
			.modelViewMatrix.multiplyMatrices(s.camera.matrixWorldInverse, this.matrixWorld), _mvPosition
			.setFromMatrixPosition(this.modelViewMatrix), s.camera.isPerspectiveCamera && this.material
			.sizeAttenuation === !1 && _worldScale.multiplyScalar(-_mvPosition.z);
		const l = this.material.rotation;
		let c, d;
		l !== 0 && (d = Math.cos(l), c = Math.sin(l));
		const f = this.center;
		transformVertex(_vA$2.set(-.5, -.5, 0), _mvPosition, f, _worldScale, c, d), transformVertex(_vB$2.set(.5, -
			.5, 0), _mvPosition, f, _worldScale, c, d), transformVertex(_vC$2.set(.5, .5, 0), _mvPosition, f,
			_worldScale, c, d), _uvA.set(0, 0), _uvB.set(1, 0), _uvC.set(1, 1);
		let m = s.ray.intersectTriangle(_vA$2, _vB$2, _vC$2, !1, _intersectPoint);
		if (m === null && (transformVertex(_vB$2.set(-.5, .5, 0), _mvPosition, f, _worldScale, c, d), _uvB.set(0,
				1), m = s.ray.intersectTriangle(_vA$2, _vC$2, _vB$2, !1, _intersectPoint), m === null)) return;
		const g = s.ray.origin.distanceTo(_intersectPoint);
		g < s.near || g > s.far || a.push({
			distance: g,
			point: _intersectPoint.clone(),
			uv: Triangle.getInterpolation(_intersectPoint, _vA$2, _vB$2, _vC$2, _uvA, _uvB, _uvC,
				new Vector2),
			face: null,
			object: this
		})
	}
	copy(s, a) {
		return super.copy(s, a), s.center !== void 0 && this.center.copy(s.center), this.material = s.material, this
	}
}

function transformVertex(o, s, a, l, c, d) {
	_alignedPosition.subVectors(o, a).addScalar(.5).multiply(l), c !== void 0 ? (_rotatedPosition.x = d *
			_alignedPosition.x - c * _alignedPosition.y, _rotatedPosition.y = c * _alignedPosition.x + d *
			_alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), o.copy(s), o.x += _rotatedPosition.x, o.y +=
		_rotatedPosition.y, o.applyMatrix4(_viewWorldMatrix)
}
const _basePosition = new Vector3$1,
	_skinIndex = new Vector4,
	_skinWeight = new Vector4,
	_vector3 = new Vector3$1,
	_matrix4 = new Matrix4,
	_vertex = new Vector3$1,
	_sphere$5 = new Sphere,
	_inverseMatrix$2 = new Matrix4,
	_ray$2 = new Ray;
class SkinnedMesh extends Mesh {
	constructor(s, a) {
		super(s, a), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = AttachedBindMode, this
			.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4, this.boundingBox = null, this
			.boundingSphere = null
	}
	computeBoundingBox() {
		const s = this.geometry;
		this.boundingBox === null && (this.boundingBox = new Box3), this.boundingBox.makeEmpty();
		const a = s.getAttribute("position");
		for (let l = 0; l < a.count; l++) this.getVertexPosition(l, _vertex), this.boundingBox.expandByPoint(
			_vertex)
	}
	computeBoundingSphere() {
		const s = this.geometry;
		this.boundingSphere === null && (this.boundingSphere = new Sphere), this.boundingSphere.makeEmpty();
		const a = s.getAttribute("position");
		for (let l = 0; l < a.count; l++) this.getVertexPosition(l, _vertex), this.boundingSphere.expandByPoint(
			_vertex)
	}
	copy(s, a) {
		return super.copy(s, a), this.bindMode = s.bindMode, this.bindMatrix.copy(s.bindMatrix), this
			.bindMatrixInverse.copy(s.bindMatrixInverse), this.skeleton = s.skeleton, s.boundingBox !== null && (
				this.boundingBox = s.boundingBox.clone()), s.boundingSphere !== null && (this.boundingSphere = s
				.boundingSphere.clone()), this
	}
	raycast(s, a) {
		const l = this.material,
			c = this.matrixWorld;
		l !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$5.copy(this
			.boundingSphere), _sphere$5.applyMatrix4(c), s.ray.intersectsSphere(_sphere$5) !== !1 && (
			_inverseMatrix$2.copy(c).invert(), _ray$2.copy(s.ray).applyMatrix4(_inverseMatrix$2), !(this
				.boundingBox !== null && _ray$2.intersectsBox(this.boundingBox) === !1) && this
			._computeIntersections(s, a, _ray$2)))
	}
	getVertexPosition(s, a) {
		return super.getVertexPosition(s, a), this.applyBoneTransform(s, a), a
	}
	bind(s, a) {
		this.skeleton = s, a === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), a = this
			.matrixWorld), this.bindMatrix.copy(a), this.bindMatrixInverse.copy(a).invert()
	}
	pose() {
		this.skeleton.pose()
	}
	normalizeSkinWeights() {
		const s = new Vector4,
			a = this.geometry.attributes.skinWeight;
		for (let l = 0, c = a.count; l < c; l++) {
			s.fromBufferAttribute(a, l);
			const d = 1 / s.manhattanLength();
			d !== 1 / 0 ? s.multiplyScalar(d) : s.set(1, 0, 0, 0), a.setXYZW(l, s.x, s.y, s.z, s.w)
		}
	}
	updateMatrixWorld(s) {
		super.updateMatrixWorld(s), this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this
			.matrixWorld).invert() : this.bindMode === DetachedBindMode ? this.bindMatrixInverse.copy(this
			.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
	}
	applyBoneTransform(s, a) {
		const l = this.skeleton,
			c = this.geometry;
		_skinIndex.fromBufferAttribute(c.attributes.skinIndex, s), _skinWeight.fromBufferAttribute(c.attributes
			.skinWeight, s), _basePosition.copy(a).applyMatrix4(this.bindMatrix), a.set(0, 0, 0);
		for (let d = 0; d < 4; d++) {
			const f = _skinWeight.getComponent(d);
			if (f !== 0) {
				const m = _skinIndex.getComponent(d);
				_matrix4.multiplyMatrices(l.bones[m].matrixWorld, l.boneInverses[m]), a.addScaledVector(_vector3
					.copy(_basePosition).applyMatrix4(_matrix4), f)
			}
		}
		return a.applyMatrix4(this.bindMatrixInverse)
	}
}
class Bone extends Object3D {
	constructor() {
		super(), this.isBone = !0, this.type = "Bone"
	}
}
class DataTexture extends Texture {
	constructor(s = null, a = 1, l = 1, c, d, f, m, g, v = NearestFilter, y = NearestFilter, b, C) {
		super(null, f, m, g, v, y, c, d, b, C), this.isDataTexture = !0, this.image = {
			data: s,
			width: a,
			height: l
		}, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
const _offsetMatrix = new Matrix4,
	_identityMatrix = new Matrix4;
class Skeleton {
	constructor(s = [], a = []) {
		this.uuid = generateUUID(), this.bones = s.slice(0), this.boneInverses = a, this.boneMatrices = null, this
			.boneTexture = null, this.init()
	}
	init() {
		const s = this.bones,
			a = this.boneInverses;
		if (this.boneMatrices = new Float32Array(s.length * 16), a.length === 0) this.calculateInverses();
		else if (s.length !== a.length) {
			console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this
				.boneInverses = [];
			for (let l = 0, c = this.bones.length; l < c; l++) this.boneInverses.push(new Matrix4)
		}
	}
	calculateInverses() {
		this.boneInverses.length = 0;
		for (let s = 0, a = this.bones.length; s < a; s++) {
			const l = new Matrix4;
			this.bones[s] && l.copy(this.bones[s].matrixWorld).invert(), this.boneInverses.push(l)
		}
	}
	pose() {
		for (let s = 0, a = this.bones.length; s < a; s++) {
			const l = this.bones[s];
			l && l.matrixWorld.copy(this.boneInverses[s]).invert()
		}
		for (let s = 0, a = this.bones.length; s < a; s++) {
			const l = this.bones[s];
			l && (l.parent && l.parent.isBone ? (l.matrix.copy(l.parent.matrixWorld).invert(), l.matrix.multiply(l
				.matrixWorld)) : l.matrix.copy(l.matrixWorld), l.matrix.decompose(l.position, l.quaternion,
				l.scale))
		}
	}
	update() {
		const s = this.bones,
			a = this.boneInverses,
			l = this.boneMatrices,
			c = this.boneTexture;
		for (let d = 0, f = s.length; d < f; d++) {
			const m = s[d] ? s[d].matrixWorld : _identityMatrix;
			_offsetMatrix.multiplyMatrices(m, a[d]), _offsetMatrix.toArray(l, d * 16)
		}
		c !== null && (c.needsUpdate = !0)
	}
	clone() {
		return new Skeleton(this.bones, this.boneInverses)
	}
	computeBoneTexture() {
		let s = Math.sqrt(this.bones.length * 4);
		s = Math.ceil(s / 4) * 4, s = Math.max(s, 4);
		const a = new Float32Array(s * s * 4);
		a.set(this.boneMatrices);
		const l = new DataTexture(a, s, s, RGBAFormat, FloatType);
		return l.needsUpdate = !0, this.boneMatrices = a, this.boneTexture = l, this
	}
	getBoneByName(s) {
		for (let a = 0, l = this.bones.length; a < l; a++) {
			const c = this.bones[a];
			if (c.name === s) return c
		}
	}
	dispose() {
		this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
	}
	fromJSON(s, a) {
		this.uuid = s.uuid;
		for (let l = 0, c = s.bones.length; l < c; l++) {
			const d = s.bones[l];
			let f = a[d];
			f === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", d), f = new Bone), this.bones
				.push(f), this.boneInverses.push(new Matrix4().fromArray(s.boneInverses[l]))
		}
		return this.init(), this
	}
	toJSON() {
		const s = {
			metadata: {
				version: 4.6,
				type: "Skeleton",
				generator: "Skeleton.toJSON"
			},
			bones: [],
			boneInverses: []
		};
		s.uuid = this.uuid;
		const a = this.bones,
			l = this.boneInverses;
		for (let c = 0, d = a.length; c < d; c++) {
			const f = a[c];
			s.bones.push(f.uuid);
			const m = l[c];
			s.boneInverses.push(m.toArray())
		}
		return s
	}
}
const _vector1 = new Vector3$1,
	_vector2 = new Vector3$1,
	_normalMatrix = new Matrix3;
class Plane {
	constructor(s = new Vector3$1(1, 0, 0), a = 0) {
		this.isPlane = !0, this.normal = s, this.constant = a
	}
	set(s, a) {
		return this.normal.copy(s), this.constant = a, this
	}
	setComponents(s, a, l, c) {
		return this.normal.set(s, a, l), this.constant = c, this
	}
	setFromNormalAndCoplanarPoint(s, a) {
		return this.normal.copy(s), this.constant = -a.dot(this.normal), this
	}
	setFromCoplanarPoints(s, a, l) {
		const c = _vector1.subVectors(l, a).cross(_vector2.subVectors(s, a)).normalize();
		return this.setFromNormalAndCoplanarPoint(c, s), this
	}
	copy(s) {
		return this.normal.copy(s.normal), this.constant = s.constant, this
	}
	normalize() {
		const s = 1 / this.normal.length();
		return this.normal.multiplyScalar(s), this.constant *= s, this
	}
	negate() {
		return this.constant *= -1, this.normal.negate(), this
	}
	distanceToPoint(s) {
		return this.normal.dot(s) + this.constant
	}
	distanceToSphere(s) {
		return this.distanceToPoint(s.center) - s.radius
	}
	projectPoint(s, a) {
		return a.copy(s).addScaledVector(this.normal, -this.distanceToPoint(s))
	}
	intersectLine(s, a) {
		const l = s.delta(_vector1),
			c = this.normal.dot(l);
		if (c === 0) return this.distanceToPoint(s.start) === 0 ? a.copy(s.start) : null;
		const d = -(s.start.dot(this.normal) + this.constant) / c;
		return d < 0 || d > 1 ? null : a.copy(s.start).addScaledVector(l, d)
	}
	intersectsLine(s) {
		const a = this.distanceToPoint(s.start),
			l = this.distanceToPoint(s.end);
		return a < 0 && l > 0 || l < 0 && a > 0
	}
	intersectsBox(s) {
		return s.intersectsPlane(this)
	}
	intersectsSphere(s) {
		return s.intersectsPlane(this)
	}
	coplanarPoint(s) {
		return s.copy(this.normal).multiplyScalar(-this.constant)
	}
	applyMatrix4(s, a) {
		const l = a || _normalMatrix.getNormalMatrix(s),
			c = this.coplanarPoint(_vector1).applyMatrix4(s),
			d = this.normal.applyMatrix3(l).normalize();
		return this.constant = -c.dot(d), this
	}
	translate(s) {
		return this.constant -= s.dot(this.normal), this
	}
	equals(s) {
		return s.normal.equals(this.normal) && s.constant === this.constant
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
const _sphere$3 = new Sphere,
	_vector$6 = new Vector3$1;
class Frustum {
	constructor(s = new Plane, a = new Plane, l = new Plane, c = new Plane, d = new Plane, f = new Plane) {
		this.planes = [s, a, l, c, d, f]
	}
	set(s, a, l, c, d, f) {
		const m = this.planes;
		return m[0].copy(s), m[1].copy(a), m[2].copy(l), m[3].copy(c), m[4].copy(d), m[5].copy(f), this
	}
	copy(s) {
		const a = this.planes;
		for (let l = 0; l < 6; l++) a[l].copy(s.planes[l]);
		return this
	}
	setFromProjectionMatrix(s, a = WebGLCoordinateSystem) {
		const l = this.planes,
			c = s.elements,
			d = c[0],
			f = c[1],
			m = c[2],
			g = c[3],
			v = c[4],
			y = c[5],
			b = c[6],
			C = c[7],
			_ = c[8],
			S = c[9],
			w = c[10],
			T = c[11],
			A = c[12],
			k = c[13],
			M = c[14],
			D = c[15];
		if (l[0].setComponents(g - d, C - v, T - _, D - A).normalize(), l[1].setComponents(g + d, C + v, T + _, D +
				A).normalize(), l[2].setComponents(g + f, C + y, T + S, D + k).normalize(), l[3].setComponents(g -
				f, C - y, T - S, D - k).normalize(), l[4].setComponents(g - m, C - b, T - w, D - M).normalize(),
			a === WebGLCoordinateSystem) l[5].setComponents(g + m, C + b, T + w, D + M).normalize();
		else if (a === WebGPUCoordinateSystem) l[5].setComponents(m, b, w, M).normalize();
		else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + a);
		return this
	}
	intersectsObject(s) {
		if (s.boundingSphere !== void 0) s.boundingSphere === null && s.computeBoundingSphere(), _sphere$3.copy(s
			.boundingSphere).applyMatrix4(s.matrixWorld);
		else {
			const a = s.geometry;
			a.boundingSphere === null && a.computeBoundingSphere(), _sphere$3.copy(a.boundingSphere).applyMatrix4(s
				.matrixWorld)
		}
		return this.intersectsSphere(_sphere$3)
	}
	intersectsSprite(s) {
		return _sphere$3.center.set(0, 0, 0), _sphere$3.radius = .7071067811865476, _sphere$3.applyMatrix4(s
			.matrixWorld), this.intersectsSphere(_sphere$3)
	}
	intersectsSphere(s) {
		const a = this.planes,
			l = s.center,
			c = -s.radius;
		for (let d = 0; d < 6; d++)
			if (a[d].distanceToPoint(l) < c) return !1;
		return !0
	}
	intersectsBox(s) {
		const a = this.planes;
		for (let l = 0; l < 6; l++) {
			const c = a[l];
			if (_vector$6.x = c.normal.x > 0 ? s.max.x : s.min.x, _vector$6.y = c.normal.y > 0 ? s.max.y : s.min.y,
				_vector$6.z = c.normal.z > 0 ? s.max.z : s.min.z, c.distanceToPoint(_vector$6) < 0) return !1
		}
		return !0
	}
	containsPoint(s) {
		const a = this.planes;
		for (let l = 0; l < 6; l++)
			if (a[l].distanceToPoint(s) < 0) return !1;
		return !0
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
class LineBasicMaterial extends Material {
	constructor(s) {
		super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Color(16777215),
			this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0,
			this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.color.copy(s.color), this.map = s.map, this.linewidth = s.linewidth, this
			.linecap = s.linecap, this.linejoin = s.linejoin, this.fog = s.fog, this
	}
}
const _vStart = new Vector3$1,
	_vEnd = new Vector3$1,
	_inverseMatrix$1 = new Matrix4,
	_ray$1$1 = new Ray,
	_sphere$1 = new Sphere,
	_intersectPointOnRay = new Vector3$1,
	_intersectPointOnSegment = new Vector3$1;
class Line extends Object3D {
	constructor(s = new BufferGeometry, a = new LineBasicMaterial) {
		super(), this.isLine = !0, this.type = "Line", this.geometry = s, this.material = a, this
			.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
	}
	copy(s, a) {
		return super.copy(s, a), this.material = Array.isArray(s.material) ? s.material.slice() : s.material, this
			.geometry = s.geometry, this
	}
	computeLineDistances() {
		const s = this.geometry;
		if (s.index === null) {
			const a = s.attributes.position,
				l = [0];
			for (let c = 1, d = a.count; c < d; c++) _vStart.fromBufferAttribute(a, c - 1), _vEnd
				.fromBufferAttribute(a, c), l[c] = l[c - 1], l[c] += _vStart.distanceTo(_vEnd);
			s.setAttribute("lineDistance", new Float32BufferAttribute(l, 1))
		} else console.warn(
			"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
		return this
	}
	raycast(s, a) {
		const l = this.geometry,
			c = this.matrixWorld,
			d = s.params.Line.threshold,
			f = l.drawRange;
		if (l.boundingSphere === null && l.computeBoundingSphere(), _sphere$1.copy(l.boundingSphere), _sphere$1
			.applyMatrix4(c), _sphere$1.radius += d, s.ray.intersectsSphere(_sphere$1) === !1) return;
		_inverseMatrix$1.copy(c).invert(), _ray$1$1.copy(s.ray).applyMatrix4(_inverseMatrix$1);
		const m = d / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			g = m * m,
			v = this.isLineSegments ? 2 : 1,
			y = l.index,
			C = l.attributes.position;
		if (y !== null) {
			const _ = Math.max(0, f.start),
				S = Math.min(y.count, f.start + f.count);
			for (let w = _, T = S - 1; w < T; w += v) {
				const A = y.getX(w),
					k = y.getX(w + 1),
					M = checkIntersection(this, s, _ray$1$1, g, A, k, w);
				M && a.push(M)
			}
			if (this.isLineLoop) {
				const w = y.getX(S - 1),
					T = y.getX(_),
					A = checkIntersection(this, s, _ray$1$1, g, w, T, S - 1);
				A && a.push(A)
			}
		} else {
			const _ = Math.max(0, f.start),
				S = Math.min(C.count, f.start + f.count);
			for (let w = _, T = S - 1; w < T; w += v) {
				const A = checkIntersection(this, s, _ray$1$1, g, w, w + 1, w);
				A && a.push(A)
			}
			if (this.isLineLoop) {
				const w = checkIntersection(this, s, _ray$1$1, g, S - 1, _, S - 1);
				w && a.push(w)
			}
		}
	}
	updateMorphTargets() {
		const a = this.geometry.morphAttributes,
			l = Object.keys(a);
		if (l.length > 0) {
			const c = a[l[0]];
			if (c !== void 0) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let d = 0, f = c.length; d < f; d++) {
					const m = c[d].name || String(d);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[m] = d
				}
			}
		}
	}
}

function checkIntersection(o, s, a, l, c, d, f) {
	const m = o.geometry.attributes.position;
	if (_vStart.fromBufferAttribute(m, c), _vEnd.fromBufferAttribute(m, d), a.distanceSqToSegment(_vStart, _vEnd,
			_intersectPointOnRay, _intersectPointOnSegment) > l) return;
	_intersectPointOnRay.applyMatrix4(o.matrixWorld);
	const v = s.ray.origin.distanceTo(_intersectPointOnRay);
	if (!(v < s.near || v > s.far)) return {
		distance: v,
		point: _intersectPointOnSegment.clone().applyMatrix4(o.matrixWorld),
		index: f,
		face: null,
		faceIndex: null,
		barycoord: null,
		object: o
	}
}
const _start$1 = new Vector3$1,
	_end$1 = new Vector3$1;
class LineSegments extends Line {
	constructor(s, a) {
		super(s, a), this.isLineSegments = !0, this.type = "LineSegments"
	}
	computeLineDistances() {
		const s = this.geometry;
		if (s.index === null) {
			const a = s.attributes.position,
				l = [];
			for (let c = 0, d = a.count; c < d; c += 2) _start$1.fromBufferAttribute(a, c), _end$1
				.fromBufferAttribute(a, c + 1), l[c] = c === 0 ? 0 : l[c - 1], l[c + 1] = l[c] + _start$1
				.distanceTo(_end$1);
			s.setAttribute("lineDistance", new Float32BufferAttribute(l, 1))
		} else console.warn(
			"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
			);
		return this
	}
}
class PointsMaterial extends Material {
	constructor(s) {
		super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Color(16777215), this
			.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this
			.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.color.copy(s.color), this.map = s.map, this.alphaMap = s.alphaMap, this.size = s
			.size, this.sizeAttenuation = s.sizeAttenuation, this.fog = s.fog, this
	}
}
const _inverseMatrix = new Matrix4,
	_ray$4 = new Ray,
	_sphere$2 = new Sphere,
	_position$2 = new Vector3$1;
let Points$1 = class extends Object3D {
	constructor(s = new BufferGeometry, a = new PointsMaterial) {
		super(), this.isPoints = !0, this.type = "Points", this.geometry = s, this.material = a, this
			.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
	}
	copy(s, a) {
		return super.copy(s, a), this.material = Array.isArray(s.material) ? s.material.slice() : s.material,
			this.geometry = s.geometry, this
	}
	raycast(s, a) {
		const l = this.geometry,
			c = this.matrixWorld,
			d = s.params.Points.threshold,
			f = l.drawRange;
		if (l.boundingSphere === null && l.computeBoundingSphere(), _sphere$2.copy(l.boundingSphere), _sphere$2
			.applyMatrix4(c), _sphere$2.radius += d, s.ray.intersectsSphere(_sphere$2) === !1) return;
		_inverseMatrix.copy(c).invert(), _ray$4.copy(s.ray).applyMatrix4(_inverseMatrix);
		const m = d / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			g = m * m,
			v = l.index,
			b = l.attributes.position;
		if (v !== null) {
			const C = Math.max(0, f.start),
				_ = Math.min(v.count, f.start + f.count);
			for (let S = C, w = _; S < w; S++) {
				const T = v.getX(S);
				_position$2.fromBufferAttribute(b, T), testPoint(_position$2, T, g, c, s, a, this)
			}
		} else {
			const C = Math.max(0, f.start),
				_ = Math.min(b.count, f.start + f.count);
			for (let S = C, w = _; S < w; S++) _position$2.fromBufferAttribute(b, S), testPoint(_position$2, S,
				g, c, s, a, this)
		}
	}
	updateMorphTargets() {
		const a = this.geometry.morphAttributes,
			l = Object.keys(a);
		if (l.length > 0) {
			const c = a[l[0]];
			if (c !== void 0) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let d = 0, f = c.length; d < f; d++) {
					const m = c[d].name || String(d);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[m] = d
				}
			}
		}
	}
};

function testPoint(o, s, a, l, c, d, f) {
	const m = _ray$4.distanceSqToPoint(o);
	if (m < a) {
		const g = new Vector3$1;
		_ray$4.closestPointToPoint(o, g), g.applyMatrix4(l);
		const v = c.ray.origin.distanceTo(g);
		if (v < c.near || v > c.far) return;
		d.push({
			distance: v,
			distanceToRay: Math.sqrt(m),
			point: g,
			index: s,
			face: null,
			faceIndex: null,
			barycoord: null,
			object: f
		})
	}
}
class DepthTexture extends Texture {
	constructor(s, a, l = UnsignedIntType, c, d, f, m = NearestFilter, g = NearestFilter, v, y = DepthFormat) {
		if (y !== DepthFormat && y !== DepthStencilFormat) throw new Error(
			"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
		super(null, c, d, f, m, g, y, l, v), this.isDepthTexture = !0, this.image = {
			width: s,
			height: a
		}, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
	}
	copy(s) {
		return super.copy(s), this.source = new Source(Object.assign({}, s.image)), this.compareFunction = s
			.compareFunction, this
	}
	toJSON(s) {
		const a = super.toJSON(s);
		return this.compareFunction !== null && (a.compareFunction = this.compareFunction), a
	}
}
class CylinderGeometry extends BufferGeometry {
	constructor(s = 1, a = 1, l = 1, c = 32, d = 1, f = !1, m = 0, g = Math.PI * 2) {
		super(), this.type = "CylinderGeometry", this.parameters = {
			radiusTop: s,
			radiusBottom: a,
			height: l,
			radialSegments: c,
			heightSegments: d,
			openEnded: f,
			thetaStart: m,
			thetaLength: g
		};
		const v = this;
		c = Math.floor(c), d = Math.floor(d);
		const y = [],
			b = [],
			C = [],
			_ = [];
		let S = 0;
		const w = [],
			T = l / 2;
		let A = 0;
		k(), f === !1 && (s > 0 && M(!0), a > 0 && M(!1)), this.setIndex(y), this.setAttribute("position",
				new Float32BufferAttribute(b, 3)), this.setAttribute("normal", new Float32BufferAttribute(C, 3)),
			this.setAttribute("uv", new Float32BufferAttribute(_, 2));

		function k() {
			const D = new Vector3$1,
				F = new Vector3$1;
			let R = 0;
			const O = (a - s) / l;
			for (let U = 0; U <= d; U++) {
				const V = [],
					z = U / d,
					j = z * (a - s) + s;
				for (let ge = 0; ge <= c; ge++) {
					const me = ge / c,
						he = me * g + m,
						ce = Math.sin(he),
						ae = Math.cos(he);
					F.x = j * ce, F.y = -z * l + T, F.z = j * ae, b.push(F.x, F.y, F.z), D.set(ce, O, ae)
					.normalize(), C.push(D.x, D.y, D.z), _.push(me, 1 - z), V.push(S++)
				}
				w.push(V)
			}
			for (let U = 0; U < c; U++)
				for (let V = 0; V < d; V++) {
					const z = w[V][U],
						j = w[V + 1][U],
						ge = w[V + 1][U + 1],
						me = w[V][U + 1];
					(s > 0 || V !== 0) && (y.push(z, j, me), R += 3), (a > 0 || V !== d - 1) && (y.push(j, ge, me),
						R += 3)
				}
			v.addGroup(A, R, 0), A += R
		}

		function M(D) {
			const F = S,
				R = new Vector2,
				O = new Vector3$1;
			let U = 0;
			const V = D === !0 ? s : a,
				z = D === !0 ? 1 : -1;
			for (let ge = 1; ge <= c; ge++) b.push(0, T * z, 0), C.push(0, z, 0), _.push(.5, .5), S++;
			const j = S;
			for (let ge = 0; ge <= c; ge++) {
				const he = ge / c * g + m,
					ce = Math.cos(he),
					ae = Math.sin(he);
				O.x = V * ae, O.y = T * z, O.z = V * ce, b.push(O.x, O.y, O.z), C.push(0, z, 0), R.x = ce * .5 + .5,
					R.y = ae * .5 * z + .5, _.push(R.x, R.y), S++
			}
			for (let ge = 0; ge < c; ge++) {
				const me = F + ge,
					he = j + ge;
				D === !0 ? y.push(he, he + 1, me) : y.push(he + 1, he, me), U += 3
			}
			v.addGroup(A, U, D === !0 ? 1 : 2), A += U
		}
	}
	copy(s) {
		return super.copy(s), this.parameters = Object.assign({}, s.parameters), this
	}
	static fromJSON(s) {
		return new CylinderGeometry(s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s
			.openEnded, s.thetaStart, s.thetaLength)
	}
}
class PlaneGeometry extends BufferGeometry {
	constructor(s = 1, a = 1, l = 1, c = 1) {
		super(), this.type = "PlaneGeometry", this.parameters = {
			width: s,
			height: a,
			widthSegments: l,
			heightSegments: c
		};
		const d = s / 2,
			f = a / 2,
			m = Math.floor(l),
			g = Math.floor(c),
			v = m + 1,
			y = g + 1,
			b = s / m,
			C = a / g,
			_ = [],
			S = [],
			w = [],
			T = [];
		for (let A = 0; A < y; A++) {
			const k = A * C - f;
			for (let M = 0; M < v; M++) {
				const D = M * b - d;
				S.push(D, -k, 0), w.push(0, 0, 1), T.push(M / m), T.push(1 - A / g)
			}
		}
		for (let A = 0; A < g; A++)
			for (let k = 0; k < m; k++) {
				const M = k + v * A,
					D = k + v * (A + 1),
					F = k + 1 + v * (A + 1),
					R = k + 1 + v * A;
				_.push(M, D, R), _.push(D, F, R)
			}
		this.setIndex(_), this.setAttribute("position", new Float32BufferAttribute(S, 3)), this.setAttribute(
			"normal", new Float32BufferAttribute(w, 3)), this.setAttribute("uv", new Float32BufferAttribute(T,
			2))
	}
	copy(s) {
		return super.copy(s), this.parameters = Object.assign({}, s.parameters), this
	}
	static fromJSON(s) {
		return new PlaneGeometry(s.width, s.height, s.widthSegments, s.heightSegments)
	}
}
class SphereGeometry extends BufferGeometry {
	constructor(s = 1, a = 32, l = 16, c = 0, d = Math.PI * 2, f = 0, m = Math.PI) {
		super(), this.type = "SphereGeometry", this.parameters = {
			radius: s,
			widthSegments: a,
			heightSegments: l,
			phiStart: c,
			phiLength: d,
			thetaStart: f,
			thetaLength: m
		}, a = Math.max(3, Math.floor(a)), l = Math.max(2, Math.floor(l));
		const g = Math.min(f + m, Math.PI);
		let v = 0;
		const y = [],
			b = new Vector3$1,
			C = new Vector3$1,
			_ = [],
			S = [],
			w = [],
			T = [];
		for (let A = 0; A <= l; A++) {
			const k = [],
				M = A / l;
			let D = 0;
			A === 0 && f === 0 ? D = .5 / a : A === l && g === Math.PI && (D = -.5 / a);
			for (let F = 0; F <= a; F++) {
				const R = F / a;
				b.x = -s * Math.cos(c + R * d) * Math.sin(f + M * m), b.y = s * Math.cos(f + M * m), b.z = s * Math
					.sin(c + R * d) * Math.sin(f + M * m), S.push(b.x, b.y, b.z), C.copy(b).normalize(), w.push(C.x,
						C.y, C.z), T.push(R + D, 1 - M), k.push(v++)
			}
			y.push(k)
		}
		for (let A = 0; A < l; A++)
			for (let k = 0; k < a; k++) {
				const M = y[A][k + 1],
					D = y[A][k],
					F = y[A + 1][k],
					R = y[A + 1][k + 1];
				(A !== 0 || f > 0) && _.push(M, D, R), (A !== l - 1 || g < Math.PI) && _.push(D, F, R)
			}
		this.setIndex(_), this.setAttribute("position", new Float32BufferAttribute(S, 3)), this.setAttribute(
			"normal", new Float32BufferAttribute(w, 3)), this.setAttribute("uv", new Float32BufferAttribute(T,
			2))
	}
	copy(s) {
		return super.copy(s), this.parameters = Object.assign({}, s.parameters), this
	}
	static fromJSON(s) {
		return new SphereGeometry(s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s
			.thetaStart, s.thetaLength)
	}
}
class WireframeGeometry extends BufferGeometry {
	constructor(s = null) {
		if (super(), this.type = "WireframeGeometry", this.parameters = {
				geometry: s
			}, s !== null) {
			const a = [],
				l = new Set,
				c = new Vector3$1,
				d = new Vector3$1;
			if (s.index !== null) {
				const f = s.attributes.position,
					m = s.index;
				let g = s.groups;
				g.length === 0 && (g = [{
					start: 0,
					count: m.count,
					materialIndex: 0
				}]);
				for (let v = 0, y = g.length; v < y; ++v) {
					const b = g[v],
						C = b.start,
						_ = b.count;
					for (let S = C, w = C + _; S < w; S += 3)
						for (let T = 0; T < 3; T++) {
							const A = m.getX(S + T),
								k = m.getX(S + (T + 1) % 3);
							c.fromBufferAttribute(f, A), d.fromBufferAttribute(f, k), isUniqueEdge(c, d, l) === !
								0 && (a.push(c.x, c.y, c.z), a.push(d.x, d.y, d.z))
						}
				}
			} else {
				const f = s.attributes.position;
				for (let m = 0, g = f.count / 3; m < g; m++)
					for (let v = 0; v < 3; v++) {
						const y = 3 * m + v,
							b = 3 * m + (v + 1) % 3;
						c.fromBufferAttribute(f, y), d.fromBufferAttribute(f, b), isUniqueEdge(c, d, l) === !0 && (a
							.push(c.x, c.y, c.z), a.push(d.x, d.y, d.z))
					}
			}
			this.setAttribute("position", new Float32BufferAttribute(a, 3))
		}
	}
	copy(s) {
		return super.copy(s), this.parameters = Object.assign({}, s.parameters), this
	}
}

function isUniqueEdge(o, s, a) {
	const l = `${o.x},${o.y},${o.z}-${s.x},${s.y},${s.z}`,
		c = `${s.x},${s.y},${s.z}-${o.x},${o.y},${o.z}`;
	return a.has(l) === !0 || a.has(c) === !0 ? !1 : (a.add(l), a.add(c), !0)
}
class MeshPhongMaterial extends Material {
	constructor(s) {
		super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Color(16777215),
			this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this
			.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this
			.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this
			.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1),
			this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap =
			null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler, this.combine =
			MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this
			.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this
			.flatShading = !1, this.fog = !0, this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.color.copy(s.color), this.specular.copy(s.specular), this.shininess = s
			.shininess, this.map = s.map, this.lightMap = s.lightMap, this.lightMapIntensity = s.lightMapIntensity,
			this.aoMap = s.aoMap, this.aoMapIntensity = s.aoMapIntensity, this.emissive.copy(s.emissive), this
			.emissiveMap = s.emissiveMap, this.emissiveIntensity = s.emissiveIntensity, this.bumpMap = s.bumpMap,
			this.bumpScale = s.bumpScale, this.normalMap = s.normalMap, this.normalMapType = s.normalMapType, this
			.normalScale.copy(s.normalScale), this.displacementMap = s.displacementMap, this.displacementScale = s
			.displacementScale, this.displacementBias = s.displacementBias, this.specularMap = s.specularMap, this
			.alphaMap = s.alphaMap, this.envMap = s.envMap, this.envMapRotation.copy(s.envMapRotation), this
			.combine = s.combine, this.reflectivity = s.reflectivity, this.refractionRatio = s.refractionRatio, this
			.wireframe = s.wireframe, this.wireframeLinewidth = s.wireframeLinewidth, this.wireframeLinecap = s
			.wireframeLinecap, this.wireframeLinejoin = s.wireframeLinejoin, this.flatShading = s.flatShading, this
			.fog = s.fog, this
	}
}
class MeshLambertMaterial extends Material {
	constructor(s) {
		super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Color(
				16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null,
			this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap =
			null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType =
			TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this
			.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this
			.envMap = null, this.envMapRotation = new Euler, this.combine = MultiplyOperation, this.reflectivity =
			1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap =
			"round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.color.copy(s.color), this.map = s.map, this.lightMap = s.lightMap, this
			.lightMapIntensity = s.lightMapIntensity, this.aoMap = s.aoMap, this.aoMapIntensity = s.aoMapIntensity,
			this.emissive.copy(s.emissive), this.emissiveMap = s.emissiveMap, this.emissiveIntensity = s
			.emissiveIntensity, this.bumpMap = s.bumpMap, this.bumpScale = s.bumpScale, this.normalMap = s
			.normalMap, this.normalMapType = s.normalMapType, this.normalScale.copy(s.normalScale), this
			.displacementMap = s.displacementMap, this.displacementScale = s.displacementScale, this
			.displacementBias = s.displacementBias, this.specularMap = s.specularMap, this.alphaMap = s.alphaMap,
			this.envMap = s.envMap, this.envMapRotation.copy(s.envMapRotation), this.combine = s.combine, this
			.reflectivity = s.reflectivity, this.refractionRatio = s.refractionRatio, this.wireframe = s.wireframe,
			this.wireframeLinewidth = s.wireframeLinewidth, this.wireframeLinecap = s.wireframeLinecap, this
			.wireframeLinejoin = s.wireframeLinejoin, this.flatShading = s.flatShading, this.fog = s.fog, this
	}
}
class MeshDepthMaterial extends Material {
	constructor(s) {
		super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking =
			BasicDepthPacking, this.map = null, this.alphaMap = null, this.displacementMap = null, this
			.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1,
			this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.depthPacking = s.depthPacking, this.map = s.map, this.alphaMap = s.alphaMap, this
			.displacementMap = s.displacementMap, this.displacementScale = s.displacementScale, this
			.displacementBias = s.displacementBias, this.wireframe = s.wireframe, this.wireframeLinewidth = s
			.wireframeLinewidth, this
	}
}
class MeshDistanceMaterial extends Material {
	constructor(s) {
		super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this
			.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0,
			this.setValues(s)
	}
	copy(s) {
		return super.copy(s), this.map = s.map, this.alphaMap = s.alphaMap, this.displacementMap = s
			.displacementMap, this.displacementScale = s.displacementScale, this.displacementBias = s
			.displacementBias, this
	}
}

function convertArray(o, s) {
	return !o || o.constructor === s ? o : typeof s.BYTES_PER_ELEMENT == "number" ? new s(o) : Array.prototype.slice
		.call(o)
}

function isTypedArray(o) {
	return ArrayBuffer.isView(o) && !(o instanceof DataView)
}

function getKeyframeOrder(o) {
	function s(c, d) {
		return o[c] - o[d]
	}
	const a = o.length,
		l = new Array(a);
	for (let c = 0; c !== a; ++c) l[c] = c;
	return l.sort(s), l
}

function sortedArray(o, s, a) {
	const l = o.length,
		c = new o.constructor(l);
	for (let d = 0, f = 0; f !== l; ++d) {
		const m = a[d] * s;
		for (let g = 0; g !== s; ++g) c[f++] = o[m + g]
	}
	return c
}

function flattenJSON(o, s, a, l) {
	let c = 1,
		d = o[0];
	for (; d !== void 0 && d[l] === void 0;) d = o[c++];
	if (d === void 0) return;
	let f = d[l];
	if (f !== void 0)
		if (Array.isArray(f))
			do f = d[l], f !== void 0 && (s.push(d.time), a.push(...f)), d = o[c++]; while (d !== void 0);
		else if (f.toArray !== void 0)
		do f = d[l], f !== void 0 && (s.push(d.time), f.toArray(a, a.length)), d = o[c++]; while (d !== void 0);
	else
		do f = d[l], f !== void 0 && (s.push(d.time), a.push(f)), d = o[c++]; while (d !== void 0)
}
class Interpolant {
	constructor(s, a, l, c) {
		this.parameterPositions = s, this._cachedIndex = 0, this.resultBuffer = c !== void 0 ? c : new a
			.constructor(l), this.sampleValues = a, this.valueSize = l, this.settings = null, this
			.DefaultSettings_ = {}
	}
	evaluate(s) {
		const a = this.parameterPositions;
		let l = this._cachedIndex,
			c = a[l],
			d = a[l - 1];
		e: {
			t: {
				let f;n: {
					r: if (!(s < c)) {
						for (let m = l + 2;;) {
							if (c === void 0) {
								if (s < d) break r;
								return l = a.length, this._cachedIndex = l, this.copySampleValue_(l - 1)
							}
							if (l === m) break;
							if (d = c, c = a[++l], s < c) break t
						}
						f = a.length;
						break n
					}if (!(s >= d)) {
						const m = a[1];
						s < m && (l = 2, d = m);
						for (let g = l - 2;;) {
							if (d === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
							if (l === g) break;
							if (c = d, d = a[--l - 1], s >= d) break t
						}
						f = l, l = 0;
						break n
					}
					break e
				}
				for (; l < f;) {
					const m = l + f >>> 1;
					s < a[m] ? f = m : l = m + 1
				}
				if (c = a[l], d = a[l - 1], d === void 0) return this._cachedIndex = 0,
				this.copySampleValue_(0);
				if (c === void 0) return l = a.length,
				this._cachedIndex = l,
				this.copySampleValue_(l - 1)
			}
			this._cachedIndex = l,
			this.intervalChanged_(l, d, c)
		}
		return this.interpolate_(l, d, s, c)
	}
	getSettings_() {
		return this.settings || this.DefaultSettings_
	}
	copySampleValue_(s) {
		const a = this.resultBuffer,
			l = this.sampleValues,
			c = this.valueSize,
			d = s * c;
		for (let f = 0; f !== c; ++f) a[f] = l[d + f];
		return a
	}
	interpolate_() {
		throw new Error("call to abstract method")
	}
	intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
	constructor(s, a, l, c) {
		super(s, a, l, c), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -
			0, this.DefaultSettings_ = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			}
	}
	intervalChanged_(s, a, l) {
		const c = this.parameterPositions;
		let d = s - 2,
			f = s + 1,
			m = c[d],
			g = c[f];
		if (m === void 0) switch (this.getSettings_().endingStart) {
			case ZeroSlopeEnding:
				d = s, m = 2 * a - l;
				break;
			case WrapAroundEnding:
				d = c.length - 2, m = a + c[d] - c[d + 1];
				break;
			default:
				d = s, m = l
		}
		if (g === void 0) switch (this.getSettings_().endingEnd) {
			case ZeroSlopeEnding:
				f = s, g = 2 * l - a;
				break;
			case WrapAroundEnding:
				f = 1, g = l + c[1] - c[0];
				break;
			default:
				f = s - 1, g = a
		}
		const v = (l - a) * .5,
			y = this.valueSize;
		this._weightPrev = v / (a - m), this._weightNext = v / (g - l), this._offsetPrev = d * y, this._offsetNext =
			f * y
	}
	interpolate_(s, a, l, c) {
		const d = this.resultBuffer,
			f = this.sampleValues,
			m = this.valueSize,
			g = s * m,
			v = g - m,
			y = this._offsetPrev,
			b = this._offsetNext,
			C = this._weightPrev,
			_ = this._weightNext,
			S = (l - a) / (c - a),
			w = S * S,
			T = w * S,
			A = -C * T + 2 * C * w - C * S,
			k = (1 + C) * T + (-1.5 - 2 * C) * w + (-.5 + C) * S + 1,
			M = (-1 - _) * T + (1.5 + _) * w + .5 * S,
			D = _ * T - _ * w;
		for (let F = 0; F !== m; ++F) d[F] = A * f[y + F] + k * f[v + F] + M * f[g + F] + D * f[b + F];
		return d
	}
}
class LinearInterpolant extends Interpolant {
	constructor(s, a, l, c) {
		super(s, a, l, c)
	}
	interpolate_(s, a, l, c) {
		const d = this.resultBuffer,
			f = this.sampleValues,
			m = this.valueSize,
			g = s * m,
			v = g - m,
			y = (l - a) / (c - a),
			b = 1 - y;
		for (let C = 0; C !== m; ++C) d[C] = f[v + C] * b + f[g + C] * y;
		return d
	}
}
class DiscreteInterpolant extends Interpolant {
	constructor(s, a, l, c) {
		super(s, a, l, c)
	}
	interpolate_(s) {
		return this.copySampleValue_(s - 1)
	}
}
class KeyframeTrack {
	constructor(s, a, l, c) {
		if (s === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
		if (a === void 0 || a.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " +
		s);
		this.name = s, this.times = convertArray(a, this.TimeBufferType), this.values = convertArray(l, this
			.ValueBufferType), this.setInterpolation(c || this.DefaultInterpolation)
	}
	static toJSON(s) {
		const a = s.constructor;
		let l;
		if (a.toJSON !== this.toJSON) l = a.toJSON(s);
		else {
			l = {
				name: s.name,
				times: convertArray(s.times, Array),
				values: convertArray(s.values, Array)
			};
			const c = s.getInterpolation();
			c !== s.DefaultInterpolation && (l.interpolation = c)
		}
		return l.type = s.ValueTypeName, l
	}
	InterpolantFactoryMethodDiscrete(s) {
		return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), s)
	}
	InterpolantFactoryMethodLinear(s) {
		return new LinearInterpolant(this.times, this.values, this.getValueSize(), s)
	}
	InterpolantFactoryMethodSmooth(s) {
		return new CubicInterpolant(this.times, this.values, this.getValueSize(), s)
	}
	setInterpolation(s) {
		let a;
		switch (s) {
			case InterpolateDiscrete:
				a = this.InterpolantFactoryMethodDiscrete;
				break;
			case InterpolateLinear:
				a = this.InterpolantFactoryMethodLinear;
				break;
			case InterpolateSmooth:
				a = this.InterpolantFactoryMethodSmooth;
				break
		}
		if (a === void 0) {
			const l = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
			if (this.createInterpolant === void 0)
				if (s !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
				else throw new Error(l);
			return console.warn("THREE.KeyframeTrack:", l), this
		}
		return this.createInterpolant = a, this
	}
	getInterpolation() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return InterpolateDiscrete;
			case this.InterpolantFactoryMethodLinear:
				return InterpolateLinear;
			case this.InterpolantFactoryMethodSmooth:
				return InterpolateSmooth
		}
	}
	getValueSize() {
		return this.values.length / this.times.length
	}
	shift(s) {
		if (s !== 0) {
			const a = this.times;
			for (let l = 0, c = a.length; l !== c; ++l) a[l] += s
		}
		return this
	}
	scale(s) {
		if (s !== 1) {
			const a = this.times;
			for (let l = 0, c = a.length; l !== c; ++l) a[l] *= s
		}
		return this
	}
	trim(s, a) {
		const l = this.times,
			c = l.length;
		let d = 0,
			f = c - 1;
		for (; d !== c && l[d] < s;) ++d;
		for (; f !== -1 && l[f] > a;) --f;
		if (++f, d !== 0 || f !== c) {
			d >= f && (f = Math.max(f, 1), d = f - 1);
			const m = this.getValueSize();
			this.times = l.slice(d, f), this.values = this.values.slice(d * m, f * m)
		}
		return this
	}
	validate() {
		let s = !0;
		const a = this.getValueSize();
		a - Math.floor(a) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), s = !
			1);
		const l = this.times,
			c = this.values,
			d = l.length;
		d === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), s = !1);
		let f = null;
		for (let m = 0; m !== d; m++) {
			const g = l[m];
			if (typeof g == "number" && isNaN(g)) {
				console.error("THREE.KeyframeTrack: Time is not a valid number.", this, m, g), s = !1;
				break
			}
			if (f !== null && f > g) {
				console.error("THREE.KeyframeTrack: Out of order keys.", this, m, g, f), s = !1;
				break
			}
			f = g
		}
		if (c !== void 0 && isTypedArray(c))
			for (let m = 0, g = c.length; m !== g; ++m) {
				const v = c[m];
				if (isNaN(v)) {
					console.error("THREE.KeyframeTrack: Value is not a valid number.", this, m, v), s = !1;
					break
				}
			}
		return s
	}
	optimize() {
		const s = this.times.slice(),
			a = this.values.slice(),
			l = this.getValueSize(),
			c = this.getInterpolation() === InterpolateSmooth,
			d = s.length - 1;
		let f = 1;
		for (let m = 1; m < d; ++m) {
			let g = !1;
			const v = s[m],
				y = s[m + 1];
			if (v !== y && (m !== 1 || v !== s[0]))
				if (c) g = !0;
				else {
					const b = m * l,
						C = b - l,
						_ = b + l;
					for (let S = 0; S !== l; ++S) {
						const w = a[b + S];
						if (w !== a[C + S] || w !== a[_ + S]) {
							g = !0;
							break
						}
					}
				} if (g) {
				if (m !== f) {
					s[f] = s[m];
					const b = m * l,
						C = f * l;
					for (let _ = 0; _ !== l; ++_) a[C + _] = a[b + _]
				}++f
			}
		}
		if (d > 0) {
			s[f] = s[d];
			for (let m = d * l, g = f * l, v = 0; v !== l; ++v) a[g + v] = a[m + v];
			++f
		}
		return f !== s.length ? (this.times = s.slice(0, f), this.values = a.slice(0, f * l)) : (this.times = s,
			this.values = a), this
	}
	clone() {
		const s = this.times.slice(),
			a = this.values.slice(),
			l = this.constructor,
			c = new l(this.name, s, a);
		return c.createInterpolant = this.createInterpolant, c
	}
}
KeyframeTrack.prototype.ValueTypeName = "";
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
	constructor(s, a, l) {
		super(s, a, l)
	}
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
	constructor(s, a, l, c) {
		super(s, a, l, c)
	}
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
	constructor(s, a, l, c) {
		super(s, a, l, c)
	}
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
	constructor(s, a, l, c) {
		super(s, a, l, c)
	}
	interpolate_(s, a, l, c) {
		const d = this.resultBuffer,
			f = this.sampleValues,
			m = this.valueSize,
			g = (l - a) / (c - a);
		let v = s * m;
		for (let y = v + m; v !== y; v += 4) Quaternion$1.slerpFlat(d, 0, f, v - m, f, v, g);
		return d
	}
}
class QuaternionKeyframeTrack extends KeyframeTrack {
	constructor(s, a, l, c) {
		super(s, a, l, c)
	}
	InterpolantFactoryMethodLinear(s) {
		return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), s)
	}
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
	constructor(s, a, l) {
		super(s, a, l)
	}
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
	constructor(s, a, l, c) {
		super(s, a, l, c)
	}
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
	constructor(s = "", a = -1, l = [], c = NormalAnimationBlendMode) {
		this.name = s, this.tracks = l, this.duration = a, this.blendMode = c, this.uuid = generateUUID(), this
			.duration < 0 && this.resetDuration()
	}
	static parse(s) {
		const a = [],
			l = s.tracks,
			c = 1 / (s.fps || 1);
		for (let f = 0, m = l.length; f !== m; ++f) a.push(parseKeyframeTrack(l[f]).scale(c));
		const d = new this(s.name, s.duration, a, s.blendMode);
		return d.uuid = s.uuid, d
	}
	static toJSON(s) {
		const a = [],
			l = s.tracks,
			c = {
				name: s.name,
				duration: s.duration,
				tracks: a,
				uuid: s.uuid,
				blendMode: s.blendMode
			};
		for (let d = 0, f = l.length; d !== f; ++d) a.push(KeyframeTrack.toJSON(l[d]));
		return c
	}
	static CreateFromMorphTargetSequence(s, a, l, c) {
		const d = a.length,
			f = [];
		for (let m = 0; m < d; m++) {
			let g = [],
				v = [];
			g.push((m + d - 1) % d, m, (m + 1) % d), v.push(0, 1, 0);
			const y = getKeyframeOrder(g);
			g = sortedArray(g, 1, y), v = sortedArray(v, 1, y), !c && g[0] === 0 && (g.push(d), v.push(v[0])), f
				.push(new NumberKeyframeTrack(".morphTargetInfluences[" + a[m].name + "]", g, v).scale(1 / l))
		}
		return new this(s, -1, f)
	}
	static findByName(s, a) {
		let l = s;
		if (!Array.isArray(s)) {
			const c = s;
			l = c.geometry && c.geometry.animations || c.animations
		}
		for (let c = 0; c < l.length; c++)
			if (l[c].name === a) return l[c];
		return null
	}
	static CreateClipsFromMorphTargetSequences(s, a, l) {
		const c = {},
			d = /^([\w-]*?)([\d]+)$/;
		for (let m = 0, g = s.length; m < g; m++) {
			const v = s[m],
				y = v.name.match(d);
			if (y && y.length > 1) {
				const b = y[1];
				let C = c[b];
				C || (c[b] = C = []), C.push(v)
			}
		}
		const f = [];
		for (const m in c) f.push(this.CreateFromMorphTargetSequence(m, c[m], a, l));
		return f
	}
	static parseAnimation(s, a) {
		if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !s)
			return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
		const l = function(b, C, _, S, w) {
				if (_.length !== 0) {
					const T = [],
						A = [];
					flattenJSON(_, T, A, S), T.length !== 0 && w.push(new b(C, T, A))
				}
			},
			c = [],
			d = s.name || "default",
			f = s.fps || 30,
			m = s.blendMode;
		let g = s.length || -1;
		const v = s.hierarchy || [];
		for (let b = 0; b < v.length; b++) {
			const C = v[b].keys;
			if (!(!C || C.length === 0))
				if (C[0].morphTargets) {
					const _ = {};
					let S;
					for (S = 0; S < C.length; S++)
						if (C[S].morphTargets)
							for (let w = 0; w < C[S].morphTargets.length; w++) _[C[S].morphTargets[w]] = -1;
					for (const w in _) {
						const T = [],
							A = [];
						for (let k = 0; k !== C[S].morphTargets.length; ++k) {
							const M = C[S];
							T.push(M.time), A.push(M.morphTarget === w ? 1 : 0)
						}
						c.push(new NumberKeyframeTrack(".morphTargetInfluence[" + w + "]", T, A))
					}
					g = _.length * f
				} else {
					const _ = ".bones[" + a[b].name + "]";
					l(VectorKeyframeTrack, _ + ".position", C, "pos", c), l(QuaternionKeyframeTrack, _ +
						".quaternion", C, "rot", c), l(VectorKeyframeTrack, _ + ".scale", C, "scl", c)
				}
		}
		return c.length === 0 ? null : new this(d, g, c, m)
	}
	resetDuration() {
		const s = this.tracks;
		let a = 0;
		for (let l = 0, c = s.length; l !== c; ++l) {
			const d = this.tracks[l];
			a = Math.max(a, d.times[d.times.length - 1])
		}
		return this.duration = a, this
	}
	trim() {
		for (let s = 0; s < this.tracks.length; s++) this.tracks[s].trim(0, this.duration);
		return this
	}
	validate() {
		let s = !0;
		for (let a = 0; a < this.tracks.length; a++) s = s && this.tracks[a].validate();
		return s
	}
	optimize() {
		for (let s = 0; s < this.tracks.length; s++) this.tracks[s].optimize();
		return this
	}
	clone() {
		const s = [];
		for (let a = 0; a < this.tracks.length; a++) s.push(this.tracks[a].clone());
		return new this.constructor(this.name, this.duration, s, this.blendMode)
	}
	toJSON() {
		return this.constructor.toJSON(this)
	}
}

function getTrackTypeForValueTypeName(o) {
	switch (o.toLowerCase()) {
		case "scalar":
		case "double":
		case "float":
		case "number":
		case "integer":
			return NumberKeyframeTrack;
		case "vector":
		case "vector2":
		case "vector3":
		case "vector4":
			return VectorKeyframeTrack;
		case "color":
			return ColorKeyframeTrack;
		case "quaternion":
			return QuaternionKeyframeTrack;
		case "bool":
		case "boolean":
			return BooleanKeyframeTrack;
		case "string":
			return StringKeyframeTrack
	}
	throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + o)
}

function parseKeyframeTrack(o) {
	if (o.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
	const s = getTrackTypeForValueTypeName(o.type);
	if (o.times === void 0) {
		const a = [],
			l = [];
		flattenJSON(o.keys, a, l, "value"), o.times = a, o.values = l
	}
	return s.parse !== void 0 ? s.parse(o) : new s(o.name, o.times, o.values, o.interpolation)
}
const Cache = {
	enabled: !1,
	files: {},
	add: function(o, s) {
		this.enabled !== !1 && (this.files[o] = s)
	},
	get: function(o) {
		if (this.enabled !== !1) return this.files[o]
	},
	remove: function(o) {
		delete this.files[o]
	},
	clear: function() {
		this.files = {}
	}
};
class LoadingManager {
	constructor(s, a, l) {
		const c = this;
		let d = !1,
			f = 0,
			m = 0,
			g;
		const v = [];
		this.onStart = void 0, this.onLoad = s, this.onProgress = a, this.onError = l, this.itemStart = function(
		y) {
			m++, d === !1 && c.onStart !== void 0 && c.onStart(y, f, m), d = !0
		}, this.itemEnd = function(y) {
			f++, c.onProgress !== void 0 && c.onProgress(y, f, m), f === m && (d = !1, c.onLoad !== void 0 && c
				.onLoad())
		}, this.itemError = function(y) {
			c.onError !== void 0 && c.onError(y)
		}, this.resolveURL = function(y) {
			return g ? g(y) : y
		}, this.setURLModifier = function(y) {
			return g = y, this
		}, this.addHandler = function(y, b) {
			return v.push(y, b), this
		}, this.removeHandler = function(y) {
			const b = v.indexOf(y);
			return b !== -1 && v.splice(b, 2), this
		}, this.getHandler = function(y) {
			for (let b = 0, C = v.length; b < C; b += 2) {
				const _ = v[b],
					S = v[b + 1];
				if (_.global && (_.lastIndex = 0), _.test(y)) return S
			}
			return null
		}
	}
}
const DefaultLoadingManager = new LoadingManager;
class Loader {
	constructor(s) {
		this.manager = s !== void 0 ? s : DefaultLoadingManager, this.crossOrigin = "anonymous", this
			.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
	}
	load() {}
	loadAsync(s, a) {
		const l = this;
		return new Promise(function(c, d) {
			l.load(s, c, a, d)
		})
	}
	parse() {}
	setCrossOrigin(s) {
		return this.crossOrigin = s, this
	}
	setWithCredentials(s) {
		return this.withCredentials = s, this
	}
	setPath(s) {
		return this.path = s, this
	}
	setResourcePath(s) {
		return this.resourcePath = s, this
	}
	setRequestHeader(s) {
		return this.requestHeader = s, this
	}
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
	constructor(s, a) {
		super(s), this.response = a
	}
}
class FileLoader extends Loader {
	constructor(s) {
		super(s), this.mimeType = "", this.responseType = ""
	}
	load(s, a, l, c) {
		s === void 0 && (s = ""), this.path !== void 0 && (s = this.path + s), s = this.manager.resolveURL(s);
		const d = Cache.get(s);
		if (d !== void 0) return this.manager.itemStart(s), setTimeout(() => {
			a && a(d), this.manager.itemEnd(s)
		}, 0), d;
		if (loading[s] !== void 0) {
			loading[s].push({
				onLoad: a,
				onProgress: l,
				onError: c
			});
			return
		}
		loading[s] = [], loading[s].push({
			onLoad: a,
			onProgress: l,
			onError: c
		});
		const f = new Request(s, {
				headers: new Headers(this.requestHeader),
				credentials: this.withCredentials ? "include" : "same-origin"
			}),
			m = this.mimeType,
			g = this.responseType;
		fetch(f).then(v => {
			if (v.status === 200 || v.status === 0) {
				if (v.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
					typeof ReadableStream > "u" || v.body === void 0 || v.body.getReader === void 0)
				return v;
				const y = loading[s],
					b = v.body.getReader(),
					C = v.headers.get("X-File-Size") || v.headers.get("Content-Length"),
					_ = C ? parseInt(C) : 0,
					S = _ !== 0;
				let w = 0;
				const T = new ReadableStream({
					start(A) {
						k();

						function k() {
							b.read().then(({
								done: M,
								value: D
							}) => {
								if (M) A.close();
								else {
									w += D.byteLength;
									const F = new ProgressEvent("progress", {
										lengthComputable: S,
										loaded: w,
										total: _
									});
									for (let R = 0, O = y.length; R < O; R++) {
										const U = y[R];
										U.onProgress && U.onProgress(F)
									}
									A.enqueue(D), k()
								}
							}, M => {
								A.error(M)
							})
						}
					}
				});
				return new Response(T)
			} else throw new HttpError(`fetch for "${v.url}" responded with ${v.status}: ${v.statusText}`,
				v)
		}).then(v => {
			switch (g) {
				case "arraybuffer":
					return v.arrayBuffer();
				case "blob":
					return v.blob();
				case "document":
					return v.text().then(y => new DOMParser().parseFromString(y, m));
				case "json":
					return v.json();
				default:
					if (m === "") return v.text(); {
						const b = /charset="?([^;"\s]*)"?/i.exec(m),
							C = b && b[1] ? b[1].toLowerCase() : void 0,
							_ = new TextDecoder(C);
						return v.arrayBuffer().then(S => _.decode(S))
					}
			}
		}).then(v => {
			Cache.add(s, v);
			const y = loading[s];
			delete loading[s];
			for (let b = 0, C = y.length; b < C; b++) {
				const _ = y[b];
				_.onLoad && _.onLoad(v)
			}
		}).catch(v => {
			const y = loading[s];
			if (y === void 0) throw this.manager.itemError(s), v;
			delete loading[s];
			for (let b = 0, C = y.length; b < C; b++) {
				const _ = y[b];
				_.onError && _.onError(v)
			}
			this.manager.itemError(s)
		}).finally(() => {
			this.manager.itemEnd(s)
		}), this.manager.itemStart(s)
	}
	setResponseType(s) {
		return this.responseType = s, this
	}
	setMimeType(s) {
		return this.mimeType = s, this
	}
}
class ImageLoader extends Loader {
	constructor(s) {
		super(s)
	}
	load(s, a, l, c) {
		this.path !== void 0 && (s = this.path + s), s = this.manager.resolveURL(s);
		const d = this,
			f = Cache.get(s);
		if (f !== void 0) return d.manager.itemStart(s), setTimeout(function() {
			a && a(f), d.manager.itemEnd(s)
		}, 0), f;
		const m = createElementNS("img");

		function g() {
			y(), Cache.add(s, this), a && a(this), d.manager.itemEnd(s)
		}

		function v(b) {
			y(), c && c(b), d.manager.itemError(s), d.manager.itemEnd(s)
		}

		function y() {
			m.removeEventListener("load", g, !1), m.removeEventListener("error", v, !1)
		}
		return m.addEventListener("load", g, !1), m.addEventListener("error", v, !1), s.slice(0, 5) !== "data:" &&
			this.crossOrigin !== void 0 && (m.crossOrigin = this.crossOrigin), d.manager.itemStart(s), m.src = s, m
	}
}
class DataTextureLoader extends Loader {
	constructor(s) {
		super(s)
	}
	load(s, a, l, c) {
		const d = this,
			f = new DataTexture,
			m = new FileLoader(this.manager);
		return m.setResponseType("arraybuffer"), m.setRequestHeader(this.requestHeader), m.setPath(this.path), m
			.setWithCredentials(d.withCredentials), m.load(s, function(g) {
				let v;
				try {
					v = d.parse(g)
				} catch (y) {
					if (c !== void 0) c(y);
					else {
						console.error(y);
						return
					}
				}
				v.image !== void 0 ? f.image = v.image : v.data !== void 0 && (f.image.width = v.width, f.image
						.height = v.height, f.image.data = v.data), f.wrapS = v.wrapS !== void 0 ? v.wrapS :
					ClampToEdgeWrapping, f.wrapT = v.wrapT !== void 0 ? v.wrapT : ClampToEdgeWrapping, f
					.magFilter = v.magFilter !== void 0 ? v.magFilter : LinearFilter, f.minFilter = v
					.minFilter !== void 0 ? v.minFilter : LinearFilter, f.anisotropy = v.anisotropy !== void 0 ?
					v.anisotropy : 1, v.colorSpace !== void 0 && (f.colorSpace = v.colorSpace), v.flipY !==
					void 0 && (f.flipY = v.flipY), v.format !== void 0 && (f.format = v.format), v.type !==
					void 0 && (f.type = v.type), v.mipmaps !== void 0 && (f.mipmaps = v.mipmaps, f.minFilter =
						LinearMipmapLinearFilter), v.mipmapCount === 1 && (f.minFilter = LinearFilter), v
					.generateMipmaps !== void 0 && (f.generateMipmaps = v.generateMipmaps), f.needsUpdate = !0,
					a && a(f, v)
			}, l, c), f
	}
}
class TextureLoader extends Loader {
	constructor(s) {
		super(s)
	}
	load(s, a, l, c) {
		const d = new Texture,
			f = new ImageLoader(this.manager);
		return f.setCrossOrigin(this.crossOrigin), f.setPath(this.path), f.load(s, function(m) {
			d.image = m, d.needsUpdate = !0, a !== void 0 && a(d)
		}, l, c), d
	}
}
class Light extends Object3D {
	constructor(s, a = 1) {
		super(), this.isLight = !0, this.type = "Light", this.color = new Color(s), this.intensity = a
	}
	dispose() {}
	copy(s, a) {
		return super.copy(s, a), this.color.copy(s.color), this.intensity = s.intensity, this
	}
	toJSON(s) {
		const a = super.toJSON(s);
		return a.object.color = this.color.getHex(), a.object.intensity = this.intensity, this.groundColor !==
			void 0 && (a.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (a.object
				.distance = this.distance), this.angle !== void 0 && (a.object.angle = this.angle), this.decay !==
			void 0 && (a.object.decay = this.decay), this.penumbra !== void 0 && (a.object.penumbra = this
			.penumbra), this.shadow !== void 0 && (a.object.shadow = this.shadow.toJSON()), this.target !==
			void 0 && (a.object.target = this.target.uuid), a
	}
}
const _projScreenMatrix$1 = new Matrix4,
	_lightPositionWorld$1 = new Vector3$1,
	_lookTarget$1 = new Vector3$1;
class LightShadow {
	constructor(s) {
		this.camera = s, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples =
			8, this.mapSize = new Vector2(512, 512), this.mapType = UnsignedByteType, this.map = null, this
			.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum =
			new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [
				new Vector4(0, 0, 1, 1)
			]
	}
	getViewportCount() {
		return this._viewportCount
	}
	getFrustum() {
		return this._frustum
	}
	updateMatrices(s) {
		const a = this.camera,
			l = this.matrix;
		_lightPositionWorld$1.setFromMatrixPosition(s.matrixWorld), a.position.copy(_lightPositionWorld$1),
			_lookTarget$1.setFromMatrixPosition(s.target.matrixWorld), a.lookAt(_lookTarget$1), a
			.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse),
			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), l.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5,
				.5, 0, 0, 0, 1), l.multiply(_projScreenMatrix$1)
	}
	getViewport(s) {
		return this._viewports[s]
	}
	getFrameExtents() {
		return this._frameExtents
	}
	dispose() {
		this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
	}
	copy(s) {
		return this.camera = s.camera.clone(), this.intensity = s.intensity, this.bias = s.bias, this.radius = s
			.radius, this.autoUpdate = s.autoUpdate, this.needsUpdate = s.needsUpdate, this.normalBias = s
			.normalBias, this.blurSamples = s.blurSamples, this.mapSize.copy(s.mapSize), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
	toJSON() {
		const s = {};
		return this.intensity !== 1 && (s.intensity = this.intensity), this.bias !== 0 && (s.bias = this.bias), this
			.normalBias !== 0 && (s.normalBias = this.normalBias), this.radius !== 1 && (s.radius = this.radius), (
				this.mapSize.x !== 512 || this.mapSize.y !== 512) && (s.mapSize = this.mapSize.toArray()), s
			.camera = this.camera.toJSON(!1).object, delete s.camera.matrix, s
	}
}
class SpotLightShadow extends LightShadow {
	constructor() {
		super(new PerspectiveCamera(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
	}
	updateMatrices(s) {
		const a = this.camera,
			l = RAD2DEG * 2 * s.angle * this.focus,
			c = this.mapSize.width / this.mapSize.height,
			d = s.distance || a.far;
		(l !== a.fov || c !== a.aspect || d !== a.far) && (a.fov = l, a.aspect = c, a.far = d, a
			.updateProjectionMatrix()), super.updateMatrices(s)
	}
	copy(s) {
		return super.copy(s), this.focus = s.focus, this
	}
}
class SpotLight extends Light {
	constructor(s, a, l = 0, c = Math.PI / 3, d = 0, f = 2) {
		super(s, a), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Object3D.DEFAULT_UP), this
			.updateMatrix(), this.target = new Object3D, this.distance = l, this.angle = c, this.penumbra = d, this
			.decay = f, this.map = null, this.shadow = new SpotLightShadow
	}
	get power() {
		return this.intensity * Math.PI
	}
	set power(s) {
		this.intensity = s / Math.PI
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(s, a) {
		return super.copy(s, a), this.distance = s.distance, this.angle = s.angle, this.penumbra = s.penumbra, this
			.decay = s.decay, this.target = s.target.clone(), this.shadow = s.shadow.clone(), this
	}
}
const _projScreenMatrix = new Matrix4,
	_lightPositionWorld = new Vector3$1,
	_lookTarget = new Vector3$1;
class PointLightShadow extends LightShadow {
	constructor() {
		super(new PerspectiveCamera(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents =
			new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0,
					1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1),
				new Vector4(1, 0, 1, 1)
			], this._cubeDirections = [new Vector3$1(1, 0, 0), new Vector3$1(-1, 0, 0), new Vector3$1(0, 0, 1),
				new Vector3$1(0, 0, -1), new Vector3$1(0, 1, 0), new Vector3$1(0, -1, 0)
			], this._cubeUps = [new Vector3$1(0, 1, 0), new Vector3$1(0, 1, 0), new Vector3$1(0, 1, 0),
				new Vector3$1(0, 1, 0), new Vector3$1(0, 0, 1), new Vector3$1(0, 0, -1)
			]
	}
	updateMatrices(s, a = 0) {
		const l = this.camera,
			c = this.matrix,
			d = s.distance || l.far;
		d !== l.far && (l.far = d, l.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(s
				.matrixWorld), l.position.copy(_lightPositionWorld), _lookTarget.copy(l.position), _lookTarget.add(
				this._cubeDirections[a]), l.up.copy(this._cubeUps[a]), l.lookAt(_lookTarget), l.updateMatrixWorld(),
			c.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z),
			_projScreenMatrix.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse), this._frustum
			.setFromProjectionMatrix(_projScreenMatrix)
	}
}
class PointLight extends Light {
	constructor(s, a, l = 0, c = 2) {
		super(s, a), this.isPointLight = !0, this.type = "PointLight", this.distance = l, this.decay = c, this
			.shadow = new PointLightShadow
	}
	get power() {
		return this.intensity * 4 * Math.PI
	}
	set power(s) {
		this.intensity = s / (4 * Math.PI)
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(s, a) {
		return super.copy(s, a), this.distance = s.distance, this.decay = s.decay, this.shadow = s.shadow.clone(),
			this
	}
}
class OrthographicCamera extends Camera {
	constructor(s = -1, a = 1, l = 1, c = -1, d = .1, f = 2e3) {
		super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null,
			this.left = s, this.right = a, this.top = l, this.bottom = c, this.near = d, this.far = f, this
			.updateProjectionMatrix()
	}
	copy(s, a) {
		return super.copy(s, a), this.left = s.left, this.right = s.right, this.top = s.top, this.bottom = s.bottom,
			this.near = s.near, this.far = s.far, this.zoom = s.zoom, this.view = s.view === null ? null : Object
			.assign({}, s.view), this
	}
	setViewOffset(s, a, l, c, d, f) {
		this.view === null && (this.view = {
				enabled: !0,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			}), this.view.enabled = !0, this.view.fullWidth = s, this.view.fullHeight = a, this.view.offsetX = l,
			this.view.offsetY = c, this.view.width = d, this.view.height = f, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		const s = (this.right - this.left) / (2 * this.zoom),
			a = (this.top - this.bottom) / (2 * this.zoom),
			l = (this.right + this.left) / 2,
			c = (this.top + this.bottom) / 2;
		let d = l - s,
			f = l + s,
			m = c + a,
			g = c - a;
		if (this.view !== null && this.view.enabled) {
			const v = (this.right - this.left) / this.view.fullWidth / this.zoom,
				y = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			d += v * this.view.offsetX, f = d + v * this.view.width, m -= y * this.view.offsetY, g = m - y * this
				.view.height
		}
		this.projectionMatrix.makeOrthographic(d, f, m, g, this.near, this.far, this.coordinateSystem), this
			.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(s) {
		const a = super.toJSON(s);
		return a.object.zoom = this.zoom, a.object.left = this.left, a.object.right = this.right, a.object.top =
			this.top, a.object.bottom = this.bottom, a.object.near = this.near, a.object.far = this.far, this
			.view !== null && (a.object.view = Object.assign({}, this.view)), a
	}
}
class DirectionalLightShadow extends LightShadow {
	constructor() {
		super(new OrthographicCamera(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
	}
}
class DirectionalLight extends Light {
	constructor(s, a) {
		super(s, a), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Object3D
				.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.shadow =
			new DirectionalLightShadow
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(s) {
		return super.copy(s), this.target = s.target.clone(), this.shadow = s.shadow.clone(), this
	}
}
class AmbientLight extends Light {
	constructor(s, a) {
		super(s, a), this.isAmbientLight = !0, this.type = "AmbientLight"
	}
}
class LoaderUtils {
	static extractUrlBase(s) {
		const a = s.lastIndexOf("/");
		return a === -1 ? "./" : s.slice(0, a + 1)
	}
	static resolveURL(s, a) {
		return typeof s != "string" || s === "" ? "" : (/^https?:\/\//i.test(a) && /^\//.test(s) && (a = a.replace(
				/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(s) || /^data:.*,.*$/i.test(s) ||
			/^blob:.*$/i.test(s) ? s : a + s)
	}
}
class InstancedBufferGeometry extends BufferGeometry {
	constructor() {
		super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount =
			1 / 0
	}
	copy(s) {
		return super.copy(s), this.instanceCount = s.instanceCount, this
	}
	toJSON() {
		const s = super.toJSON();
		return s.instanceCount = this.instanceCount, s.isInstancedBufferGeometry = !0, s
	}
}
class ArrayCamera extends PerspectiveCamera {
	constructor(s = []) {
		super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = s
	}
}
class Clock {
	constructor(s = !0) {
		this.autoStart = s, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
	}
	start() {
		this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
	}
	stop() {
		this.getElapsedTime(), this.running = !1, this.autoStart = !1
	}
	getElapsedTime() {
		return this.getDelta(), this.elapsedTime
	}
	getDelta() {
		let s = 0;
		if (this.autoStart && !this.running) return this.start(), 0;
		if (this.running) {
			const a = now();
			s = (a - this.oldTime) / 1e3, this.oldTime = a, this.elapsedTime += s
		}
		return s
	}
}

function now() {
	return performance.now()
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
	constructor(s, a, l = 1) {
		super(s, a), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = l
	}
	copy(s) {
		return super.copy(s), this.meshPerAttribute = s.meshPerAttribute, this
	}
	clone(s) {
		const a = super.clone(s);
		return a.meshPerAttribute = this.meshPerAttribute, a
	}
	toJSON(s) {
		const a = super.toJSON(s);
		return a.isInstancedInterleavedBuffer = !0, a.meshPerAttribute = this.meshPerAttribute, a
	}
}
const _matrix = new Matrix4;
class Raycaster {
	constructor(s, a, l = 0, c = 1 / 0) {
		this.ray = new Ray(s, a), this.near = l, this.far = c, this.camera = null, this.layers = new Layers, this
			.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			}
	}
	set(s, a) {
		this.ray.set(s, a)
	}
	setFromCamera(s, a) {
		a.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(a.matrixWorld), this.ray.direction.set(s.x, s
			.y, .5).unproject(a).sub(this.ray.origin).normalize(), this.camera = a) : a.isOrthographicCamera ? (
			this.ray.origin.set(s.x, s.y, (a.near + a.far) / (a.near - a.far)).unproject(a), this.ray.direction
			.set(0, 0, -1).transformDirection(a.matrixWorld), this.camera = a) : console.error(
			"THREE.Raycaster: Unsupported camera type: " + a.type)
	}
	setFromXRController(s) {
		return _matrix.identity().extractRotation(s.matrixWorld), this.ray.origin.setFromMatrixPosition(s
			.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix), this
	}
	intersectObject(s, a = !0, l = []) {
		return intersect(s, this, l, a), l.sort(ascSort), l
	}
	intersectObjects(s, a = !0, l = []) {
		for (let c = 0, d = s.length; c < d; c++) intersect(s[c], this, l, a);
		return l.sort(ascSort), l
	}
}

function ascSort(o, s) {
	return o.distance - s.distance
}

function intersect(o, s, a, l) {
	let c = !0;
	if (o.layers.test(s.layers) && o.raycast(s, a) === !1 && (c = !1), c === !0 && l === !0) {
		const d = o.children;
		for (let f = 0, m = d.length; f < m; f++) intersect(d[f], s, a, !0)
	}
}
class Spherical {
	constructor(s = 1, a = 0, l = 0) {
		this.radius = s, this.phi = a, this.theta = l
	}
	set(s, a, l) {
		return this.radius = s, this.phi = a, this.theta = l, this
	}
	copy(s) {
		return this.radius = s.radius, this.phi = s.phi, this.theta = s.theta, this
	}
	makeSafe() {
		return this.phi = clamp$1(this.phi, 1e-6, Math.PI - 1e-6), this
	}
	setFromVector3(s) {
		return this.setFromCartesianCoords(s.x, s.y, s.z)
	}
	setFromCartesianCoords(s, a, l) {
		return this.radius = Math.sqrt(s * s + a * a + l * l), this.radius === 0 ? (this.theta = 0, this.phi = 0) :
			(this.theta = Math.atan2(s, l), this.phi = Math.acos(clamp$1(a / this.radius, -1, 1))), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
const _startP = new Vector3$1,
	_startEnd = new Vector3$1;
class Line3 {
	constructor(s = new Vector3$1, a = new Vector3$1) {
		this.start = s, this.end = a
	}
	set(s, a) {
		return this.start.copy(s), this.end.copy(a), this
	}
	copy(s) {
		return this.start.copy(s.start), this.end.copy(s.end), this
	}
	getCenter(s) {
		return s.addVectors(this.start, this.end).multiplyScalar(.5)
	}
	delta(s) {
		return s.subVectors(this.end, this.start)
	}
	distanceSq() {
		return this.start.distanceToSquared(this.end)
	}
	distance() {
		return this.start.distanceTo(this.end)
	}
	at(s, a) {
		return this.delta(a).multiplyScalar(s).add(this.start)
	}
	closestPointToPointParameter(s, a) {
		_startP.subVectors(s, this.start), _startEnd.subVectors(this.end, this.start);
		const l = _startEnd.dot(_startEnd);
		let d = _startEnd.dot(_startP) / l;
		return a && (d = clamp$1(d, 0, 1)), d
	}
	closestPointToPoint(s, a, l) {
		const c = this.closestPointToPointParameter(s, a);
		return this.delta(l).multiplyScalar(c).add(this.start)
	}
	applyMatrix4(s) {
		return this.start.applyMatrix4(s), this.end.applyMatrix4(s), this
	}
	equals(s) {
		return s.start.equals(this.start) && s.end.equals(this.end)
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
class Controls extends EventDispatcher {
	constructor(s, a = null) {
		super(), this.object = s, this.domElement = a, this.enabled = !0, this.state = -1, this.keys = {}, this
			.mouseButtons = {
				LEFT: null,
				MIDDLE: null,
				RIGHT: null
			}, this.touches = {
				ONE: null,
				TWO: null
			}
	}
	connect(s) {
		if (s === void 0) {
			console.warn("THREE.Controls: connect() now requires an element.");
			return
		}
		this.domElement !== null && this.disconnect(), this.domElement = s
	}
	disconnect() {}
	dispose() {}
	update() {}
}

function getByteLength(o, s, a, l) {
	const c = getTextureTypeByteLength(l);
	switch (a) {
		case AlphaFormat:
			return o * s;
		case RedFormat:
			return o * s / c.components * c.byteLength;
		case RedIntegerFormat:
			return o * s / c.components * c.byteLength;
		case RGFormat:
			return o * s * 2 / c.components * c.byteLength;
		case RGIntegerFormat:
			return o * s * 2 / c.components * c.byteLength;
		case RGBFormat:
			return o * s * 3 / c.components * c.byteLength;
		case RGBAFormat:
			return o * s * 4 / c.components * c.byteLength;
		case RGBAIntegerFormat:
			return o * s * 4 / c.components * c.byteLength;
		case RGB_S3TC_DXT1_Format:
		case RGBA_S3TC_DXT1_Format:
			return Math.floor((o + 3) / 4) * Math.floor((s + 3) / 4) * 8;
		case RGBA_S3TC_DXT3_Format:
		case RGBA_S3TC_DXT5_Format:
			return Math.floor((o + 3) / 4) * Math.floor((s + 3) / 4) * 16;
		case RGB_PVRTC_2BPPV1_Format:
		case RGBA_PVRTC_2BPPV1_Format:
			return Math.max(o, 16) * Math.max(s, 8) / 4;
		case RGB_PVRTC_4BPPV1_Format:
		case RGBA_PVRTC_4BPPV1_Format:
			return Math.max(o, 8) * Math.max(s, 8) / 2;
		case RGB_ETC1_Format:
		case RGB_ETC2_Format:
			return Math.floor((o + 3) / 4) * Math.floor((s + 3) / 4) * 8;
		case RGBA_ETC2_EAC_Format:
			return Math.floor((o + 3) / 4) * Math.floor((s + 3) / 4) * 16;
		case RGBA_ASTC_4x4_Format:
			return Math.floor((o + 3) / 4) * Math.floor((s + 3) / 4) * 16;
		case RGBA_ASTC_5x4_Format:
			return Math.floor((o + 4) / 5) * Math.floor((s + 3) / 4) * 16;
		case RGBA_ASTC_5x5_Format:
			return Math.floor((o + 4) / 5) * Math.floor((s + 4) / 5) * 16;
		case RGBA_ASTC_6x5_Format:
			return Math.floor((o + 5) / 6) * Math.floor((s + 4) / 5) * 16;
		case RGBA_ASTC_6x6_Format:
			return Math.floor((o + 5) / 6) * Math.floor((s + 5) / 6) * 16;
		case RGBA_ASTC_8x5_Format:
			return Math.floor((o + 7) / 8) * Math.floor((s + 4) / 5) * 16;
		case RGBA_ASTC_8x6_Format:
			return Math.floor((o + 7) / 8) * Math.floor((s + 5) / 6) * 16;
		case RGBA_ASTC_8x8_Format:
			return Math.floor((o + 7) / 8) * Math.floor((s + 7) / 8) * 16;
		case RGBA_ASTC_10x5_Format:
			return Math.floor((o + 9) / 10) * Math.floor((s + 4) / 5) * 16;
		case RGBA_ASTC_10x6_Format:
			return Math.floor((o + 9) / 10) * Math.floor((s + 5) / 6) * 16;
		case RGBA_ASTC_10x8_Format:
			return Math.floor((o + 9) / 10) * Math.floor((s + 7) / 8) * 16;
		case RGBA_ASTC_10x10_Format:
			return Math.floor((o + 9) / 10) * Math.floor((s + 9) / 10) * 16;
		case RGBA_ASTC_12x10_Format:
			return Math.floor((o + 11) / 12) * Math.floor((s + 9) / 10) * 16;
		case RGBA_ASTC_12x12_Format:
			return Math.floor((o + 11) / 12) * Math.floor((s + 11) / 12) * 16;
		case RGBA_BPTC_Format:
		case RGB_BPTC_SIGNED_Format:
		case RGB_BPTC_UNSIGNED_Format:
			return Math.ceil(o / 4) * Math.ceil(s / 4) * 16;
		case RED_RGTC1_Format:
		case SIGNED_RED_RGTC1_Format:
			return Math.ceil(o / 4) * Math.ceil(s / 4) * 8;
		case RED_GREEN_RGTC2_Format:
		case SIGNED_RED_GREEN_RGTC2_Format:
			return Math.ceil(o / 4) * Math.ceil(s / 4) * 16
	}
	throw new Error(`Unable to determine texture byte length for ${a} format.`)
}

function getTextureTypeByteLength(o) {
	switch (o) {
		case UnsignedByteType:
		case ByteType:
			return {
				byteLength: 1, components: 1
			};
		case UnsignedShortType:
		case ShortType:
		case HalfFloatType:
			return {
				byteLength: 2, components: 1
			};
		case UnsignedShort4444Type:
		case UnsignedShort5551Type:
			return {
				byteLength: 2, components: 4
			};
		case UnsignedIntType:
		case IntType:
		case FloatType:
			return {
				byteLength: 4, components: 1
			};
		case UnsignedInt5999Type:
			return {
				byteLength: 4, components: 3
			}
	}
	throw new Error(`Unknown texture type ${o}.`)
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
	detail: {
		revision: REVISION
	}
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") :
	window.__THREE__ = REVISION);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function WebGLAnimation() {
	let o = null,
		s = !1,
		a = null,
		l = null;

	function c(d, f) {
		a(d, f), l = o.requestAnimationFrame(c)
	}
	return {
		start: function() {
			s !== !0 && a !== null && (l = o.requestAnimationFrame(c), s = !0)
		},
		stop: function() {
			o.cancelAnimationFrame(l), s = !1
		},
		setAnimationLoop: function(d) {
			a = d
		},
		setContext: function(d) {
			o = d
		}
	}
}

function WebGLAttributes(o) {
	const s = new WeakMap;

	function a(m, g) {
		const v = m.array,
			y = m.usage,
			b = v.byteLength,
			C = o.createBuffer();
		o.bindBuffer(g, C), o.bufferData(g, v, y), m.onUploadCallback();
		let _;
		if (v instanceof Float32Array) _ = o.FLOAT;
		else if (v instanceof Uint16Array) m.isFloat16BufferAttribute ? _ = o.HALF_FLOAT : _ = o.UNSIGNED_SHORT;
		else if (v instanceof Int16Array) _ = o.SHORT;
		else if (v instanceof Uint32Array) _ = o.UNSIGNED_INT;
		else if (v instanceof Int32Array) _ = o.INT;
		else if (v instanceof Int8Array) _ = o.BYTE;
		else if (v instanceof Uint8Array) _ = o.UNSIGNED_BYTE;
		else if (v instanceof Uint8ClampedArray) _ = o.UNSIGNED_BYTE;
		else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + v);
		return {
			buffer: C,
			type: _,
			bytesPerElement: v.BYTES_PER_ELEMENT,
			version: m.version,
			size: b
		}
	}

	function l(m, g, v) {
		const y = g.array,
			b = g.updateRanges;
		if (o.bindBuffer(v, m), b.length === 0) o.bufferSubData(v, 0, y);
		else {
			b.sort((_, S) => _.start - S.start);
			let C = 0;
			for (let _ = 1; _ < b.length; _++) {
				const S = b[C],
					w = b[_];
				w.start <= S.start + S.count + 1 ? S.count = Math.max(S.count, w.start + w.count - S.start) : (++C, b[
					C] = w)
			}
			b.length = C + 1;
			for (let _ = 0, S = b.length; _ < S; _++) {
				const w = b[_];
				o.bufferSubData(v, w.start * y.BYTES_PER_ELEMENT, y, w.start, w.count)
			}
			g.clearUpdateRanges()
		}
		g.onUploadCallback()
	}

	function c(m) {
		return m.isInterleavedBufferAttribute && (m = m.data), s.get(m)
	}

	function d(m) {
		m.isInterleavedBufferAttribute && (m = m.data);
		const g = s.get(m);
		g && (o.deleteBuffer(g.buffer), s.delete(m))
	}

	function f(m, g) {
		if (m.isInterleavedBufferAttribute && (m = m.data), m.isGLBufferAttribute) {
			const y = s.get(m);
			(!y || y.version < m.version) && s.set(m, {
				buffer: m.buffer,
				type: m.type,
				bytesPerElement: m.elementSize,
				version: m.version
			});
			return
		}
		const v = s.get(m);
		if (v === void 0) s.set(m, a(m, g));
		else if (v.version < m.version) {
			if (v.size !== m.array.byteLength) throw new Error(
				"THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
				);
			l(v.buffer, m, g), v.version = m.version
		}
	}
	return {
		get: c,
		remove: d,
		update: f
	}
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
	alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
	alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
	alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
	alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
	alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
	aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
	aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
	batching_pars_vertex = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
	batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
	begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
	beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
	bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
	iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
	bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
	clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
	clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
	clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
	clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
	color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
	color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
	color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
	color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
	common$1 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
	cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
	defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
	displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
	displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
	emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
	emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
	colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
	colorspace_pars_fragment = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
	envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
	envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
	envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
	envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
	envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
	fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
	fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
	fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
	fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
	gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
	lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
	lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
	lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
	lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
	envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
	lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
	lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
	lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
	lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
	lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
	lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
	lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
	lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
	lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
	logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
	logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
	logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
	logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
	map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
	map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
	map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
	map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
	metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
	metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
	morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
	morphcolor_vertex = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
	morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
	morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
	morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
	normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
	normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
	normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
	normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
	normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
	normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
	clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
	clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
	clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
	iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
	opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
	packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
	premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
	project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
	dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
	dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
	roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
	roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
	shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
	shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
	shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
	shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
	skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
	skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
	skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
	skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
	specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
	specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
	tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
	tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
	transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
	transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
	uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
	uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
	uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
	worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
	fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
	fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
	fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	vertex$e = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
	fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
	vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
	fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
	vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
	fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
	fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
	vertex$a = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
	fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
	fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
	fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
	vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
	fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
	fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
	vertex$2 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
	fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	ShaderChunk = {
		alphahash_fragment,
		alphahash_pars_fragment,
		alphamap_fragment,
		alphamap_pars_fragment,
		alphatest_fragment,
		alphatest_pars_fragment,
		aomap_fragment,
		aomap_pars_fragment,
		batching_pars_vertex,
		batching_vertex,
		begin_vertex,
		beginnormal_vertex,
		bsdfs,
		iridescence_fragment,
		bumpmap_pars_fragment,
		clipping_planes_fragment,
		clipping_planes_pars_fragment,
		clipping_planes_pars_vertex,
		clipping_planes_vertex,
		color_fragment,
		color_pars_fragment,
		color_pars_vertex,
		color_vertex,
		common: common$1,
		cube_uv_reflection_fragment,
		defaultnormal_vertex,
		displacementmap_pars_vertex,
		displacementmap_vertex,
		emissivemap_fragment,
		emissivemap_pars_fragment,
		colorspace_fragment,
		colorspace_pars_fragment,
		envmap_fragment,
		envmap_common_pars_fragment,
		envmap_pars_fragment,
		envmap_pars_vertex,
		envmap_physical_pars_fragment,
		envmap_vertex,
		fog_vertex,
		fog_pars_vertex,
		fog_fragment,
		fog_pars_fragment,
		gradientmap_pars_fragment,
		lightmap_pars_fragment,
		lights_lambert_fragment,
		lights_lambert_pars_fragment,
		lights_pars_begin,
		lights_toon_fragment,
		lights_toon_pars_fragment,
		lights_phong_fragment,
		lights_phong_pars_fragment,
		lights_physical_fragment,
		lights_physical_pars_fragment,
		lights_fragment_begin,
		lights_fragment_maps,
		lights_fragment_end,
		logdepthbuf_fragment,
		logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex,
		logdepthbuf_vertex,
		map_fragment,
		map_pars_fragment,
		map_particle_fragment,
		map_particle_pars_fragment,
		metalnessmap_fragment,
		metalnessmap_pars_fragment,
		morphinstance_vertex,
		morphcolor_vertex,
		morphnormal_vertex,
		morphtarget_pars_vertex,
		morphtarget_vertex,
		normal_fragment_begin,
		normal_fragment_maps,
		normal_pars_fragment,
		normal_pars_vertex,
		normal_vertex,
		normalmap_pars_fragment,
		clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment,
		iridescence_pars_fragment,
		opaque_fragment,
		packing,
		premultiplied_alpha_fragment,
		project_vertex,
		dithering_fragment,
		dithering_pars_fragment,
		roughnessmap_fragment,
		roughnessmap_pars_fragment,
		shadowmap_pars_fragment,
		shadowmap_pars_vertex,
		shadowmap_vertex,
		shadowmask_pars_fragment,
		skinbase_vertex,
		skinning_pars_vertex,
		skinning_vertex,
		skinnormal_vertex,
		specularmap_fragment,
		specularmap_pars_fragment,
		tonemapping_fragment,
		tonemapping_pars_fragment,
		transmission_fragment,
		transmission_pars_fragment,
		uv_pars_fragment,
		uv_pars_vertex,
		uv_vertex,
		worldpos_vertex,
		background_vert: vertex$h,
		background_frag: fragment$h,
		backgroundCube_vert: vertex$g,
		backgroundCube_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	},
	UniformsLib = {
		common: {
			diffuse: {
				value: new Color(16777215)
			},
			opacity: {
				value: 1
			},
			map: {
				value: null
			},
			mapTransform: {
				value: new Matrix3
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new Matrix3
			},
			alphaTest: {
				value: 0
			}
		},
		specularmap: {
			specularMap: {
				value: null
			},
			specularMapTransform: {
				value: new Matrix3
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			envMapRotation: {
				value: new Matrix3
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1
			},
			ior: {
				value: 1.5
			},
			refractionRatio: {
				value: .98
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			},
			aoMapTransform: {
				value: new Matrix3
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			},
			lightMapTransform: {
				value: new Matrix3
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpMapTransform: {
				value: new Matrix3
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalMapTransform: {
				value: new Matrix3
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementMapTransform: {
				value: new Matrix3
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			},
			emissiveMapTransform: {
				value: new Matrix3
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			},
			metalnessMapTransform: {
				value: new Matrix3
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			},
			roughnessMapTransform: {
				value: new Matrix3
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 25e-5
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2e3
			},
			fogColor: {
				value: new Color(16777215)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowIntensity: 1,
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowIntensity: 1,
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotLightMap: {
				value: []
			},
			spotShadowMap: {
				value: []
			},
			spotLightMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowIntensity: 1,
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(16777215)
			},
			opacity: {
				value: 1
			},
			size: {
				value: 1
			},
			scale: {
				value: 1
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new Matrix3
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Matrix3
			}
		},
		sprite: {
			diffuse: {
				value: new Color(16777215)
			},
			opacity: {
				value: 1
			},
			center: {
				value: new Vector2(.5, .5)
			},
			rotation: {
				value: 0
			},
			map: {
				value: null
			},
			mapTransform: {
				value: new Matrix3
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new Matrix3
			},
			alphaTest: {
				value: 0
			}
		}
	},
	ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap,
				UniformsLib.lightmap, UniformsLib.fog
			]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap,
				UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap,
				UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
					emissive: {
						value: new Color(0)
					}
				}
			]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap,
				UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap,
				UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
					emissive: {
						value: new Color(0)
					},
					specular: {
						value: new Color(1118481)
					},
					shininess: {
						value: 30
					}
				}
			]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap,
				UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib
				.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog,
				UniformsLib.lights, {
					emissive: {
						value: new Color(0)
					},
					roughness: {
						value: 1
					},
					metalness: {
						value: 0
					},
					envMapIntensity: {
						value: 1
					}
				}
			]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib
				.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap,
				UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
					emissive: {
						value: new Color(0)
					}
				}
			]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib
				.displacementmap, UniformsLib.fog, {
					matcap: {
						value: null
					}
				}
			]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib
				.displacementmap, {
					opacity: {
						value: 1
					}
				}
			]),
			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3
				},
				t2D: {
					value: null
				},
				backgroundIntensity: {
					value: 1
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},
		backgroundCube: {
			uniforms: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				backgroundBlurriness: {
					value: 0
				},
				backgroundIntensity: {
					value: 1
				},
				backgroundRotation: {
					value: new Matrix3
				}
			},
			vertexShader: ShaderChunk.backgroundCube_vert,
			fragmentShader: ShaderChunk.backgroundCube_frag
		},
		cube: {
			uniforms: {
				tCube: {
					value: null
				},
				tFlip: {
					value: -1
				},
				opacity: {
					value: 1
				}
			},
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3$1
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1e3
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0)
				},
				opacity: {
					value: 1
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
ShaderLib.physical = {
	uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
		clearcoat: {
			value: 0
		},
		clearcoatMap: {
			value: null
		},
		clearcoatMapTransform: {
			value: new Matrix3
		},
		clearcoatNormalMap: {
			value: null
		},
		clearcoatNormalMapTransform: {
			value: new Matrix3
		},
		clearcoatNormalScale: {
			value: new Vector2(1, 1)
		},
		clearcoatRoughness: {
			value: 0
		},
		clearcoatRoughnessMap: {
			value: null
		},
		clearcoatRoughnessMapTransform: {
			value: new Matrix3
		},
		dispersion: {
			value: 0
		},
		iridescence: {
			value: 0
		},
		iridescenceMap: {
			value: null
		},
		iridescenceMapTransform: {
			value: new Matrix3
		},
		iridescenceIOR: {
			value: 1.3
		},
		iridescenceThicknessMinimum: {
			value: 100
		},
		iridescenceThicknessMaximum: {
			value: 400
		},
		iridescenceThicknessMap: {
			value: null
		},
		iridescenceThicknessMapTransform: {
			value: new Matrix3
		},
		sheen: {
			value: 0
		},
		sheenColor: {
			value: new Color(0)
		},
		sheenColorMap: {
			value: null
		},
		sheenColorMapTransform: {
			value: new Matrix3
		},
		sheenRoughness: {
			value: 1
		},
		sheenRoughnessMap: {
			value: null
		},
		sheenRoughnessMapTransform: {
			value: new Matrix3
		},
		transmission: {
			value: 0
		},
		transmissionMap: {
			value: null
		},
		transmissionMapTransform: {
			value: new Matrix3
		},
		transmissionSamplerSize: {
			value: new Vector2
		},
		transmissionSamplerMap: {
			value: null
		},
		thickness: {
			value: 0
		},
		thicknessMap: {
			value: null
		},
		thicknessMapTransform: {
			value: new Matrix3
		},
		attenuationDistance: {
			value: 0
		},
		attenuationColor: {
			value: new Color(0)
		},
		specularColor: {
			value: new Color(1, 1, 1)
		},
		specularColorMap: {
			value: null
		},
		specularColorMapTransform: {
			value: new Matrix3
		},
		specularIntensity: {
			value: 1
		},
		specularIntensityMap: {
			value: null
		},
		specularIntensityMapTransform: {
			value: new Matrix3
		},
		anisotropyVector: {
			value: new Vector2
		},
		anisotropyMap: {
			value: null
		},
		anisotropyMapTransform: {
			value: new Matrix3
		}
	}]),
	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = {
		r: 0,
		b: 0,
		g: 0
	},
	_e1$1 = new Euler,
	_m1$1 = new Matrix4;

function WebGLBackground(o, s, a, l, c, d, f) {
	const m = new Color(0);
	let g = d === !0 ? 0 : 1,
		v, y, b = null,
		C = 0,
		_ = null;

	function S(M) {
		let D = M.isScene === !0 ? M.background : null;
		return D && D.isTexture && (D = (M.backgroundBlurriness > 0 ? a : s).get(D)), D
	}

	function w(M) {
		let D = !1;
		const F = S(M);
		F === null ? A(m, g) : F && F.isColor && (A(F, 1), D = !0);
		const R = o.xr.getEnvironmentBlendMode();
		R === "additive" ? l.buffers.color.setClear(0, 0, 0, 1, f) : R === "alpha-blend" && l.buffers.color.setClear(0,
			0, 0, 0, f), (o.autoClear || D) && (l.buffers.depth.setTest(!0), l.buffers.depth.setMask(!0), l.buffers
			.color.setMask(!0), o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil))
	}

	function T(M, D) {
		const F = S(D);
		F && (F.isCubeTexture || F.mapping === CubeUVReflectionMapping) ? (y === void 0 && (y = new Mesh(
					new BoxGeometry(1, 1, 1), new ShaderMaterial({
						name: "BackgroundCubeMaterial",
						uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
						vertexShader: ShaderLib.backgroundCube.vertexShader,
						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
						side: BackSide,
						depthTest: !1,
						depthWrite: !1,
						fog: !1,
						allowOverride: !1
					})), y.geometry.deleteAttribute("normal"), y.geometry.deleteAttribute("uv"), y.onBeforeRender =
				function(R, O, U) {
					this.matrixWorld.copyPosition(U.matrixWorld)
				}, Object.defineProperty(y.material, "envMap", {
					get: function() {
						return this.uniforms.envMap.value
					}
				}), c.update(y)), _e1$1.copy(D.backgroundRotation), _e1$1.x *= -1, _e1$1.y *= -1, _e1$1.z *= -1, F
			.isCubeTexture && F.isRenderTargetTexture === !1 && (_e1$1.y *= -1, _e1$1.z *= -1), y.material.uniforms
			.envMap.value = F, y.material.uniforms.flipEnvMap.value = F.isCubeTexture && F.isRenderTargetTexture ===
			!1 ? -1 : 1, y.material.uniforms.backgroundBlurriness.value = D.backgroundBlurriness, y.material
			.uniforms.backgroundIntensity.value = D.backgroundIntensity, y.material.uniforms.backgroundRotation
			.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)), y.material.toneMapped = ColorManagement
			.getTransfer(F.colorSpace) !== SRGBTransfer, (b !== F || C !== F.version || _ !== o.toneMapping) && (y
				.material.needsUpdate = !0, b = F, C = F.version, _ = o.toneMapping), y.layers.enableAll(), M
			.unshift(y, y.geometry, y.material, 0, 0, null)) : F && F.isTexture && (v === void 0 && (v = new Mesh(
				new PlaneGeometry(2, 2), new ShaderMaterial({
					name: "BackgroundMaterial",
					uniforms: cloneUniforms(ShaderLib.background.uniforms),
					vertexShader: ShaderLib.background.vertexShader,
					fragmentShader: ShaderLib.background.fragmentShader,
					side: FrontSide,
					depthTest: !1,
					depthWrite: !1,
					fog: !1,
					allowOverride: !1
				})), v.geometry.deleteAttribute("normal"), Object.defineProperty(v.material, "map", {
				get: function() {
					return this.uniforms.t2D.value
				}
			}), c.update(v)), v.material.uniforms.t2D.value = F, v.material.uniforms.backgroundIntensity.value = D
			.backgroundIntensity, v.material.toneMapped = ColorManagement.getTransfer(F.colorSpace) !==
			SRGBTransfer, F.matrixAutoUpdate === !0 && F.updateMatrix(), v.material.uniforms.uvTransform.value.copy(
				F.matrix), (b !== F || C !== F.version || _ !== o.toneMapping) && (v.material.needsUpdate = !0, b =
				F, C = F.version, _ = o.toneMapping), v.layers.enableAll(), M.unshift(v, v.geometry, v.material, 0,
				0, null))
	}

	function A(M, D) {
		M.getRGB(_rgb, getUnlitUniformColorSpace(o)), l.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, D, f)
	}

	function k() {
		y !== void 0 && (y.geometry.dispose(), y.material.dispose(), y = void 0), v !== void 0 && (v.geometry.dispose(),
			v.material.dispose(), v = void 0)
	}
	return {
		getClearColor: function() {
			return m
		},
		setClearColor: function(M, D = 1) {
			m.set(M), g = D, A(m, g)
		},
		getClearAlpha: function() {
			return g
		},
		setClearAlpha: function(M) {
			g = M, A(m, g)
		},
		render: w,
		addToRenderList: T,
		dispose: k
	}
}

function WebGLBindingStates(o, s) {
	const a = o.getParameter(o.MAX_VERTEX_ATTRIBS),
		l = {},
		c = C(null);
	let d = c,
		f = !1;

	function m(z, j, ge, me, he) {
		let ce = !1;
		const ae = b(me, ge, j);
		d !== ae && (d = ae, v(d.object)), ce = _(z, me, ge, he), ce && S(z, me, ge, he), he !== null && s.update(he, o
			.ELEMENT_ARRAY_BUFFER), (ce || f) && (f = !1, D(z, j, ge, me), he !== null && o.bindBuffer(o
			.ELEMENT_ARRAY_BUFFER, s.get(he).buffer))
	}

	function g() {
		return o.createVertexArray()
	}

	function v(z) {
		return o.bindVertexArray(z)
	}

	function y(z) {
		return o.deleteVertexArray(z)
	}

	function b(z, j, ge) {
		const me = ge.wireframe === !0;
		let he = l[z.id];
		he === void 0 && (he = {}, l[z.id] = he);
		let ce = he[j.id];
		ce === void 0 && (ce = {}, he[j.id] = ce);
		let ae = ce[me];
		return ae === void 0 && (ae = C(g()), ce[me] = ae), ae
	}

	function C(z) {
		const j = [],
			ge = [],
			me = [];
		for (let he = 0; he < a; he++) j[he] = 0, ge[he] = 0, me[he] = 0;
		return {
			geometry: null,
			program: null,
			wireframe: !1,
			newAttributes: j,
			enabledAttributes: ge,
			attributeDivisors: me,
			object: z,
			attributes: {},
			index: null
		}
	}

	function _(z, j, ge, me) {
		const he = d.attributes,
			ce = j.attributes;
		let ae = 0;
		const fe = ge.getAttributes();
		for (const q in fe)
			if (fe[q].location >= 0) {
				const de = he[q];
				let _e = ce[q];
				if (_e === void 0 && (q === "instanceMatrix" && z.instanceMatrix && (_e = z.instanceMatrix), q ===
						"instanceColor" && z.instanceColor && (_e = z.instanceColor)), de === void 0 || de.attribute !==
					_e || _e && de.data !== _e.data) return !0;
				ae++
			} return d.attributesNum !== ae || d.index !== me
	}

	function S(z, j, ge, me) {
		const he = {},
			ce = j.attributes;
		let ae = 0;
		const fe = ge.getAttributes();
		for (const q in fe)
			if (fe[q].location >= 0) {
				let de = ce[q];
				de === void 0 && (q === "instanceMatrix" && z.instanceMatrix && (de = z.instanceMatrix), q ===
					"instanceColor" && z.instanceColor && (de = z.instanceColor));
				const _e = {};
				_e.attribute = de, de && de.data && (_e.data = de.data), he[q] = _e, ae++
			} d.attributes = he, d.attributesNum = ae, d.index = me
	}

	function w() {
		const z = d.newAttributes;
		for (let j = 0, ge = z.length; j < ge; j++) z[j] = 0
	}

	function T(z) {
		A(z, 0)
	}

	function A(z, j) {
		const ge = d.newAttributes,
			me = d.enabledAttributes,
			he = d.attributeDivisors;
		ge[z] = 1, me[z] === 0 && (o.enableVertexAttribArray(z), me[z] = 1), he[z] !== j && (o.vertexAttribDivisor(z,
			j), he[z] = j)
	}

	function k() {
		const z = d.newAttributes,
			j = d.enabledAttributes;
		for (let ge = 0, me = j.length; ge < me; ge++) j[ge] !== z[ge] && (o.disableVertexAttribArray(ge), j[ge] = 0)
	}

	function M(z, j, ge, me, he, ce, ae) {
		ae === !0 ? o.vertexAttribIPointer(z, j, ge, he, ce) : o.vertexAttribPointer(z, j, ge, me, he, ce)
	}

	function D(z, j, ge, me) {
		w();
		const he = me.attributes,
			ce = ge.getAttributes(),
			ae = j.defaultAttributeValues;
		for (const fe in ce) {
			const q = ce[fe];
			if (q.location >= 0) {
				let le = he[fe];
				if (le === void 0 && (fe === "instanceMatrix" && z.instanceMatrix && (le = z.instanceMatrix), fe ===
						"instanceColor" && z.instanceColor && (le = z.instanceColor)), le !== void 0) {
					const de = le.normalized,
						_e = le.itemSize,
						ke = s.get(le);
					if (ke === void 0) continue;
					const De = ke.buffer,
						Se = ke.type,
						be = ke.bytesPerElement,
						Me = Se === o.INT || Se === o.UNSIGNED_INT || le.gpuType === IntType;
					if (le.isInterleavedBufferAttribute) {
						const Ve = le.data,
							it = Ve.stride,
							pt = le.offset;
						if (Ve.isInstancedInterleavedBuffer) {
							for (let dt = 0; dt < q.locationSize; dt++) A(q.location + dt, Ve.meshPerAttribute);
							z.isInstancedMesh !== !0 && me._maxInstanceCount === void 0 && (me._maxInstanceCount = Ve
								.meshPerAttribute * Ve.count)
						} else
							for (let dt = 0; dt < q.locationSize; dt++) T(q.location + dt);
						o.bindBuffer(o.ARRAY_BUFFER, De);
						for (let dt = 0; dt < q.locationSize; dt++) M(q.location + dt, _e / q.locationSize, Se, de, it *
							be, (pt + _e / q.locationSize * dt) * be, Me)
					} else {
						if (le.isInstancedBufferAttribute) {
							for (let Ve = 0; Ve < q.locationSize; Ve++) A(q.location + Ve, le.meshPerAttribute);
							z.isInstancedMesh !== !0 && me._maxInstanceCount === void 0 && (me._maxInstanceCount = le
								.meshPerAttribute * le.count)
						} else
							for (let Ve = 0; Ve < q.locationSize; Ve++) T(q.location + Ve);
						o.bindBuffer(o.ARRAY_BUFFER, De);
						for (let Ve = 0; Ve < q.locationSize; Ve++) M(q.location + Ve, _e / q.locationSize, Se, de, _e *
							be, _e / q.locationSize * Ve * be, Me)
					}
				} else if (ae !== void 0) {
					const de = ae[fe];
					if (de !== void 0) switch (de.length) {
						case 2:
							o.vertexAttrib2fv(q.location, de);
							break;
						case 3:
							o.vertexAttrib3fv(q.location, de);
							break;
						case 4:
							o.vertexAttrib4fv(q.location, de);
							break;
						default:
							o.vertexAttrib1fv(q.location, de)
					}
				}
			}
		}
		k()
	}

	function F() {
		U();
		for (const z in l) {
			const j = l[z];
			for (const ge in j) {
				const me = j[ge];
				for (const he in me) y(me[he].object), delete me[he];
				delete j[ge]
			}
			delete l[z]
		}
	}

	function R(z) {
		if (l[z.id] === void 0) return;
		const j = l[z.id];
		for (const ge in j) {
			const me = j[ge];
			for (const he in me) y(me[he].object), delete me[he];
			delete j[ge]
		}
		delete l[z.id]
	}

	function O(z) {
		for (const j in l) {
			const ge = l[j];
			if (ge[z.id] === void 0) continue;
			const me = ge[z.id];
			for (const he in me) y(me[he].object), delete me[he];
			delete ge[z.id]
		}
	}

	function U() {
		V(), f = !0, d !== c && (d = c, v(d.object))
	}

	function V() {
		c.geometry = null, c.program = null, c.wireframe = !1
	}
	return {
		setup: m,
		reset: U,
		resetDefaultState: V,
		dispose: F,
		releaseStatesOfGeometry: R,
		releaseStatesOfProgram: O,
		initAttributes: w,
		enableAttribute: T,
		disableUnusedAttributes: k
	}
}

function WebGLBufferRenderer(o, s, a) {
	let l;

	function c(v) {
		l = v
	}

	function d(v, y) {
		o.drawArrays(l, v, y), a.update(y, l, 1)
	}

	function f(v, y, b) {
		b !== 0 && (o.drawArraysInstanced(l, v, y, b), a.update(y, l, b))
	}

	function m(v, y, b) {
		if (b === 0) return;
		s.get("WEBGL_multi_draw").multiDrawArraysWEBGL(l, v, 0, y, 0, b);
		let _ = 0;
		for (let S = 0; S < b; S++) _ += y[S];
		a.update(_, l, 1)
	}

	function g(v, y, b, C) {
		if (b === 0) return;
		const _ = s.get("WEBGL_multi_draw");
		if (_ === null)
			for (let S = 0; S < v.length; S++) f(v[S], y[S], C[S]);
		else {
			_.multiDrawArraysInstancedWEBGL(l, v, 0, y, 0, C, 0, b);
			let S = 0;
			for (let w = 0; w < b; w++) S += y[w] * C[w];
			a.update(S, l, 1)
		}
	}
	this.setMode = c, this.render = d, this.renderInstances = f, this.renderMultiDraw = m, this
		.renderMultiDrawInstances = g
}

function WebGLCapabilities(o, s, a, l) {
	let c;

	function d() {
		if (c !== void 0) return c;
		if (s.has("EXT_texture_filter_anisotropic") === !0) {
			const O = s.get("EXT_texture_filter_anisotropic");
			c = o.getParameter(O.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
		} else c = 0;
		return c
	}

	function f(O) {
		return !(O !== RGBAFormat && l.convert(O) !== o.getParameter(o.IMPLEMENTATION_COLOR_READ_FORMAT))
	}

	function m(O) {
		const U = O === HalfFloatType && (s.has("EXT_color_buffer_half_float") || s.has("EXT_color_buffer_float"));
		return !(O !== UnsignedByteType && l.convert(O) !== o.getParameter(o.IMPLEMENTATION_COLOR_READ_TYPE) && O !==
			FloatType && !U)
	}

	function g(O) {
		if (O === "highp") {
			if (o.getShaderPrecisionFormat(o.VERTEX_SHADER, o.HIGH_FLOAT).precision > 0 && o.getShaderPrecisionFormat(o
					.FRAGMENT_SHADER, o.HIGH_FLOAT).precision > 0) return "highp";
			O = "mediump"
		}
		return O === "mediump" && o.getShaderPrecisionFormat(o.VERTEX_SHADER, o.MEDIUM_FLOAT).precision > 0 && o
			.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
	}
	let v = a.precision !== void 0 ? a.precision : "highp";
	const y = g(v);
	y !== v && (console.warn("THREE.WebGLRenderer:", v, "not supported, using", y, "instead."), v = y);
	const b = a.logarithmicDepthBuffer === !0,
		C = a.reverseDepthBuffer === !0 && s.has("EXT_clip_control"),
		_ = o.getParameter(o.MAX_TEXTURE_IMAGE_UNITS),
		S = o.getParameter(o.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
		w = o.getParameter(o.MAX_TEXTURE_SIZE),
		T = o.getParameter(o.MAX_CUBE_MAP_TEXTURE_SIZE),
		A = o.getParameter(o.MAX_VERTEX_ATTRIBS),
		k = o.getParameter(o.MAX_VERTEX_UNIFORM_VECTORS),
		M = o.getParameter(o.MAX_VARYING_VECTORS),
		D = o.getParameter(o.MAX_FRAGMENT_UNIFORM_VECTORS),
		F = S > 0,
		R = o.getParameter(o.MAX_SAMPLES);
	return {
		isWebGL2: !0,
		getMaxAnisotropy: d,
		getMaxPrecision: g,
		textureFormatReadable: f,
		textureTypeReadable: m,
		precision: v,
		logarithmicDepthBuffer: b,
		reverseDepthBuffer: C,
		maxTextures: _,
		maxVertexTextures: S,
		maxTextureSize: w,
		maxCubemapSize: T,
		maxAttributes: A,
		maxVertexUniforms: k,
		maxVaryings: M,
		maxFragmentUniforms: D,
		vertexTextures: F,
		maxSamples: R
	}
}

function WebGLClipping(o) {
	const s = this;
	let a = null,
		l = 0,
		c = !1,
		d = !1;
	const f = new Plane,
		m = new Matrix3,
		g = {
			value: null,
			needsUpdate: !1
		};
	this.uniform = g, this.numPlanes = 0, this.numIntersection = 0, this.init = function(b, C) {
		const _ = b.length !== 0 || C || l !== 0 || c;
		return c = C, l = b.length, _
	}, this.beginShadows = function() {
		d = !0, y(null)
	}, this.endShadows = function() {
		d = !1
	}, this.setGlobalState = function(b, C) {
		a = y(b, C, 0)
	}, this.setState = function(b, C, _) {
		const S = b.clippingPlanes,
			w = b.clipIntersection,
			T = b.clipShadows,
			A = o.get(b);
		if (!c || S === null || S.length === 0 || d && !T) d ? y(null) : v();
		else {
			const k = d ? 0 : l,
				M = k * 4;
			let D = A.clippingState || null;
			g.value = D, D = y(S, C, M, _);
			for (let F = 0; F !== M; ++F) D[F] = a[F];
			A.clippingState = D, this.numIntersection = w ? this.numPlanes : 0, this.numPlanes += k
		}
	};

	function v() {
		g.value !== a && (g.value = a, g.needsUpdate = l > 0), s.numPlanes = l, s.numIntersection = 0
	}

	function y(b, C, _, S) {
		const w = b !== null ? b.length : 0;
		let T = null;
		if (w !== 0) {
			if (T = g.value, S !== !0 || T === null) {
				const A = _ + w * 4,
					k = C.matrixWorldInverse;
				m.getNormalMatrix(k), (T === null || T.length < A) && (T = new Float32Array(A));
				for (let M = 0, D = _; M !== w; ++M, D += 4) f.copy(b[M]).applyMatrix4(k, m), f.normal.toArray(T, D), T[
					D + 3] = f.constant
			}
			g.value = T, g.needsUpdate = !0
		}
		return s.numPlanes = w, s.numIntersection = 0, T
	}
}

function WebGLCubeMaps(o) {
	let s = new WeakMap;

	function a(f, m) {
		return m === EquirectangularReflectionMapping ? f.mapping = CubeReflectionMapping : m ===
			EquirectangularRefractionMapping && (f.mapping = CubeRefractionMapping), f
	}

	function l(f) {
		if (f && f.isTexture) {
			const m = f.mapping;
			if (m === EquirectangularReflectionMapping || m === EquirectangularRefractionMapping)
				if (s.has(f)) {
					const g = s.get(f).texture;
					return a(g, f.mapping)
				} else {
					const g = f.image;
					if (g && g.height > 0) {
						const v = new WebGLCubeRenderTarget(g.height);
						return v.fromEquirectangularTexture(o, f), s.set(f, v), f.addEventListener("dispose", c), a(v
							.texture, f.mapping)
					} else return null
				}
		}
		return f
	}

	function c(f) {
		const m = f.target;
		m.removeEventListener("dispose", c);
		const g = s.get(m);
		g !== void 0 && (s.delete(m), g.dispose())
	}

	function d() {
		s = new WeakMap
	}
	return {
		get: l,
		dispose: d
	}
}
const LOD_MIN = 4,
	EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582],
	MAX_SAMPLES = 20,
	_flatCamera = new OrthographicCamera,
	_clearColor = new Color;
let _oldTarget = null,
	_oldActiveCubeFace = 0,
	_oldActiveMipmapLevel = 0,
	_oldXrEnabled = !1;
const PHI = (1 + Math.sqrt(5)) / 2,
	INV_PHI = 1 / PHI,
	_axisDirections = [new Vector3$1(-PHI, INV_PHI, 0), new Vector3$1(PHI, INV_PHI, 0), new Vector3$1(-INV_PHI, 0, PHI),
		new Vector3$1(INV_PHI, 0, PHI), new Vector3$1(0, PHI, -INV_PHI), new Vector3$1(0, PHI, INV_PHI), new Vector3$1(-
			1, 1, -1), new Vector3$1(1, 1, -1), new Vector3$1(-1, 1, 1), new Vector3$1(1, 1, 1)
	],
	_origin = new Vector3$1;
class PMREMGenerator {
	constructor(s) {
		this._renderer = s, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this
			._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this
			._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
	}
	fromScene(s, a = 0, l = .1, c = 100, d = {}) {
		const {
			size: f = 256,
			position: m = _origin
		} = d;
		_oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(),
			_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr
			.enabled, this._renderer.xr.enabled = !1, this._setSize(f);
		const g = this._allocateTargets();
		return g.depthBuffer = !0, this._sceneToCubeUV(s, l, c, g, m), a > 0 && this._blur(g, 0, 0, a), this
			._applyPMREM(g), this._cleanup(g), g
	}
	fromEquirectangular(s, a = null) {
		return this._fromTexture(s, a)
	}
	fromCubemap(s, a = null) {
		return this._fromTexture(s, a)
	}
	compileCubemapShader() {
		this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(), this._compileMaterial(this
			._cubemapMaterial))
	}
	compileEquirectangularShader() {
		this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(), this._compileMaterial(
			this._equirectMaterial))
	}
	dispose() {
		this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this
			._equirectMaterial !== null && this._equirectMaterial.dispose()
	}
	_setSize(s) {
		this._lodMax = Math.floor(Math.log2(s)), this._cubeSize = Math.pow(2, this._lodMax)
	}
	_dispose() {
		this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this
			._pingPongRenderTarget.dispose();
		for (let s = 0; s < this._lodPlanes.length; s++) this._lodPlanes[s].dispose()
	}
	_cleanup(s) {
		this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel), this._renderer.xr
			.enabled = _oldXrEnabled, s.scissorTest = !1, _setViewport(s, 0, 0, s.width, s.height)
	}
	_fromTexture(s, a) {
		s.mapping === CubeReflectionMapping || s.mapping === CubeRefractionMapping ? this._setSize(s.image
				.length === 0 ? 16 : s.image[0].width || s.image[0].image.width) : this._setSize(s.image.width / 4),
			_oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(),
			_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr
			.enabled, this._renderer.xr.enabled = !1;
		const l = a || this._allocateTargets();
		return this._textureToCubeUV(s, l), this._applyPMREM(l), this._cleanup(l), l
	}
	_allocateTargets() {
		const s = 3 * Math.max(this._cubeSize, 112),
			a = 4 * this._cubeSize,
			l = {
				magFilter: LinearFilter,
				minFilter: LinearFilter,
				generateMipmaps: !1,
				type: HalfFloatType,
				format: RGBAFormat,
				colorSpace: LinearSRGBColorSpace,
				depthBuffer: !1
			},
			c = _createRenderTarget(s, a, l);
		if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== s || this
			._pingPongRenderTarget.height !== a) {
			this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget =
				_createRenderTarget(s, a, l);
			const {
				_lodMax: d
			} = this;
			({
				sizeLods: this._sizeLods,
				lodPlanes: this._lodPlanes,
				sigmas: this._sigmas
			} = _createPlanes(d)), this._blurMaterial = _getBlurShader(d, s, a)
		}
		return c
	}
	_compileMaterial(s) {
		const a = new Mesh(this._lodPlanes[0], s);
		this._renderer.compile(a, _flatCamera)
	}
	_sceneToCubeUV(s, a, l, c, d) {
		const g = new PerspectiveCamera(90, 1, a, l),
			v = [1, -1, 1, 1, 1, 1],
			y = [1, 1, 1, -1, -1, -1],
			b = this._renderer,
			C = b.autoClear,
			_ = b.toneMapping;
		b.getClearColor(_clearColor), b.toneMapping = NoToneMapping, b.autoClear = !1;
		const S = new MeshBasicMaterial({
				name: "PMREM.Background",
				side: BackSide,
				depthWrite: !1,
				depthTest: !1
			}),
			w = new Mesh(new BoxGeometry, S);
		let T = !1;
		const A = s.background;
		A ? A.isColor && (S.color.copy(A), s.background = null, T = !0) : (S.color.copy(_clearColor), T = !0);
		for (let k = 0; k < 6; k++) {
			const M = k % 3;
			M === 0 ? (g.up.set(0, v[k], 0), g.position.set(d.x, d.y, d.z), g.lookAt(d.x + y[k], d.y, d.z)) : M ===
				1 ? (g.up.set(0, 0, v[k]), g.position.set(d.x, d.y, d.z), g.lookAt(d.x, d.y + y[k], d.z)) : (g.up
					.set(0, v[k], 0), g.position.set(d.x, d.y, d.z), g.lookAt(d.x, d.y, d.z + y[k]));
			const D = this._cubeSize;
			_setViewport(c, M * D, k > 2 ? D : 0, D, D), b.setRenderTarget(c), T && b.render(w, g), b.render(s, g)
		}
		w.geometry.dispose(), w.material.dispose(), b.toneMapping = _, b.autoClear = C, s.background = A
	}
	_textureToCubeUV(s, a) {
		const l = this._renderer,
			c = s.mapping === CubeReflectionMapping || s.mapping === CubeRefractionMapping;
		c ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()), this
				._cubemapMaterial.uniforms.flipEnvMap.value = s.isRenderTargetTexture === !1 ? -1 : 1) : this
			._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial());
		const d = c ? this._cubemapMaterial : this._equirectMaterial,
			f = new Mesh(this._lodPlanes[0], d),
			m = d.uniforms;
		m.envMap.value = s;
		const g = this._cubeSize;
		_setViewport(a, 0, 0, 3 * g, 2 * g), l.setRenderTarget(a), l.render(f, _flatCamera)
	}
	_applyPMREM(s) {
		const a = this._renderer,
			l = a.autoClear;
		a.autoClear = !1;
		const c = this._lodPlanes.length;
		for (let d = 1; d < c; d++) {
			const f = Math.sqrt(this._sigmas[d] * this._sigmas[d] - this._sigmas[d - 1] * this._sigmas[d - 1]),
				m = _axisDirections[(c - d - 1) % _axisDirections.length];
			this._blur(s, d - 1, d, f, m)
		}
		a.autoClear = l
	}
	_blur(s, a, l, c, d) {
		const f = this._pingPongRenderTarget;
		this._halfBlur(s, f, a, l, c, "latitudinal", d), this._halfBlur(f, s, l, l, c, "longitudinal", d)
	}
	_halfBlur(s, a, l, c, d, f, m) {
		const g = this._renderer,
			v = this._blurMaterial;
		f !== "latitudinal" && f !== "longitudinal" && console.error(
			"blur direction must be either latitudinal or longitudinal!");
		const y = 3,
			b = new Mesh(this._lodPlanes[c], v),
			C = v.uniforms,
			_ = this._sizeLods[l] - 1,
			S = isFinite(d) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * MAX_SAMPLES - 1),
			w = d / S,
			T = isFinite(d) ? 1 + Math.floor(y * w) : MAX_SAMPLES;
		T > MAX_SAMPLES && console.warn(
			`sigmaRadians, ${d}, is too large and will clip, as it requested ${T} samples when the maximum is set to ${MAX_SAMPLES}`
			);
		const A = [];
		let k = 0;
		for (let O = 0; O < MAX_SAMPLES; ++O) {
			const U = O / w,
				V = Math.exp(-U * U / 2);
			A.push(V), O === 0 ? k += V : O < T && (k += 2 * V)
		}
		for (let O = 0; O < A.length; O++) A[O] = A[O] / k;
		C.envMap.value = s.texture, C.samples.value = T, C.weights.value = A, C.latitudinal.value = f ===
			"latitudinal", m && (C.poleAxis.value = m);
		const {
			_lodMax: M
		} = this;
		C.dTheta.value = S, C.mipInt.value = M - l;
		const D = this._sizeLods[c],
			F = 3 * D * (c > M - LOD_MIN ? c - M + LOD_MIN : 0),
			R = 4 * (this._cubeSize - D);
		_setViewport(a, F, R, 3 * D, 2 * D), g.setRenderTarget(a), g.render(b, _flatCamera)
	}
}

function _createPlanes(o) {
	const s = [],
		a = [],
		l = [];
	let c = o;
	const d = o - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
	for (let f = 0; f < d; f++) {
		const m = Math.pow(2, c);
		a.push(m);
		let g = 1 / m;
		f > o - LOD_MIN ? g = EXTRA_LOD_SIGMA[f - o + LOD_MIN - 1] : f === 0 && (g = 0), l.push(g);
		const v = 1 / (m - 2),
			y = -v,
			b = 1 + v,
			C = [y, y, b, y, b, b, y, y, b, b, y, b],
			_ = 6,
			S = 6,
			w = 3,
			T = 2,
			A = 1,
			k = new Float32Array(w * S * _),
			M = new Float32Array(T * S * _),
			D = new Float32Array(A * S * _);
		for (let R = 0; R < _; R++) {
			const O = R % 3 * 2 / 3 - 1,
				U = R > 2 ? 0 : -1,
				V = [O, U, 0, O + 2 / 3, U, 0, O + 2 / 3, U + 1, 0, O, U, 0, O + 2 / 3, U + 1, 0, O, U + 1, 0];
			k.set(V, w * S * R), M.set(C, T * S * R);
			const z = [R, R, R, R, R, R];
			D.set(z, A * S * R)
		}
		const F = new BufferGeometry;
		F.setAttribute("position", new BufferAttribute(k, w)), F.setAttribute("uv", new BufferAttribute(M, T)), F
			.setAttribute("faceIndex", new BufferAttribute(D, A)), s.push(F), c > LOD_MIN && c--
	}
	return {
		lodPlanes: s,
		sizeLods: a,
		sigmas: l
	}
}

function _createRenderTarget(o, s, a) {
	const l = new WebGLRenderTarget(o, s, a);
	return l.texture.mapping = CubeUVReflectionMapping, l.texture.name = "PMREM.cubeUv", l.scissorTest = !0, l
}

function _setViewport(o, s, a, l, c) {
	o.viewport.set(s, a, l, c), o.scissor.set(s, a, l, c)
}

function _getBlurShader(o, s, a) {
	const l = new Float32Array(MAX_SAMPLES),
		c = new Vector3$1(0, 1, 0);
	return new ShaderMaterial({
		name: "SphericalGaussianBlur",
		defines: {
			n: MAX_SAMPLES,
			CUBEUV_TEXEL_WIDTH: 1 / s,
			CUBEUV_TEXEL_HEIGHT: 1 / a,
			CUBEUV_MAX_MIP: `${o}.0`
		},
		uniforms: {
			envMap: {
				value: null
			},
			samples: {
				value: 1
			},
			weights: {
				value: l
			},
			latitudinal: {
				value: !1
			},
			dTheta: {
				value: 0
			},
			mipInt: {
				value: 0
			},
			poleAxis: {
				value: c
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
		blending: NoBlending,
		depthTest: !1,
		depthWrite: !1
	})
}

function _getEquirectMaterial() {
	return new ShaderMaterial({
		name: "EquirectangularToCubeUV",
		uniforms: {
			envMap: {
				value: null
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
		blending: NoBlending,
		depthTest: !1,
		depthWrite: !1
	})
}

function _getCubemapMaterial() {
	return new ShaderMaterial({
		name: "CubemapToCubeUV",
		uniforms: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
		blending: NoBlending,
		depthTest: !1,
		depthWrite: !1
	})
}

function _getCommonVertexShader() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function WebGLCubeUVMaps(o) {
	let s = new WeakMap,
		a = null;

	function l(m) {
		if (m && m.isTexture) {
			const g = m.mapping,
				v = g === EquirectangularReflectionMapping || g === EquirectangularRefractionMapping,
				y = g === CubeReflectionMapping || g === CubeRefractionMapping;
			if (v || y) {
				let b = s.get(m);
				const C = b !== void 0 ? b.texture.pmremVersion : 0;
				if (m.isRenderTargetTexture && m.pmremVersion !== C) return a === null && (a = new PMREMGenerator(o)),
					b = v ? a.fromEquirectangular(m, b) : a.fromCubemap(m, b), b.texture.pmremVersion = m
					.pmremVersion, s.set(m, b), b.texture;
				if (b !== void 0) return b.texture; {
					const _ = m.image;
					return v && _ && _.height > 0 || y && _ && c(_) ? (a === null && (a = new PMREMGenerator(o)), b =
						v ? a.fromEquirectangular(m) : a.fromCubemap(m), b.texture.pmremVersion = m.pmremVersion, s
						.set(m, b), m.addEventListener("dispose", d), b.texture) : null
				}
			}
		}
		return m
	}

	function c(m) {
		let g = 0;
		const v = 6;
		for (let y = 0; y < v; y++) m[y] !== void 0 && g++;
		return g === v
	}

	function d(m) {
		const g = m.target;
		g.removeEventListener("dispose", d);
		const v = s.get(g);
		v !== void 0 && (s.delete(g), v.dispose())
	}

	function f() {
		s = new WeakMap, a !== null && (a.dispose(), a = null)
	}
	return {
		get: l,
		dispose: f
	}
}

function WebGLExtensions(o) {
	const s = {};

	function a(l) {
		if (s[l] !== void 0) return s[l];
		let c;
		switch (l) {
			case "WEBGL_depth_texture":
				c = o.getExtension("WEBGL_depth_texture") || o.getExtension("MOZ_WEBGL_depth_texture") || o
					.getExtension("WEBKIT_WEBGL_depth_texture");
				break;
			case "EXT_texture_filter_anisotropic":
				c = o.getExtension("EXT_texture_filter_anisotropic") || o.getExtension(
					"MOZ_EXT_texture_filter_anisotropic") || o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
				break;
			case "WEBGL_compressed_texture_s3tc":
				c = o.getExtension("WEBGL_compressed_texture_s3tc") || o.getExtension(
					"MOZ_WEBGL_compressed_texture_s3tc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
				break;
			case "WEBGL_compressed_texture_pvrtc":
				c = o.getExtension("WEBGL_compressed_texture_pvrtc") || o.getExtension(
					"WEBKIT_WEBGL_compressed_texture_pvrtc");
				break;
			default:
				c = o.getExtension(l)
		}
		return s[l] = c, c
	}
	return {
		has: function(l) {
			return a(l) !== null
		},
		init: function() {
			a("EXT_color_buffer_float"), a("WEBGL_clip_cull_distance"), a("OES_texture_float_linear"), a(
				"EXT_color_buffer_half_float"), a("WEBGL_multisampled_render_to_texture"), a(
				"WEBGL_render_shared_exponent")
		},
		get: function(l) {
			const c = a(l);
			return c === null && warnOnce("THREE.WebGLRenderer: " + l + " extension not supported."), c
		}
	}
}

function WebGLGeometries(o, s, a, l) {
	const c = {},
		d = new WeakMap;

	function f(b) {
		const C = b.target;
		C.index !== null && s.remove(C.index);
		for (const S in C.attributes) s.remove(C.attributes[S]);
		C.removeEventListener("dispose", f), delete c[C.id];
		const _ = d.get(C);
		_ && (s.remove(_), d.delete(C)), l.releaseStatesOfGeometry(C), C.isInstancedBufferGeometry === !0 && delete C
			._maxInstanceCount, a.memory.geometries--
	}

	function m(b, C) {
		return c[C.id] === !0 || (C.addEventListener("dispose", f), c[C.id] = !0, a.memory.geometries++), C
	}

	function g(b) {
		const C = b.attributes;
		for (const _ in C) s.update(C[_], o.ARRAY_BUFFER)
	}

	function v(b) {
		const C = [],
			_ = b.index,
			S = b.attributes.position;
		let w = 0;
		if (_ !== null) {
			const k = _.array;
			w = _.version;
			for (let M = 0, D = k.length; M < D; M += 3) {
				const F = k[M + 0],
					R = k[M + 1],
					O = k[M + 2];
				C.push(F, R, R, O, O, F)
			}
		} else if (S !== void 0) {
			const k = S.array;
			w = S.version;
			for (let M = 0, D = k.length / 3 - 1; M < D; M += 3) {
				const F = M + 0,
					R = M + 1,
					O = M + 2;
				C.push(F, R, R, O, O, F)
			}
		} else return;
		const T = new(arrayNeedsUint32(C) ? Uint32BufferAttribute : Uint16BufferAttribute)(C, 1);
		T.version = w;
		const A = d.get(b);
		A && s.remove(A), d.set(b, T)
	}

	function y(b) {
		const C = d.get(b);
		if (C) {
			const _ = b.index;
			_ !== null && C.version < _.version && v(b)
		} else v(b);
		return d.get(b)
	}
	return {
		get: m,
		update: g,
		getWireframeAttribute: y
	}
}

function WebGLIndexedBufferRenderer(o, s, a) {
	let l;

	function c(C) {
		l = C
	}
	let d, f;

	function m(C) {
		d = C.type, f = C.bytesPerElement
	}

	function g(C, _) {
		o.drawElements(l, _, d, C * f), a.update(_, l, 1)
	}

	function v(C, _, S) {
		S !== 0 && (o.drawElementsInstanced(l, _, d, C * f, S), a.update(_, l, S))
	}

	function y(C, _, S) {
		if (S === 0) return;
		s.get("WEBGL_multi_draw").multiDrawElementsWEBGL(l, _, 0, d, C, 0, S);
		let T = 0;
		for (let A = 0; A < S; A++) T += _[A];
		a.update(T, l, 1)
	}

	function b(C, _, S, w) {
		if (S === 0) return;
		const T = s.get("WEBGL_multi_draw");
		if (T === null)
			for (let A = 0; A < C.length; A++) v(C[A] / f, _[A], w[A]);
		else {
			T.multiDrawElementsInstancedWEBGL(l, _, 0, d, C, 0, w, 0, S);
			let A = 0;
			for (let k = 0; k < S; k++) A += _[k] * w[k];
			a.update(A, l, 1)
		}
	}
	this.setMode = c, this.setIndex = m, this.render = g, this.renderInstances = v, this.renderMultiDraw = y, this
		.renderMultiDrawInstances = b
}

function WebGLInfo(o) {
	const s = {
			geometries: 0,
			textures: 0
		},
		a = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

	function l(d, f, m) {
		switch (a.calls++, f) {
			case o.TRIANGLES:
				a.triangles += m * (d / 3);
				break;
			case o.LINES:
				a.lines += m * (d / 2);
				break;
			case o.LINE_STRIP:
				a.lines += m * (d - 1);
				break;
			case o.LINE_LOOP:
				a.lines += m * d;
				break;
			case o.POINTS:
				a.points += m * d;
				break;
			default:
				console.error("THREE.WebGLInfo: Unknown draw mode:", f);
				break
		}
	}

	function c() {
		a.calls = 0, a.triangles = 0, a.points = 0, a.lines = 0
	}
	return {
		memory: s,
		render: a,
		programs: null,
		autoReset: !0,
		reset: c,
		update: l
	}
}

function WebGLMorphtargets(o, s, a) {
	const l = new WeakMap,
		c = new Vector4;

	function d(f, m, g) {
		const v = f.morphTargetInfluences,
			y = m.morphAttributes.position || m.morphAttributes.normal || m.morphAttributes.color,
			b = y !== void 0 ? y.length : 0;
		let C = l.get(m);
		if (C === void 0 || C.count !== b) {
			let V = function() {
				O.dispose(), l.delete(m), m.removeEventListener("dispose", V)
			};
			C !== void 0 && C.texture.dispose();
			const _ = m.morphAttributes.position !== void 0,
				S = m.morphAttributes.normal !== void 0,
				w = m.morphAttributes.color !== void 0,
				T = m.morphAttributes.position || [],
				A = m.morphAttributes.normal || [],
				k = m.morphAttributes.color || [];
			let M = 0;
			_ === !0 && (M = 1), S === !0 && (M = 2), w === !0 && (M = 3);
			let D = m.attributes.position.count * M,
				F = 1;
			D > s.maxTextureSize && (F = Math.ceil(D / s.maxTextureSize), D = s.maxTextureSize);
			const R = new Float32Array(D * F * 4 * b),
				O = new DataArrayTexture(R, D, F, b);
			O.type = FloatType, O.needsUpdate = !0;
			const U = M * 4;
			for (let z = 0; z < b; z++) {
				const j = T[z],
					ge = A[z],
					me = k[z],
					he = D * F * 4 * z;
				for (let ce = 0; ce < j.count; ce++) {
					const ae = ce * U;
					_ === !0 && (c.fromBufferAttribute(j, ce), R[he + ae + 0] = c.x, R[he + ae + 1] = c.y, R[he + ae +
						2] = c.z, R[he + ae + 3] = 0), S === !0 && (c.fromBufferAttribute(ge, ce), R[he + ae + 4] =
						c.x, R[he + ae + 5] = c.y, R[he + ae + 6] = c.z, R[he + ae + 7] = 0), w === !0 && (c
						.fromBufferAttribute(me, ce), R[he + ae + 8] = c.x, R[he + ae + 9] = c.y, R[he + ae + 10] =
						c.z, R[he + ae + 11] = me.itemSize === 4 ? c.w : 1)
				}
			}
			C = {
				count: b,
				texture: O,
				size: new Vector2(D, F)
			}, l.set(m, C), m.addEventListener("dispose", V)
		}
		if (f.isInstancedMesh === !0 && f.morphTexture !== null) g.getUniforms().setValue(o, "morphTexture", f
			.morphTexture, a);
		else {
			let _ = 0;
			for (let w = 0; w < v.length; w++) _ += v[w];
			const S = m.morphTargetsRelative ? 1 : 1 - _;
			g.getUniforms().setValue(o, "morphTargetBaseInfluence", S), g.getUniforms().setValue(o,
				"morphTargetInfluences", v)
		}
		g.getUniforms().setValue(o, "morphTargetsTexture", C.texture, a), g.getUniforms().setValue(o,
			"morphTargetsTextureSize", C.size)
	}
	return {
		update: d
	}
}

function WebGLObjects(o, s, a, l) {
	let c = new WeakMap;

	function d(g) {
		const v = l.render.frame,
			y = g.geometry,
			b = s.get(g, y);
		if (c.get(b) !== v && (s.update(b), c.set(b, v)), g.isInstancedMesh && (g.hasEventListener("dispose", m) === !
				1 && g.addEventListener("dispose", m), c.get(g) !== v && (a.update(g.instanceMatrix, o.ARRAY_BUFFER), g
					.instanceColor !== null && a.update(g.instanceColor, o.ARRAY_BUFFER), c.set(g, v))), g
			.isSkinnedMesh) {
			const C = g.skeleton;
			c.get(C) !== v && (C.update(), c.set(C, v))
		}
		return b
	}

	function f() {
		c = new WeakMap
	}

	function m(g) {
		const v = g.target;
		v.removeEventListener("dispose", m), a.remove(v.instanceMatrix), v.instanceColor !== null && a.remove(v
			.instanceColor)
	}
	return {
		update: d,
		dispose: f
	}
}
const emptyTexture = new Texture,
	emptyShadowTexture = new DepthTexture(1, 1),
	emptyArrayTexture = new DataArrayTexture,
	empty3dTexture = new Data3DTexture,
	emptyCubeTexture = new CubeTexture,
	arrayCacheF32 = [],
	arrayCacheI32 = [],
	mat4array = new Float32Array(16),
	mat3array = new Float32Array(9),
	mat2array = new Float32Array(4);

function flatten$1(o, s, a) {
	const l = o[0];
	if (l <= 0 || l > 0) return o;
	const c = s * a;
	let d = arrayCacheF32[c];
	if (d === void 0 && (d = new Float32Array(c), arrayCacheF32[c] = d), s !== 0) {
		l.toArray(d, 0);
		for (let f = 1, m = 0; f !== s; ++f) m += a, o[f].toArray(d, m)
	}
	return d
}

function arraysEqual(o, s) {
	if (o.length !== s.length) return !1;
	for (let a = 0, l = o.length; a < l; a++)
		if (o[a] !== s[a]) return !1;
	return !0
}

function copyArray(o, s) {
	for (let a = 0, l = s.length; a < l; a++) o[a] = s[a]
}

function allocTexUnits(o, s) {
	let a = arrayCacheI32[s];
	a === void 0 && (a = new Int32Array(s), arrayCacheI32[s] = a);
	for (let l = 0; l !== s; ++l) a[l] = o.allocateTextureUnit();
	return a
}

function setValueV1f(o, s) {
	const a = this.cache;
	a[0] !== s && (o.uniform1f(this.addr, s), a[0] = s)
}

function setValueV2f(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y) && (o.uniform2f(this.addr, s.x, s.y), a[0] = s.x, a[1] = s.y);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform2fv(this.addr, s), copyArray(a, s)
	}
}

function setValueV3f(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y || a[2] !== s.z) && (o.uniform3f(this.addr, s.x, s.y, s.z), a[0] =
		s.x, a[1] = s.y, a[2] = s.z);
	else if (s.r !== void 0)(a[0] !== s.r || a[1] !== s.g || a[2] !== s.b) && (o.uniform3f(this.addr, s.r, s.g, s.b), a[
		0] = s.r, a[1] = s.g, a[2] = s.b);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform3fv(this.addr, s), copyArray(a, s)
	}
}

function setValueV4f(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y || a[2] !== s.z || a[3] !== s.w) && (o.uniform4f(this.addr, s.x, s
		.y, s.z, s.w), a[0] = s.x, a[1] = s.y, a[2] = s.z, a[3] = s.w);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform4fv(this.addr, s), copyArray(a, s)
	}
}

function setValueM2(o, s) {
	const a = this.cache,
		l = s.elements;
	if (l === void 0) {
		if (arraysEqual(a, s)) return;
		o.uniformMatrix2fv(this.addr, !1, s), copyArray(a, s)
	} else {
		if (arraysEqual(a, l)) return;
		mat2array.set(l), o.uniformMatrix2fv(this.addr, !1, mat2array), copyArray(a, l)
	}
}

function setValueM3(o, s) {
	const a = this.cache,
		l = s.elements;
	if (l === void 0) {
		if (arraysEqual(a, s)) return;
		o.uniformMatrix3fv(this.addr, !1, s), copyArray(a, s)
	} else {
		if (arraysEqual(a, l)) return;
		mat3array.set(l), o.uniformMatrix3fv(this.addr, !1, mat3array), copyArray(a, l)
	}
}

function setValueM4(o, s) {
	const a = this.cache,
		l = s.elements;
	if (l === void 0) {
		if (arraysEqual(a, s)) return;
		o.uniformMatrix4fv(this.addr, !1, s), copyArray(a, s)
	} else {
		if (arraysEqual(a, l)) return;
		mat4array.set(l), o.uniformMatrix4fv(this.addr, !1, mat4array), copyArray(a, l)
	}
}

function setValueV1i(o, s) {
	const a = this.cache;
	a[0] !== s && (o.uniform1i(this.addr, s), a[0] = s)
}

function setValueV2i(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y) && (o.uniform2i(this.addr, s.x, s.y), a[0] = s.x, a[1] = s.y);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform2iv(this.addr, s), copyArray(a, s)
	}
}

function setValueV3i(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y || a[2] !== s.z) && (o.uniform3i(this.addr, s.x, s.y, s.z), a[0] =
		s.x, a[1] = s.y, a[2] = s.z);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform3iv(this.addr, s), copyArray(a, s)
	}
}

function setValueV4i(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y || a[2] !== s.z || a[3] !== s.w) && (o.uniform4i(this.addr, s.x, s
		.y, s.z, s.w), a[0] = s.x, a[1] = s.y, a[2] = s.z, a[3] = s.w);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform4iv(this.addr, s), copyArray(a, s)
	}
}

function setValueV1ui(o, s) {
	const a = this.cache;
	a[0] !== s && (o.uniform1ui(this.addr, s), a[0] = s)
}

function setValueV2ui(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y) && (o.uniform2ui(this.addr, s.x, s.y), a[0] = s.x, a[1] = s.y);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform2uiv(this.addr, s), copyArray(a, s)
	}
}

function setValueV3ui(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y || a[2] !== s.z) && (o.uniform3ui(this.addr, s.x, s.y, s.z), a[0] =
		s.x, a[1] = s.y, a[2] = s.z);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform3uiv(this.addr, s), copyArray(a, s)
	}
}

function setValueV4ui(o, s) {
	const a = this.cache;
	if (s.x !== void 0)(a[0] !== s.x || a[1] !== s.y || a[2] !== s.z || a[3] !== s.w) && (o.uniform4ui(this.addr, s.x, s
		.y, s.z, s.w), a[0] = s.x, a[1] = s.y, a[2] = s.z, a[3] = s.w);
	else {
		if (arraysEqual(a, s)) return;
		o.uniform4uiv(this.addr, s), copyArray(a, s)
	}
}

function setValueT1(o, s, a) {
	const l = this.cache,
		c = a.allocateTextureUnit();
	l[0] !== c && (o.uniform1i(this.addr, c), l[0] = c);
	let d;
	this.type === o.SAMPLER_2D_SHADOW ? (emptyShadowTexture.compareFunction = LessEqualCompare, d =
		emptyShadowTexture) : d = emptyTexture, a.setTexture2D(s || d, c)
}

function setValueT3D1(o, s, a) {
	const l = this.cache,
		c = a.allocateTextureUnit();
	l[0] !== c && (o.uniform1i(this.addr, c), l[0] = c), a.setTexture3D(s || empty3dTexture, c)
}

function setValueT6(o, s, a) {
	const l = this.cache,
		c = a.allocateTextureUnit();
	l[0] !== c && (o.uniform1i(this.addr, c), l[0] = c), a.setTextureCube(s || emptyCubeTexture, c)
}

function setValueT2DArray1(o, s, a) {
	const l = this.cache,
		c = a.allocateTextureUnit();
	l[0] !== c && (o.uniform1i(this.addr, c), l[0] = c), a.setTexture2DArray(s || emptyArrayTexture, c)
}

function getSingularSetter(o) {
	switch (o) {
		case 5126:
			return setValueV1f;
		case 35664:
			return setValueV2f;
		case 35665:
			return setValueV3f;
		case 35666:
			return setValueV4f;
		case 35674:
			return setValueM2;
		case 35675:
			return setValueM3;
		case 35676:
			return setValueM4;
		case 5124:
		case 35670:
			return setValueV1i;
		case 35667:
		case 35671:
			return setValueV2i;
		case 35668:
		case 35672:
			return setValueV3i;
		case 35669:
		case 35673:
			return setValueV4i;
		case 5125:
			return setValueV1ui;
		case 36294:
			return setValueV2ui;
		case 36295:
			return setValueV3ui;
		case 36296:
			return setValueV4ui;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682:
			return setValueT1;
		case 35679:
		case 36299:
		case 36307:
			return setValueT3D1;
		case 35680:
		case 36300:
		case 36308:
		case 36293:
			return setValueT6;
		case 36289:
		case 36303:
		case 36311:
		case 36292:
			return setValueT2DArray1
	}
}

function setValueV1fArray(o, s) {
	o.uniform1fv(this.addr, s)
}

function setValueV2fArray(o, s) {
	const a = flatten$1(s, this.size, 2);
	o.uniform2fv(this.addr, a)
}

function setValueV3fArray(o, s) {
	const a = flatten$1(s, this.size, 3);
	o.uniform3fv(this.addr, a)
}

function setValueV4fArray(o, s) {
	const a = flatten$1(s, this.size, 4);
	o.uniform4fv(this.addr, a)
}

function setValueM2Array(o, s) {
	const a = flatten$1(s, this.size, 4);
	o.uniformMatrix2fv(this.addr, !1, a)
}

function setValueM3Array(o, s) {
	const a = flatten$1(s, this.size, 9);
	o.uniformMatrix3fv(this.addr, !1, a)
}

function setValueM4Array(o, s) {
	const a = flatten$1(s, this.size, 16);
	o.uniformMatrix4fv(this.addr, !1, a)
}

function setValueV1iArray(o, s) {
	o.uniform1iv(this.addr, s)
}

function setValueV2iArray(o, s) {
	o.uniform2iv(this.addr, s)
}

function setValueV3iArray(o, s) {
	o.uniform3iv(this.addr, s)
}

function setValueV4iArray(o, s) {
	o.uniform4iv(this.addr, s)
}

function setValueV1uiArray(o, s) {
	o.uniform1uiv(this.addr, s)
}

function setValueV2uiArray(o, s) {
	o.uniform2uiv(this.addr, s)
}

function setValueV3uiArray(o, s) {
	o.uniform3uiv(this.addr, s)
}

function setValueV4uiArray(o, s) {
	o.uniform4uiv(this.addr, s)
}

function setValueT1Array(o, s, a) {
	const l = this.cache,
		c = s.length,
		d = allocTexUnits(a, c);
	arraysEqual(l, d) || (o.uniform1iv(this.addr, d), copyArray(l, d));
	for (let f = 0; f !== c; ++f) a.setTexture2D(s[f] || emptyTexture, d[f])
}

function setValueT3DArray(o, s, a) {
	const l = this.cache,
		c = s.length,
		d = allocTexUnits(a, c);
	arraysEqual(l, d) || (o.uniform1iv(this.addr, d), copyArray(l, d));
	for (let f = 0; f !== c; ++f) a.setTexture3D(s[f] || empty3dTexture, d[f])
}

function setValueT6Array(o, s, a) {
	const l = this.cache,
		c = s.length,
		d = allocTexUnits(a, c);
	arraysEqual(l, d) || (o.uniform1iv(this.addr, d), copyArray(l, d));
	for (let f = 0; f !== c; ++f) a.setTextureCube(s[f] || emptyCubeTexture, d[f])
}

function setValueT2DArrayArray(o, s, a) {
	const l = this.cache,
		c = s.length,
		d = allocTexUnits(a, c);
	arraysEqual(l, d) || (o.uniform1iv(this.addr, d), copyArray(l, d));
	for (let f = 0; f !== c; ++f) a.setTexture2DArray(s[f] || emptyArrayTexture, d[f])
}

function getPureArraySetter(o) {
	switch (o) {
		case 5126:
			return setValueV1fArray;
		case 35664:
			return setValueV2fArray;
		case 35665:
			return setValueV3fArray;
		case 35666:
			return setValueV4fArray;
		case 35674:
			return setValueM2Array;
		case 35675:
			return setValueM3Array;
		case 35676:
			return setValueM4Array;
		case 5124:
		case 35670:
			return setValueV1iArray;
		case 35667:
		case 35671:
			return setValueV2iArray;
		case 35668:
		case 35672:
			return setValueV3iArray;
		case 35669:
		case 35673:
			return setValueV4iArray;
		case 5125:
			return setValueV1uiArray;
		case 36294:
			return setValueV2uiArray;
		case 36295:
			return setValueV3uiArray;
		case 36296:
			return setValueV4uiArray;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682:
			return setValueT1Array;
		case 35679:
		case 36299:
		case 36307:
			return setValueT3DArray;
		case 35680:
		case 36300:
		case 36308:
		case 36293:
			return setValueT6Array;
		case 36289:
		case 36303:
		case 36311:
		case 36292:
			return setValueT2DArrayArray
	}
}
class SingleUniform {
	constructor(s, a, l) {
		this.id = s, this.addr = l, this.cache = [], this.type = a.type, this.setValue = getSingularSetter(a.type)
	}
}
class PureArrayUniform {
	constructor(s, a, l) {
		this.id = s, this.addr = l, this.cache = [], this.type = a.type, this.size = a.size, this.setValue =
			getPureArraySetter(a.type)
	}
}
class StructuredUniform {
	constructor(s) {
		this.id = s, this.seq = [], this.map = {}
	}
	setValue(s, a, l) {
		const c = this.seq;
		for (let d = 0, f = c.length; d !== f; ++d) {
			const m = c[d];
			m.setValue(s, a[m.id], l)
		}
	}
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;

function addUniform(o, s) {
	o.seq.push(s), o.map[s.id] = s
}

function parseUniform(o, s, a) {
	const l = o.name,
		c = l.length;
	for (RePathPart.lastIndex = 0;;) {
		const d = RePathPart.exec(l),
			f = RePathPart.lastIndex;
		let m = d[1];
		const g = d[2] === "]",
			v = d[3];
		if (g && (m = m | 0), v === void 0 || v === "[" && f + 2 === c) {
			addUniform(a, v === void 0 ? new SingleUniform(m, o, s) : new PureArrayUniform(m, o, s));
			break
		} else {
			let b = a.map[m];
			b === void 0 && (b = new StructuredUniform(m), addUniform(a, b)), a = b
		}
	}
}
class WebGLUniforms {
	constructor(s, a) {
		this.seq = [], this.map = {};
		const l = s.getProgramParameter(a, s.ACTIVE_UNIFORMS);
		for (let c = 0; c < l; ++c) {
			const d = s.getActiveUniform(a, c),
				f = s.getUniformLocation(a, d.name);
			parseUniform(d, f, this)
		}
	}
	setValue(s, a, l, c) {
		const d = this.map[a];
		d !== void 0 && d.setValue(s, l, c)
	}
	setOptional(s, a, l) {
		const c = a[l];
		c !== void 0 && this.setValue(s, l, c)
	}
	static upload(s, a, l, c) {
		for (let d = 0, f = a.length; d !== f; ++d) {
			const m = a[d],
				g = l[m.id];
			g.needsUpdate !== !1 && m.setValue(s, g.value, c)
		}
	}
	static seqWithValue(s, a) {
		const l = [];
		for (let c = 0, d = s.length; c !== d; ++c) {
			const f = s[c];
			f.id in a && l.push(f)
		}
		return l
	}
}

function WebGLShader(o, s, a) {
	const l = o.createShader(s);
	return o.shaderSource(l, a), o.compileShader(l), l
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;

function handleSource(o, s) {
	const a = o.split(`
`),
		l = [],
		c = Math.max(s - 6, 0),
		d = Math.min(s + 6, a.length);
	for (let f = c; f < d; f++) {
		const m = f + 1;
		l.push(`${m===s?">":" "} ${m}: ${a[f]}`)
	}
	return l.join(`
`)
}
const _m0 = new Matrix3;

function getEncodingComponents(o) {
	ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, o);
	const s = `mat3( ${_m0.elements.map(a=>a.toFixed(4))} )`;
	switch (ColorManagement.getTransfer(o)) {
		case LinearTransfer:
			return [s, "LinearTransferOETF"];
		case SRGBTransfer:
			return [s, "sRGBTransferOETF"];
		default:
			return console.warn("THREE.WebGLProgram: Unsupported color space: ", o), [s, "LinearTransferOETF"]
	}
}

function getShaderErrors(o, s, a) {
	const l = o.getShaderParameter(s, o.COMPILE_STATUS),
		c = o.getShaderInfoLog(s).trim();
	if (l && c === "") return "";
	const d = /ERROR: 0:(\d+)/.exec(c);
	if (d) {
		const f = parseInt(d[1]);
		return a.toUpperCase() + `

` + c + `

` + handleSource(o.getShaderSource(s), f)
	} else return c
}

function getTexelEncodingFunction(o, s) {
	const a = getEncodingComponents(s);
	return [`vec4 ${o}( vec4 value ) {`, `	return ${a[1]}( vec4( value.rgb * ${a[0]}, value.a ) );`, "}"].join(`
`)
}

function getToneMappingFunction(o, s) {
	let a;
	switch (s) {
		case LinearToneMapping:
			a = "Linear";
			break;
		case ReinhardToneMapping:
			a = "Reinhard";
			break;
		case CineonToneMapping:
			a = "Cineon";
			break;
		case ACESFilmicToneMapping:
			a = "ACESFilmic";
			break;
		case AgXToneMapping:
			a = "AgX";
			break;
		case NeutralToneMapping:
			a = "Neutral";
			break;
		case CustomToneMapping:
			a = "Custom";
			break;
		default:
			console.warn("THREE.WebGLProgram: Unsupported toneMapping:", s), a = "Linear"
	}
	return "vec3 " + o + "( vec3 color ) { return " + a + "ToneMapping( color ); }"
}
const _v0 = new Vector3$1;

function getLuminanceFunction() {
	ColorManagement.getLuminanceCoefficients(_v0);
	const o = _v0.x.toFixed(4),
		s = _v0.y.toFixed(4),
		a = _v0.z.toFixed(4);
	return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${o}, ${s}, ${a} );`,
		"	return dot( weights, rgb );", "}"
	].join(`
`)
}

function generateVertexExtensions(o) {
	return [o.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", o
		.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
	].filter(filterEmptyLine).join(`
`)
}

function generateDefines(o) {
	const s = [];
	for (const a in o) {
		const l = o[a];
		l !== !1 && s.push("#define " + a + " " + l)
	}
	return s.join(`
`)
}

function fetchAttributeLocations(o, s) {
	const a = {},
		l = o.getProgramParameter(s, o.ACTIVE_ATTRIBUTES);
	for (let c = 0; c < l; c++) {
		const d = o.getActiveAttrib(s, c),
			f = d.name;
		let m = 1;
		d.type === o.FLOAT_MAT2 && (m = 2), d.type === o.FLOAT_MAT3 && (m = 3), d.type === o.FLOAT_MAT4 && (m = 4), a[
			f] = {
				type: d.type,
				location: o.getAttribLocation(s, f),
				locationSize: m
			}
	}
	return a
}

function filterEmptyLine(o) {
	return o !== ""
}

function replaceLightNums(o, s) {
	const a = s.numSpotLightShadows + s.numSpotLightMaps - s.numSpotLightShadowsWithMaps;
	return o.replace(/NUM_DIR_LIGHTS/g, s.numDirLights).replace(/NUM_SPOT_LIGHTS/g, s.numSpotLights).replace(
		/NUM_SPOT_LIGHT_MAPS/g, s.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, a).replace(
		/NUM_RECT_AREA_LIGHTS/g, s.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, s.numPointLights).replace(
		/NUM_HEMI_LIGHTS/g, s.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, s.numDirLightShadows).replace(
		/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, s.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, s
		.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, s.numPointLightShadows)
}

function replaceClippingPlaneNums(o, s) {
	return o.replace(/NUM_CLIPPING_PLANES/g, s.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, s
		.numClippingPlanes - s.numClipIntersection)
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(o) {
	return o.replace(includePattern, includeReplacer)
}
const shaderChunkMap = new Map;

function includeReplacer(o, s) {
	let a = ShaderChunk[s];
	if (a === void 0) {
		const l = shaderChunkMap.get(s);
		if (l !== void 0) a = ShaderChunk[l], console.warn(
			'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', s, l);
		else throw new Error("Can not resolve #include <" + s + ">")
	}
	return resolveIncludes(a)
}
const unrollLoopPattern =
	/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops(o) {
	return o.replace(unrollLoopPattern, loopReplacer)
}

function loopReplacer(o, s, a, l) {
	let c = "";
	for (let d = parseInt(s); d < parseInt(a); d++) c += l.replace(/\[\s*i\s*\]/g, "[ " + d + " ]").replace(
		/UNROLLED_LOOP_INDEX/g, d);
	return c
}

function generatePrecision(o) {
	let s = `precision ${o.precision} float;
	precision ${o.precision} int;
	precision ${o.precision} sampler2D;
	precision ${o.precision} samplerCube;
	precision ${o.precision} sampler3D;
	precision ${o.precision} sampler2DArray;
	precision ${o.precision} sampler2DShadow;
	precision ${o.precision} samplerCubeShadow;
	precision ${o.precision} sampler2DArrayShadow;
	precision ${o.precision} isampler2D;
	precision ${o.precision} isampler3D;
	precision ${o.precision} isamplerCube;
	precision ${o.precision} isampler2DArray;
	precision ${o.precision} usampler2D;
	precision ${o.precision} usampler3D;
	precision ${o.precision} usamplerCube;
	precision ${o.precision} usampler2DArray;
	`;
	return o.precision === "highp" ? s += `
#define HIGH_PRECISION` : o.precision === "mediump" ? s += `
#define MEDIUM_PRECISION` : o.precision === "lowp" && (s += `
#define LOW_PRECISION`), s
}

function generateShadowMapTypeDefine(o) {
	let s = "SHADOWMAP_TYPE_BASIC";
	return o.shadowMapType === PCFShadowMap ? s = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === PCFSoftShadowMap ? s =
		"SHADOWMAP_TYPE_PCF_SOFT" : o.shadowMapType === VSMShadowMap && (s = "SHADOWMAP_TYPE_VSM"), s
}

function generateEnvMapTypeDefine(o) {
	let s = "ENVMAP_TYPE_CUBE";
	if (o.envMap) switch (o.envMapMode) {
		case CubeReflectionMapping:
		case CubeRefractionMapping:
			s = "ENVMAP_TYPE_CUBE";
			break;
		case CubeUVReflectionMapping:
			s = "ENVMAP_TYPE_CUBE_UV";
			break
	}
	return s
}

function generateEnvMapModeDefine(o) {
	let s = "ENVMAP_MODE_REFLECTION";
	if (o.envMap) switch (o.envMapMode) {
		case CubeRefractionMapping:
			s = "ENVMAP_MODE_REFRACTION";
			break
	}
	return s
}

function generateEnvMapBlendingDefine(o) {
	let s = "ENVMAP_BLENDING_NONE";
	if (o.envMap) switch (o.combine) {
		case MultiplyOperation:
			s = "ENVMAP_BLENDING_MULTIPLY";
			break;
		case MixOperation:
			s = "ENVMAP_BLENDING_MIX";
			break;
		case AddOperation:
			s = "ENVMAP_BLENDING_ADD";
			break
	}
	return s
}

function generateCubeUVSize(o) {
	const s = o.envMapCubeUVHeight;
	if (s === null) return null;
	const a = Math.log2(s) - 2,
		l = 1 / s;
	return {
		texelWidth: 1 / (3 * Math.max(Math.pow(2, a), 7 * 16)),
		texelHeight: l,
		maxMip: a
	}
}

function WebGLProgram(o, s, a, l) {
	const c = o.getContext(),
		d = a.defines;
	let f = a.vertexShader,
		m = a.fragmentShader;
	const g = generateShadowMapTypeDefine(a),
		v = generateEnvMapTypeDefine(a),
		y = generateEnvMapModeDefine(a),
		b = generateEnvMapBlendingDefine(a),
		C = generateCubeUVSize(a),
		_ = generateVertexExtensions(a),
		S = generateDefines(d),
		w = c.createProgram();
	let T, A, k = a.glslVersion ? "#version " + a.glslVersion + `
` : "";
	a.isRawShaderMaterial ? (T = ["#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, S]
			.filter(filterEmptyLine).join(`
`), T.length > 0 && (T += `
`), A = ["#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, S].filter(filterEmptyLine).join(`
`), A.length > 0 && (A += `
`)) : (T = [generatePrecision(a), "#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, S, a
			.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", a.batching ? "#define USE_BATCHING" : "",
			a.batchingColor ? "#define USE_BATCHING_COLOR" : "", a.instancing ? "#define USE_INSTANCING" : "", a
			.instancingColor ? "#define USE_INSTANCING_COLOR" : "", a.instancingMorph ?
			"#define USE_INSTANCING_MORPH" : "", a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp2 ?
			"#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a
			.envMap ? "#define " + y : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" :
			"", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a
			.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", a.normalMapTangentSpace ?
			"#define USE_NORMALMAP_TANGENTSPACE" : "", a.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", a
			.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.anisotropy ? "#define USE_ANISOTROPY" : "", a
			.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", a.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", a
			.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", a.clearcoatNormalMap ?
			"#define USE_CLEARCOAT_NORMALMAP" : "", a.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", a
			.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", a.specularMap ?
			"#define USE_SPECULARMAP" : "", a.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", a
			.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", a.roughnessMap ?
			"#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ?
			"#define USE_ALPHAMAP" : "", a.alphaHash ? "#define USE_ALPHAHASH" : "", a.transmission ?
			"#define USE_TRANSMISSION" : "", a.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", a
			.thicknessMap ? "#define USE_THICKNESSMAP" : "", a.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", a
			.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", a.mapUv ? "#define MAP_UV " + a.mapUv : "",
			a.alphaMapUv ? "#define ALPHAMAP_UV " + a.alphaMapUv : "", a.lightMapUv ? "#define LIGHTMAP_UV " + a
			.lightMapUv : "", a.aoMapUv ? "#define AOMAP_UV " + a.aoMapUv : "", a.emissiveMapUv ?
			"#define EMISSIVEMAP_UV " + a.emissiveMapUv : "", a.bumpMapUv ? "#define BUMPMAP_UV " + a.bumpMapUv :
			"", a.normalMapUv ? "#define NORMALMAP_UV " + a.normalMapUv : "", a.displacementMapUv ?
			"#define DISPLACEMENTMAP_UV " + a.displacementMapUv : "", a.metalnessMapUv ?
			"#define METALNESSMAP_UV " + a.metalnessMapUv : "", a.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + a
			.roughnessMapUv : "", a.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + a.anisotropyMapUv : "", a
			.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + a.clearcoatMapUv : "", a.clearcoatNormalMapUv ?
			"#define CLEARCOAT_NORMALMAP_UV " + a.clearcoatNormalMapUv : "", a.clearcoatRoughnessMapUv ?
			"#define CLEARCOAT_ROUGHNESSMAP_UV " + a.clearcoatRoughnessMapUv : "", a.iridescenceMapUv ?
			"#define IRIDESCENCEMAP_UV " + a.iridescenceMapUv : "", a.iridescenceThicknessMapUv ?
			"#define IRIDESCENCE_THICKNESSMAP_UV " + a.iridescenceThicknessMapUv : "", a.sheenColorMapUv ?
			"#define SHEEN_COLORMAP_UV " + a.sheenColorMapUv : "", a.sheenRoughnessMapUv ?
			"#define SHEEN_ROUGHNESSMAP_UV " + a.sheenRoughnessMapUv : "", a.specularMapUv ?
			"#define SPECULARMAP_UV " + a.specularMapUv : "", a.specularColorMapUv ?
			"#define SPECULAR_COLORMAP_UV " + a.specularColorMapUv : "", a.specularIntensityMapUv ?
			"#define SPECULAR_INTENSITYMAP_UV " + a.specularIntensityMapUv : "", a.transmissionMapUv ?
			"#define TRANSMISSIONMAP_UV " + a.transmissionMapUv : "", a.thicknessMapUv ?
			"#define THICKNESSMAP_UV " + a.thicknessMapUv : "", a.vertexTangents && a.flatShading === !1 ?
			"#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.vertexAlphas ?
			"#define USE_COLOR_ALPHA" : "", a.vertexUv1s ? "#define USE_UV1" : "", a.vertexUv2s ?
			"#define USE_UV2" : "", a.vertexUv3s ? "#define USE_UV3" : "", a.pointsUvs ? "#define USE_POINTS_UV" :
			"", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a
			.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && a.flatShading === !1 ?
			"#define USE_MORPHNORMALS" : "", a.morphColors ? "#define USE_MORPHCOLORS" : "", a.morphTargetsCount >
			0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + a.morphTextureStride : "", a.morphTargetsCount > 0 ?
			"#define MORPHTARGETS_COUNT " + a.morphTargetsCount : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a
			.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a
			.shadowMapEnabled ? "#define " + g : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a
			.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", a.logarithmicDepthBuffer ?
			"#define USE_LOGDEPTHBUF" : "", a.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
			"uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;",
			"uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif",
			"#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif",
			"#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;",
			"attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif",
			"#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif",
			"#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )",
			"	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif",
			"#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`
		].filter(filterEmptyLine).join(`
`), A = [generatePrecision(a), "#define SHADER_TYPE " + a.shaderType, "#define SHADER_NAME " + a.shaderName, S, a
			.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "", a
			.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", a.map ? "#define USE_MAP" : "", a.matcap ?
			"#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + v : "", a
			.envMap ? "#define " + y : "", a.envMap ? "#define " + b : "", C ? "#define CUBEUV_TEXEL_WIDTH " + C
			.texelWidth : "", C ? "#define CUBEUV_TEXEL_HEIGHT " + C.texelHeight : "", C ?
			"#define CUBEUV_MAX_MIP " + C.maxMip + ".0" : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ?
			"#define USE_AOMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ?
			"#define USE_NORMALMAP" : "", a.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", a
			.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", a.emissiveMap ?
			"#define USE_EMISSIVEMAP" : "", a.anisotropy ? "#define USE_ANISOTROPY" : "", a.anisotropyMap ?
			"#define USE_ANISOTROPYMAP" : "", a.clearcoat ? "#define USE_CLEARCOAT" : "", a.clearcoatMap ?
			"#define USE_CLEARCOATMAP" : "", a.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", a
			.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", a.dispersion ? "#define USE_DISPERSION" :
			"", a.iridescence ? "#define USE_IRIDESCENCE" : "", a.iridescenceMap ? "#define USE_IRIDESCENCEMAP" :
			"", a.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", a.specularMap ?
			"#define USE_SPECULARMAP" : "", a.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", a
			.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", a.roughnessMap ?
			"#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ?
			"#define USE_ALPHAMAP" : "", a.alphaTest ? "#define USE_ALPHATEST" : "", a.alphaHash ?
			"#define USE_ALPHAHASH" : "", a.sheen ? "#define USE_SHEEN" : "", a.sheenColorMap ?
			"#define USE_SHEEN_COLORMAP" : "", a.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", a
			.transmission ? "#define USE_TRANSMISSION" : "", a.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
			a.thicknessMap ? "#define USE_THICKNESSMAP" : "", a.vertexTangents && a.flatShading === !1 ?
			"#define USE_TANGENT" : "", a.vertexColors || a.instancingColor || a.batchingColor ?
			"#define USE_COLOR" : "", a.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", a.vertexUv1s ?
			"#define USE_UV1" : "", a.vertexUv2s ? "#define USE_UV2" : "", a.vertexUv3s ? "#define USE_UV3" : "", a
			.pointsUvs ? "#define USE_POINTS_UV" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a
			.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ?
			"#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ?
			"#define " + g : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.numLightProbes > 0 ?
			"#define USE_LIGHT_PROBES" : "", a.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", a
			.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", a.logarithmicDepthBuffer ?
			"#define USE_LOGDEPTHBUF" : "", a.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
			"uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", a
			.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", a.toneMapping !== NoToneMapping ?
			ShaderChunk.tonemapping_pars_fragment : "", a.toneMapping !== NoToneMapping ? getToneMappingFunction(
				"toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.opaque ?
			"#define OPAQUE" : "", ShaderChunk.colorspace_pars_fragment, getTexelEncodingFunction(
				"linearToOutputTexel", a.outputColorSpace), getLuminanceFunction(), a.useDepthPacking ?
			"#define DEPTH_PACKING " + a.depthPacking : "", `
`
		].filter(filterEmptyLine).join(`
`)), f = resolveIncludes(f), f = replaceLightNums(f, a), f = replaceClippingPlaneNums(f, a), m = resolveIncludes(m), m =
		replaceLightNums(m, a), m = replaceClippingPlaneNums(m, a), f = unrollLoops(f), m = unrollLoops(m), a
		.isRawShaderMaterial !== !0 && (k = `#version 300 es
`, T = [_, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + T, A = ["#define varying in", a.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", a
			.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
			"#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture",
			"#define texture2DProj textureProj", "#define texture2DLodEXT textureLod",
			"#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod",
			"#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad",
			"#define textureCubeGradEXT textureGrad"
		].join(`
`) + `
` + A);
	const M = k + T + f,
		D = k + A + m,
		F = WebGLShader(c, c.VERTEX_SHADER, M),
		R = WebGLShader(c, c.FRAGMENT_SHADER, D);
	c.attachShader(w, F), c.attachShader(w, R), a.index0AttributeName !== void 0 ? c.bindAttribLocation(w, 0, a
		.index0AttributeName) : a.morphTargets === !0 && c.bindAttribLocation(w, 0, "position"), c.linkProgram(w);

	function O(j) {
		if (o.debug.checkShaderErrors) {
			const ge = c.getProgramInfoLog(w).trim(),
				me = c.getShaderInfoLog(F).trim(),
				he = c.getShaderInfoLog(R).trim();
			let ce = !0,
				ae = !0;
			if (c.getProgramParameter(w, c.LINK_STATUS) === !1)
				if (ce = !1, typeof o.debug.onShaderError == "function") o.debug.onShaderError(c, w, F, R);
				else {
					const fe = getShaderErrors(c, F, "vertex"),
						q = getShaderErrors(c, R, "fragment");
					console.error("THREE.WebGLProgram: Shader Error " + c.getError() + " - VALIDATE_STATUS " + c
						.getProgramParameter(w, c.VALIDATE_STATUS) + `

Material Name: ` + j.name + `
Material Type: ` + j.type + `

Program Info Log: ` + ge + `
` + fe + `
` + q)
				}
			else ge !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", ge) : (me === "" || he === "") && (
				ae = !1);
			ae && (j.diagnostics = {
				runnable: ce,
				programLog: ge,
				vertexShader: {
					log: me,
					prefix: T
				},
				fragmentShader: {
					log: he,
					prefix: A
				}
			})
		}
		c.deleteShader(F), c.deleteShader(R), U = new WebGLUniforms(c, w), V = fetchAttributeLocations(c, w)
	}
	let U;
	this.getUniforms = function() {
		return U === void 0 && O(this), U
	};
	let V;
	this.getAttributes = function() {
		return V === void 0 && O(this), V
	};
	let z = a.rendererExtensionParallelShaderCompile === !1;
	return this.isReady = function() {
			return z === !1 && (z = c.getProgramParameter(w, COMPLETION_STATUS_KHR)), z
		}, this.destroy = function() {
			l.releaseStatesOfProgram(this), c.deleteProgram(w), this.program = void 0
		}, this.type = a.shaderType, this.name = a.shaderName, this.id = programIdCount++, this.cacheKey = s, this
		.usedTimes = 1, this.program = w, this.vertexShader = F, this.fragmentShader = R, this
}
let _id = 0;
class WebGLShaderCache {
	constructor() {
		this.shaderCache = new Map, this.materialCache = new Map
	}
	update(s) {
		const a = s.vertexShader,
			l = s.fragmentShader,
			c = this._getShaderStage(a),
			d = this._getShaderStage(l),
			f = this._getShaderCacheForMaterial(s);
		return f.has(c) === !1 && (f.add(c), c.usedTimes++), f.has(d) === !1 && (f.add(d), d.usedTimes++), this
	}
	remove(s) {
		const a = this.materialCache.get(s);
		for (const l of a) l.usedTimes--, l.usedTimes === 0 && this.shaderCache.delete(l.code);
		return this.materialCache.delete(s), this
	}
	getVertexShaderID(s) {
		return this._getShaderStage(s.vertexShader).id
	}
	getFragmentShaderID(s) {
		return this._getShaderStage(s.fragmentShader).id
	}
	dispose() {
		this.shaderCache.clear(), this.materialCache.clear()
	}
	_getShaderCacheForMaterial(s) {
		const a = this.materialCache;
		let l = a.get(s);
		return l === void 0 && (l = new Set, a.set(s, l)), l
	}
	_getShaderStage(s) {
		const a = this.shaderCache;
		let l = a.get(s);
		return l === void 0 && (l = new WebGLShaderStage(s), a.set(s, l)), l
	}
}
class WebGLShaderStage {
	constructor(s) {
		this.id = _id++, this.code = s, this.usedTimes = 0
	}
}

function WebGLPrograms(o, s, a, l, c, d, f) {
	const m = new Layers,
		g = new WebGLShaderCache,
		v = new Set,
		y = [],
		b = c.logarithmicDepthBuffer,
		C = c.vertexTextures;
	let _ = c.precision;
	const S = {
		MeshDepthMaterial: "depth",
		MeshDistanceMaterial: "distanceRGBA",
		MeshNormalMaterial: "normal",
		MeshBasicMaterial: "basic",
		MeshLambertMaterial: "lambert",
		MeshPhongMaterial: "phong",
		MeshToonMaterial: "toon",
		MeshStandardMaterial: "physical",
		MeshPhysicalMaterial: "physical",
		MeshMatcapMaterial: "matcap",
		LineBasicMaterial: "basic",
		LineDashedMaterial: "dashed",
		PointsMaterial: "points",
		ShadowMaterial: "shadow",
		SpriteMaterial: "sprite"
	};

	function w(V) {
		return v.add(V), V === 0 ? "uv" : `uv${V}`
	}

	function T(V, z, j, ge, me) {
		const he = ge.fog,
			ce = me.geometry,
			ae = V.isMeshStandardMaterial ? ge.environment : null,
			fe = (V.isMeshStandardMaterial ? a : s).get(V.envMap || ae),
			q = fe && fe.mapping === CubeUVReflectionMapping ? fe.image.height : null,
			le = S[V.type];
		V.precision !== null && (_ = c.getMaxPrecision(V.precision), _ !== V.precision && console.warn(
			"THREE.WebGLProgram.getParameters:", V.precision, "not supported, using", _, "instead."));
		const de = ce.morphAttributes.position || ce.morphAttributes.normal || ce.morphAttributes.color,
			_e = de !== void 0 ? de.length : 0;
		let ke = 0;
		ce.morphAttributes.position !== void 0 && (ke = 1), ce.morphAttributes.normal !== void 0 && (ke = 2), ce
			.morphAttributes.color !== void 0 && (ke = 3);
		let De, Se, be, Me;
		if (le) {
			const Mt = ShaderLib[le];
			De = Mt.vertexShader, Se = Mt.fragmentShader
		} else De = V.vertexShader, Se = V.fragmentShader, g.update(V), be = g.getVertexShaderID(V), Me = g
			.getFragmentShaderID(V);
		const Ve = o.getRenderTarget(),
			it = o.state.buffers.depth.getReversed(),
			pt = me.isInstancedMesh === !0,
			dt = me.isBatchedMesh === !0,
			He = !!V.map,
			Ae = !!V.matcap,
			xe = !!fe,
			ye = !!V.aoMap,
			Le = !!V.lightMap,
			Ue = !!V.bumpMap,
			nt = !!V.normalMap,
			ot = !!V.displacementMap,
			at = !!V.emissiveMap,
			Je = !!V.metalnessMap,
			Ne = !!V.roughnessMap,
			we = V.anisotropy > 0,
			Ce = V.clearcoat > 0,
			$e = V.dispersion > 0,
			Fe = V.iridescence > 0,
			Ge = V.sheen > 0,
			ze = V.transmission > 0,
			Oe = we && !!V.anisotropyMap,
			Xe = Ce && !!V.clearcoatMap,
			rt = Ce && !!V.clearcoatNormalMap,
			ut = Ce && !!V.clearcoatRoughnessMap,
			gt = Fe && !!V.iridescenceMap,
			Et = Fe && !!V.iridescenceThicknessMap,
			Ze = Ge && !!V.sheenColorMap,
			Ye = Ge && !!V.sheenRoughnessMap,
			ct = !!V.specularMap,
			yt = !!V.specularColorMap,
			wt = !!V.specularIntensityMap,
			Qe = ze && !!V.transmissionMap,
			At = ze && !!V.thicknessMap,
			Ct = !!V.gradientMap,
			xt = !!V.alphaMap,
			Rt = V.alphaTest > 0,
			$t = !!V.alphaHash,
			zt = !!V.extensions;
		let sn = NoToneMapping;
		V.toneMapped && (Ve === null || Ve.isXRRenderTarget === !0) && (sn = o.toneMapping);
		const dn = {
			shaderID: le,
			shaderType: V.type,
			shaderName: V.name,
			vertexShader: De,
			fragmentShader: Se,
			defines: V.defines,
			customVertexShaderID: be,
			customFragmentShaderID: Me,
			isRawShaderMaterial: V.isRawShaderMaterial === !0,
			glslVersion: V.glslVersion,
			precision: _,
			batching: dt,
			batchingColor: dt && me._colorsTexture !== null,
			instancing: pt,
			instancingColor: pt && me.instanceColor !== null,
			instancingMorph: pt && me.morphTexture !== null,
			supportsVertexTextures: C,
			outputColorSpace: Ve === null ? o.outputColorSpace : Ve.isXRRenderTarget === !0 ? Ve.texture
				.colorSpace : LinearSRGBColorSpace,
			alphaToCoverage: !!V.alphaToCoverage,
			map: He,
			matcap: Ae,
			envMap: xe,
			envMapMode: xe && fe.mapping,
			envMapCubeUVHeight: q,
			aoMap: ye,
			lightMap: Le,
			bumpMap: Ue,
			normalMap: nt,
			displacementMap: C && ot,
			emissiveMap: at,
			normalMapObjectSpace: nt && V.normalMapType === ObjectSpaceNormalMap,
			normalMapTangentSpace: nt && V.normalMapType === TangentSpaceNormalMap,
			metalnessMap: Je,
			roughnessMap: Ne,
			anisotropy: we,
			anisotropyMap: Oe,
			clearcoat: Ce,
			clearcoatMap: Xe,
			clearcoatNormalMap: rt,
			clearcoatRoughnessMap: ut,
			dispersion: $e,
			iridescence: Fe,
			iridescenceMap: gt,
			iridescenceThicknessMap: Et,
			sheen: Ge,
			sheenColorMap: Ze,
			sheenRoughnessMap: Ye,
			specularMap: ct,
			specularColorMap: yt,
			specularIntensityMap: wt,
			transmission: ze,
			transmissionMap: Qe,
			thicknessMap: At,
			gradientMap: Ct,
			opaque: V.transparent === !1 && V.blending === NormalBlending && V.alphaToCoverage === !1,
			alphaMap: xt,
			alphaTest: Rt,
			alphaHash: $t,
			combine: V.combine,
			mapUv: He && w(V.map.channel),
			aoMapUv: ye && w(V.aoMap.channel),
			lightMapUv: Le && w(V.lightMap.channel),
			bumpMapUv: Ue && w(V.bumpMap.channel),
			normalMapUv: nt && w(V.normalMap.channel),
			displacementMapUv: ot && w(V.displacementMap.channel),
			emissiveMapUv: at && w(V.emissiveMap.channel),
			metalnessMapUv: Je && w(V.metalnessMap.channel),
			roughnessMapUv: Ne && w(V.roughnessMap.channel),
			anisotropyMapUv: Oe && w(V.anisotropyMap.channel),
			clearcoatMapUv: Xe && w(V.clearcoatMap.channel),
			clearcoatNormalMapUv: rt && w(V.clearcoatNormalMap.channel),
			clearcoatRoughnessMapUv: ut && w(V.clearcoatRoughnessMap.channel),
			iridescenceMapUv: gt && w(V.iridescenceMap.channel),
			iridescenceThicknessMapUv: Et && w(V.iridescenceThicknessMap.channel),
			sheenColorMapUv: Ze && w(V.sheenColorMap.channel),
			sheenRoughnessMapUv: Ye && w(V.sheenRoughnessMap.channel),
			specularMapUv: ct && w(V.specularMap.channel),
			specularColorMapUv: yt && w(V.specularColorMap.channel),
			specularIntensityMapUv: wt && w(V.specularIntensityMap.channel),
			transmissionMapUv: Qe && w(V.transmissionMap.channel),
			thicknessMapUv: At && w(V.thicknessMap.channel),
			alphaMapUv: xt && w(V.alphaMap.channel),
			vertexTangents: !!ce.attributes.tangent && (nt || we),
			vertexColors: V.vertexColors,
			vertexAlphas: V.vertexColors === !0 && !!ce.attributes.color && ce.attributes.color.itemSize === 4,
			pointsUvs: me.isPoints === !0 && !!ce.attributes.uv && (He || xt),
			fog: !!he,
			useFog: V.fog === !0,
			fogExp2: !!he && he.isFogExp2,
			flatShading: V.flatShading === !0,
			sizeAttenuation: V.sizeAttenuation === !0,
			logarithmicDepthBuffer: b,
			reverseDepthBuffer: it,
			skinning: me.isSkinnedMesh === !0,
			morphTargets: ce.morphAttributes.position !== void 0,
			morphNormals: ce.morphAttributes.normal !== void 0,
			morphColors: ce.morphAttributes.color !== void 0,
			morphTargetsCount: _e,
			morphTextureStride: ke,
			numDirLights: z.directional.length,
			numPointLights: z.point.length,
			numSpotLights: z.spot.length,
			numSpotLightMaps: z.spotLightMap.length,
			numRectAreaLights: z.rectArea.length,
			numHemiLights: z.hemi.length,
			numDirLightShadows: z.directionalShadowMap.length,
			numPointLightShadows: z.pointShadowMap.length,
			numSpotLightShadows: z.spotShadowMap.length,
			numSpotLightShadowsWithMaps: z.numSpotLightShadowsWithMaps,
			numLightProbes: z.numLightProbes,
			numClippingPlanes: f.numPlanes,
			numClipIntersection: f.numIntersection,
			dithering: V.dithering,
			shadowMapEnabled: o.shadowMap.enabled && j.length > 0,
			shadowMapType: o.shadowMap.type,
			toneMapping: sn,
			decodeVideoTexture: He && V.map.isVideoTexture === !0 && ColorManagement.getTransfer(V.map
				.colorSpace) === SRGBTransfer,
			decodeVideoTextureEmissive: at && V.emissiveMap.isVideoTexture === !0 && ColorManagement.getTransfer(V
				.emissiveMap.colorSpace) === SRGBTransfer,
			premultipliedAlpha: V.premultipliedAlpha,
			doubleSided: V.side === DoubleSide,
			flipSided: V.side === BackSide,
			useDepthPacking: V.depthPacking >= 0,
			depthPacking: V.depthPacking || 0,
			index0AttributeName: V.index0AttributeName,
			extensionClipCullDistance: zt && V.extensions.clipCullDistance === !0 && l.has(
				"WEBGL_clip_cull_distance"),
			extensionMultiDraw: (zt && V.extensions.multiDraw === !0 || dt) && l.has("WEBGL_multi_draw"),
			rendererExtensionParallelShaderCompile: l.has("KHR_parallel_shader_compile"),
			customProgramCacheKey: V.customProgramCacheKey()
		};
		return dn.vertexUv1s = v.has(1), dn.vertexUv2s = v.has(2), dn.vertexUv3s = v.has(3), v.clear(), dn
	}

	function A(V) {
		const z = [];
		if (V.shaderID ? z.push(V.shaderID) : (z.push(V.customVertexShaderID), z.push(V.customFragmentShaderID)), V
			.defines !== void 0)
			for (const j in V.defines) z.push(j), z.push(V.defines[j]);
		return V.isRawShaderMaterial === !1 && (k(z, V), M(z, V), z.push(o.outputColorSpace)), z.push(V
			.customProgramCacheKey), z.join()
	}

	function k(V, z) {
		V.push(z.precision), V.push(z.outputColorSpace), V.push(z.envMapMode), V.push(z.envMapCubeUVHeight), V.push(z
				.mapUv), V.push(z.alphaMapUv), V.push(z.lightMapUv), V.push(z.aoMapUv), V.push(z.bumpMapUv), V.push(z
				.normalMapUv), V.push(z.displacementMapUv), V.push(z.emissiveMapUv), V.push(z.metalnessMapUv), V.push(z
				.roughnessMapUv), V.push(z.anisotropyMapUv), V.push(z.clearcoatMapUv), V.push(z.clearcoatNormalMapUv), V
			.push(z.clearcoatRoughnessMapUv), V.push(z.iridescenceMapUv), V.push(z.iridescenceThicknessMapUv), V.push(z
				.sheenColorMapUv), V.push(z.sheenRoughnessMapUv), V.push(z.specularMapUv), V.push(z.specularColorMapUv),
			V.push(z.specularIntensityMapUv), V.push(z.transmissionMapUv), V.push(z.thicknessMapUv), V.push(z.combine),
			V.push(z.fogExp2), V.push(z.sizeAttenuation), V.push(z.morphTargetsCount), V.push(z.morphAttributeCount), V
			.push(z.numDirLights), V.push(z.numPointLights), V.push(z.numSpotLights), V.push(z.numSpotLightMaps), V
			.push(z.numHemiLights), V.push(z.numRectAreaLights), V.push(z.numDirLightShadows), V.push(z
				.numPointLightShadows), V.push(z.numSpotLightShadows), V.push(z.numSpotLightShadowsWithMaps), V.push(z
				.numLightProbes), V.push(z.shadowMapType), V.push(z.toneMapping), V.push(z.numClippingPlanes), V.push(z
				.numClipIntersection), V.push(z.depthPacking)
	}

	function M(V, z) {
		m.disableAll(), z.supportsVertexTextures && m.enable(0), z.instancing && m.enable(1), z.instancingColor && m
			.enable(2), z.instancingMorph && m.enable(3), z.matcap && m.enable(4), z.envMap && m.enable(5), z
			.normalMapObjectSpace && m.enable(6), z.normalMapTangentSpace && m.enable(7), z.clearcoat && m.enable(8), z
			.iridescence && m.enable(9), z.alphaTest && m.enable(10), z.vertexColors && m.enable(11), z.vertexAlphas &&
			m.enable(12), z.vertexUv1s && m.enable(13), z.vertexUv2s && m.enable(14), z.vertexUv3s && m.enable(15), z
			.vertexTangents && m.enable(16), z.anisotropy && m.enable(17), z.alphaHash && m.enable(18), z.batching && m
			.enable(19), z.dispersion && m.enable(20), z.batchingColor && m.enable(21), V.push(m.mask), m.disableAll(),
			z.fog && m.enable(0), z.useFog && m.enable(1), z.flatShading && m.enable(2), z.logarithmicDepthBuffer && m
			.enable(3), z.reverseDepthBuffer && m.enable(4), z.skinning && m.enable(5), z.morphTargets && m.enable(6), z
			.morphNormals && m.enable(7), z.morphColors && m.enable(8), z.premultipliedAlpha && m.enable(9), z
			.shadowMapEnabled && m.enable(10), z.doubleSided && m.enable(11), z.flipSided && m.enable(12), z
			.useDepthPacking && m.enable(13), z.dithering && m.enable(14), z.transmission && m.enable(15), z.sheen && m
			.enable(16), z.opaque && m.enable(17), z.pointsUvs && m.enable(18), z.decodeVideoTexture && m.enable(19), z
			.decodeVideoTextureEmissive && m.enable(20), z.alphaToCoverage && m.enable(21), V.push(m.mask)
	}

	function D(V) {
		const z = S[V.type];
		let j;
		if (z) {
			const ge = ShaderLib[z];
			j = UniformsUtils.clone(ge.uniforms)
		} else j = V.uniforms;
		return j
	}

	function F(V, z) {
		let j;
		for (let ge = 0, me = y.length; ge < me; ge++) {
			const he = y[ge];
			if (he.cacheKey === z) {
				j = he, ++j.usedTimes;
				break
			}
		}
		return j === void 0 && (j = new WebGLProgram(o, z, V, d), y.push(j)), j
	}

	function R(V) {
		if (--V.usedTimes === 0) {
			const z = y.indexOf(V);
			y[z] = y[y.length - 1], y.pop(), V.destroy()
		}
	}

	function O(V) {
		g.remove(V)
	}

	function U() {
		g.dispose()
	}
	return {
		getParameters: T,
		getProgramCacheKey: A,
		getUniforms: D,
		acquireProgram: F,
		releaseProgram: R,
		releaseShaderCache: O,
		programs: y,
		dispose: U
	}
}

function WebGLProperties() {
	let o = new WeakMap;

	function s(f) {
		return o.has(f)
	}

	function a(f) {
		let m = o.get(f);
		return m === void 0 && (m = {}, o.set(f, m)), m
	}

	function l(f) {
		o.delete(f)
	}

	function c(f, m, g) {
		o.get(f)[m] = g
	}

	function d() {
		o = new WeakMap
	}
	return {
		has: s,
		get: a,
		remove: l,
		update: c,
		dispose: d
	}
}

function painterSortStable(o, s) {
	return o.groupOrder !== s.groupOrder ? o.groupOrder - s.groupOrder : o.renderOrder !== s.renderOrder ? o
		.renderOrder - s.renderOrder : o.material.id !== s.material.id ? o.material.id - s.material.id : o.z !== s.z ? o
		.z - s.z : o.id - s.id
}

function reversePainterSortStable(o, s) {
	return o.groupOrder !== s.groupOrder ? o.groupOrder - s.groupOrder : o.renderOrder !== s.renderOrder ? o
		.renderOrder - s.renderOrder : o.z !== s.z ? s.z - o.z : o.id - s.id
}

function WebGLRenderList() {
	const o = [];
	let s = 0;
	const a = [],
		l = [],
		c = [];

	function d() {
		s = 0, a.length = 0, l.length = 0, c.length = 0
	}

	function f(b, C, _, S, w, T) {
		let A = o[s];
		return A === void 0 ? (A = {
			id: b.id,
			object: b,
			geometry: C,
			material: _,
			groupOrder: S,
			renderOrder: b.renderOrder,
			z: w,
			group: T
		}, o[s] = A) : (A.id = b.id, A.object = b, A.geometry = C, A.material = _, A.groupOrder = S, A.renderOrder =
			b.renderOrder, A.z = w, A.group = T), s++, A
	}

	function m(b, C, _, S, w, T) {
		const A = f(b, C, _, S, w, T);
		_.transmission > 0 ? l.push(A) : _.transparent === !0 ? c.push(A) : a.push(A)
	}

	function g(b, C, _, S, w, T) {
		const A = f(b, C, _, S, w, T);
		_.transmission > 0 ? l.unshift(A) : _.transparent === !0 ? c.unshift(A) : a.unshift(A)
	}

	function v(b, C) {
		a.length > 1 && a.sort(b || painterSortStable), l.length > 1 && l.sort(C || reversePainterSortStable), c
			.length > 1 && c.sort(C || reversePainterSortStable)
	}

	function y() {
		for (let b = s, C = o.length; b < C; b++) {
			const _ = o[b];
			if (_.id === null) break;
			_.id = null, _.object = null, _.geometry = null, _.material = null, _.group = null
		}
	}
	return {
		opaque: a,
		transmissive: l,
		transparent: c,
		init: d,
		push: m,
		unshift: g,
		finish: y,
		sort: v
	}
}

function WebGLRenderLists() {
	let o = new WeakMap;

	function s(l, c) {
		const d = o.get(l);
		let f;
		return d === void 0 ? (f = new WebGLRenderList, o.set(l, [f])) : c >= d.length ? (f = new WebGLRenderList, d
			.push(f)) : f = d[c], f
	}

	function a() {
		o = new WeakMap
	}
	return {
		get: s,
		dispose: a
	}
}

function UniformsCache() {
	const o = {};
	return {
		get: function(s) {
			if (o[s.id] !== void 0) return o[s.id];
			let a;
			switch (s.type) {
				case "DirectionalLight":
					a = {
						direction: new Vector3$1,
						color: new Color
					};
					break;
				case "SpotLight":
					a = {
						position: new Vector3$1,
						direction: new Vector3$1,
						color: new Color,
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;
				case "PointLight":
					a = {
						position: new Vector3$1,
						color: new Color,
						distance: 0,
						decay: 0
					};
					break;
				case "HemisphereLight":
					a = {
						direction: new Vector3$1,
						skyColor: new Color,
						groundColor: new Color
					};
					break;
				case "RectAreaLight":
					a = {
						color: new Color,
						position: new Vector3$1,
						halfWidth: new Vector3$1,
						halfHeight: new Vector3$1
					};
					break
			}
			return o[s.id] = a, a
		}
	}
}

function ShadowUniformsCache() {
	const o = {};
	return {
		get: function(s) {
			if (o[s.id] !== void 0) return o[s.id];
			let a;
			switch (s.type) {
				case "DirectionalLight":
					a = {
						shadowIntensity: 1,
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2
					};
					break;
				case "SpotLight":
					a = {
						shadowIntensity: 1,
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2
					};
					break;
				case "PointLight":
					a = {
						shadowIntensity: 1,
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2,
						shadowCameraNear: 1,
						shadowCameraFar: 1e3
					};
					break
			}
			return o[s.id] = a, a
		}
	}
}
let nextVersion = 0;

function shadowCastingAndTexturingLightsFirst(o, s) {
	return (s.castShadow ? 2 : 0) - (o.castShadow ? 2 : 0) + (s.map ? 1 : 0) - (o.map ? 1 : 0)
}

function WebGLLights(o) {
	const s = new UniformsCache,
		a = ShadowUniformsCache(),
		l = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1,
				numSpotMaps: -1,
				numLightProbes: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0,
			numLightProbes: 0
		};
	for (let v = 0; v < 9; v++) l.probe.push(new Vector3$1);
	const c = new Vector3$1,
		d = new Matrix4,
		f = new Matrix4;

	function m(v) {
		let y = 0,
			b = 0,
			C = 0;
		for (let V = 0; V < 9; V++) l.probe[V].set(0, 0, 0);
		let _ = 0,
			S = 0,
			w = 0,
			T = 0,
			A = 0,
			k = 0,
			M = 0,
			D = 0,
			F = 0,
			R = 0,
			O = 0;
		v.sort(shadowCastingAndTexturingLightsFirst);
		for (let V = 0, z = v.length; V < z; V++) {
			const j = v[V],
				ge = j.color,
				me = j.intensity,
				he = j.distance,
				ce = j.shadow && j.shadow.map ? j.shadow.map.texture : null;
			if (j.isAmbientLight) y += ge.r * me, b += ge.g * me, C += ge.b * me;
			else if (j.isLightProbe) {
				for (let ae = 0; ae < 9; ae++) l.probe[ae].addScaledVector(j.sh.coefficients[ae], me);
				O++
			} else if (j.isDirectionalLight) {
				const ae = s.get(j);
				if (ae.color.copy(j.color).multiplyScalar(j.intensity), j.castShadow) {
					const fe = j.shadow,
						q = a.get(j);
					q.shadowIntensity = fe.intensity, q.shadowBias = fe.bias, q.shadowNormalBias = fe.normalBias, q
						.shadowRadius = fe.radius, q.shadowMapSize = fe.mapSize, l.directionalShadow[_] = q, l
						.directionalShadowMap[_] = ce, l.directionalShadowMatrix[_] = j.shadow.matrix, k++
				}
				l.directional[_] = ae, _++
			} else if (j.isSpotLight) {
				const ae = s.get(j);
				ae.position.setFromMatrixPosition(j.matrixWorld), ae.color.copy(ge).multiplyScalar(me), ae.distance =
					he, ae.coneCos = Math.cos(j.angle), ae.penumbraCos = Math.cos(j.angle * (1 - j.penumbra)), ae
					.decay = j.decay, l.spot[w] = ae;
				const fe = j.shadow;
				if (j.map && (l.spotLightMap[F] = j.map, F++, fe.updateMatrices(j), j.castShadow && R++), l
					.spotLightMatrix[w] = fe.matrix, j.castShadow) {
					const q = a.get(j);
					q.shadowIntensity = fe.intensity, q.shadowBias = fe.bias, q.shadowNormalBias = fe.normalBias, q
						.shadowRadius = fe.radius, q.shadowMapSize = fe.mapSize, l.spotShadow[w] = q, l.spotShadowMap[
						w] = ce, D++
				}
				w++
			} else if (j.isRectAreaLight) {
				const ae = s.get(j);
				ae.color.copy(ge).multiplyScalar(me), ae.halfWidth.set(j.width * .5, 0, 0), ae.halfHeight.set(0, j
					.height * .5, 0), l.rectArea[T] = ae, T++
			} else if (j.isPointLight) {
				const ae = s.get(j);
				if (ae.color.copy(j.color).multiplyScalar(j.intensity), ae.distance = j.distance, ae.decay = j.decay, j
					.castShadow) {
					const fe = j.shadow,
						q = a.get(j);
					q.shadowIntensity = fe.intensity, q.shadowBias = fe.bias, q.shadowNormalBias = fe.normalBias, q
						.shadowRadius = fe.radius, q.shadowMapSize = fe.mapSize, q.shadowCameraNear = fe.camera.near, q
						.shadowCameraFar = fe.camera.far, l.pointShadow[S] = q, l.pointShadowMap[S] = ce, l
						.pointShadowMatrix[S] = j.shadow.matrix, M++
				}
				l.point[S] = ae, S++
			} else if (j.isHemisphereLight) {
				const ae = s.get(j);
				ae.skyColor.copy(j.color).multiplyScalar(me), ae.groundColor.copy(j.groundColor).multiplyScalar(me), l
					.hemi[A] = ae, A++
			}
		}
		T > 0 && (o.has("OES_texture_float_linear") === !0 ? (l.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, l.rectAreaLTC2 =
			UniformsLib.LTC_FLOAT_2) : (l.rectAreaLTC1 = UniformsLib.LTC_HALF_1, l.rectAreaLTC2 = UniformsLib
			.LTC_HALF_2)), l.ambient[0] = y, l.ambient[1] = b, l.ambient[2] = C;
		const U = l.hash;
		(U.directionalLength !== _ || U.pointLength !== S || U.spotLength !== w || U.rectAreaLength !== T || U
			.hemiLength !== A || U.numDirectionalShadows !== k || U.numPointShadows !== M || U.numSpotShadows !== D || U
			.numSpotMaps !== F || U.numLightProbes !== O) && (l.directional.length = _, l.spot.length = w, l.rectArea
			.length = T, l.point.length = S, l.hemi.length = A, l.directionalShadow.length = k, l.directionalShadowMap
			.length = k, l.pointShadow.length = M, l.pointShadowMap.length = M, l.spotShadow.length = D, l.spotShadowMap
			.length = D, l.directionalShadowMatrix.length = k, l.pointShadowMatrix.length = M, l.spotLightMatrix
			.length = D + F - R, l.spotLightMap.length = F, l.numSpotLightShadowsWithMaps = R, l.numLightProbes = O, U
			.directionalLength = _, U.pointLength = S, U.spotLength = w, U.rectAreaLength = T, U.hemiLength = A, U
			.numDirectionalShadows = k, U.numPointShadows = M, U.numSpotShadows = D, U.numSpotMaps = F, U
			.numLightProbes = O, l.version = nextVersion++)
	}

	function g(v, y) {
		let b = 0,
			C = 0,
			_ = 0,
			S = 0,
			w = 0;
		const T = y.matrixWorldInverse;
		for (let A = 0, k = v.length; A < k; A++) {
			const M = v[A];
			if (M.isDirectionalLight) {
				const D = l.directional[b];
				D.direction.setFromMatrixPosition(M.matrixWorld), c.setFromMatrixPosition(M.target.matrixWorld), D
					.direction.sub(c), D.direction.transformDirection(T), b++
			} else if (M.isSpotLight) {
				const D = l.spot[_];
				D.position.setFromMatrixPosition(M.matrixWorld), D.position.applyMatrix4(T), D.direction
					.setFromMatrixPosition(M.matrixWorld), c.setFromMatrixPosition(M.target.matrixWorld), D.direction
					.sub(c), D.direction.transformDirection(T), _++
			} else if (M.isRectAreaLight) {
				const D = l.rectArea[S];
				D.position.setFromMatrixPosition(M.matrixWorld), D.position.applyMatrix4(T), f.identity(), d.copy(M
						.matrixWorld), d.premultiply(T), f.extractRotation(d), D.halfWidth.set(M.width * .5, 0, 0), D
					.halfHeight.set(0, M.height * .5, 0), D.halfWidth.applyMatrix4(f), D.halfHeight.applyMatrix4(f), S++
			} else if (M.isPointLight) {
				const D = l.point[C];
				D.position.setFromMatrixPosition(M.matrixWorld), D.position.applyMatrix4(T), C++
			} else if (M.isHemisphereLight) {
				const D = l.hemi[w];
				D.direction.setFromMatrixPosition(M.matrixWorld), D.direction.transformDirection(T), w++
			}
		}
	}
	return {
		setup: m,
		setupView: g,
		state: l
	}
}

function WebGLRenderState(o) {
	const s = new WebGLLights(o),
		a = [],
		l = [];

	function c(y) {
		v.camera = y, a.length = 0, l.length = 0
	}

	function d(y) {
		a.push(y)
	}

	function f(y) {
		l.push(y)
	}

	function m() {
		s.setup(a)
	}

	function g(y) {
		s.setupView(a, y)
	}
	const v = {
		lightsArray: a,
		shadowsArray: l,
		camera: null,
		lights: s,
		transmissionRenderTarget: {}
	};
	return {
		init: c,
		state: v,
		setupLights: m,
		setupLightsView: g,
		pushLight: d,
		pushShadow: f
	}
}

function WebGLRenderStates(o) {
	let s = new WeakMap;

	function a(c, d = 0) {
		const f = s.get(c);
		let m;
		return f === void 0 ? (m = new WebGLRenderState(o), s.set(c, [m])) : d >= f.length ? (m = new WebGLRenderState(
			o), f.push(m)) : m = f[d], m
	}

	function l() {
		s = new WeakMap
	}
	return {
		get: a,
		dispose: l
	}
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
	fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function WebGLShadowMap(o, s, a) {
	let l = new Frustum;
	const c = new Vector2,
		d = new Vector2,
		f = new Vector4,
		m = new MeshDepthMaterial({
			depthPacking: RGBADepthPacking
		}),
		g = new MeshDistanceMaterial,
		v = {},
		y = a.maxTextureSize,
		b = {
			[FrontSide]: BackSide,
			[BackSide]: FrontSide,
			[DoubleSide]: DoubleSide
		},
		C = new ShaderMaterial({
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2
				},
				radius: {
					value: 4
				}
			},
			vertexShader: vertex,
			fragmentShader: fragment
		}),
		_ = C.clone();
	_.defines.HORIZONTAL_PASS = 1;
	const S = new BufferGeometry;
	S.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
	const w = new Mesh(S, C),
		T = this;
	this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap;
	let A = this.type;
	this.render = function(R, O, U) {
		if (T.enabled === !1 || T.autoUpdate === !1 && T.needsUpdate === !1 || R.length === 0) return;
		const V = o.getRenderTarget(),
			z = o.getActiveCubeFace(),
			j = o.getActiveMipmapLevel(),
			ge = o.state;
		ge.setBlending(NoBlending), ge.buffers.color.setClear(1, 1, 1, 1), ge.buffers.depth.setTest(!0), ge
			.setScissorTest(!1);
		const me = A !== VSMShadowMap && this.type === VSMShadowMap,
			he = A === VSMShadowMap && this.type !== VSMShadowMap;
		for (let ce = 0, ae = R.length; ce < ae; ce++) {
			const fe = R[ce],
				q = fe.shadow;
			if (q === void 0) {
				console.warn("THREE.WebGLShadowMap:", fe, "has no shadow.");
				continue
			}
			if (q.autoUpdate === !1 && q.needsUpdate === !1) continue;
			c.copy(q.mapSize);
			const le = q.getFrameExtents();
			if (c.multiply(le), d.copy(q.mapSize), (c.x > y || c.y > y) && (c.x > y && (d.x = Math.floor(y / le.x),
					c.x = d.x * le.x, q.mapSize.x = d.x), c.y > y && (d.y = Math.floor(y / le.y), c.y = d.y * le
					.y, q.mapSize.y = d.y)), q.map === null || me === !0 || he === !0) {
				const _e = this.type !== VSMShadowMap ? {
					minFilter: NearestFilter,
					magFilter: NearestFilter
				} : {};
				q.map !== null && q.map.dispose(), q.map = new WebGLRenderTarget(c.x, c.y, _e), q.map.texture.name =
					fe.name + ".shadowMap", q.camera.updateProjectionMatrix()
			}
			o.setRenderTarget(q.map), o.clear();
			const de = q.getViewportCount();
			for (let _e = 0; _e < de; _e++) {
				const ke = q.getViewport(_e);
				f.set(d.x * ke.x, d.y * ke.y, d.x * ke.z, d.y * ke.w), ge.viewport(f), q.updateMatrices(fe, _e), l =
					q.getFrustum(), D(O, U, q.camera, fe, this.type)
			}
			q.isPointLightShadow !== !0 && this.type === VSMShadowMap && k(q, U), q.needsUpdate = !1
		}
		A = this.type, T.needsUpdate = !1, o.setRenderTarget(V, z, j)
	};

	function k(R, O) {
		const U = s.update(w);
		C.defines.VSM_SAMPLES !== R.blurSamples && (C.defines.VSM_SAMPLES = R.blurSamples, _.defines.VSM_SAMPLES = R
				.blurSamples, C.needsUpdate = !0, _.needsUpdate = !0), R.mapPass === null && (R.mapPass =
				new WebGLRenderTarget(c.x, c.y)), C.uniforms.shadow_pass.value = R.map.texture, C.uniforms.resolution
			.value = R.mapSize, C.uniforms.radius.value = R.radius, o.setRenderTarget(R.mapPass), o.clear(), o
			.renderBufferDirect(O, null, U, C, w, null), _.uniforms.shadow_pass.value = R.mapPass.texture, _.uniforms
			.resolution.value = R.mapSize, _.uniforms.radius.value = R.radius, o.setRenderTarget(R.map), o.clear(), o
			.renderBufferDirect(O, null, U, _, w, null)
	}

	function M(R, O, U, V) {
		let z = null;
		const j = U.isPointLight === !0 ? R.customDistanceMaterial : R.customDepthMaterial;
		if (j !== void 0) z = j;
		else if (z = U.isPointLight === !0 ? g : m, o.localClippingEnabled && O.clipShadows === !0 && Array.isArray(O
				.clippingPlanes) && O.clippingPlanes.length !== 0 || O.displacementMap && O.displacementScale !== 0 || O
			.alphaMap && O.alphaTest > 0 || O.map && O.alphaTest > 0 || O.alphaToCoverage === !0) {
			const ge = z.uuid,
				me = O.uuid;
			let he = v[ge];
			he === void 0 && (he = {}, v[ge] = he);
			let ce = he[me];
			ce === void 0 && (ce = z.clone(), he[me] = ce, O.addEventListener("dispose", F)), z = ce
		}
		if (z.visible = O.visible, z.wireframe = O.wireframe, V === VSMShadowMap ? z.side = O.shadowSide !== null ? O
			.shadowSide : O.side : z.side = O.shadowSide !== null ? O.shadowSide : b[O.side], z.alphaMap = O.alphaMap, z
			.alphaTest = O.alphaToCoverage === !0 ? .5 : O.alphaTest, z.map = O.map, z.clipShadows = O.clipShadows, z
			.clippingPlanes = O.clippingPlanes, z.clipIntersection = O.clipIntersection, z.displacementMap = O
			.displacementMap, z.displacementScale = O.displacementScale, z.displacementBias = O.displacementBias, z
			.wireframeLinewidth = O.wireframeLinewidth, z.linewidth = O.linewidth, U.isPointLight === !0 && z
			.isMeshDistanceMaterial === !0) {
			const ge = o.properties.get(z);
			ge.light = U
		}
		return z
	}

	function D(R, O, U, V, z) {
		if (R.visible === !1) return;
		if (R.layers.test(O.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && z ===
				VSMShadowMap) && (!R.frustumCulled || l.intersectsObject(R))) {
			R.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, R.matrixWorld);
			const me = s.update(R),
				he = R.material;
			if (Array.isArray(he)) {
				const ce = me.groups;
				for (let ae = 0, fe = ce.length; ae < fe; ae++) {
					const q = ce[ae],
						le = he[q.materialIndex];
					if (le && le.visible) {
						const de = M(R, le, V, z);
						R.onBeforeShadow(o, R, O, U, me, de, q), o.renderBufferDirect(U, null, me, de, R, q), R
							.onAfterShadow(o, R, O, U, me, de, q)
					}
				}
			} else if (he.visible) {
				const ce = M(R, he, V, z);
				R.onBeforeShadow(o, R, O, U, me, ce, null), o.renderBufferDirect(U, null, me, ce, R, null), R
					.onAfterShadow(o, R, O, U, me, ce, null)
			}
		}
		const ge = R.children;
		for (let me = 0, he = ge.length; me < he; me++) D(ge[me], O, U, V, z)
	}

	function F(R) {
		R.target.removeEventListener("dispose", F);
		for (const U in v) {
			const V = v[U],
				z = R.target.uuid;
			z in V && (V[z].dispose(), delete V[z])
		}
	}
}
const reversedFuncs = {
	[NeverDepth]: AlwaysDepth,
	[LessDepth]: GreaterDepth,
	[EqualDepth]: NotEqualDepth,
	[LessEqualDepth]: GreaterEqualDepth,
	[AlwaysDepth]: NeverDepth,
	[GreaterDepth]: LessDepth,
	[NotEqualDepth]: EqualDepth,
	[GreaterEqualDepth]: LessEqualDepth
};

function WebGLState(o, s) {
	function a() {
		let Qe = !1;
		const At = new Vector4;
		let Ct = null;
		const xt = new Vector4(0, 0, 0, 0);
		return {
			setMask: function(Rt) {
				Ct !== Rt && !Qe && (o.colorMask(Rt, Rt, Rt, Rt), Ct = Rt)
			},
			setLocked: function(Rt) {
				Qe = Rt
			},
			setClear: function(Rt, $t, zt, sn, dn) {
				dn === !0 && (Rt *= sn, $t *= sn, zt *= sn), At.set(Rt, $t, zt, sn), xt.equals(At) === !1 && (o
					.clearColor(Rt, $t, zt, sn), xt.copy(At))
			},
			reset: function() {
				Qe = !1, Ct = null, xt.set(-1, 0, 0, 0)
			}
		}
	}

	function l() {
		let Qe = !1,
			At = !1,
			Ct = null,
			xt = null,
			Rt = null;
		return {
			setReversed: function($t) {
				if (At !== $t) {
					const zt = s.get("EXT_clip_control");
					$t ? zt.clipControlEXT(zt.LOWER_LEFT_EXT, zt.ZERO_TO_ONE_EXT) : zt.clipControlEXT(zt
						.LOWER_LEFT_EXT, zt.NEGATIVE_ONE_TO_ONE_EXT), At = $t;
					const sn = Rt;
					Rt = null, this.setClear(sn)
				}
			},
			getReversed: function() {
				return At
			},
			setTest: function($t) {
				$t ? Ve(o.DEPTH_TEST) : it(o.DEPTH_TEST)
			},
			setMask: function($t) {
				Ct !== $t && !Qe && (o.depthMask($t), Ct = $t)
			},
			setFunc: function($t) {
				if (At && ($t = reversedFuncs[$t]), xt !== $t) {
					switch ($t) {
						case NeverDepth:
							o.depthFunc(o.NEVER);
							break;
						case AlwaysDepth:
							o.depthFunc(o.ALWAYS);
							break;
						case LessDepth:
							o.depthFunc(o.LESS);
							break;
						case LessEqualDepth:
							o.depthFunc(o.LEQUAL);
							break;
						case EqualDepth:
							o.depthFunc(o.EQUAL);
							break;
						case GreaterEqualDepth:
							o.depthFunc(o.GEQUAL);
							break;
						case GreaterDepth:
							o.depthFunc(o.GREATER);
							break;
						case NotEqualDepth:
							o.depthFunc(o.NOTEQUAL);
							break;
						default:
							o.depthFunc(o.LEQUAL)
					}
					xt = $t
				}
			},
			setLocked: function($t) {
				Qe = $t
			},
			setClear: function($t) {
				Rt !== $t && (At && ($t = 1 - $t), o.clearDepth($t), Rt = $t)
			},
			reset: function() {
				Qe = !1, Ct = null, xt = null, Rt = null, At = !1
			}
		}
	}

	function c() {
		let Qe = !1,
			At = null,
			Ct = null,
			xt = null,
			Rt = null,
			$t = null,
			zt = null,
			sn = null,
			dn = null;
		return {
			setTest: function(Mt) {
				Qe || (Mt ? Ve(o.STENCIL_TEST) : it(o.STENCIL_TEST))
			},
			setMask: function(Mt) {
				At !== Mt && !Qe && (o.stencilMask(Mt), At = Mt)
			},
			setFunc: function(Mt, qt, pn) {
				(Ct !== Mt || xt !== qt || Rt !== pn) && (o.stencilFunc(Mt, qt, pn), Ct = Mt, xt = qt, Rt = pn)
			},
			setOp: function(Mt, qt, pn) {
				($t !== Mt || zt !== qt || sn !== pn) && (o.stencilOp(Mt, qt, pn), $t = Mt, zt = qt, sn = pn)
			},
			setLocked: function(Mt) {
				Qe = Mt
			},
			setClear: function(Mt) {
				dn !== Mt && (o.clearStencil(Mt), dn = Mt)
			},
			reset: function() {
				Qe = !1, At = null, Ct = null, xt = null, Rt = null, $t = null, zt = null, sn = null, dn = null
			}
		}
	}
	const d = new a,
		f = new l,
		m = new c,
		g = new WeakMap,
		v = new WeakMap;
	let y = {},
		b = {},
		C = new WeakMap,
		_ = [],
		S = null,
		w = !1,
		T = null,
		A = null,
		k = null,
		M = null,
		D = null,
		F = null,
		R = null,
		O = new Color(0, 0, 0),
		U = 0,
		V = !1,
		z = null,
		j = null,
		ge = null,
		me = null,
		he = null;
	const ce = o.getParameter(o.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	let ae = !1,
		fe = 0;
	const q = o.getParameter(o.VERSION);
	q.indexOf("WebGL") !== -1 ? (fe = parseFloat(/^WebGL (\d)/.exec(q)[1]), ae = fe >= 1) : q.indexOf("OpenGL ES") !== -
		1 && (fe = parseFloat(/^OpenGL ES (\d)/.exec(q)[1]), ae = fe >= 2);
	let le = null,
		de = {};
	const _e = o.getParameter(o.SCISSOR_BOX),
		ke = o.getParameter(o.VIEWPORT),
		De = new Vector4().fromArray(_e),
		Se = new Vector4().fromArray(ke);

	function be(Qe, At, Ct, xt) {
		const Rt = new Uint8Array(4),
			$t = o.createTexture();
		o.bindTexture(Qe, $t), o.texParameteri(Qe, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(Qe, o
			.TEXTURE_MAG_FILTER, o.NEAREST);
		for (let zt = 0; zt < Ct; zt++) Qe === o.TEXTURE_3D || Qe === o.TEXTURE_2D_ARRAY ? o.texImage3D(At, 0, o.RGBA,
			1, 1, xt, 0, o.RGBA, o.UNSIGNED_BYTE, Rt) : o.texImage2D(At + zt, 0, o.RGBA, 1, 1, 0, o.RGBA, o
			.UNSIGNED_BYTE, Rt);
		return $t
	}
	const Me = {};
	Me[o.TEXTURE_2D] = be(o.TEXTURE_2D, o.TEXTURE_2D, 1), Me[o.TEXTURE_CUBE_MAP] = be(o.TEXTURE_CUBE_MAP, o
			.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Me[o.TEXTURE_2D_ARRAY] = be(o.TEXTURE_2D_ARRAY, o.TEXTURE_2D_ARRAY, 1, 1),
		Me[o.TEXTURE_3D] = be(o.TEXTURE_3D, o.TEXTURE_3D, 1, 1), d.setClear(0, 0, 0, 1), f.setClear(1), m.setClear(0),
		Ve(o.DEPTH_TEST), f.setFunc(LessEqualDepth), Ue(!1), nt(CullFaceBack), Ve(o.CULL_FACE), ye(NoBlending);

	function Ve(Qe) {
		y[Qe] !== !0 && (o.enable(Qe), y[Qe] = !0)
	}

	function it(Qe) {
		y[Qe] !== !1 && (o.disable(Qe), y[Qe] = !1)
	}

	function pt(Qe, At) {
		return b[Qe] !== At ? (o.bindFramebuffer(Qe, At), b[Qe] = At, Qe === o.DRAW_FRAMEBUFFER && (b[o.FRAMEBUFFER] =
			At), Qe === o.FRAMEBUFFER && (b[o.DRAW_FRAMEBUFFER] = At), !0) : !1
	}

	function dt(Qe, At) {
		let Ct = _,
			xt = !1;
		if (Qe) {
			Ct = C.get(At), Ct === void 0 && (Ct = [], C.set(At, Ct));
			const Rt = Qe.textures;
			if (Ct.length !== Rt.length || Ct[0] !== o.COLOR_ATTACHMENT0) {
				for (let $t = 0, zt = Rt.length; $t < zt; $t++) Ct[$t] = o.COLOR_ATTACHMENT0 + $t;
				Ct.length = Rt.length, xt = !0
			}
		} else Ct[0] !== o.BACK && (Ct[0] = o.BACK, xt = !0);
		xt && o.drawBuffers(Ct)
	}

	function He(Qe) {
		return S !== Qe ? (o.useProgram(Qe), S = Qe, !0) : !1
	}
	const Ae = {
		[AddEquation]: o.FUNC_ADD,
		[SubtractEquation]: o.FUNC_SUBTRACT,
		[ReverseSubtractEquation]: o.FUNC_REVERSE_SUBTRACT
	};
	Ae[MinEquation] = o.MIN, Ae[MaxEquation] = o.MAX;
	const xe = {
		[ZeroFactor]: o.ZERO,
		[OneFactor]: o.ONE,
		[SrcColorFactor]: o.SRC_COLOR,
		[SrcAlphaFactor]: o.SRC_ALPHA,
		[SrcAlphaSaturateFactor]: o.SRC_ALPHA_SATURATE,
		[DstColorFactor]: o.DST_COLOR,
		[DstAlphaFactor]: o.DST_ALPHA,
		[OneMinusSrcColorFactor]: o.ONE_MINUS_SRC_COLOR,
		[OneMinusSrcAlphaFactor]: o.ONE_MINUS_SRC_ALPHA,
		[OneMinusDstColorFactor]: o.ONE_MINUS_DST_COLOR,
		[OneMinusDstAlphaFactor]: o.ONE_MINUS_DST_ALPHA,
		[ConstantColorFactor]: o.CONSTANT_COLOR,
		[OneMinusConstantColorFactor]: o.ONE_MINUS_CONSTANT_COLOR,
		[ConstantAlphaFactor]: o.CONSTANT_ALPHA,
		[OneMinusConstantAlphaFactor]: o.ONE_MINUS_CONSTANT_ALPHA
	};

	function ye(Qe, At, Ct, xt, Rt, $t, zt, sn, dn, Mt) {
		if (Qe === NoBlending) {
			w === !0 && (it(o.BLEND), w = !1);
			return
		}
		if (w === !1 && (Ve(o.BLEND), w = !0), Qe !== CustomBlending) {
			if (Qe !== T || Mt !== V) {
				if ((A !== AddEquation || D !== AddEquation) && (o.blendEquation(o.FUNC_ADD), A = AddEquation, D =
						AddEquation), Mt) switch (Qe) {
					case NormalBlending:
						o.blendFuncSeparate(o.ONE, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA);
						break;
					case AdditiveBlending:
						o.blendFunc(o.ONE, o.ONE);
						break;
					case SubtractiveBlending:
						o.blendFuncSeparate(o.ZERO, o.ONE_MINUS_SRC_COLOR, o.ZERO, o.ONE);
						break;
					case MultiplyBlending:
						o.blendFuncSeparate(o.ZERO, o.SRC_COLOR, o.ZERO, o.SRC_ALPHA);
						break;
					default:
						console.error("THREE.WebGLState: Invalid blending: ", Qe);
						break
				} else switch (Qe) {
					case NormalBlending:
						o.blendFuncSeparate(o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA);
						break;
					case AdditiveBlending:
						o.blendFunc(o.SRC_ALPHA, o.ONE);
						break;
					case SubtractiveBlending:
						o.blendFuncSeparate(o.ZERO, o.ONE_MINUS_SRC_COLOR, o.ZERO, o.ONE);
						break;
					case MultiplyBlending:
						o.blendFunc(o.ZERO, o.SRC_COLOR);
						break;
					default:
						console.error("THREE.WebGLState: Invalid blending: ", Qe);
						break
				}
				k = null, M = null, F = null, R = null, O.set(0, 0, 0), U = 0, T = Qe, V = Mt
			}
			return
		}
		Rt = Rt || At, $t = $t || Ct, zt = zt || xt, (At !== A || Rt !== D) && (o.blendEquationSeparate(Ae[At], Ae[Rt]),
			A = At, D = Rt), (Ct !== k || xt !== M || $t !== F || zt !== R) && (o.blendFuncSeparate(xe[Ct], xe[xt],
			xe[$t], xe[zt]), k = Ct, M = xt, F = $t, R = zt), (sn.equals(O) === !1 || dn !== U) && (o.blendColor(sn
			.r, sn.g, sn.b, dn), O.copy(sn), U = dn), T = Qe, V = !1
	}

	function Le(Qe, At) {
		Qe.side === DoubleSide ? it(o.CULL_FACE) : Ve(o.CULL_FACE);
		let Ct = Qe.side === BackSide;
		At && (Ct = !Ct), Ue(Ct), Qe.blending === NormalBlending && Qe.transparent === !1 ? ye(NoBlending) : ye(Qe
				.blending, Qe.blendEquation, Qe.blendSrc, Qe.blendDst, Qe.blendEquationAlpha, Qe.blendSrcAlpha, Qe
				.blendDstAlpha, Qe.blendColor, Qe.blendAlpha, Qe.premultipliedAlpha), f.setFunc(Qe.depthFunc), f
			.setTest(Qe.depthTest), f.setMask(Qe.depthWrite), d.setMask(Qe.colorWrite);
		const xt = Qe.stencilWrite;
		m.setTest(xt), xt && (m.setMask(Qe.stencilWriteMask), m.setFunc(Qe.stencilFunc, Qe.stencilRef, Qe
				.stencilFuncMask), m.setOp(Qe.stencilFail, Qe.stencilZFail, Qe.stencilZPass)), at(Qe.polygonOffset, Qe
				.polygonOffsetFactor, Qe.polygonOffsetUnits), Qe.alphaToCoverage === !0 ? Ve(o
			.SAMPLE_ALPHA_TO_COVERAGE) : it(o.SAMPLE_ALPHA_TO_COVERAGE)
	}

	function Ue(Qe) {
		z !== Qe && (Qe ? o.frontFace(o.CW) : o.frontFace(o.CCW), z = Qe)
	}

	function nt(Qe) {
		Qe !== CullFaceNone ? (Ve(o.CULL_FACE), Qe !== j && (Qe === CullFaceBack ? o.cullFace(o.BACK) : Qe ===
			CullFaceFront ? o.cullFace(o.FRONT) : o.cullFace(o.FRONT_AND_BACK))) : it(o.CULL_FACE), j = Qe
	}

	function ot(Qe) {
		Qe !== ge && (ae && o.lineWidth(Qe), ge = Qe)
	}

	function at(Qe, At, Ct) {
		Qe ? (Ve(o.POLYGON_OFFSET_FILL), (me !== At || he !== Ct) && (o.polygonOffset(At, Ct), me = At, he = Ct)) : it(o
			.POLYGON_OFFSET_FILL)
	}

	function Je(Qe) {
		Qe ? Ve(o.SCISSOR_TEST) : it(o.SCISSOR_TEST)
	}

	function Ne(Qe) {
		Qe === void 0 && (Qe = o.TEXTURE0 + ce - 1), le !== Qe && (o.activeTexture(Qe), le = Qe)
	}

	function we(Qe, At, Ct) {
		Ct === void 0 && (le === null ? Ct = o.TEXTURE0 + ce - 1 : Ct = le);
		let xt = de[Ct];
		xt === void 0 && (xt = {
			type: void 0,
			texture: void 0
		}, de[Ct] = xt), (xt.type !== Qe || xt.texture !== At) && (le !== Ct && (o.activeTexture(Ct), le = Ct), o
			.bindTexture(Qe, At || Me[Qe]), xt.type = Qe, xt.texture = At)
	}

	function Ce() {
		const Qe = de[le];
		Qe !== void 0 && Qe.type !== void 0 && (o.bindTexture(Qe.type, null), Qe.type = void 0, Qe.texture = void 0)
	}

	function $e() {
		try {
			o.compressedTexImage2D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function Fe() {
		try {
			o.compressedTexImage3D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function Ge() {
		try {
			o.texSubImage2D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function ze() {
		try {
			o.texSubImage3D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function Oe() {
		try {
			o.compressedTexSubImage2D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function Xe() {
		try {
			o.compressedTexSubImage3D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function rt() {
		try {
			o.texStorage2D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function ut() {
		try {
			o.texStorage3D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function gt() {
		try {
			o.texImage2D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function Et() {
		try {
			o.texImage3D(...arguments)
		} catch (Qe) {
			console.error("THREE.WebGLState:", Qe)
		}
	}

	function Ze(Qe) {
		De.equals(Qe) === !1 && (o.scissor(Qe.x, Qe.y, Qe.z, Qe.w), De.copy(Qe))
	}

	function Ye(Qe) {
		Se.equals(Qe) === !1 && (o.viewport(Qe.x, Qe.y, Qe.z, Qe.w), Se.copy(Qe))
	}

	function ct(Qe, At) {
		let Ct = v.get(At);
		Ct === void 0 && (Ct = new WeakMap, v.set(At, Ct));
		let xt = Ct.get(Qe);
		xt === void 0 && (xt = o.getUniformBlockIndex(At, Qe.name), Ct.set(Qe, xt))
	}

	function yt(Qe, At) {
		const xt = v.get(At).get(Qe);
		g.get(At) !== xt && (o.uniformBlockBinding(At, xt, Qe.__bindingPointIndex), g.set(At, xt))
	}

	function wt() {
		o.disable(o.BLEND), o.disable(o.CULL_FACE), o.disable(o.DEPTH_TEST), o.disable(o.POLYGON_OFFSET_FILL), o
			.disable(o.SCISSOR_TEST), o.disable(o.STENCIL_TEST), o.disable(o.SAMPLE_ALPHA_TO_COVERAGE), o.blendEquation(
				o.FUNC_ADD), o.blendFunc(o.ONE, o.ZERO), o.blendFuncSeparate(o.ONE, o.ZERO, o.ONE, o.ZERO), o
			.blendColor(0, 0, 0, 0), o.colorMask(!0, !0, !0, !0), o.clearColor(0, 0, 0, 0), o.depthMask(!0), o
			.depthFunc(o.LESS), f.setReversed(!1), o.clearDepth(1), o.stencilMask(4294967295), o.stencilFunc(o.ALWAYS,
				0, 4294967295), o.stencilOp(o.KEEP, o.KEEP, o.KEEP), o.clearStencil(0), o.cullFace(o.BACK), o.frontFace(
				o.CCW), o.polygonOffset(0, 0), o.activeTexture(o.TEXTURE0), o.bindFramebuffer(o.FRAMEBUFFER, null), o
			.bindFramebuffer(o.DRAW_FRAMEBUFFER, null), o.bindFramebuffer(o.READ_FRAMEBUFFER, null), o.useProgram(null),
			o.lineWidth(1), o.scissor(0, 0, o.canvas.width, o.canvas.height), o.viewport(0, 0, o.canvas.width, o.canvas
				.height), y = {}, le = null, de = {}, b = {}, C = new WeakMap, _ = [], S = null, w = !1, T = null, A =
			null, k = null, M = null, D = null, F = null, R = null, O = new Color(0, 0, 0), U = 0, V = !1, z = null, j =
			null, ge = null, me = null, he = null, De.set(0, 0, o.canvas.width, o.canvas.height), Se.set(0, 0, o.canvas
				.width, o.canvas.height), d.reset(), f.reset(), m.reset()
	}
	return {
		buffers: {
			color: d,
			depth: f,
			stencil: m
		},
		enable: Ve,
		disable: it,
		bindFramebuffer: pt,
		drawBuffers: dt,
		useProgram: He,
		setBlending: ye,
		setMaterial: Le,
		setFlipSided: Ue,
		setCullFace: nt,
		setLineWidth: ot,
		setPolygonOffset: at,
		setScissorTest: Je,
		activeTexture: Ne,
		bindTexture: we,
		unbindTexture: Ce,
		compressedTexImage2D: $e,
		compressedTexImage3D: Fe,
		texImage2D: gt,
		texImage3D: Et,
		updateUBOMapping: ct,
		uniformBlockBinding: yt,
		texStorage2D: rt,
		texStorage3D: ut,
		texSubImage2D: Ge,
		texSubImage3D: ze,
		compressedTexSubImage2D: Oe,
		compressedTexSubImage3D: Xe,
		scissor: Ze,
		viewport: Ye,
		reset: wt
	}
}

function WebGLTextures(o, s, a, l, c, d, f) {
	const m = s.has("WEBGL_multisampled_render_to_texture") ? s.get("WEBGL_multisampled_render_to_texture") : null,
		g = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
		v = new Vector2,
		y = new WeakMap;
	let b;
	const C = new WeakMap;
	let _ = !1;
	try {
		_ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
	} catch {}

	function S(Ne, we) {
		return _ ? new OffscreenCanvas(Ne, we) : createElementNS("canvas")
	}

	function w(Ne, we, Ce) {
		let $e = 1;
		const Fe = Je(Ne);
		if ((Fe.width > Ce || Fe.height > Ce) && ($e = Ce / Math.max(Fe.width, Fe.height)), $e < 1)
			if (typeof HTMLImageElement < "u" && Ne instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" &&
				Ne instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Ne instanceof ImageBitmap ||
				typeof VideoFrame < "u" && Ne instanceof VideoFrame) {
				const Ge = Math.floor($e * Fe.width),
					ze = Math.floor($e * Fe.height);
				b === void 0 && (b = S(Ge, ze));
				const Oe = we ? S(Ge, ze) : b;
				return Oe.width = Ge, Oe.height = ze, Oe.getContext("2d").drawImage(Ne, 0, 0, Ge, ze), console.warn(
					"THREE.WebGLRenderer: Texture has been resized from (" + Fe.width + "x" + Fe.height + ") to (" +
					Ge + "x" + ze + ")."), Oe
			} else return "data" in Ne && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Fe
				.width + "x" + Fe.height + ")."), Ne;
		return Ne
	}

	function T(Ne) {
		return Ne.generateMipmaps
	}

	function A(Ne) {
		o.generateMipmap(Ne)
	}

	function k(Ne) {
		return Ne.isWebGLCubeRenderTarget ? o.TEXTURE_CUBE_MAP : Ne.isWebGL3DRenderTarget ? o.TEXTURE_3D : Ne
			.isWebGLArrayRenderTarget || Ne.isCompressedArrayTexture ? o.TEXTURE_2D_ARRAY : o.TEXTURE_2D
	}

	function M(Ne, we, Ce, $e, Fe = !1) {
		if (Ne !== null) {
			if (o[Ne] !== void 0) return o[Ne];
			console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Ne + "'")
		}
		let Ge = we;
		if (we === o.RED && (Ce === o.FLOAT && (Ge = o.R32F), Ce === o.HALF_FLOAT && (Ge = o.R16F), Ce === o
				.UNSIGNED_BYTE && (Ge = o.R8)), we === o.RED_INTEGER && (Ce === o.UNSIGNED_BYTE && (Ge = o.R8UI), Ce ===
				o.UNSIGNED_SHORT && (Ge = o.R16UI), Ce === o.UNSIGNED_INT && (Ge = o.R32UI), Ce === o.BYTE && (Ge = o
					.R8I), Ce === o.SHORT && (Ge = o.R16I), Ce === o.INT && (Ge = o.R32I)), we === o.RG && (Ce === o
				.FLOAT && (Ge = o.RG32F), Ce === o.HALF_FLOAT && (Ge = o.RG16F), Ce === o.UNSIGNED_BYTE && (Ge = o.RG8)
				), we === o.RG_INTEGER && (Ce === o.UNSIGNED_BYTE && (Ge = o.RG8UI), Ce === o.UNSIGNED_SHORT && (Ge = o
					.RG16UI), Ce === o.UNSIGNED_INT && (Ge = o.RG32UI), Ce === o.BYTE && (Ge = o.RG8I), Ce === o
				.SHORT && (Ge = o.RG16I), Ce === o.INT && (Ge = o.RG32I)), we === o.RGB_INTEGER && (Ce === o
				.UNSIGNED_BYTE && (Ge = o.RGB8UI), Ce === o.UNSIGNED_SHORT && (Ge = o.RGB16UI), Ce === o.UNSIGNED_INT &&
				(Ge = o.RGB32UI), Ce === o.BYTE && (Ge = o.RGB8I), Ce === o.SHORT && (Ge = o.RGB16I), Ce === o.INT && (
					Ge = o.RGB32I)), we === o.RGBA_INTEGER && (Ce === o.UNSIGNED_BYTE && (Ge = o.RGBA8UI), Ce === o
				.UNSIGNED_SHORT && (Ge = o.RGBA16UI), Ce === o.UNSIGNED_INT && (Ge = o.RGBA32UI), Ce === o.BYTE && (Ge =
					o.RGBA8I), Ce === o.SHORT && (Ge = o.RGBA16I), Ce === o.INT && (Ge = o.RGBA32I)), we === o.RGB &&
			Ce === o.UNSIGNED_INT_5_9_9_9_REV && (Ge = o.RGB9_E5), we === o.RGBA) {
			const ze = Fe ? LinearTransfer : ColorManagement.getTransfer($e);
			Ce === o.FLOAT && (Ge = o.RGBA32F), Ce === o.HALF_FLOAT && (Ge = o.RGBA16F), Ce === o.UNSIGNED_BYTE && (Ge =
					ze === SRGBTransfer ? o.SRGB8_ALPHA8 : o.RGBA8), Ce === o.UNSIGNED_SHORT_4_4_4_4 && (Ge = o.RGBA4),
				Ce === o.UNSIGNED_SHORT_5_5_5_1 && (Ge = o.RGB5_A1)
		}
		return (Ge === o.R16F || Ge === o.R32F || Ge === o.RG16F || Ge === o.RG32F || Ge === o.RGBA16F || Ge === o
			.RGBA32F) && s.get("EXT_color_buffer_float"), Ge
	}

	function D(Ne, we) {
		let Ce;
		return Ne ? we === null || we === UnsignedIntType || we === UnsignedInt248Type ? Ce = o.DEPTH24_STENCIL8 :
			we === FloatType ? Ce = o.DEPTH32F_STENCIL8 : we === UnsignedShortType && (Ce = o.DEPTH24_STENCIL8, console
				.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")
				) : we === null || we === UnsignedIntType || we === UnsignedInt248Type ? Ce = o.DEPTH_COMPONENT24 :
			we === FloatType ? Ce = o.DEPTH_COMPONENT32F : we === UnsignedShortType && (Ce = o.DEPTH_COMPONENT16), Ce
	}

	function F(Ne, we) {
		return T(Ne) === !0 || Ne.isFramebufferTexture && Ne.minFilter !== NearestFilter && Ne.minFilter !==
			LinearFilter ? Math.log2(Math.max(we.width, we.height)) + 1 : Ne.mipmaps !== void 0 && Ne.mipmaps.length >
			0 ? Ne.mipmaps.length : Ne.isCompressedTexture && Array.isArray(Ne.image) ? we.mipmaps.length : 1
	}

	function R(Ne) {
		const we = Ne.target;
		we.removeEventListener("dispose", R), U(we), we.isVideoTexture && y.delete(we)
	}

	function O(Ne) {
		const we = Ne.target;
		we.removeEventListener("dispose", O), z(we)
	}

	function U(Ne) {
		const we = l.get(Ne);
		if (we.__webglInit === void 0) return;
		const Ce = Ne.source,
			$e = C.get(Ce);
		if ($e) {
			const Fe = $e[we.__cacheKey];
			Fe.usedTimes--, Fe.usedTimes === 0 && V(Ne), Object.keys($e).length === 0 && C.delete(Ce)
		}
		l.remove(Ne)
	}

	function V(Ne) {
		const we = l.get(Ne);
		o.deleteTexture(we.__webglTexture);
		const Ce = Ne.source,
			$e = C.get(Ce);
		delete $e[we.__cacheKey], f.memory.textures--
	}

	function z(Ne) {
		const we = l.get(Ne);
		if (Ne.depthTexture && (Ne.depthTexture.dispose(), l.remove(Ne.depthTexture)), Ne.isWebGLCubeRenderTarget)
			for (let $e = 0; $e < 6; $e++) {
				if (Array.isArray(we.__webglFramebuffer[$e]))
					for (let Fe = 0; Fe < we.__webglFramebuffer[$e].length; Fe++) o.deleteFramebuffer(we
						.__webglFramebuffer[$e][Fe]);
				else o.deleteFramebuffer(we.__webglFramebuffer[$e]);
				we.__webglDepthbuffer && o.deleteRenderbuffer(we.__webglDepthbuffer[$e])
			} else {
				if (Array.isArray(we.__webglFramebuffer))
					for (let $e = 0; $e < we.__webglFramebuffer.length; $e++) o.deleteFramebuffer(we.__webglFramebuffer[
						$e]);
				else o.deleteFramebuffer(we.__webglFramebuffer);
				if (we.__webglDepthbuffer && o.deleteRenderbuffer(we.__webglDepthbuffer), we
					.__webglMultisampledFramebuffer && o.deleteFramebuffer(we.__webglMultisampledFramebuffer), we
					.__webglColorRenderbuffer)
					for (let $e = 0; $e < we.__webglColorRenderbuffer.length; $e++) we.__webglColorRenderbuffer[$e] && o
						.deleteRenderbuffer(we.__webglColorRenderbuffer[$e]);
				we.__webglDepthRenderbuffer && o.deleteRenderbuffer(we.__webglDepthRenderbuffer)
			}
		const Ce = Ne.textures;
		for (let $e = 0, Fe = Ce.length; $e < Fe; $e++) {
			const Ge = l.get(Ce[$e]);
			Ge.__webglTexture && (o.deleteTexture(Ge.__webglTexture), f.memory.textures--), l.remove(Ce[$e])
		}
		l.remove(Ne)
	}
	let j = 0;

	function ge() {
		j = 0
	}

	function me() {
		const Ne = j;
		return Ne >= c.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Ne +
			" texture units while this GPU supports only " + c.maxTextures), j += 1, Ne
	}

	function he(Ne) {
		const we = [];
		return we.push(Ne.wrapS), we.push(Ne.wrapT), we.push(Ne.wrapR || 0), we.push(Ne.magFilter), we.push(Ne
				.minFilter), we.push(Ne.anisotropy), we.push(Ne.internalFormat), we.push(Ne.format), we.push(Ne.type),
			we.push(Ne.generateMipmaps), we.push(Ne.premultiplyAlpha), we.push(Ne.flipY), we.push(Ne.unpackAlignment),
			we.push(Ne.colorSpace), we.join()
	}

	function ce(Ne, we) {
		const Ce = l.get(Ne);
		if (Ne.isVideoTexture && ot(Ne), Ne.isRenderTargetTexture === !1 && Ne.version > 0 && Ce.__version !== Ne
			.version) {
			const $e = Ne.image;
			if ($e === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
			else if ($e.complete === !1) console.warn(
				"THREE.WebGLRenderer: Texture marked for update but image is incomplete");
			else {
				Se(Ce, Ne, we);
				return
			}
		}
		a.bindTexture(o.TEXTURE_2D, Ce.__webglTexture, o.TEXTURE0 + we)
	}

	function ae(Ne, we) {
		const Ce = l.get(Ne);
		if (Ne.version > 0 && Ce.__version !== Ne.version) {
			Se(Ce, Ne, we);
			return
		}
		a.bindTexture(o.TEXTURE_2D_ARRAY, Ce.__webglTexture, o.TEXTURE0 + we)
	}

	function fe(Ne, we) {
		const Ce = l.get(Ne);
		if (Ne.version > 0 && Ce.__version !== Ne.version) {
			Se(Ce, Ne, we);
			return
		}
		a.bindTexture(o.TEXTURE_3D, Ce.__webglTexture, o.TEXTURE0 + we)
	}

	function q(Ne, we) {
		const Ce = l.get(Ne);
		if (Ne.version > 0 && Ce.__version !== Ne.version) {
			be(Ce, Ne, we);
			return
		}
		a.bindTexture(o.TEXTURE_CUBE_MAP, Ce.__webglTexture, o.TEXTURE0 + we)
	}
	const le = {
			[RepeatWrapping]: o.REPEAT,
			[ClampToEdgeWrapping]: o.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: o.MIRRORED_REPEAT
		},
		de = {
			[NearestFilter]: o.NEAREST,
			[NearestMipmapNearestFilter]: o.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: o.NEAREST_MIPMAP_LINEAR,
			[LinearFilter]: o.LINEAR,
			[LinearMipmapNearestFilter]: o.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: o.LINEAR_MIPMAP_LINEAR
		},
		_e = {
			[NeverCompare]: o.NEVER,
			[AlwaysCompare]: o.ALWAYS,
			[LessCompare]: o.LESS,
			[LessEqualCompare]: o.LEQUAL,
			[EqualCompare]: o.EQUAL,
			[GreaterEqualCompare]: o.GEQUAL,
			[GreaterCompare]: o.GREATER,
			[NotEqualCompare]: o.NOTEQUAL
		};

	function ke(Ne, we) {
		if (we.type === FloatType && s.has("OES_texture_float_linear") === !1 && (we.magFilter === LinearFilter || we
				.magFilter === LinearMipmapNearestFilter || we.magFilter === NearestMipmapLinearFilter || we
				.magFilter === LinearMipmapLinearFilter || we.minFilter === LinearFilter || we.minFilter ===
				LinearMipmapNearestFilter || we.minFilter === NearestMipmapLinearFilter || we.minFilter ===
				LinearMipmapLinearFilter) && console.warn(
				"THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
				), o.texParameteri(Ne, o.TEXTURE_WRAP_S, le[we.wrapS]), o.texParameteri(Ne, o.TEXTURE_WRAP_T, le[we
				.wrapT]), (Ne === o.TEXTURE_3D || Ne === o.TEXTURE_2D_ARRAY) && o.texParameteri(Ne, o.TEXTURE_WRAP_R,
				le[we.wrapR]), o.texParameteri(Ne, o.TEXTURE_MAG_FILTER, de[we.magFilter]), o.texParameteri(Ne, o
				.TEXTURE_MIN_FILTER, de[we.minFilter]), we.compareFunction && (o.texParameteri(Ne, o
				.TEXTURE_COMPARE_MODE, o.COMPARE_REF_TO_TEXTURE), o.texParameteri(Ne, o.TEXTURE_COMPARE_FUNC, _e[we
				.compareFunction])), s.has("EXT_texture_filter_anisotropic") === !0) {
			if (we.magFilter === NearestFilter || we.minFilter !== NearestMipmapLinearFilter && we.minFilter !==
				LinearMipmapLinearFilter || we.type === FloatType && s.has("OES_texture_float_linear") === !1) return;
			if (we.anisotropy > 1 || l.get(we).__currentAnisotropy) {
				const Ce = s.get("EXT_texture_filter_anisotropic");
				o.texParameterf(Ne, Ce.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(we.anisotropy, c.getMaxAnisotropy())), l
					.get(we).__currentAnisotropy = we.anisotropy
			}
		}
	}

	function De(Ne, we) {
		let Ce = !1;
		Ne.__webglInit === void 0 && (Ne.__webglInit = !0, we.addEventListener("dispose", R));
		const $e = we.source;
		let Fe = C.get($e);
		Fe === void 0 && (Fe = {}, C.set($e, Fe));
		const Ge = he(we);
		if (Ge !== Ne.__cacheKey) {
			Fe[Ge] === void 0 && (Fe[Ge] = {
				texture: o.createTexture(),
				usedTimes: 0
			}, f.memory.textures++, Ce = !0), Fe[Ge].usedTimes++;
			const ze = Fe[Ne.__cacheKey];
			ze !== void 0 && (Fe[Ne.__cacheKey].usedTimes--, ze.usedTimes === 0 && V(we)), Ne.__cacheKey = Ge, Ne
				.__webglTexture = Fe[Ge].texture
		}
		return Ce
	}

	function Se(Ne, we, Ce) {
		let $e = o.TEXTURE_2D;
		(we.isDataArrayTexture || we.isCompressedArrayTexture) && ($e = o.TEXTURE_2D_ARRAY), we.isData3DTexture && ($e =
			o.TEXTURE_3D);
		const Fe = De(Ne, we),
			Ge = we.source;
		a.bindTexture($e, Ne.__webglTexture, o.TEXTURE0 + Ce);
		const ze = l.get(Ge);
		if (Ge.version !== ze.__version || Fe === !0) {
			a.activeTexture(o.TEXTURE0 + Ce);
			const Oe = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
				Xe = we.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(we.colorSpace),
				rt = we.colorSpace === NoColorSpace || Oe === Xe ? o.NONE : o.BROWSER_DEFAULT_WEBGL;
			o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, we.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, we
				.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, we.unpackAlignment), o.pixelStorei(o
				.UNPACK_COLORSPACE_CONVERSION_WEBGL, rt);
			let ut = w(we.image, !1, c.maxTextureSize);
			ut = at(we, ut);
			const gt = d.convert(we.format, we.colorSpace),
				Et = d.convert(we.type);
			let Ze = M(we.internalFormat, gt, Et, we.colorSpace, we.isVideoTexture);
			ke($e, we);
			let Ye;
			const ct = we.mipmaps,
				yt = we.isVideoTexture !== !0,
				wt = ze.__version === void 0 || Fe === !0,
				Qe = Ge.dataReady,
				At = F(we, ut);
			if (we.isDepthTexture) Ze = D(we.format === DepthStencilFormat, we.type), wt && (yt ? a.texStorage2D(o
				.TEXTURE_2D, 1, Ze, ut.width, ut.height) : a.texImage2D(o.TEXTURE_2D, 0, Ze, ut.width, ut
				.height, 0, gt, Et, null));
			else if (we.isDataTexture)
				if (ct.length > 0) {
					yt && wt && a.texStorage2D(o.TEXTURE_2D, At, Ze, ct[0].width, ct[0].height);
					for (let Ct = 0, xt = ct.length; Ct < xt; Ct++) Ye = ct[Ct], yt ? Qe && a.texSubImage2D(o
						.TEXTURE_2D, Ct, 0, 0, Ye.width, Ye.height, gt, Et, Ye.data) : a.texImage2D(o.TEXTURE_2D,
						Ct, Ze, Ye.width, Ye.height, 0, gt, Et, Ye.data);
					we.generateMipmaps = !1
				} else yt ? (wt && a.texStorage2D(o.TEXTURE_2D, At, Ze, ut.width, ut.height), Qe && a.texSubImage2D(o
					.TEXTURE_2D, 0, 0, 0, ut.width, ut.height, gt, Et, ut.data)) : a.texImage2D(o.TEXTURE_2D, 0, Ze,
					ut.width, ut.height, 0, gt, Et, ut.data);
			else if (we.isCompressedTexture)
				if (we.isCompressedArrayTexture) {
					yt && wt && a.texStorage3D(o.TEXTURE_2D_ARRAY, At, Ze, ct[0].width, ct[0].height, ut.depth);
					for (let Ct = 0, xt = ct.length; Ct < xt; Ct++)
						if (Ye = ct[Ct], we.format !== RGBAFormat)
							if (gt !== null)
								if (yt) {
									if (Qe)
										if (we.layerUpdates.size > 0) {
											const Rt = getByteLength(Ye.width, Ye.height, we.format, we.type);
											for (const $t of we.layerUpdates) {
												const zt = Ye.data.subarray($t * Rt / Ye.data.BYTES_PER_ELEMENT, ($t +
													1) * Rt / Ye.data.BYTES_PER_ELEMENT);
												a.compressedTexSubImage3D(o.TEXTURE_2D_ARRAY, Ct, 0, 0, $t, Ye.width, Ye
													.height, 1, gt, zt)
											}
											we.clearLayerUpdates()
										} else a.compressedTexSubImage3D(o.TEXTURE_2D_ARRAY, Ct, 0, 0, 0, Ye.width, Ye
											.height, ut.depth, gt, Ye.data)
								} else a.compressedTexImage3D(o.TEXTURE_2D_ARRAY, Ct, Ze, Ye.width, Ye.height, ut.depth,
									0, Ye.data, 0, 0);
					else console.warn(
						"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
						);
					else yt ? Qe && a.texSubImage3D(o.TEXTURE_2D_ARRAY, Ct, 0, 0, 0, Ye.width, Ye.height, ut.depth, gt,
						Et, Ye.data) : a.texImage3D(o.TEXTURE_2D_ARRAY, Ct, Ze, Ye.width, Ye.height, ut.depth, 0,
						gt, Et, Ye.data)
				} else {
					yt && wt && a.texStorage2D(o.TEXTURE_2D, At, Ze, ct[0].width, ct[0].height);
					for (let Ct = 0, xt = ct.length; Ct < xt; Ct++) Ye = ct[Ct], we.format !== RGBAFormat ? gt !==
						null ? yt ? Qe && a.compressedTexSubImage2D(o.TEXTURE_2D, Ct, 0, 0, Ye.width, Ye.height, gt, Ye
							.data) : a.compressedTexImage2D(o.TEXTURE_2D, Ct, Ze, Ye.width, Ye.height, 0, Ye.data) :
						console.warn(
							"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
							) : yt ? Qe && a.texSubImage2D(o.TEXTURE_2D, Ct, 0, 0, Ye.width, Ye.height, gt, Et, Ye
						.data) : a.texImage2D(o.TEXTURE_2D, Ct, Ze, Ye.width, Ye.height, 0, gt, Et, Ye.data)
				}
			else if (we.isDataArrayTexture)
				if (yt) {
					if (wt && a.texStorage3D(o.TEXTURE_2D_ARRAY, At, Ze, ut.width, ut.height, ut.depth), Qe)
						if (we.layerUpdates.size > 0) {
							const Ct = getByteLength(ut.width, ut.height, we.format, we.type);
							for (const xt of we.layerUpdates) {
								const Rt = ut.data.subarray(xt * Ct / ut.data.BYTES_PER_ELEMENT, (xt + 1) * Ct / ut.data
									.BYTES_PER_ELEMENT);
								a.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, xt, ut.width, ut.height, 1, gt, Et, Rt)
							}
							we.clearLayerUpdates()
						} else a.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ut.width, ut.height, ut.depth, gt, Et, ut
							.data)
				} else a.texImage3D(o.TEXTURE_2D_ARRAY, 0, Ze, ut.width, ut.height, ut.depth, 0, gt, Et, ut.data);
			else if (we.isData3DTexture) yt ? (wt && a.texStorage3D(o.TEXTURE_3D, At, Ze, ut.width, ut.height, ut
				.depth), Qe && a.texSubImage3D(o.TEXTURE_3D, 0, 0, 0, 0, ut.width, ut.height, ut.depth, gt, Et, ut
					.data)) : a.texImage3D(o.TEXTURE_3D, 0, Ze, ut.width, ut.height, ut.depth, 0, gt, Et, ut.data);
			else if (we.isFramebufferTexture) {
				if (wt)
					if (yt) a.texStorage2D(o.TEXTURE_2D, At, Ze, ut.width, ut.height);
					else {
						let Ct = ut.width,
							xt = ut.height;
						for (let Rt = 0; Rt < At; Rt++) a.texImage2D(o.TEXTURE_2D, Rt, Ze, Ct, xt, 0, gt, Et, null),
							Ct >>= 1, xt >>= 1
					}
			} else if (ct.length > 0) {
				if (yt && wt) {
					const Ct = Je(ct[0]);
					a.texStorage2D(o.TEXTURE_2D, At, Ze, Ct.width, Ct.height)
				}
				for (let Ct = 0, xt = ct.length; Ct < xt; Ct++) Ye = ct[Ct], yt ? Qe && a.texSubImage2D(o.TEXTURE_2D,
					Ct, 0, 0, gt, Et, Ye) : a.texImage2D(o.TEXTURE_2D, Ct, Ze, gt, Et, Ye);
				we.generateMipmaps = !1
			} else if (yt) {
				if (wt) {
					const Ct = Je(ut);
					a.texStorage2D(o.TEXTURE_2D, At, Ze, Ct.width, Ct.height)
				}
				Qe && a.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, gt, Et, ut)
			} else a.texImage2D(o.TEXTURE_2D, 0, Ze, gt, Et, ut);
			T(we) && A($e), ze.__version = Ge.version, we.onUpdate && we.onUpdate(we)
		}
		Ne.__version = we.version
	}

	function be(Ne, we, Ce) {
		if (we.image.length !== 6) return;
		const $e = De(Ne, we),
			Fe = we.source;
		a.bindTexture(o.TEXTURE_CUBE_MAP, Ne.__webglTexture, o.TEXTURE0 + Ce);
		const Ge = l.get(Fe);
		if (Fe.version !== Ge.__version || $e === !0) {
			a.activeTexture(o.TEXTURE0 + Ce);
			const ze = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
				Oe = we.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(we.colorSpace),
				Xe = we.colorSpace === NoColorSpace || ze === Oe ? o.NONE : o.BROWSER_DEFAULT_WEBGL;
			o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, we.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, we
				.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, we.unpackAlignment), o.pixelStorei(o
				.UNPACK_COLORSPACE_CONVERSION_WEBGL, Xe);
			const rt = we.isCompressedTexture || we.image[0].isCompressedTexture,
				ut = we.image[0] && we.image[0].isDataTexture,
				gt = [];
			for (let xt = 0; xt < 6; xt++) !rt && !ut ? gt[xt] = w(we.image[xt], !0, c.maxCubemapSize) : gt[xt] = ut ?
				we.image[xt].image : we.image[xt], gt[xt] = at(we, gt[xt]);
			const Et = gt[0],
				Ze = d.convert(we.format, we.colorSpace),
				Ye = d.convert(we.type),
				ct = M(we.internalFormat, Ze, Ye, we.colorSpace),
				yt = we.isVideoTexture !== !0,
				wt = Ge.__version === void 0 || $e === !0,
				Qe = Fe.dataReady;
			let At = F(we, Et);
			ke(o.TEXTURE_CUBE_MAP, we);
			let Ct;
			if (rt) {
				yt && wt && a.texStorage2D(o.TEXTURE_CUBE_MAP, At, ct, Et.width, Et.height);
				for (let xt = 0; xt < 6; xt++) {
					Ct = gt[xt].mipmaps;
					for (let Rt = 0; Rt < Ct.length; Rt++) {
						const $t = Ct[Rt];
						we.format !== RGBAFormat ? Ze !== null ? yt ? Qe && a.compressedTexSubImage2D(o
								.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt, 0, 0, $t.width, $t.height, Ze, $t.data) : a
							.compressedTexImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt, ct, $t.width, $t.height, 0, $t
								.data) : console.warn(
								"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
								) : yt ? Qe && a.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt, 0, 0, $t.width,
								$t.height, Ze, Ye, $t.data) : a.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt, ct,
								$t.width, $t.height, 0, Ze, Ye, $t.data)
					}
				}
			} else {
				if (Ct = we.mipmaps, yt && wt) {
					Ct.length > 0 && At++;
					const xt = Je(gt[0]);
					a.texStorage2D(o.TEXTURE_CUBE_MAP, At, ct, xt.width, xt.height)
				}
				for (let xt = 0; xt < 6; xt++)
					if (ut) {
						yt ? Qe && a.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, 0, 0, 0, gt[xt].width, gt[xt]
							.height, Ze, Ye, gt[xt].data) : a.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, 0, ct,
							gt[xt].width, gt[xt].height, 0, Ze, Ye, gt[xt].data);
						for (let Rt = 0; Rt < Ct.length; Rt++) {
							const zt = Ct[Rt].image[xt].image;
							yt ? Qe && a.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt + 1, 0, 0, zt.width, zt
								.height, Ze, Ye, zt.data) : a.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt + 1,
								ct, zt.width, zt.height, 0, Ze, Ye, zt.data)
						}
					} else {
						yt ? Qe && a.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, 0, 0, 0, Ze, Ye, gt[xt]) : a
							.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, 0, ct, Ze, Ye, gt[xt]);
						for (let Rt = 0; Rt < Ct.length; Rt++) {
							const $t = Ct[Rt];
							yt ? Qe && a.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt + 1, 0, 0, Ze, Ye, $t
								.image[xt]) : a.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + xt, Rt + 1, ct, Ze, Ye,
								$t.image[xt])
						}
					}
			}
			T(we) && A(o.TEXTURE_CUBE_MAP), Ge.__version = Fe.version, we.onUpdate && we.onUpdate(we)
		}
		Ne.__version = we.version
	}

	function Me(Ne, we, Ce, $e, Fe, Ge) {
		const ze = d.convert(Ce.format, Ce.colorSpace),
			Oe = d.convert(Ce.type),
			Xe = M(Ce.internalFormat, ze, Oe, Ce.colorSpace),
			rt = l.get(we),
			ut = l.get(Ce);
		if (ut.__renderTarget = we, !rt.__hasExternalTextures) {
			const gt = Math.max(1, we.width >> Ge),
				Et = Math.max(1, we.height >> Ge);
			Fe === o.TEXTURE_3D || Fe === o.TEXTURE_2D_ARRAY ? a.texImage3D(Fe, Ge, Xe, gt, Et, we.depth, 0, ze, Oe,
				null) : a.texImage2D(Fe, Ge, Xe, gt, Et, 0, ze, Oe, null)
		}
		a.bindFramebuffer(o.FRAMEBUFFER, Ne), nt(we) ? m.framebufferTexture2DMultisampleEXT(o.FRAMEBUFFER, $e, Fe, ut
				.__webglTexture, 0, Ue(we)) : (Fe === o.TEXTURE_2D || Fe >= o.TEXTURE_CUBE_MAP_POSITIVE_X && Fe <= o
				.TEXTURE_CUBE_MAP_NEGATIVE_Z) && o.framebufferTexture2D(o.FRAMEBUFFER, $e, Fe, ut.__webglTexture, Ge), a
			.bindFramebuffer(o.FRAMEBUFFER, null)
	}

	function Ve(Ne, we, Ce) {
		if (o.bindRenderbuffer(o.RENDERBUFFER, Ne), we.depthBuffer) {
			const $e = we.depthTexture,
				Fe = $e && $e.isDepthTexture ? $e.type : null,
				Ge = D(we.stencilBuffer, Fe),
				ze = we.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT,
				Oe = Ue(we);
			nt(we) ? m.renderbufferStorageMultisampleEXT(o.RENDERBUFFER, Oe, Ge, we.width, we.height) : Ce ? o
				.renderbufferStorageMultisample(o.RENDERBUFFER, Oe, Ge, we.width, we.height) : o.renderbufferStorage(o
					.RENDERBUFFER, Ge, we.width, we.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, ze, o
					.RENDERBUFFER, Ne)
		} else {
			const $e = we.textures;
			for (let Fe = 0; Fe < $e.length; Fe++) {
				const Ge = $e[Fe],
					ze = d.convert(Ge.format, Ge.colorSpace),
					Oe = d.convert(Ge.type),
					Xe = M(Ge.internalFormat, ze, Oe, Ge.colorSpace),
					rt = Ue(we);
				Ce && nt(we) === !1 ? o.renderbufferStorageMultisample(o.RENDERBUFFER, rt, Xe, we.width, we.height) :
					nt(we) ? m.renderbufferStorageMultisampleEXT(o.RENDERBUFFER, rt, Xe, we.width, we.height) : o
					.renderbufferStorage(o.RENDERBUFFER, Xe, we.width, we.height)
			}
		}
		o.bindRenderbuffer(o.RENDERBUFFER, null)
	}

	function it(Ne, we) {
		if (we && we.isWebGLCubeRenderTarget) throw new Error(
		"Depth Texture with cube render targets is not supported");
		if (a.bindFramebuffer(o.FRAMEBUFFER, Ne), !(we.depthTexture && we.depthTexture.isDepthTexture)) throw new Error(
			"renderTarget.depthTexture must be an instance of THREE.DepthTexture");
		const $e = l.get(we.depthTexture);
		$e.__renderTarget = we, (!$e.__webglTexture || we.depthTexture.image.width !== we.width || we.depthTexture.image
			.height !== we.height) && (we.depthTexture.image.width = we.width, we.depthTexture.image.height = we
			.height, we.depthTexture.needsUpdate = !0), ce(we.depthTexture, 0);
		const Fe = $e.__webglTexture,
			Ge = Ue(we);
		if (we.depthTexture.format === DepthFormat) nt(we) ? m.framebufferTexture2DMultisampleEXT(o.FRAMEBUFFER, o
			.DEPTH_ATTACHMENT, o.TEXTURE_2D, Fe, 0, Ge) : o.framebufferTexture2D(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT,
			o.TEXTURE_2D, Fe, 0);
		else if (we.depthTexture.format === DepthStencilFormat) nt(we) ? m.framebufferTexture2DMultisampleEXT(o
			.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.TEXTURE_2D, Fe, 0, Ge) : o.framebufferTexture2D(o
			.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.TEXTURE_2D, Fe, 0);
		else throw new Error("Unknown depthTexture format")
	}

	function pt(Ne) {
		const we = l.get(Ne),
			Ce = Ne.isWebGLCubeRenderTarget === !0;
		if (we.__boundDepthTexture !== Ne.depthTexture) {
			const $e = Ne.depthTexture;
			if (we.__depthDisposeCallback && we.__depthDisposeCallback(), $e) {
				const Fe = () => {
					delete we.__boundDepthTexture, delete we.__depthDisposeCallback, $e.removeEventListener(
						"dispose", Fe)
				};
				$e.addEventListener("dispose", Fe), we.__depthDisposeCallback = Fe
			}
			we.__boundDepthTexture = $e
		}
		if (Ne.depthTexture && !we.__autoAllocateDepthBuffer) {
			if (Ce) throw new Error("target.depthTexture not supported in Cube render targets");
			const $e = Ne.texture.mipmaps;
			$e && $e.length > 0 ? it(we.__webglFramebuffer[0], Ne) : it(we.__webglFramebuffer, Ne)
		} else if (Ce) {
			we.__webglDepthbuffer = [];
			for (let $e = 0; $e < 6; $e++)
				if (a.bindFramebuffer(o.FRAMEBUFFER, we.__webglFramebuffer[$e]), we.__webglDepthbuffer[$e] === void 0)
					we.__webglDepthbuffer[$e] = o.createRenderbuffer(), Ve(we.__webglDepthbuffer[$e], Ne, !1);
				else {
					const Fe = Ne.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT,
						Ge = we.__webglDepthbuffer[$e];
					o.bindRenderbuffer(o.RENDERBUFFER, Ge), o.framebufferRenderbuffer(o.FRAMEBUFFER, Fe, o.RENDERBUFFER,
						Ge)
				}
		} else {
			const $e = Ne.texture.mipmaps;
			if ($e && $e.length > 0 ? a.bindFramebuffer(o.FRAMEBUFFER, we.__webglFramebuffer[0]) : a.bindFramebuffer(o
					.FRAMEBUFFER, we.__webglFramebuffer), we.__webglDepthbuffer === void 0) we.__webglDepthbuffer = o
				.createRenderbuffer(), Ve(we.__webglDepthbuffer, Ne, !1);
			else {
				const Fe = Ne.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT,
					Ge = we.__webglDepthbuffer;
				o.bindRenderbuffer(o.RENDERBUFFER, Ge), o.framebufferRenderbuffer(o.FRAMEBUFFER, Fe, o.RENDERBUFFER, Ge)
			}
		}
		a.bindFramebuffer(o.FRAMEBUFFER, null)
	}

	function dt(Ne, we, Ce) {
		const $e = l.get(Ne);
		we !== void 0 && Me($e.__webglFramebuffer, Ne, Ne.texture, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, 0), Ce !==
			void 0 && pt(Ne)
	}

	function He(Ne) {
		const we = Ne.texture,
			Ce = l.get(Ne),
			$e = l.get(we);
		Ne.addEventListener("dispose", O);
		const Fe = Ne.textures,
			Ge = Ne.isWebGLCubeRenderTarget === !0,
			ze = Fe.length > 1;
		if (ze || ($e.__webglTexture === void 0 && ($e.__webglTexture = o.createTexture()), $e.__version = we.version, f
				.memory.textures++), Ge) {
			Ce.__webglFramebuffer = [];
			for (let Oe = 0; Oe < 6; Oe++)
				if (we.mipmaps && we.mipmaps.length > 0) {
					Ce.__webglFramebuffer[Oe] = [];
					for (let Xe = 0; Xe < we.mipmaps.length; Xe++) Ce.__webglFramebuffer[Oe][Xe] = o.createFramebuffer()
				} else Ce.__webglFramebuffer[Oe] = o.createFramebuffer()
		} else {
			if (we.mipmaps && we.mipmaps.length > 0) {
				Ce.__webglFramebuffer = [];
				for (let Oe = 0; Oe < we.mipmaps.length; Oe++) Ce.__webglFramebuffer[Oe] = o.createFramebuffer()
			} else Ce.__webglFramebuffer = o.createFramebuffer();
			if (ze)
				for (let Oe = 0, Xe = Fe.length; Oe < Xe; Oe++) {
					const rt = l.get(Fe[Oe]);
					rt.__webglTexture === void 0 && (rt.__webglTexture = o.createTexture(), f.memory.textures++)
				}
			if (Ne.samples > 0 && nt(Ne) === !1) {
				Ce.__webglMultisampledFramebuffer = o.createFramebuffer(), Ce.__webglColorRenderbuffer = [], a
					.bindFramebuffer(o.FRAMEBUFFER, Ce.__webglMultisampledFramebuffer);
				for (let Oe = 0; Oe < Fe.length; Oe++) {
					const Xe = Fe[Oe];
					Ce.__webglColorRenderbuffer[Oe] = o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, Ce
						.__webglColorRenderbuffer[Oe]);
					const rt = d.convert(Xe.format, Xe.colorSpace),
						ut = d.convert(Xe.type),
						gt = M(Xe.internalFormat, rt, ut, Xe.colorSpace, Ne.isXRRenderTarget === !0),
						Et = Ue(Ne);
					o.renderbufferStorageMultisample(o.RENDERBUFFER, Et, gt, Ne.width, Ne.height), o
						.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + Oe, o.RENDERBUFFER, Ce
							.__webglColorRenderbuffer[Oe])
				}
				o.bindRenderbuffer(o.RENDERBUFFER, null), Ne.depthBuffer && (Ce.__webglDepthRenderbuffer = o
					.createRenderbuffer(), Ve(Ce.__webglDepthRenderbuffer, Ne, !0)), a.bindFramebuffer(o
					.FRAMEBUFFER, null)
			}
		}
		if (Ge) {
			a.bindTexture(o.TEXTURE_CUBE_MAP, $e.__webglTexture), ke(o.TEXTURE_CUBE_MAP, we);
			for (let Oe = 0; Oe < 6; Oe++)
				if (we.mipmaps && we.mipmaps.length > 0)
					for (let Xe = 0; Xe < we.mipmaps.length; Xe++) Me(Ce.__webglFramebuffer[Oe][Xe], Ne, we, o
						.COLOR_ATTACHMENT0, o.TEXTURE_CUBE_MAP_POSITIVE_X + Oe, Xe);
				else Me(Ce.__webglFramebuffer[Oe], Ne, we, o.COLOR_ATTACHMENT0, o.TEXTURE_CUBE_MAP_POSITIVE_X + Oe, 0);
			T(we) && A(o.TEXTURE_CUBE_MAP), a.unbindTexture()
		} else if (ze) {
			for (let Oe = 0, Xe = Fe.length; Oe < Xe; Oe++) {
				const rt = Fe[Oe],
					ut = l.get(rt);
				a.bindTexture(o.TEXTURE_2D, ut.__webglTexture), ke(o.TEXTURE_2D, rt), Me(Ce.__webglFramebuffer, Ne, rt,
					o.COLOR_ATTACHMENT0 + Oe, o.TEXTURE_2D, 0), T(rt) && A(o.TEXTURE_2D)
			}
			a.unbindTexture()
		} else {
			let Oe = o.TEXTURE_2D;
			if ((Ne.isWebGL3DRenderTarget || Ne.isWebGLArrayRenderTarget) && (Oe = Ne.isWebGL3DRenderTarget ? o
					.TEXTURE_3D : o.TEXTURE_2D_ARRAY), a.bindTexture(Oe, $e.__webglTexture), ke(Oe, we), we.mipmaps &&
				we.mipmaps.length > 0)
				for (let Xe = 0; Xe < we.mipmaps.length; Xe++) Me(Ce.__webglFramebuffer[Xe], Ne, we, o
					.COLOR_ATTACHMENT0, Oe, Xe);
			else Me(Ce.__webglFramebuffer, Ne, we, o.COLOR_ATTACHMENT0, Oe, 0);
			T(we) && A(Oe), a.unbindTexture()
		}
		Ne.depthBuffer && pt(Ne)
	}

	function Ae(Ne) {
		const we = Ne.textures;
		for (let Ce = 0, $e = we.length; Ce < $e; Ce++) {
			const Fe = we[Ce];
			if (T(Fe)) {
				const Ge = k(Ne),
					ze = l.get(Fe).__webglTexture;
				a.bindTexture(Ge, ze), A(Ge), a.unbindTexture()
			}
		}
	}
	const xe = [],
		ye = [];

	function Le(Ne) {
		if (Ne.samples > 0) {
			if (nt(Ne) === !1) {
				const we = Ne.textures,
					Ce = Ne.width,
					$e = Ne.height;
				let Fe = o.COLOR_BUFFER_BIT;
				const Ge = Ne.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT,
					ze = l.get(Ne),
					Oe = we.length > 1;
				if (Oe)
					for (let rt = 0; rt < we.length; rt++) a.bindFramebuffer(o.FRAMEBUFFER, ze
						.__webglMultisampledFramebuffer), o.framebufferRenderbuffer(o.FRAMEBUFFER, o
						.COLOR_ATTACHMENT0 + rt, o.RENDERBUFFER, null), a.bindFramebuffer(o.FRAMEBUFFER, ze
						.__webglFramebuffer), o.framebufferTexture2D(o.DRAW_FRAMEBUFFER, o.COLOR_ATTACHMENT0 + rt, o
						.TEXTURE_2D, null, 0);
				a.bindFramebuffer(o.READ_FRAMEBUFFER, ze.__webglMultisampledFramebuffer);
				const Xe = Ne.texture.mipmaps;
				Xe && Xe.length > 0 ? a.bindFramebuffer(o.DRAW_FRAMEBUFFER, ze.__webglFramebuffer[0]) : a
					.bindFramebuffer(o.DRAW_FRAMEBUFFER, ze.__webglFramebuffer);
				for (let rt = 0; rt < we.length; rt++) {
					if (Ne.resolveDepthBuffer && (Ne.depthBuffer && (Fe |= o.DEPTH_BUFFER_BIT), Ne.stencilBuffer && Ne
							.resolveStencilBuffer && (Fe |= o.STENCIL_BUFFER_BIT)), Oe) {
						o.framebufferRenderbuffer(o.READ_FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.RENDERBUFFER, ze
							.__webglColorRenderbuffer[rt]);
						const ut = l.get(we[rt]).__webglTexture;
						o.framebufferTexture2D(o.DRAW_FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, ut, 0)
					}
					o.blitFramebuffer(0, 0, Ce, $e, 0, 0, Ce, $e, Fe, o.NEAREST), g === !0 && (xe.length = 0, ye
						.length = 0, xe.push(o.COLOR_ATTACHMENT0 + rt), Ne.depthBuffer && Ne.resolveDepthBuffer ===
						!1 && (xe.push(Ge), ye.push(Ge), o.invalidateFramebuffer(o.DRAW_FRAMEBUFFER, ye)), o
						.invalidateFramebuffer(o.READ_FRAMEBUFFER, xe))
				}
				if (a.bindFramebuffer(o.READ_FRAMEBUFFER, null), a.bindFramebuffer(o.DRAW_FRAMEBUFFER, null), Oe)
					for (let rt = 0; rt < we.length; rt++) {
						a.bindFramebuffer(o.FRAMEBUFFER, ze.__webglMultisampledFramebuffer), o.framebufferRenderbuffer(o
							.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + rt, o.RENDERBUFFER, ze.__webglColorRenderbuffer[rt]);
						const ut = l.get(we[rt]).__webglTexture;
						a.bindFramebuffer(o.FRAMEBUFFER, ze.__webglFramebuffer), o.framebufferTexture2D(o
							.DRAW_FRAMEBUFFER, o.COLOR_ATTACHMENT0 + rt, o.TEXTURE_2D, ut, 0)
					}
				a.bindFramebuffer(o.DRAW_FRAMEBUFFER, ze.__webglMultisampledFramebuffer)
			} else if (Ne.depthBuffer && Ne.resolveDepthBuffer === !1 && g) {
				const we = Ne.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT;
				o.invalidateFramebuffer(o.DRAW_FRAMEBUFFER, [we])
			}
		}
	}

	function Ue(Ne) {
		return Math.min(c.maxSamples, Ne.samples)
	}

	function nt(Ne) {
		const we = l.get(Ne);
		return Ne.samples > 0 && s.has("WEBGL_multisampled_render_to_texture") === !0 && we.__useRenderToTexture !== !1
	}

	function ot(Ne) {
		const we = f.render.frame;
		y.get(Ne) !== we && (y.set(Ne, we), Ne.update())
	}

	function at(Ne, we) {
		const Ce = Ne.colorSpace,
			$e = Ne.format,
			Fe = Ne.type;
		return Ne.isCompressedTexture === !0 || Ne.isVideoTexture === !0 || Ce !== LinearSRGBColorSpace && Ce !==
			NoColorSpace && (ColorManagement.getTransfer(Ce) === SRGBTransfer ? ($e !== RGBAFormat || Fe !==
					UnsignedByteType) && console.warn(
					"THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console
				.error("THREE.WebGLTextures: Unsupported texture color space:", Ce)), we
	}

	function Je(Ne) {
		return typeof HTMLImageElement < "u" && Ne instanceof HTMLImageElement ? (v.width = Ne.naturalWidth || Ne.width,
			v.height = Ne.naturalHeight || Ne.height) : typeof VideoFrame < "u" && Ne instanceof VideoFrame ? (v
			.width = Ne.displayWidth, v.height = Ne.displayHeight) : (v.width = Ne.width, v.height = Ne.height), v
	}
	this.allocateTextureUnit = me, this.resetTextureUnits = ge, this.setTexture2D = ce, this.setTexture2DArray = ae,
		this.setTexture3D = fe, this.setTextureCube = q, this.rebindTextures = dt, this.setupRenderTarget = He, this
		.updateRenderTargetMipmap = Ae, this.updateMultisampleRenderTarget = Le, this.setupDepthRenderbuffer = pt, this
		.setupFrameBufferTexture = Me, this.useMultisampledRTT = nt
}

function WebGLUtils(o, s) {
	function a(l, c = NoColorSpace) {
		let d;
		const f = ColorManagement.getTransfer(c);
		if (l === UnsignedByteType) return o.UNSIGNED_BYTE;
		if (l === UnsignedShort4444Type) return o.UNSIGNED_SHORT_4_4_4_4;
		if (l === UnsignedShort5551Type) return o.UNSIGNED_SHORT_5_5_5_1;
		if (l === UnsignedInt5999Type) return o.UNSIGNED_INT_5_9_9_9_REV;
		if (l === ByteType) return o.BYTE;
		if (l === ShortType) return o.SHORT;
		if (l === UnsignedShortType) return o.UNSIGNED_SHORT;
		if (l === IntType) return o.INT;
		if (l === UnsignedIntType) return o.UNSIGNED_INT;
		if (l === FloatType) return o.FLOAT;
		if (l === HalfFloatType) return o.HALF_FLOAT;
		if (l === AlphaFormat) return o.ALPHA;
		if (l === RGBFormat) return o.RGB;
		if (l === RGBAFormat) return o.RGBA;
		if (l === DepthFormat) return o.DEPTH_COMPONENT;
		if (l === DepthStencilFormat) return o.DEPTH_STENCIL;
		if (l === RedFormat) return o.RED;
		if (l === RedIntegerFormat) return o.RED_INTEGER;
		if (l === RGFormat) return o.RG;
		if (l === RGIntegerFormat) return o.RG_INTEGER;
		if (l === RGBAIntegerFormat) return o.RGBA_INTEGER;
		if (l === RGB_S3TC_DXT1_Format || l === RGBA_S3TC_DXT1_Format || l === RGBA_S3TC_DXT3_Format || l ===
			RGBA_S3TC_DXT5_Format)
			if (f === SRGBTransfer)
				if (d = s.get("WEBGL_compressed_texture_s3tc_srgb"), d !== null) {
					if (l === RGB_S3TC_DXT1_Format) return d.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if (l === RGBA_S3TC_DXT1_Format) return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if (l === RGBA_S3TC_DXT3_Format) return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if (l === RGBA_S3TC_DXT5_Format) return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
				} else return null;
		else if (d = s.get("WEBGL_compressed_texture_s3tc"), d !== null) {
			if (l === RGB_S3TC_DXT1_Format) return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if (l === RGBA_S3TC_DXT1_Format) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if (l === RGBA_S3TC_DXT3_Format) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if (l === RGBA_S3TC_DXT5_Format) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT
		} else return null;
		if (l === RGB_PVRTC_4BPPV1_Format || l === RGB_PVRTC_2BPPV1_Format || l === RGBA_PVRTC_4BPPV1_Format || l ===
			RGBA_PVRTC_2BPPV1_Format)
			if (d = s.get("WEBGL_compressed_texture_pvrtc"), d !== null) {
				if (l === RGB_PVRTC_4BPPV1_Format) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (l === RGB_PVRTC_2BPPV1_Format) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (l === RGBA_PVRTC_4BPPV1_Format) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (l === RGBA_PVRTC_2BPPV1_Format) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
			} else return null;
		if (l === RGB_ETC1_Format || l === RGB_ETC2_Format || l === RGBA_ETC2_EAC_Format)
			if (d = s.get("WEBGL_compressed_texture_etc"), d !== null) {
				if (l === RGB_ETC1_Format || l === RGB_ETC2_Format) return f === SRGBTransfer ? d
					.COMPRESSED_SRGB8_ETC2 : d.COMPRESSED_RGB8_ETC2;
				if (l === RGBA_ETC2_EAC_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : d
					.COMPRESSED_RGBA8_ETC2_EAC
			} else return null;
		if (l === RGBA_ASTC_4x4_Format || l === RGBA_ASTC_5x4_Format || l === RGBA_ASTC_5x5_Format || l ===
			RGBA_ASTC_6x5_Format || l === RGBA_ASTC_6x6_Format || l === RGBA_ASTC_8x5_Format || l ===
			RGBA_ASTC_8x6_Format || l === RGBA_ASTC_8x8_Format || l === RGBA_ASTC_10x5_Format || l ===
			RGBA_ASTC_10x6_Format || l === RGBA_ASTC_10x8_Format || l === RGBA_ASTC_10x10_Format || l ===
			RGBA_ASTC_12x10_Format || l === RGBA_ASTC_12x12_Format)
			if (d = s.get("WEBGL_compressed_texture_astc"), d !== null) {
				if (l === RGBA_ASTC_4x4_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : d
					.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (l === RGBA_ASTC_5x4_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : d
					.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (l === RGBA_ASTC_5x5_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : d
					.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (l === RGBA_ASTC_6x5_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : d
					.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (l === RGBA_ASTC_6x6_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : d
					.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (l === RGBA_ASTC_8x5_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : d
					.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (l === RGBA_ASTC_8x6_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : d
					.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (l === RGBA_ASTC_8x8_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : d
					.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (l === RGBA_ASTC_10x5_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : d
					.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (l === RGBA_ASTC_10x6_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : d
					.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (l === RGBA_ASTC_10x8_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : d
					.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (l === RGBA_ASTC_10x10_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR :
					d.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (l === RGBA_ASTC_12x10_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR :
					d.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (l === RGBA_ASTC_12x12_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR :
					d.COMPRESSED_RGBA_ASTC_12x12_KHR
			} else return null;
		if (l === RGBA_BPTC_Format || l === RGB_BPTC_SIGNED_Format || l === RGB_BPTC_UNSIGNED_Format)
			if (d = s.get("EXT_texture_compression_bptc"), d !== null) {
				if (l === RGBA_BPTC_Format) return f === SRGBTransfer ? d.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : d
					.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if (l === RGB_BPTC_SIGNED_Format) return d.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if (l === RGB_BPTC_UNSIGNED_Format) return d.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
			} else return null;
		if (l === RED_RGTC1_Format || l === SIGNED_RED_RGTC1_Format || l === RED_GREEN_RGTC2_Format || l ===
			SIGNED_RED_GREEN_RGTC2_Format)
			if (d = s.get("EXT_texture_compression_rgtc"), d !== null) {
				if (l === RGBA_BPTC_Format) return d.COMPRESSED_RED_RGTC1_EXT;
				if (l === SIGNED_RED_RGTC1_Format) return d.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if (l === RED_GREEN_RGTC2_Format) return d.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if (l === SIGNED_RED_GREEN_RGTC2_Format) return d.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
			} else return null;
		return l === UnsignedInt248Type ? o.UNSIGNED_INT_24_8 : o[l] !== void 0 ? o[l] : null
	}
	return {
		convert: a
	}
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
	_occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
	constructor() {
		this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
	}
	init(s, a, l) {
		if (this.texture === null) {
			const c = new Texture,
				d = s.properties.get(c);
			d.__webglTexture = a.texture, (a.depthNear !== l.depthNear || a.depthFar !== l.depthFar) && (this
				.depthNear = a.depthNear, this.depthFar = a.depthFar), this.texture = c
		}
	}
	getMesh(s) {
		if (this.texture !== null && this.mesh === null) {
			const a = s.cameras[0].viewport,
				l = new ShaderMaterial({
					vertexShader: _occlusion_vertex,
					fragmentShader: _occlusion_fragment,
					uniforms: {
						depthColor: {
							value: this.texture
						},
						depthWidth: {
							value: a.z
						},
						depthHeight: {
							value: a.w
						}
					}
				});
			this.mesh = new Mesh(new PlaneGeometry(20, 20), l)
		}
		return this.mesh
	}
	reset() {
		this.texture = null, this.mesh = null
	}
	getDepthTexture() {
		return this.texture
	}
}
class WebXRManager extends EventDispatcher {
	constructor(s, a) {
		super();
		const l = this;
		let c = null,
			d = 1,
			f = null,
			m = "local-floor",
			g = 1,
			v = null,
			y = null,
			b = null,
			C = null,
			_ = null,
			S = null;
		const w = new WebXRDepthSensing,
			T = a.getContextAttributes();
		let A = null,
			k = null;
		const M = [],
			D = [],
			F = new Vector2;
		let R = null;
		const O = new PerspectiveCamera;
		O.viewport = new Vector4;
		const U = new PerspectiveCamera;
		U.viewport = new Vector4;
		const V = [O, U],
			z = new ArrayCamera;
		let j = null,
			ge = null;
		this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Se) {
			let be = M[Se];
			return be === void 0 && (be = new WebXRController, M[Se] = be), be.getTargetRaySpace()
		}, this.getControllerGrip = function(Se) {
			let be = M[Se];
			return be === void 0 && (be = new WebXRController, M[Se] = be), be.getGripSpace()
		}, this.getHand = function(Se) {
			let be = M[Se];
			return be === void 0 && (be = new WebXRController, M[Se] = be), be.getHandSpace()
		};

		function me(Se) {
			const be = D.indexOf(Se.inputSource);
			if (be === -1) return;
			const Me = M[be];
			Me !== void 0 && (Me.update(Se.inputSource, Se.frame, v || f), Me.dispatchEvent({
				type: Se.type,
				data: Se.inputSource
			}))
		}

		function he() {
			c.removeEventListener("select", me), c.removeEventListener("selectstart", me), c.removeEventListener(
					"selectend", me), c.removeEventListener("squeeze", me), c.removeEventListener("squeezestart",
					me), c.removeEventListener("squeezeend", me), c.removeEventListener("end", he), c
				.removeEventListener("inputsourceschange", ce);
			for (let Se = 0; Se < M.length; Se++) {
				const be = D[Se];
				be !== null && (D[Se] = null, M[Se].disconnect(be))
			}
			j = null, ge = null, w.reset(), s.setRenderTarget(A), _ = null, C = null, b = null, c = null, k = null,
				De.stop(), l.isPresenting = !1, s.setPixelRatio(R), s.setSize(F.width, F.height, !1), l
				.dispatchEvent({
					type: "sessionend"
				})
		}
		this.setFramebufferScaleFactor = function(Se) {
			d = Se, l.isPresenting === !0 && console.warn(
				"THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
		}, this.setReferenceSpaceType = function(Se) {
			m = Se, l.isPresenting === !0 && console.warn(
				"THREE.WebXRManager: Cannot change reference space type while presenting.")
		}, this.getReferenceSpace = function() {
			return v || f
		}, this.setReferenceSpace = function(Se) {
			v = Se
		}, this.getBaseLayer = function() {
			return C !== null ? C : _
		}, this.getBinding = function() {
			return b
		}, this.getFrame = function() {
			return S
		}, this.getSession = function() {
			return c
		}, this.setSession = async function(Se) {
			if (c = Se, c !== null) {
				if (A = s.getRenderTarget(), c.addEventListener("select", me), c.addEventListener(
						"selectstart", me), c.addEventListener("selectend", me), c.addEventListener(
						"squeeze", me), c.addEventListener("squeezestart", me), c.addEventListener(
						"squeezeend", me), c.addEventListener("end", he), c.addEventListener(
						"inputsourceschange", ce), T.xrCompatible !== !0 && await a.makeXRCompatible(), R =
					s.getPixelRatio(), s.getSize(F), typeof XRWebGLBinding < "u" &&
					"createProjectionLayer" in XRWebGLBinding.prototype) {
					let Me = null,
						Ve = null,
						it = null;
					T.depth && (it = T.stencil ? a.DEPTH24_STENCIL8 : a.DEPTH_COMPONENT24, Me = T.stencil ?
						DepthStencilFormat : DepthFormat, Ve = T.stencil ? UnsignedInt248Type :
						UnsignedIntType);
					const pt = {
						colorFormat: a.RGBA8,
						depthFormat: it,
						scaleFactor: d
					};
					b = new XRWebGLBinding(c, a), C = b.createProjectionLayer(pt), c.updateRenderState({
							layers: [C]
						}), s.setPixelRatio(1), s.setSize(C.textureWidth, C.textureHeight, !1), k =
						new WebGLRenderTarget(C.textureWidth, C.textureHeight, {
							format: RGBAFormat,
							type: UnsignedByteType,
							depthTexture: new DepthTexture(C.textureWidth, C.textureHeight, Ve, void 0,
								void 0, void 0, void 0, void 0, void 0, Me),
							stencilBuffer: T.stencil,
							colorSpace: s.outputColorSpace,
							samples: T.antialias ? 4 : 0,
							resolveDepthBuffer: C.ignoreDepthValues === !1,
							resolveStencilBuffer: C.ignoreDepthValues === !1
						})
				} else {
					const Me = {
						antialias: T.antialias,
						alpha: !0,
						depth: T.depth,
						stencil: T.stencil,
						framebufferScaleFactor: d
					};
					_ = new XRWebGLLayer(c, a, Me), c.updateRenderState({
							baseLayer: _
						}), s.setPixelRatio(1), s.setSize(_.framebufferWidth, _.framebufferHeight, !1), k =
						new WebGLRenderTarget(_.framebufferWidth, _.framebufferHeight, {
							format: RGBAFormat,
							type: UnsignedByteType,
							colorSpace: s.outputColorSpace,
							stencilBuffer: T.stencil,
							resolveDepthBuffer: _.ignoreDepthValues === !1,
							resolveStencilBuffer: _.ignoreDepthValues === !1
						})
				}
				k.isXRRenderTarget = !0, this.setFoveation(g), v = null, f = await c.requestReferenceSpace(
					m), De.setContext(c), De.start(), l.isPresenting = !0, l.dispatchEvent({
					type: "sessionstart"
				})
			}
		}, this.getEnvironmentBlendMode = function() {
			if (c !== null) return c.environmentBlendMode
		}, this.getDepthTexture = function() {
			return w.getDepthTexture()
		};

		function ce(Se) {
			for (let be = 0; be < Se.removed.length; be++) {
				const Me = Se.removed[be],
					Ve = D.indexOf(Me);
				Ve >= 0 && (D[Ve] = null, M[Ve].disconnect(Me))
			}
			for (let be = 0; be < Se.added.length; be++) {
				const Me = Se.added[be];
				let Ve = D.indexOf(Me);
				if (Ve === -1) {
					for (let pt = 0; pt < M.length; pt++)
						if (pt >= D.length) {
							D.push(Me), Ve = pt;
							break
						} else if (D[pt] === null) {
						D[pt] = Me, Ve = pt;
						break
					}
					if (Ve === -1) break
				}
				const it = M[Ve];
				it && it.connect(Me)
			}
		}
		const ae = new Vector3$1,
			fe = new Vector3$1;

		function q(Se, be, Me) {
			ae.setFromMatrixPosition(be.matrixWorld), fe.setFromMatrixPosition(Me.matrixWorld);
			const Ve = ae.distanceTo(fe),
				it = be.projectionMatrix.elements,
				pt = Me.projectionMatrix.elements,
				dt = it[14] / (it[10] - 1),
				He = it[14] / (it[10] + 1),
				Ae = (it[9] + 1) / it[5],
				xe = (it[9] - 1) / it[5],
				ye = (it[8] - 1) / it[0],
				Le = (pt[8] + 1) / pt[0],
				Ue = dt * ye,
				nt = dt * Le,
				ot = Ve / (-ye + Le),
				at = ot * -ye;
			if (be.matrixWorld.decompose(Se.position, Se.quaternion, Se.scale), Se.translateX(at), Se.translateZ(
				ot), Se.matrixWorld.compose(Se.position, Se.quaternion, Se.scale), Se.matrixWorldInverse.copy(Se
					.matrixWorld).invert(), it[10] === -1) Se.projectionMatrix.copy(be.projectionMatrix), Se
				.projectionMatrixInverse.copy(be.projectionMatrixInverse);
			else {
				const Je = dt + ot,
					Ne = He + ot,
					we = Ue - at,
					Ce = nt + (Ve - at),
					$e = Ae * He / Ne * Je,
					Fe = xe * He / Ne * Je;
				Se.projectionMatrix.makePerspective(we, Ce, $e, Fe, Je, Ne), Se.projectionMatrixInverse.copy(Se
					.projectionMatrix).invert()
			}
		}

		function le(Se, be) {
			be === null ? Se.matrixWorld.copy(Se.matrix) : Se.matrixWorld.multiplyMatrices(be.matrixWorld, Se
				.matrix), Se.matrixWorldInverse.copy(Se.matrixWorld).invert()
		}
		this.updateCamera = function(Se) {
			if (c === null) return;
			let be = Se.near,
				Me = Se.far;
			w.texture !== null && (w.depthNear > 0 && (be = w.depthNear), w.depthFar > 0 && (Me = w.depthFar)),
				z.near = U.near = O.near = be, z.far = U.far = O.far = Me, (j !== z.near || ge !== z.far) && (c
					.updateRenderState({
						depthNear: z.near,
						depthFar: z.far
					}), j = z.near, ge = z.far), O.layers.mask = Se.layers.mask | 2, U.layers.mask = Se.layers
				.mask | 4, z.layers.mask = O.layers.mask | U.layers.mask;
			const Ve = Se.parent,
				it = z.cameras;
			le(z, Ve);
			for (let pt = 0; pt < it.length; pt++) le(it[pt], Ve);
			it.length === 2 ? q(z, O, U) : z.projectionMatrix.copy(O.projectionMatrix), de(Se, z, Ve)
		};

		function de(Se, be, Me) {
			Me === null ? Se.matrix.copy(be.matrixWorld) : (Se.matrix.copy(Me.matrixWorld), Se.matrix.invert(), Se
					.matrix.multiply(be.matrixWorld)), Se.matrix.decompose(Se.position, Se.quaternion, Se.scale), Se
				.updateMatrixWorld(!0), Se.projectionMatrix.copy(be.projectionMatrix), Se.projectionMatrixInverse
				.copy(be.projectionMatrixInverse), Se.isPerspectiveCamera && (Se.fov = RAD2DEG * 2 * Math.atan(1 /
					Se.projectionMatrix.elements[5]), Se.zoom = 1)
		}
		this.getCamera = function() {
			return z
		}, this.getFoveation = function() {
			if (!(C === null && _ === null)) return g
		}, this.setFoveation = function(Se) {
			g = Se, C !== null && (C.fixedFoveation = Se), _ !== null && _.fixedFoveation !== void 0 && (_
				.fixedFoveation = Se)
		}, this.hasDepthSensing = function() {
			return w.texture !== null
		}, this.getDepthSensingMesh = function() {
			return w.getMesh(z)
		};
		let _e = null;

		function ke(Se, be) {
			if (y = be.getViewerPose(v || f), S = be, y !== null) {
				const Me = y.views;
				_ !== null && (s.setRenderTargetFramebuffer(k, _.framebuffer), s.setRenderTarget(k));
				let Ve = !1;
				Me.length !== z.cameras.length && (z.cameras.length = 0, Ve = !0);
				for (let dt = 0; dt < Me.length; dt++) {
					const He = Me[dt];
					let Ae = null;
					if (_ !== null) Ae = _.getViewport(He);
					else {
						const ye = b.getViewSubImage(C, He);
						Ae = ye.viewport, dt === 0 && (s.setRenderTargetTextures(k, ye.colorTexture, ye
							.depthStencilTexture), s.setRenderTarget(k))
					}
					let xe = V[dt];
					xe === void 0 && (xe = new PerspectiveCamera, xe.layers.enable(dt), xe.viewport = new Vector4,
							V[dt] = xe), xe.matrix.fromArray(He.transform.matrix), xe.matrix.decompose(xe.position,
							xe.quaternion, xe.scale), xe.projectionMatrix.fromArray(He.projectionMatrix), xe
						.projectionMatrixInverse.copy(xe.projectionMatrix).invert(), xe.viewport.set(Ae.x, Ae.y, Ae
							.width, Ae.height), dt === 0 && (z.matrix.copy(xe.matrix), z.matrix.decompose(z
							.position, z.quaternion, z.scale)), Ve === !0 && z.cameras.push(xe)
				}
				const it = c.enabledFeatures;
				if (it && it.includes("depth-sensing") && c.depthUsage == "gpu-optimized" && b) {
					const dt = b.getDepthInformation(Me[0]);
					dt && dt.isValid && dt.texture && w.init(s, dt, c.renderState)
				}
			}
			for (let Me = 0; Me < M.length; Me++) {
				const Ve = D[Me],
					it = M[Me];
				Ve !== null && it !== void 0 && it.update(Ve, be, v || f)
			}
			_e && _e(Se, be), be.detectedPlanes && l.dispatchEvent({
				type: "planesdetected",
				data: be
			}), S = null
		}
		const De = new WebGLAnimation;
		De.setAnimationLoop(ke), this.setAnimationLoop = function(Se) {
			_e = Se
		}, this.dispose = function() {}
	}
}
const _e1 = new Euler,
	_m1 = new Matrix4;

function WebGLMaterials(o, s) {
	function a(T, A) {
		T.matrixAutoUpdate === !0 && T.updateMatrix(), A.value.copy(T.matrix)
	}

	function l(T, A) {
		A.color.getRGB(T.fogColor.value, getUnlitUniformColorSpace(o)), A.isFog ? (T.fogNear.value = A.near, T.fogFar
			.value = A.far) : A.isFogExp2 && (T.fogDensity.value = A.density)
	}

	function c(T, A, k, M, D) {
		A.isMeshBasicMaterial || A.isMeshLambertMaterial ? d(T, A) : A.isMeshToonMaterial ? (d(T, A), b(T, A)) : A
			.isMeshPhongMaterial ? (d(T, A), y(T, A)) : A.isMeshStandardMaterial ? (d(T, A), C(T, A), A
				.isMeshPhysicalMaterial && _(T, A, D)) : A.isMeshMatcapMaterial ? (d(T, A), S(T, A)) : A
			.isMeshDepthMaterial ? d(T, A) : A.isMeshDistanceMaterial ? (d(T, A), w(T, A)) : A.isMeshNormalMaterial ? d(
				T, A) : A.isLineBasicMaterial ? (f(T, A), A.isLineDashedMaterial && m(T, A)) : A.isPointsMaterial ? g(T,
				A, k, M) : A.isSpriteMaterial ? v(T, A) : A.isShadowMaterial ? (T.color.value.copy(A.color), T.opacity
				.value = A.opacity) : A.isShaderMaterial && (A.uniformsNeedUpdate = !1)
	}

	function d(T, A) {
		T.opacity.value = A.opacity, A.color && T.diffuse.value.copy(A.color), A.emissive && T.emissive.value.copy(A
				.emissive).multiplyScalar(A.emissiveIntensity), A.map && (T.map.value = A.map, a(A.map, T
			.mapTransform)), A.alphaMap && (T.alphaMap.value = A.alphaMap, a(A.alphaMap, T.alphaMapTransform)), A
			.bumpMap && (T.bumpMap.value = A.bumpMap, a(A.bumpMap, T.bumpMapTransform), T.bumpScale.value = A.bumpScale,
				A.side === BackSide && (T.bumpScale.value *= -1)), A.normalMap && (T.normalMap.value = A.normalMap, a(A
					.normalMap, T.normalMapTransform), T.normalScale.value.copy(A.normalScale), A.side === BackSide && T
				.normalScale.value.negate()), A.displacementMap && (T.displacementMap.value = A.displacementMap, a(A
					.displacementMap, T.displacementMapTransform), T.displacementScale.value = A.displacementScale, T
				.displacementBias.value = A.displacementBias), A.emissiveMap && (T.emissiveMap.value = A.emissiveMap, a(
				A.emissiveMap, T.emissiveMapTransform)), A.specularMap && (T.specularMap.value = A.specularMap, a(A
				.specularMap, T.specularMapTransform)), A.alphaTest > 0 && (T.alphaTest.value = A.alphaTest);
		const k = s.get(A),
			M = k.envMap,
			D = k.envMapRotation;
		M && (T.envMap.value = M, _e1.copy(D), _e1.x *= -1, _e1.y *= -1, _e1.z *= -1, M.isCubeTexture && M
			.isRenderTargetTexture === !1 && (_e1.y *= -1, _e1.z *= -1), T.envMapRotation.value.setFromMatrix4(_m1
				.makeRotationFromEuler(_e1)), T.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !
			1 ? -1 : 1, T.reflectivity.value = A.reflectivity, T.ior.value = A.ior, T.refractionRatio.value = A
			.refractionRatio), A.lightMap && (T.lightMap.value = A.lightMap, T.lightMapIntensity.value = A
			.lightMapIntensity, a(A.lightMap, T.lightMapTransform)), A.aoMap && (T.aoMap.value = A.aoMap, T
			.aoMapIntensity.value = A.aoMapIntensity, a(A.aoMap, T.aoMapTransform))
	}

	function f(T, A) {
		T.diffuse.value.copy(A.color), T.opacity.value = A.opacity, A.map && (T.map.value = A.map, a(A.map, T
			.mapTransform))
	}

	function m(T, A) {
		T.dashSize.value = A.dashSize, T.totalSize.value = A.dashSize + A.gapSize, T.scale.value = A.scale
	}

	function g(T, A, k, M) {
		T.diffuse.value.copy(A.color), T.opacity.value = A.opacity, T.size.value = A.size * k, T.scale.value = M * .5, A
			.map && (T.map.value = A.map, a(A.map, T.uvTransform)), A.alphaMap && (T.alphaMap.value = A.alphaMap, a(A
				.alphaMap, T.alphaMapTransform)), A.alphaTest > 0 && (T.alphaTest.value = A.alphaTest)
	}

	function v(T, A) {
		T.diffuse.value.copy(A.color), T.opacity.value = A.opacity, T.rotation.value = A.rotation, A.map && (T.map
			.value = A.map, a(A.map, T.mapTransform)), A.alphaMap && (T.alphaMap.value = A.alphaMap, a(A.alphaMap, T
			.alphaMapTransform)), A.alphaTest > 0 && (T.alphaTest.value = A.alphaTest)
	}

	function y(T, A) {
		T.specular.value.copy(A.specular), T.shininess.value = Math.max(A.shininess, 1e-4)
	}

	function b(T, A) {
		A.gradientMap && (T.gradientMap.value = A.gradientMap)
	}

	function C(T, A) {
		T.metalness.value = A.metalness, A.metalnessMap && (T.metalnessMap.value = A.metalnessMap, a(A.metalnessMap, T
			.metalnessMapTransform)), T.roughness.value = A.roughness, A.roughnessMap && (T.roughnessMap.value = A
			.roughnessMap, a(A.roughnessMap, T.roughnessMapTransform)), A.envMap && (T.envMapIntensity.value = A
			.envMapIntensity)
	}

	function _(T, A, k) {
		T.ior.value = A.ior, A.sheen > 0 && (T.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen), T
				.sheenRoughness.value = A.sheenRoughness, A.sheenColorMap && (T.sheenColorMap.value = A.sheenColorMap,
					a(A.sheenColorMap, T.sheenColorMapTransform)), A.sheenRoughnessMap && (T.sheenRoughnessMap.value = A
					.sheenRoughnessMap, a(A.sheenRoughnessMap, T.sheenRoughnessMapTransform))), A.clearcoat > 0 && (T
				.clearcoat.value = A.clearcoat, T.clearcoatRoughness.value = A.clearcoatRoughness, A.clearcoatMap && (T
					.clearcoatMap.value = A.clearcoatMap, a(A.clearcoatMap, T.clearcoatMapTransform)), A
				.clearcoatRoughnessMap && (T.clearcoatRoughnessMap.value = A.clearcoatRoughnessMap, a(A
					.clearcoatRoughnessMap, T.clearcoatRoughnessMapTransform)), A.clearcoatNormalMap && (T
					.clearcoatNormalMap.value = A.clearcoatNormalMap, a(A.clearcoatNormalMap, T
						.clearcoatNormalMapTransform), T.clearcoatNormalScale.value.copy(A.clearcoatNormalScale), A
					.side === BackSide && T.clearcoatNormalScale.value.negate())), A.dispersion > 0 && (T.dispersion
				.value = A.dispersion), A.iridescence > 0 && (T.iridescence.value = A.iridescence, T.iridescenceIOR
				.value = A.iridescenceIOR, T.iridescenceThicknessMinimum.value = A.iridescenceThicknessRange[0], T
				.iridescenceThicknessMaximum.value = A.iridescenceThicknessRange[1], A.iridescenceMap && (T
					.iridescenceMap.value = A.iridescenceMap, a(A.iridescenceMap, T.iridescenceMapTransform)), A
				.iridescenceThicknessMap && (T.iridescenceThicknessMap.value = A.iridescenceThicknessMap, a(A
					.iridescenceThicknessMap, T.iridescenceThicknessMapTransform))), A.transmission > 0 && (T
				.transmission.value = A.transmission, T.transmissionSamplerMap.value = k.texture, T
				.transmissionSamplerSize.value.set(k.width, k.height), A.transmissionMap && (T.transmissionMap.value = A
					.transmissionMap, a(A.transmissionMap, T.transmissionMapTransform)), T.thickness.value = A
				.thickness, A.thicknessMap && (T.thicknessMap.value = A.thicknessMap, a(A.thicknessMap, T
					.thicknessMapTransform)), T.attenuationDistance.value = A.attenuationDistance, T.attenuationColor
				.value.copy(A.attenuationColor)), A.anisotropy > 0 && (T.anisotropyVector.value.set(A.anisotropy * Math
				.cos(A.anisotropyRotation), A.anisotropy * Math.sin(A.anisotropyRotation)), A.anisotropyMap && (T
				.anisotropyMap.value = A.anisotropyMap, a(A.anisotropyMap, T.anisotropyMapTransform))), T
			.specularIntensity.value = A.specularIntensity, T.specularColor.value.copy(A.specularColor), A
			.specularColorMap && (T.specularColorMap.value = A.specularColorMap, a(A.specularColorMap, T
				.specularColorMapTransform)), A.specularIntensityMap && (T.specularIntensityMap.value = A
				.specularIntensityMap, a(A.specularIntensityMap, T.specularIntensityMapTransform))
	}

	function S(T, A) {
		A.matcap && (T.matcap.value = A.matcap)
	}

	function w(T, A) {
		const k = s.get(A).light;
		T.referencePosition.value.setFromMatrixPosition(k.matrixWorld), T.nearDistance.value = k.shadow.camera.near, T
			.farDistance.value = k.shadow.camera.far
	}
	return {
		refreshFogUniforms: l,
		refreshMaterialUniforms: c
	}
}

function WebGLUniformsGroups(o, s, a, l) {
	let c = {},
		d = {},
		f = [];
	const m = o.getParameter(o.MAX_UNIFORM_BUFFER_BINDINGS);

	function g(k, M) {
		const D = M.program;
		l.uniformBlockBinding(k, D)
	}

	function v(k, M) {
		let D = c[k.id];
		D === void 0 && (S(k), D = y(k), c[k.id] = D, k.addEventListener("dispose", T));
		const F = M.program;
		l.updateUBOMapping(k, F);
		const R = s.render.frame;
		d[k.id] !== R && (C(k), d[k.id] = R)
	}

	function y(k) {
		const M = b();
		k.__bindingPointIndex = M;
		const D = o.createBuffer(),
			F = k.__size,
			R = k.usage;
		return o.bindBuffer(o.UNIFORM_BUFFER, D), o.bufferData(o.UNIFORM_BUFFER, F, R), o.bindBuffer(o.UNIFORM_BUFFER,
			null), o.bindBufferBase(o.UNIFORM_BUFFER, M, D), D
	}

	function b() {
		for (let k = 0; k < m; k++)
			if (f.indexOf(k) === -1) return f.push(k), k;
		return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
	}

	function C(k) {
		const M = c[k.id],
			D = k.uniforms,
			F = k.__cache;
		o.bindBuffer(o.UNIFORM_BUFFER, M);
		for (let R = 0, O = D.length; R < O; R++) {
			const U = Array.isArray(D[R]) ? D[R] : [D[R]];
			for (let V = 0, z = U.length; V < z; V++) {
				const j = U[V];
				if (_(j, R, V, F) === !0) {
					const ge = j.__offset,
						me = Array.isArray(j.value) ? j.value : [j.value];
					let he = 0;
					for (let ce = 0; ce < me.length; ce++) {
						const ae = me[ce],
							fe = w(ae);
						typeof ae == "number" || typeof ae == "boolean" ? (j.__data[0] = ae, o.bufferSubData(o
							.UNIFORM_BUFFER, ge + he, j.__data)) : ae.isMatrix3 ? (j.__data[0] = ae.elements[0], j
							.__data[1] = ae.elements[1], j.__data[2] = ae.elements[2], j.__data[3] = 0, j.__data[
							4] = ae.elements[3], j.__data[5] = ae.elements[4], j.__data[6] = ae.elements[5], j
							.__data[7] = 0, j.__data[8] = ae.elements[6], j.__data[9] = ae.elements[7], j.__data[
							10] = ae.elements[8], j.__data[11] = 0) : (ae.toArray(j.__data, he), he += fe.storage /
							Float32Array.BYTES_PER_ELEMENT)
					}
					o.bufferSubData(o.UNIFORM_BUFFER, ge, j.__data)
				}
			}
		}
		o.bindBuffer(o.UNIFORM_BUFFER, null)
	}

	function _(k, M, D, F) {
		const R = k.value,
			O = M + "_" + D;
		if (F[O] === void 0) return typeof R == "number" || typeof R == "boolean" ? F[O] = R : F[O] = R.clone(), !0; {
			const U = F[O];
			if (typeof R == "number" || typeof R == "boolean") {
				if (U !== R) return F[O] = R, !0
			} else if (U.equals(R) === !1) return U.copy(R), !0
		}
		return !1
	}

	function S(k) {
		const M = k.uniforms;
		let D = 0;
		const F = 16;
		for (let O = 0, U = M.length; O < U; O++) {
			const V = Array.isArray(M[O]) ? M[O] : [M[O]];
			for (let z = 0, j = V.length; z < j; z++) {
				const ge = V[z],
					me = Array.isArray(ge.value) ? ge.value : [ge.value];
				for (let he = 0, ce = me.length; he < ce; he++) {
					const ae = me[he],
						fe = w(ae),
						q = D % F,
						le = q % fe.boundary,
						de = q + le;
					D += le, de !== 0 && F - de < fe.storage && (D += F - de), ge.__data = new Float32Array(fe.storage /
						Float32Array.BYTES_PER_ELEMENT), ge.__offset = D, D += fe.storage
				}
			}
		}
		const R = D % F;
		return R > 0 && (D += F - R), k.__size = D, k.__cache = {}, this
	}

	function w(k) {
		const M = {
			boundary: 0,
			storage: 0
		};
		return typeof k == "number" || typeof k == "boolean" ? (M.boundary = 4, M.storage = 4) : k.isVector2 ? (M
				.boundary = 8, M.storage = 8) : k.isVector3 || k.isColor ? (M.boundary = 16, M.storage = 12) : k
			.isVector4 ? (M.boundary = 16, M.storage = 16) : k.isMatrix3 ? (M.boundary = 48, M.storage = 48) : k
			.isMatrix4 ? (M.boundary = 64, M.storage = 64) : k.isTexture ? console.warn(
				"THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn(
				"THREE.WebGLRenderer: Unsupported uniform value type.", k), M
	}

	function T(k) {
		const M = k.target;
		M.removeEventListener("dispose", T);
		const D = f.indexOf(M.__bindingPointIndex);
		f.splice(D, 1), o.deleteBuffer(c[M.id]), delete c[M.id], delete d[M.id]
	}

	function A() {
		for (const k in c) o.deleteBuffer(c[k]);
		f = [], c = {}, d = {}
	}
	return {
		bind: g,
		update: v,
		dispose: A
	}
}
class WebGLRenderer {
	constructor(s = {}) {
		const {
			canvas: a = createCanvasElement(),
			context: l = null,
			depth: c = !0,
			stencil: d = !1,
			alpha: f = !1,
			antialias: m = !1,
			premultipliedAlpha: g = !0,
			preserveDrawingBuffer: v = !1,
			powerPreference: y = "default",
			failIfMajorPerformanceCaveat: b = !1,
			reverseDepthBuffer: C = !1
		} = s;
		this.isWebGLRenderer = !0;
		let _;
		if (l !== null) {
			if (typeof WebGLRenderingContext < "u" && l instanceof WebGLRenderingContext) throw new Error(
				"THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
			_ = l.getContextAttributes().alpha
		} else _ = f;
		const S = new Uint32Array(4),
			w = new Int32Array(4);
		let T = null,
			A = null;
		const k = [],
			M = [];
		this.domElement = a, this.debug = {
				checkShaderErrors: !0,
				onShaderError: null
			}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0,
			this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping =
			NoToneMapping, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
		const D = this;
		let F = !1;
		this._outputColorSpace = SRGBColorSpace;
		let R = 0,
			O = 0,
			U = null,
			V = -1,
			z = null;
		const j = new Vector4,
			ge = new Vector4;
		let me = null;
		const he = new Color(0);
		let ce = 0,
			ae = a.width,
			fe = a.height,
			q = 1,
			le = null,
			de = null;
		const _e = new Vector4(0, 0, ae, fe),
			ke = new Vector4(0, 0, ae, fe);
		let De = !1;
		const Se = new Frustum;
		let be = !1,
			Me = !1;
		const Ve = new Matrix4,
			it = new Matrix4,
			pt = new Vector3$1,
			dt = new Vector4,
			He = {
				background: null,
				fog: null,
				environment: null,
				overrideMaterial: null,
				isScene: !0
			};
		let Ae = !1;

		function xe() {
			return U === null ? q : 1
		}
		let ye = l;

		function Le(We, et) {
			return a.getContext(We, et)
		}
		try {
			const We = {
				alpha: !0,
				depth: c,
				stencil: d,
				antialias: m,
				premultipliedAlpha: g,
				preserveDrawingBuffer: v,
				powerPreference: y,
				failIfMajorPerformanceCaveat: b
			};
			if ("setAttribute" in a && a.setAttribute("data-engine", `three.js r${REVISION}`), a.addEventListener(
					"webglcontextlost", xt, !1), a.addEventListener("webglcontextrestored", Rt, !1), a
				.addEventListener("webglcontextcreationerror", $t, !1), ye === null) {
				const et = "webgl2";
				if (ye = Le(et, We), ye === null) throw Le(et) ? new Error(
					"Error creating WebGL context with your selected attributes.") : new Error(
					"Error creating WebGL context.")
			}
		} catch (We) {
			throw console.error("THREE.WebGLRenderer: " + We.message), We
		}
		let Ue, nt, ot, at, Je, Ne, we, Ce, $e, Fe, Ge, ze, Oe, Xe, rt, ut, gt, Et, Ze, Ye, ct, yt, wt, Qe;

		function At() {
			Ue = new WebGLExtensions(ye), Ue.init(), yt = new WebGLUtils(ye, Ue), nt = new WebGLCapabilities(ye, Ue,
					s, yt), ot = new WebGLState(ye, Ue), nt.reverseDepthBuffer && C && ot.buffers.depth.setReversed(
					!0), at = new WebGLInfo(ye), Je = new WebGLProperties, Ne = new WebGLTextures(ye, Ue, ot, Je,
					nt, yt, at), we = new WebGLCubeMaps(D), Ce = new WebGLCubeUVMaps(D), $e = new WebGLAttributes(
					ye), wt = new WebGLBindingStates(ye, $e), Fe = new WebGLGeometries(ye, $e, at, wt), Ge =
				new WebGLObjects(ye, Fe, $e, at), Ze = new WebGLMorphtargets(ye, nt, Ne), ut = new WebGLClipping(
				Je), ze = new WebGLPrograms(D, we, Ce, Ue, nt, wt, ut), Oe = new WebGLMaterials(D, Je), Xe =
				new WebGLRenderLists, rt = new WebGLRenderStates(Ue), Et = new WebGLBackground(D, we, Ce, ot, Ge, _,
					g), gt = new WebGLShadowMap(D, Ge, nt), Qe = new WebGLUniformsGroups(ye, at, nt, ot), Ye =
				new WebGLBufferRenderer(ye, Ue, at), ct = new WebGLIndexedBufferRenderer(ye, Ue, at), at.programs =
				ze.programs, D.capabilities = nt, D.extensions = Ue, D.properties = Je, D.renderLists = Xe, D
				.shadowMap = gt, D.state = ot, D.info = at
		}
		At();
		const Ct = new WebXRManager(D, ye);
		this.xr = Ct, this.getContext = function() {
			return ye
		}, this.getContextAttributes = function() {
			return ye.getContextAttributes()
		}, this.forceContextLoss = function() {
			const We = Ue.get("WEBGL_lose_context");
			We && We.loseContext()
		}, this.forceContextRestore = function() {
			const We = Ue.get("WEBGL_lose_context");
			We && We.restoreContext()
		}, this.getPixelRatio = function() {
			return q
		}, this.setPixelRatio = function(We) {
			We !== void 0 && (q = We, this.setSize(ae, fe, !1))
		}, this.getSize = function(We) {
			return We.set(ae, fe)
		}, this.setSize = function(We, et, ft = !0) {
			if (Ct.isPresenting) {
				console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
				return
			}
			ae = We, fe = et, a.width = Math.floor(We * q), a.height = Math.floor(et * q), ft === !0 && (a.style
				.width = We + "px", a.style.height = et + "px"), this.setViewport(0, 0, We, et)
		}, this.getDrawingBufferSize = function(We) {
			return We.set(ae * q, fe * q).floor()
		}, this.setDrawingBufferSize = function(We, et, ft) {
			ae = We, fe = et, q = ft, a.width = Math.floor(We * ft), a.height = Math.floor(et * ft), this
				.setViewport(0, 0, We, et)
		}, this.getCurrentViewport = function(We) {
			return We.copy(j)
		}, this.getViewport = function(We) {
			return We.copy(_e)
		}, this.setViewport = function(We, et, ft, vt) {
			We.isVector4 ? _e.set(We.x, We.y, We.z, We.w) : _e.set(We, et, ft, vt), ot.viewport(j.copy(_e)
				.multiplyScalar(q).round())
		}, this.getScissor = function(We) {
			return We.copy(ke)
		}, this.setScissor = function(We, et, ft, vt) {
			We.isVector4 ? ke.set(We.x, We.y, We.z, We.w) : ke.set(We, et, ft, vt), ot.scissor(ge.copy(ke)
				.multiplyScalar(q).round())
		}, this.getScissorTest = function() {
			return De
		}, this.setScissorTest = function(We) {
			ot.setScissorTest(De = We)
		}, this.setOpaqueSort = function(We) {
			le = We
		}, this.setTransparentSort = function(We) {
			de = We
		}, this.getClearColor = function(We) {
			return We.copy(Et.getClearColor())
		}, this.setClearColor = function() {
			Et.setClearColor(...arguments)
		}, this.getClearAlpha = function() {
			return Et.getClearAlpha()
		}, this.setClearAlpha = function() {
			Et.setClearAlpha(...arguments)
		}, this.clear = function(We = !0, et = !0, ft = !0) {
			let vt = 0;
			if (We) {
				let mt = !1;
				if (U !== null) {
					const Dt = U.texture.format;
					mt = Dt === RGBAIntegerFormat || Dt === RGIntegerFormat || Dt === RedIntegerFormat
				}
				if (mt) {
					const Dt = U.texture.type,
						Pt = Dt === UnsignedByteType || Dt === UnsignedIntType || Dt === UnsignedShortType ||
						Dt === UnsignedInt248Type || Dt === UnsignedShort4444Type || Dt ===
						UnsignedShort5551Type,
						Lt = Et.getClearColor(),
						Ht = Et.getClearAlpha(),
						rn = Lt.r,
						en = Lt.g,
						Xt = Lt.b;
					Pt ? (S[0] = rn, S[1] = en, S[2] = Xt, S[3] = Ht, ye.clearBufferuiv(ye.COLOR, 0, S)) : (w[
						0] = rn, w[1] = en, w[2] = Xt, w[3] = Ht, ye.clearBufferiv(ye.COLOR, 0, w))
				} else vt |= ye.COLOR_BUFFER_BIT
			}
			et && (vt |= ye.DEPTH_BUFFER_BIT), ft && (vt |= ye.STENCIL_BUFFER_BIT, this.state.buffers.stencil
				.setMask(4294967295)), ye.clear(vt)
		}, this.clearColor = function() {
			this.clear(!0, !1, !1)
		}, this.clearDepth = function() {
			this.clear(!1, !0, !1)
		}, this.clearStencil = function() {
			this.clear(!1, !1, !0)
		}, this.dispose = function() {
			a.removeEventListener("webglcontextlost", xt, !1), a.removeEventListener("webglcontextrestored", Rt,
					!1), a.removeEventListener("webglcontextcreationerror", $t, !1), Et.dispose(), Xe.dispose(),
				rt.dispose(), Je.dispose(), we.dispose(), Ce.dispose(), Ge.dispose(), wt.dispose(), Qe
			.dispose(), ze.dispose(), Ct.dispose(), Ct.removeEventListener("sessionstart", Te), Ct
				.removeEventListener("sessionend", Pe), lt.stop()
		};

		function xt(We) {
			We.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), F = !0
		}

		function Rt() {
			console.log("THREE.WebGLRenderer: Context Restored."), F = !1;
			const We = at.autoReset,
				et = gt.enabled,
				ft = gt.autoUpdate,
				vt = gt.needsUpdate,
				mt = gt.type;
			At(), at.autoReset = We, gt.enabled = et, gt.autoUpdate = ft, gt.needsUpdate = vt, gt.type = mt
		}

		function $t(We) {
			console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", We.statusMessage)
		}

		function zt(We) {
			const et = We.target;
			et.removeEventListener("dispose", zt), sn(et)
		}

		function sn(We) {
			dn(We), Je.remove(We)
		}

		function dn(We) {
			const et = Je.get(We).programs;
			et !== void 0 && (et.forEach(function(ft) {
				ze.releaseProgram(ft)
			}), We.isShaderMaterial && ze.releaseShaderCache(We))
		}
		this.renderBufferDirect = function(We, et, ft, vt, mt, Dt) {
			et === null && (et = He);
			const Pt = mt.isMesh && mt.matrixWorld.determinant() < 0,
				Lt = zn(We, et, ft, vt, mt);
			ot.setMaterial(vt, Pt);
			let Ht = ft.index,
				rn = 1;
			if (vt.wireframe === !0) {
				if (Ht = Fe.getWireframeAttribute(ft), Ht === void 0) return;
				rn = 2
			}
			const en = ft.drawRange,
				Xt = ft.attributes.position;
			let un = en.start * rn,
				mn = (en.start + en.count) * rn;
			Dt !== null && (un = Math.max(un, Dt.start * rn), mn = Math.min(mn, (Dt.start + Dt.count) * rn)),
				Ht !== null ? (un = Math.max(un, 0), mn = Math.min(mn, Ht.count)) : Xt != null && (un = Math
					.max(un, 0), mn = Math.min(mn, Xt.count));
			const Tn = mn - un;
			if (Tn < 0 || Tn === 1 / 0) return;
			wt.setup(mt, vt, Lt, ft, Ht);
			let cn, hn = Ye;
			if (Ht !== null && (cn = $e.get(Ht), hn = ct, hn.setIndex(cn)), mt.isMesh) vt.wireframe === !0 ? (ot
				.setLineWidth(vt.wireframeLinewidth * xe()), hn.setMode(ye.LINES)) : hn.setMode(ye
				.TRIANGLES);
			else if (mt.isLine) {
				let Zt = vt.linewidth;
				Zt === void 0 && (Zt = 1), ot.setLineWidth(Zt * xe()), mt.isLineSegments ? hn.setMode(ye
					.LINES) : mt.isLineLoop ? hn.setMode(ye.LINE_LOOP) : hn.setMode(ye.LINE_STRIP)
			} else mt.isPoints ? hn.setMode(ye.POINTS) : mt.isSprite && hn.setMode(ye.TRIANGLES);
			if (mt.isBatchedMesh)
				if (mt._multiDrawInstances !== null) warnOnce(
					"THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
					), hn.renderMultiDrawInstances(mt._multiDrawStarts, mt._multiDrawCounts, mt
					._multiDrawCount, mt._multiDrawInstances);
				else if (Ue.get("WEBGL_multi_draw")) hn.renderMultiDraw(mt._multiDrawStarts, mt
				._multiDrawCounts, mt._multiDrawCount);
			else {
				const Zt = mt._multiDrawStarts,
					Fn = mt._multiDrawCounts,
					gn = mt._multiDrawCount,
					jn = Ht ? $e.get(Ht).bytesPerElement : 1,
					Sn = Je.get(vt).currentProgram.getUniforms();
				for (let Vn = 0; Vn < gn; Vn++) Sn.setValue(ye, "_gl_DrawID", Vn), hn.render(Zt[Vn] / jn, Fn[
					Vn])
			} else if (mt.isInstancedMesh) hn.renderInstances(un, Tn, mt.count);
			else if (ft.isInstancedBufferGeometry) {
				const Zt = ft._maxInstanceCount !== void 0 ? ft._maxInstanceCount : 1 / 0,
					Fn = Math.min(ft.instanceCount, Zt);
				hn.renderInstances(un, Tn, Fn)
			} else hn.render(un, Tn)
		};

		function Mt(We, et, ft) {
			We.transparent === !0 && We.side === DoubleSide && We.forceSinglePass === !1 ? (We.side = BackSide, We
				.needsUpdate = !0, wn(We, et, ft), We.side = FrontSide, We.needsUpdate = !0, wn(We, et, ft), We
				.side = DoubleSide) : wn(We, et, ft)
		}
		this.compile = function(We, et, ft = null) {
			ft === null && (ft = We), A = rt.get(ft), A.init(et), M.push(A), ft.traverseVisible(function(mt) {
				mt.isLight && mt.layers.test(et.layers) && (A.pushLight(mt), mt.castShadow && A
					.pushShadow(mt))
			}), We !== ft && We.traverseVisible(function(mt) {
				mt.isLight && mt.layers.test(et.layers) && (A.pushLight(mt), mt.castShadow && A
					.pushShadow(mt))
			}), A.setupLights();
			const vt = new Set;
			return We.traverse(function(mt) {
				if (!(mt.isMesh || mt.isPoints || mt.isLine || mt.isSprite)) return;
				const Dt = mt.material;
				if (Dt)
					if (Array.isArray(Dt))
						for (let Pt = 0; Pt < Dt.length; Pt++) {
							const Lt = Dt[Pt];
							Mt(Lt, ft, mt), vt.add(Lt)
						} else Mt(Dt, ft, mt), vt.add(Dt)
			}), A = M.pop(), vt
		}, this.compileAsync = function(We, et, ft = null) {
			const vt = this.compile(We, et, ft);
			return new Promise(mt => {
				function Dt() {
					if (vt.forEach(function(Pt) {
							Je.get(Pt).currentProgram.isReady() && vt.delete(Pt)
						}), vt.size === 0) {
						mt(We);
						return
					}
					setTimeout(Dt, 10)
				}
				Ue.get("KHR_parallel_shader_compile") !== null ? Dt() : setTimeout(Dt, 10)
			})
		};
		let qt = null;

		function pn(We) {
			qt && qt(We)
		}

		function Te() {
			lt.stop()
		}

		function Pe() {
			lt.start()
		}
		const lt = new WebGLAnimation;
		lt.setAnimationLoop(pn), typeof self < "u" && lt.setContext(self), this.setAnimationLoop = function(We) {
				qt = We, Ct.setAnimationLoop(We), We === null ? lt.stop() : lt.start()
			}, Ct.addEventListener("sessionstart", Te), Ct.addEventListener("sessionend", Pe), this.render =
			function(We, et) {
				if (et !== void 0 && et.isCamera !== !0) {
					console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
					return
				}
				if (F === !0) return;
				if (We.matrixWorldAutoUpdate === !0 && We.updateMatrixWorld(), et.parent === null && et
					.matrixWorldAutoUpdate === !0 && et.updateMatrixWorld(), Ct.enabled === !0 && Ct
					.isPresenting === !0 && (Ct.cameraAutoUpdate === !0 && Ct.updateCamera(et), et = Ct
				.getCamera()), We.isScene === !0 && We.onBeforeRender(D, We, et, U), A = rt.get(We, M.length), A
					.init(et), M.push(A), it.multiplyMatrices(et.projectionMatrix, et.matrixWorldInverse), Se
					.setFromProjectionMatrix(it), Me = this.localClippingEnabled, be = ut.init(this.clippingPlanes,
						Me), T = Xe.get(We, k.length), T.init(), k.push(T), Ct.enabled === !0 && Ct.isPresenting ===
					!0) {
					const Dt = D.xr.getDepthSensingMesh();
					Dt !== null && bt(Dt, et, -1 / 0, D.sortObjects)
				}
				bt(We, et, 0, D.sortObjects), T.finish(), D.sortObjects === !0 && T.sort(le, de), Ae = Ct
					.enabled === !1 || Ct.isPresenting === !1 || Ct.hasDepthSensing() === !1, Ae && Et
					.addToRenderList(T, We), this.info.render.frame++, be === !0 && ut.beginShadows();
				const ft = A.state.shadowsArray;
				gt.render(ft, We, et), be === !0 && ut.endShadows(), this.info.autoReset === !0 && this.info
			.reset();
				const vt = T.opaque,
					mt = T.transmissive;
				if (A.setupLights(), et.isArrayCamera) {
					const Dt = et.cameras;
					if (mt.length > 0)
						for (let Pt = 0, Lt = Dt.length; Pt < Lt; Pt++) {
							const Ht = Dt[Pt];
							Ot(vt, mt, We, Ht)
						}
					Ae && Et.render(We);
					for (let Pt = 0, Lt = Dt.length; Pt < Lt; Pt++) {
						const Ht = Dt[Pt];
						Nt(T, We, Ht, Ht.viewport)
					}
				} else mt.length > 0 && Ot(vt, mt, We, et), Ae && Et.render(We), Nt(T, We, et);
				U !== null && O === 0 && (Ne.updateMultisampleRenderTarget(U), Ne.updateRenderTargetMipmap(U)), We
					.isScene === !0 && We.onAfterRender(D, We, et), wt.resetDefaultState(), V = -1, z = null, M
					.pop(), M.length > 0 ? (A = M[M.length - 1], be === !0 && ut.setGlobalState(D.clippingPlanes, A
						.state.camera)) : A = null, k.pop(), k.length > 0 ? T = k[k.length - 1] : T = null
			};

		function bt(We, et, ft, vt) {
			if (We.visible === !1) return;
			if (We.layers.test(et.layers)) {
				if (We.isGroup) ft = We.renderOrder;
				else if (We.isLOD) We.autoUpdate === !0 && We.update(et);
				else if (We.isLight) A.pushLight(We), We.castShadow && A.pushShadow(We);
				else if (We.isSprite) {
					if (!We.frustumCulled || Se.intersectsSprite(We)) {
						vt && dt.setFromMatrixPosition(We.matrixWorld).applyMatrix4(it);
						const Pt = Ge.update(We),
							Lt = We.material;
						Lt.visible && T.push(We, Pt, Lt, ft, dt.z, null)
					}
				} else if ((We.isMesh || We.isLine || We.isPoints) && (!We.frustumCulled || Se.intersectsObject(
					We))) {
					const Pt = Ge.update(We),
						Lt = We.material;
					if (vt && (We.boundingSphere !== void 0 ? (We.boundingSphere === null && We
							.computeBoundingSphere(), dt.copy(We.boundingSphere.center)) : (Pt
							.boundingSphere === null && Pt.computeBoundingSphere(), dt.copy(Pt.boundingSphere
								.center)), dt.applyMatrix4(We.matrixWorld).applyMatrix4(it)), Array.isArray(Lt)) {
						const Ht = Pt.groups;
						for (let rn = 0, en = Ht.length; rn < en; rn++) {
							const Xt = Ht[rn],
								un = Lt[Xt.materialIndex];
							un && un.visible && T.push(We, Pt, un, ft, dt.z, Xt)
						}
					} else Lt.visible && T.push(We, Pt, Lt, ft, dt.z, null)
				}
			}
			const Dt = We.children;
			for (let Pt = 0, Lt = Dt.length; Pt < Lt; Pt++) bt(Dt[Pt], et, ft, vt)
		}

		function Nt(We, et, ft, vt) {
			const mt = We.opaque,
				Dt = We.transmissive,
				Pt = We.transparent;
			A.setupLightsView(ft), be === !0 && ut.setGlobalState(D.clippingPlanes, ft), vt && ot.viewport(j.copy(
				vt)), mt.length > 0 && nn(mt, et, ft), Dt.length > 0 && nn(Dt, et, ft), Pt.length > 0 && nn(Pt,
				et, ft), ot.buffers.depth.setTest(!0), ot.buffers.depth.setMask(!0), ot.buffers.color.setMask(!
				0), ot.setPolygonOffset(!1)
		}

		function Ot(We, et, ft, vt) {
			if ((ft.isScene === !0 ? ft.overrideMaterial : null) !== null) return;
			A.state.transmissionRenderTarget[vt.id] === void 0 && (A.state.transmissionRenderTarget[vt.id] =
				new WebGLRenderTarget(1, 1, {
					generateMipmaps: !0,
					type: Ue.has("EXT_color_buffer_half_float") || Ue.has("EXT_color_buffer_float") ?
						HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					samples: 4,
					stencilBuffer: d,
					resolveDepthBuffer: !1,
					resolveStencilBuffer: !1,
					colorSpace: ColorManagement.workingColorSpace
				}));
			const Dt = A.state.transmissionRenderTarget[vt.id],
				Pt = vt.viewport || j;
			Dt.setSize(Pt.z * D.transmissionResolutionScale, Pt.w * D.transmissionResolutionScale);
			const Lt = D.getRenderTarget();
			D.setRenderTarget(Dt), D.getClearColor(he), ce = D.getClearAlpha(), ce < 1 && D.setClearColor(16777215,
				.5), D.clear(), Ae && Et.render(ft);
			const Ht = D.toneMapping;
			D.toneMapping = NoToneMapping;
			const rn = vt.viewport;
			if (vt.viewport !== void 0 && (vt.viewport = void 0), A.setupLightsView(vt), be === !0 && ut
				.setGlobalState(D.clippingPlanes, vt), nn(We, ft, vt), Ne.updateMultisampleRenderTarget(Dt), Ne
				.updateRenderTargetMipmap(Dt), Ue.has("WEBGL_multisampled_render_to_texture") === !1) {
				let en = !1;
				for (let Xt = 0, un = et.length; Xt < un; Xt++) {
					const mn = et[Xt],
						Tn = mn.object,
						cn = mn.geometry,
						hn = mn.material,
						Zt = mn.group;
					if (hn.side === DoubleSide && Tn.layers.test(vt.layers)) {
						const Fn = hn.side;
						hn.side = BackSide, hn.needsUpdate = !0, Cn(Tn, ft, vt, cn, hn, Zt), hn.side = Fn, hn
							.needsUpdate = !0, en = !0
					}
				}
				en === !0 && (Ne.updateMultisampleRenderTarget(Dt), Ne.updateRenderTargetMipmap(Dt))
			}
			D.setRenderTarget(Lt), D.setClearColor(he, ce), rn !== void 0 && (vt.viewport = rn), D.toneMapping = Ht
		}

		function nn(We, et, ft) {
			const vt = et.isScene === !0 ? et.overrideMaterial : null;
			for (let mt = 0, Dt = We.length; mt < Dt; mt++) {
				const Pt = We[mt],
					Lt = Pt.object,
					Ht = Pt.geometry,
					rn = Pt.group;
				let en = Pt.material;
				en.allowOverride === !0 && vt !== null && (en = vt), Lt.layers.test(ft.layers) && Cn(Lt, et, ft, Ht,
					en, rn)
			}
		}

		function Cn(We, et, ft, vt, mt, Dt) {
			We.onBeforeRender(D, et, ft, vt, mt, Dt), We.modelViewMatrix.multiplyMatrices(ft.matrixWorldInverse, We
				.matrixWorld), We.normalMatrix.getNormalMatrix(We.modelViewMatrix), mt.onBeforeRender(D, et, ft,
				vt, We, Dt), mt.transparent === !0 && mt.side === DoubleSide && mt.forceSinglePass === !1 ? (mt
				.side = BackSide, mt.needsUpdate = !0, D.renderBufferDirect(ft, et, vt, mt, We, Dt), mt.side =
				FrontSide, mt.needsUpdate = !0, D.renderBufferDirect(ft, et, vt, mt, We, Dt), mt.side =
				DoubleSide) : D.renderBufferDirect(ft, et, vt, mt, We, Dt), We.onAfterRender(D, et, ft, vt, mt,
				Dt)
		}

		function wn(We, et, ft) {
			et.isScene !== !0 && (et = He);
			const vt = Je.get(We),
				mt = A.state.lights,
				Dt = A.state.shadowsArray,
				Pt = mt.state.version,
				Lt = ze.getParameters(We, mt.state, Dt, et, ft),
				Ht = ze.getProgramCacheKey(Lt);
			let rn = vt.programs;
			vt.environment = We.isMeshStandardMaterial ? et.environment : null, vt.fog = et.fog, vt.envMap = (We
					.isMeshStandardMaterial ? Ce : we).get(We.envMap || vt.environment), vt.envMapRotation = vt
				.environment !== null && We.envMap === null ? et.environmentRotation : We.envMapRotation, rn ===
				void 0 && (We.addEventListener("dispose", zt), rn = new Map, vt.programs = rn);
			let en = rn.get(Ht);
			if (en !== void 0) {
				if (vt.currentProgram === en && vt.lightsStateVersion === Pt) return fn(We, Lt), en
			} else Lt.uniforms = ze.getUniforms(We), We.onBeforeCompile(Lt, D), en = ze.acquireProgram(Lt, Ht), rn
				.set(Ht, en), vt.uniforms = Lt.uniforms;
			const Xt = vt.uniforms;
			return (!We.isShaderMaterial && !We.isRawShaderMaterial || We.clipping === !0) && (Xt.clippingPlanes =
					ut.uniform), fn(We, Lt), vt.needsLights = Nn(We), vt.lightsStateVersion = Pt, vt.needsLights &&
				(Xt.ambientLightColor.value = mt.state.ambient, Xt.lightProbe.value = mt.state.probe, Xt
					.directionalLights.value = mt.state.directional, Xt.directionalLightShadows.value = mt.state
					.directionalShadow, Xt.spotLights.value = mt.state.spot, Xt.spotLightShadows.value = mt.state
					.spotShadow, Xt.rectAreaLights.value = mt.state.rectArea, Xt.ltc_1.value = mt.state
					.rectAreaLTC1, Xt.ltc_2.value = mt.state.rectAreaLTC2, Xt.pointLights.value = mt.state.point, Xt
					.pointLightShadows.value = mt.state.pointShadow, Xt.hemisphereLights.value = mt.state.hemi, Xt
					.directionalShadowMap.value = mt.state.directionalShadowMap, Xt.directionalShadowMatrix.value =
					mt.state.directionalShadowMatrix, Xt.spotShadowMap.value = mt.state.spotShadowMap, Xt
					.spotLightMatrix.value = mt.state.spotLightMatrix, Xt.spotLightMap.value = mt.state
					.spotLightMap, Xt.pointShadowMap.value = mt.state.pointShadowMap, Xt.pointShadowMatrix.value =
					mt.state.pointShadowMatrix), vt.currentProgram = en, vt.uniformsList = null, en
		}

		function Mn(We) {
			if (We.uniformsList === null) {
				const et = We.currentProgram.getUniforms();
				We.uniformsList = WebGLUniforms.seqWithValue(et.seq, We.uniforms)
			}
			return We.uniformsList
		}

		function fn(We, et) {
			const ft = Je.get(We);
			ft.outputColorSpace = et.outputColorSpace, ft.batching = et.batching, ft.batchingColor = et
				.batchingColor, ft.instancing = et.instancing, ft.instancingColor = et.instancingColor, ft
				.instancingMorph = et.instancingMorph, ft.skinning = et.skinning, ft.morphTargets = et.morphTargets,
				ft.morphNormals = et.morphNormals, ft.morphColors = et.morphColors, ft.morphTargetsCount = et
				.morphTargetsCount, ft.numClippingPlanes = et.numClippingPlanes, ft.numIntersection = et
				.numClipIntersection, ft.vertexAlphas = et.vertexAlphas, ft.vertexTangents = et.vertexTangents, ft
				.toneMapping = et.toneMapping
		}

		function zn(We, et, ft, vt, mt) {
			et.isScene !== !0 && (et = He), Ne.resetTextureUnits();
			const Dt = et.fog,
				Pt = vt.isMeshStandardMaterial ? et.environment : null,
				Lt = U === null ? D.outputColorSpace : U.isXRRenderTarget === !0 ? U.texture.colorSpace :
				LinearSRGBColorSpace,
				Ht = (vt.isMeshStandardMaterial ? Ce : we).get(vt.envMap || Pt),
				rn = vt.vertexColors === !0 && !!ft.attributes.color && ft.attributes.color.itemSize === 4,
				en = !!ft.attributes.tangent && (!!vt.normalMap || vt.anisotropy > 0),
				Xt = !!ft.morphAttributes.position,
				un = !!ft.morphAttributes.normal,
				mn = !!ft.morphAttributes.color;
			let Tn = NoToneMapping;
			vt.toneMapped && (U === null || U.isXRRenderTarget === !0) && (Tn = D.toneMapping);
			const cn = ft.morphAttributes.position || ft.morphAttributes.normal || ft.morphAttributes.color,
				hn = cn !== void 0 ? cn.length : 0,
				Zt = Je.get(vt),
				Fn = A.state.lights;
			if (be === !0 && (Me === !0 || We !== z)) {
				const In = We === z && vt.id === V;
				ut.setState(vt, We, In)
			}
			let gn = !1;
			vt.version === Zt.__version ? (Zt.needsLights && Zt.lightsStateVersion !== Fn.state.version || Zt
				.outputColorSpace !== Lt || mt.isBatchedMesh && Zt.batching === !1 || !mt.isBatchedMesh && Zt
				.batching === !0 || mt.isBatchedMesh && Zt.batchingColor === !0 && mt.colorTexture === null ||
				mt.isBatchedMesh && Zt.batchingColor === !1 && mt.colorTexture !== null || mt.isInstancedMesh &&
				Zt.instancing === !1 || !mt.isInstancedMesh && Zt.instancing === !0 || mt.isSkinnedMesh && Zt
				.skinning === !1 || !mt.isSkinnedMesh && Zt.skinning === !0 || mt.isInstancedMesh && Zt
				.instancingColor === !0 && mt.instanceColor === null || mt.isInstancedMesh && Zt
				.instancingColor === !1 && mt.instanceColor !== null || mt.isInstancedMesh && Zt
				.instancingMorph === !0 && mt.morphTexture === null || mt.isInstancedMesh && Zt
				.instancingMorph === !1 && mt.morphTexture !== null || Zt.envMap !== Ht || vt.fog === !0 && Zt
				.fog !== Dt || Zt.numClippingPlanes !== void 0 && (Zt.numClippingPlanes !== ut.numPlanes || Zt
					.numIntersection !== ut.numIntersection) || Zt.vertexAlphas !== rn || Zt.vertexTangents !==
				en || Zt.morphTargets !== Xt || Zt.morphNormals !== un || Zt.morphColors !== mn || Zt
				.toneMapping !== Tn || Zt.morphTargetsCount !== hn) && (gn = !0) : (gn = !0, Zt.__version = vt
				.version);
			let jn = Zt.currentProgram;
			gn === !0 && (jn = wn(vt, et, mt));
			let Sn = !1,
				Vn = !1,
				qn = !1;
			const yn = jn.getUniforms(),
				Un = Zt.uniforms;
			if (ot.useProgram(jn.program) && (Sn = !0, Vn = !0, qn = !0), vt.id !== V && (V = vt.id, Vn = !0), Sn ||
				z !== We) {
				ot.buffers.depth.getReversed() ? (Ve.copy(We.projectionMatrix), toNormalizedProjectionMatrix(Ve),
					toReversedProjectionMatrix(Ve), yn.setValue(ye, "projectionMatrix", Ve)) : yn.setValue(ye,
					"projectionMatrix", We.projectionMatrix), yn.setValue(ye, "viewMatrix", We
					.matrixWorldInverse);
				const Pn = yn.map.cameraPosition;
				Pn !== void 0 && Pn.setValue(ye, pt.setFromMatrixPosition(We.matrixWorld)), nt
					.logarithmicDepthBuffer && yn.setValue(ye, "logDepthBufFC", 2 / (Math.log(We.far + 1) / Math
						.LN2)), (vt.isMeshPhongMaterial || vt.isMeshToonMaterial || vt.isMeshLambertMaterial || vt
						.isMeshBasicMaterial || vt.isMeshStandardMaterial || vt.isShaderMaterial) && yn.setValue(ye,
						"isOrthographic", We.isOrthographicCamera === !0), z !== We && (z = We, Vn = !0, qn = !0)
			}
			if (mt.isSkinnedMesh) {
				yn.setOptional(ye, mt, "bindMatrix"), yn.setOptional(ye, mt, "bindMatrixInverse");
				const In = mt.skeleton;
				In && (In.boneTexture === null && In.computeBoneTexture(), yn.setValue(ye, "boneTexture", In
					.boneTexture, Ne))
			}
			mt.isBatchedMesh && (yn.setOptional(ye, mt, "batchingTexture"), yn.setValue(ye, "batchingTexture", mt
				._matricesTexture, Ne), yn.setOptional(ye, mt, "batchingIdTexture"), yn.setValue(ye,
				"batchingIdTexture", mt._indirectTexture, Ne), yn.setOptional(ye, mt,
				"batchingColorTexture"), mt._colorsTexture !== null && yn.setValue(ye,
				"batchingColorTexture", mt._colorsTexture, Ne));
			const Bn = ft.morphAttributes;
			if ((Bn.position !== void 0 || Bn.normal !== void 0 || Bn.color !== void 0) && Ze.update(mt, ft, jn), (
					Vn || Zt.receiveShadow !== mt.receiveShadow) && (Zt.receiveShadow = mt.receiveShadow, yn
					.setValue(ye, "receiveShadow", mt.receiveShadow)), vt.isMeshGouraudMaterial && vt.envMap !==
				null && (Un.envMap.value = Ht, Un.flipEnvMap.value = Ht.isCubeTexture && Ht
					.isRenderTargetTexture === !1 ? -1 : 1), vt.isMeshStandardMaterial && vt.envMap === null && et
				.environment !== null && (Un.envMapIntensity.value = et.environmentIntensity), Vn && (yn.setValue(
						ye, "toneMappingExposure", D.toneMappingExposure), Zt.needsLights && On(Un, qn), Dt && vt
					.fog === !0 && Oe.refreshFogUniforms(Un, Dt), Oe.refreshMaterialUniforms(Un, vt, q, fe, A.state
						.transmissionRenderTarget[We.id]), WebGLUniforms.upload(ye, Mn(Zt), Un, Ne)), vt
				.isShaderMaterial && vt.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(ye, Mn(Zt), Un, Ne), vt
					.uniformsNeedUpdate = !1), vt.isSpriteMaterial && yn.setValue(ye, "center", mt.center), yn
				.setValue(ye, "modelViewMatrix", mt.modelViewMatrix), yn.setValue(ye, "normalMatrix", mt
					.normalMatrix), yn.setValue(ye, "modelMatrix", mt.matrixWorld), vt.isShaderMaterial || vt
				.isRawShaderMaterial) {
				const In = vt.uniformsGroups;
				for (let Pn = 0, er = In.length; Pn < er; Pn++) {
					const Kn = In[Pn];
					Qe.update(Kn, jn), Qe.bind(Kn, jn)
				}
			}
			return jn
		}

		function On(We, et) {
			We.ambientLightColor.needsUpdate = et, We.lightProbe.needsUpdate = et, We.directionalLights
				.needsUpdate = et, We.directionalLightShadows.needsUpdate = et, We.pointLights.needsUpdate = et, We
				.pointLightShadows.needsUpdate = et, We.spotLights.needsUpdate = et, We.spotLightShadows
				.needsUpdate = et, We.rectAreaLights.needsUpdate = et, We.hemisphereLights.needsUpdate = et
		}

		function Nn(We) {
			return We.isMeshLambertMaterial || We.isMeshToonMaterial || We.isMeshPhongMaterial || We
				.isMeshStandardMaterial || We.isShadowMaterial || We.isShaderMaterial && We.lights === !0
		}
		this.getActiveCubeFace = function() {
			return R
		}, this.getActiveMipmapLevel = function() {
			return O
		}, this.getRenderTarget = function() {
			return U
		}, this.setRenderTargetTextures = function(We, et, ft) {
			const vt = Je.get(We);
			vt.__autoAllocateDepthBuffer = We.resolveDepthBuffer === !1, vt.__autoAllocateDepthBuffer === !1 &&
				(vt.__useRenderToTexture = !1), Je.get(We.texture).__webglTexture = et, Je.get(We.depthTexture)
				.__webglTexture = vt.__autoAllocateDepthBuffer ? void 0 : ft, vt.__hasExternalTextures = !0
		}, this.setRenderTargetFramebuffer = function(We, et) {
			const ft = Je.get(We);
			ft.__webglFramebuffer = et, ft.__useDefaultFramebuffer = et === void 0
		};
		const An = ye.createFramebuffer();
		this.setRenderTarget = function(We, et = 0, ft = 0) {
			U = We, R = et, O = ft;
			let vt = !0,
				mt = null,
				Dt = !1,
				Pt = !1;
			if (We) {
				const Ht = Je.get(We);
				if (Ht.__useDefaultFramebuffer !== void 0) ot.bindFramebuffer(ye.FRAMEBUFFER, null), vt = !1;
				else if (Ht.__webglFramebuffer === void 0) Ne.setupRenderTarget(We);
				else if (Ht.__hasExternalTextures) Ne.rebindTextures(We, Je.get(We.texture).__webglTexture, Je
					.get(We.depthTexture).__webglTexture);
				else if (We.depthBuffer) {
					const Xt = We.depthTexture;
					if (Ht.__boundDepthTexture !== Xt) {
						if (Xt !== null && Je.has(Xt) && (We.width !== Xt.image.width || We.height !== Xt.image
								.height)) throw new Error(
							"WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
							);
						Ne.setupDepthRenderbuffer(We)
					}
				}
				const rn = We.texture;
				(rn.isData3DTexture || rn.isDataArrayTexture || rn.isCompressedArrayTexture) && (Pt = !0);
				const en = Je.get(We).__webglFramebuffer;
				We.isWebGLCubeRenderTarget ? (Array.isArray(en[et]) ? mt = en[et][ft] : mt = en[et], Dt = !0) :
					We.samples > 0 && Ne.useMultisampledRTT(We) === !1 ? mt = Je.get(We)
					.__webglMultisampledFramebuffer : Array.isArray(en) ? mt = en[ft] : mt = en, j.copy(We
						.viewport), ge.copy(We.scissor), me = We.scissorTest
			} else j.copy(_e).multiplyScalar(q).floor(), ge.copy(ke).multiplyScalar(q).floor(), me = De;
			if (ft !== 0 && (mt = An), ot.bindFramebuffer(ye.FRAMEBUFFER, mt) && vt && ot.drawBuffers(We, mt),
				ot.viewport(j), ot.scissor(ge), ot.setScissorTest(me), Dt) {
				const Ht = Je.get(We.texture);
				ye.framebufferTexture2D(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye.TEXTURE_CUBE_MAP_POSITIVE_X +
					et, Ht.__webglTexture, ft)
			} else if (Pt) {
				const Ht = Je.get(We.texture),
					rn = et;
				ye.framebufferTextureLayer(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, Ht.__webglTexture, ft, rn)
			} else if (We !== null && ft !== 0) {
				const Ht = Je.get(We.texture);
				ye.framebufferTexture2D(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye.TEXTURE_2D, Ht.__webglTexture,
					ft)
			}
			V = -1
		}, this.readRenderTargetPixels = function(We, et, ft, vt, mt, Dt, Pt) {
			if (!(We && We.isWebGLRenderTarget)) {
				console.error(
					"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
					);
				return
			}
			let Lt = Je.get(We).__webglFramebuffer;
			if (We.isWebGLCubeRenderTarget && Pt !== void 0 && (Lt = Lt[Pt]), Lt) {
				ot.bindFramebuffer(ye.FRAMEBUFFER, Lt);
				try {
					const Ht = We.texture,
						rn = Ht.format,
						en = Ht.type;
					if (!nt.textureFormatReadable(rn)) {
						console.error(
							"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
							);
						return
					}
					if (!nt.textureTypeReadable(en)) {
						console.error(
							"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
							);
						return
					}
					et >= 0 && et <= We.width - vt && ft >= 0 && ft <= We.height - mt && ye.readPixels(et, ft,
						vt, mt, yt.convert(rn), yt.convert(en), Dt)
				} finally {
					const Ht = U !== null ? Je.get(U).__webglFramebuffer : null;
					ot.bindFramebuffer(ye.FRAMEBUFFER, Ht)
				}
			}
		}, this.readRenderTargetPixelsAsync = async function(We, et, ft, vt, mt, Dt, Pt) {
			if (!(We && We.isWebGLRenderTarget)) throw new Error(
				"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
				);
			let Lt = Je.get(We).__webglFramebuffer;
			if (We.isWebGLCubeRenderTarget && Pt !== void 0 && (Lt = Lt[Pt]), Lt)
				if (et >= 0 && et <= We.width - vt && ft >= 0 && ft <= We.height - mt) {
					ot.bindFramebuffer(ye.FRAMEBUFFER, Lt);
					const Ht = We.texture,
						rn = Ht.format,
						en = Ht.type;
					if (!nt.textureFormatReadable(rn)) throw new Error(
						"THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
						);
					if (!nt.textureTypeReadable(en)) throw new Error(
						"THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
						);
					const Xt = ye.createBuffer();
					ye.bindBuffer(ye.PIXEL_PACK_BUFFER, Xt), ye.bufferData(ye.PIXEL_PACK_BUFFER, Dt
						.byteLength, ye.STREAM_READ), ye.readPixels(et, ft, vt, mt, yt.convert(rn), yt
						.convert(en), 0);
					const un = U !== null ? Je.get(U).__webglFramebuffer : null;
					ot.bindFramebuffer(ye.FRAMEBUFFER, un);
					const mn = ye.fenceSync(ye.SYNC_GPU_COMMANDS_COMPLETE, 0);
					return ye.flush(), await probeAsync(ye, mn, 4), ye.bindBuffer(ye.PIXEL_PACK_BUFFER, Xt),
						ye.getBufferSubData(ye.PIXEL_PACK_BUFFER, 0, Dt), ye.deleteBuffer(Xt), ye
						.deleteSync(mn), Dt
				} else throw new Error(
					"THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
					)
		}, this.copyFramebufferToTexture = function(We, et = null, ft = 0) {
			const vt = Math.pow(2, -ft),
				mt = Math.floor(We.image.width * vt),
				Dt = Math.floor(We.image.height * vt),
				Pt = et !== null ? et.x : 0,
				Lt = et !== null ? et.y : 0;
			Ne.setTexture2D(We, 0), ye.copyTexSubImage2D(ye.TEXTURE_2D, ft, 0, 0, Pt, Lt, mt, Dt), ot
				.unbindTexture()
		};
		const $n = ye.createFramebuffer(),
			Rn = ye.createFramebuffer();
		this.copyTextureToTexture = function(We, et, ft = null, vt = null, mt = 0, Dt = null) {
			Dt === null && (mt !== 0 ? (warnOnce(
				"WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."
				), Dt = mt, mt = 0) : Dt = 0);
			let Pt, Lt, Ht, rn, en, Xt, un, mn, Tn;
			const cn = We.isCompressedTexture ? We.mipmaps[Dt] : We.image;
			if (ft !== null) Pt = ft.max.x - ft.min.x, Lt = ft.max.y - ft.min.y, Ht = ft.isBox3 ? ft.max.z - ft
				.min.z : 1, rn = ft.min.x, en = ft.min.y, Xt = ft.isBox3 ? ft.min.z : 0;
			else {
				const Bn = Math.pow(2, -mt);
				Pt = Math.floor(cn.width * Bn), Lt = Math.floor(cn.height * Bn), We.isDataArrayTexture ? Ht = cn
					.depth : We.isData3DTexture ? Ht = Math.floor(cn.depth * Bn) : Ht = 1, rn = 0, en = 0, Xt =
					0
			}
			vt !== null ? (un = vt.x, mn = vt.y, Tn = vt.z) : (un = 0, mn = 0, Tn = 0);
			const hn = yt.convert(et.format),
				Zt = yt.convert(et.type);
			let Fn;
			et.isData3DTexture ? (Ne.setTexture3D(et, 0), Fn = ye.TEXTURE_3D) : et.isDataArrayTexture || et
				.isCompressedArrayTexture ? (Ne.setTexture2DArray(et, 0), Fn = ye.TEXTURE_2D_ARRAY) : (Ne
					.setTexture2D(et, 0), Fn = ye.TEXTURE_2D), ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL, et.flipY),
				ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL, et.premultiplyAlpha), ye.pixelStorei(ye
					.UNPACK_ALIGNMENT, et.unpackAlignment);
			const gn = ye.getParameter(ye.UNPACK_ROW_LENGTH),
				jn = ye.getParameter(ye.UNPACK_IMAGE_HEIGHT),
				Sn = ye.getParameter(ye.UNPACK_SKIP_PIXELS),
				Vn = ye.getParameter(ye.UNPACK_SKIP_ROWS),
				qn = ye.getParameter(ye.UNPACK_SKIP_IMAGES);
			ye.pixelStorei(ye.UNPACK_ROW_LENGTH, cn.width), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, cn.height),
				ye.pixelStorei(ye.UNPACK_SKIP_PIXELS, rn), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, en), ye
				.pixelStorei(ye.UNPACK_SKIP_IMAGES, Xt);
			const yn = We.isDataArrayTexture || We.isData3DTexture,
				Un = et.isDataArrayTexture || et.isData3DTexture;
			if (We.isDepthTexture) {
				const Bn = Je.get(We),
					In = Je.get(et),
					Pn = Je.get(Bn.__renderTarget),
					er = Je.get(In.__renderTarget);
				ot.bindFramebuffer(ye.READ_FRAMEBUFFER, Pn.__webglFramebuffer), ot.bindFramebuffer(ye
					.DRAW_FRAMEBUFFER, er.__webglFramebuffer);
				for (let Kn = 0; Kn < Ht; Kn++) yn && (ye.framebufferTextureLayer(ye.READ_FRAMEBUFFER, ye
						.COLOR_ATTACHMENT0, Je.get(We).__webglTexture, mt, Xt + Kn), ye
					.framebufferTextureLayer(ye.DRAW_FRAMEBUFFER, ye.COLOR_ATTACHMENT0, Je.get(et)
						.__webglTexture, Dt, Tn + Kn)), ye.blitFramebuffer(rn, en, Pt, Lt, un, mn, Pt, Lt,
					ye.DEPTH_BUFFER_BIT, ye.NEAREST);
				ot.bindFramebuffer(ye.READ_FRAMEBUFFER, null), ot.bindFramebuffer(ye.DRAW_FRAMEBUFFER, null)
			} else if (mt !== 0 || We.isRenderTargetTexture || Je.has(We)) {
				const Bn = Je.get(We),
					In = Je.get(et);
				ot.bindFramebuffer(ye.READ_FRAMEBUFFER, $n), ot.bindFramebuffer(ye.DRAW_FRAMEBUFFER, Rn);
				for (let Pn = 0; Pn < Ht; Pn++) yn ? ye.framebufferTextureLayer(ye.READ_FRAMEBUFFER, ye
						.COLOR_ATTACHMENT0, Bn.__webglTexture, mt, Xt + Pn) : ye.framebufferTexture2D(ye
						.READ_FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye.TEXTURE_2D, Bn.__webglTexture, mt), Un ? ye
					.framebufferTextureLayer(ye.DRAW_FRAMEBUFFER, ye.COLOR_ATTACHMENT0, In.__webglTexture, Dt,
						Tn + Pn) : ye.framebufferTexture2D(ye.DRAW_FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye
						.TEXTURE_2D, In.__webglTexture, Dt), mt !== 0 ? ye.blitFramebuffer(rn, en, Pt, Lt, un,
						mn, Pt, Lt, ye.COLOR_BUFFER_BIT, ye.NEAREST) : Un ? ye.copyTexSubImage3D(Fn, Dt, un, mn,
						Tn + Pn, rn, en, Pt, Lt) : ye.copyTexSubImage2D(Fn, Dt, un, mn, rn, en, Pt, Lt);
				ot.bindFramebuffer(ye.READ_FRAMEBUFFER, null), ot.bindFramebuffer(ye.DRAW_FRAMEBUFFER, null)
			} else Un ? We.isDataTexture || We.isData3DTexture ? ye.texSubImage3D(Fn, Dt, un, mn, Tn, Pt, Lt,
				Ht, hn, Zt, cn.data) : et.isCompressedArrayTexture ? ye.compressedTexSubImage3D(Fn, Dt, un,
				mn, Tn, Pt, Lt, Ht, hn, cn.data) : ye.texSubImage3D(Fn, Dt, un, mn, Tn, Pt, Lt, Ht, hn, Zt,
				cn) : We.isDataTexture ? ye.texSubImage2D(ye.TEXTURE_2D, Dt, un, mn, Pt, Lt, hn, Zt, cn
				.data) : We.isCompressedTexture ? ye.compressedTexSubImage2D(ye.TEXTURE_2D, Dt, un, mn, cn
				.width, cn.height, hn, cn.data) : ye.texSubImage2D(ye.TEXTURE_2D, Dt, un, mn, Pt, Lt, hn,
				Zt, cn);
			ye.pixelStorei(ye.UNPACK_ROW_LENGTH, gn), ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT, jn), ye
				.pixelStorei(ye.UNPACK_SKIP_PIXELS, Sn), ye.pixelStorei(ye.UNPACK_SKIP_ROWS, Vn), ye
				.pixelStorei(ye.UNPACK_SKIP_IMAGES, qn), Dt === 0 && et.generateMipmaps && ye.generateMipmap(
				Fn), ot.unbindTexture()
		}, this.copyTextureToTexture3D = function(We, et, ft = null, vt = null, mt = 0) {
			return warnOnce(
				'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
				), this.copyTextureToTexture(We, et, ft, vt, mt)
		}, this.initRenderTarget = function(We) {
			Je.get(We).__webglFramebuffer === void 0 && Ne.setupRenderTarget(We)
		}, this.initTexture = function(We) {
			We.isCubeTexture ? Ne.setTextureCube(We, 0) : We.isData3DTexture ? Ne.setTexture3D(We, 0) : We
				.isDataArrayTexture || We.isCompressedArrayTexture ? Ne.setTexture2DArray(We, 0) : Ne
				.setTexture2D(We, 0), ot.unbindTexture()
		}, this.resetState = function() {
			R = 0, O = 0, U = null, ot.reset(), wt.reset()
		}, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}
	get coordinateSystem() {
		return WebGLCoordinateSystem
	}
	get outputColorSpace() {
		return this._outputColorSpace
	}
	set outputColorSpace(s) {
		this._outputColorSpace = s;
		const a = this.getContext();
		a.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace(s), a.unpackColorSpace =
			ColorManagement._getUnpackColorSpace()
	}
}
const _changeEvent = {
		type: "change"
	},
	_startEvent = {
		type: "start"
	},
	_endEvent = {
		type: "end"
	},
	_ray$1 = new Ray,
	_plane = new Plane,
	_TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD),
	_v = new Vector3$1,
	_twoPI = 2 * Math.PI,
	_STATE = {
		NONE: -1,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2,
		TOUCH_ROTATE: 3,
		TOUCH_PAN: 4,
		TOUCH_DOLLY_PAN: 5,
		TOUCH_DOLLY_ROTATE: 6
	},
	_EPS = 1e-6;
class OrbitControls extends Controls {
	constructor(s, a = null) {
		super(s, a), this.state = _STATE.NONE, this.target = new Vector3$1, this.cursor = new Vector3$1, this
			.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this
			.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math
			.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this
			.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this
			.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this
			.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this
			.autoRotateSpeed = 2, this.keys = {
				LEFT: "ArrowLeft",
				UP: "ArrowUp",
				RIGHT: "ArrowRight",
				BOTTOM: "ArrowDown"
			}, this.mouseButtons = {
				LEFT: MOUSE.ROTATE,
				MIDDLE: MOUSE.DOLLY,
				RIGHT: MOUSE.PAN
			}, this.touches = {
				ONE: TOUCH.ROTATE,
				TWO: TOUCH.DOLLY_PAN
			}, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this
			.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new Vector3$1, this
			._lastQuaternion = new Quaternion$1, this._lastTargetPosition = new Vector3$1, this._quat =
			new Quaternion$1().setFromUnitVectors(s.up, new Vector3$1(0, 1, 0)), this._quatInverse = this._quat
			.clone().invert(), this._spherical = new Spherical, this._sphericalDelta = new Spherical, this._scale =
			1, this._panOffset = new Vector3$1, this._rotateStart = new Vector2, this._rotateEnd = new Vector2, this
			._rotateDelta = new Vector2, this._panStart = new Vector2, this._panEnd = new Vector2, this._panDelta =
			new Vector2, this._dollyStart = new Vector2, this._dollyEnd = new Vector2, this._dollyDelta =
			new Vector2, this._dollyDirection = new Vector3$1, this._mouse = new Vector2, this
			._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1,
			this._onPointerMove = onPointerMove.bind(this), this._onPointerDown = onPointerDown.bind(this), this
			._onPointerUp = onPointerUp.bind(this), this._onContextMenu = onContextMenu.bind(this), this
			._onMouseWheel = onMouseWheel.bind(this), this._onKeyDown = onKeyDown.bind(this), this._onTouchStart =
			onTouchStart.bind(this), this._onTouchMove = onTouchMove.bind(this), this._onMouseDown = onMouseDown
			.bind(this), this._onMouseMove = onMouseMove.bind(this), this._interceptControlDown =
			interceptControlDown.bind(this), this._interceptControlUp = interceptControlUp.bind(this), this
			.domElement !== null && this.connect(this.domElement), this.update()
	}
	connect(s) {
		super.connect(s), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement
			.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu",
				this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, {
				passive: !1
			}), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
				passive: !0,
				capture: !0
			}), this.domElement.style.touchAction = "none"
	}
	disconnect() {
		this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement
			.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener(
				"pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this
				._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement
			.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement
			.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
				capture: !0
			}), this.domElement.style.touchAction = "auto"
	}
	dispose() {
		this.disconnect()
	}
	getPolarAngle() {
		return this._spherical.phi
	}
	getAzimuthalAngle() {
		return this._spherical.theta
	}
	getDistance() {
		return this.object.position.distanceTo(this.target)
	}
	listenToKeyEvents(s) {
		s.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = s
	}
	stopListenToKeyEvents() {
		this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this
			._onKeyDown), this._domElementKeyEvents = null)
	}
	saveState() {
		this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom
	}
	reset() {
		this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0,
			this.object.updateProjectionMatrix(), this.dispatchEvent(_changeEvent), this.update(), this.state =
			_STATE.NONE
	}
	update(s = null) {
		const a = this.object.position;
		_v.copy(a).sub(this.target), _v.applyQuaternion(this._quat), this._spherical.setFromVector3(_v), this
			.autoRotate && this.state === _STATE.NONE && this._rotateLeft(this._getAutoRotationAngle(s)), this
			.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this
				._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this
				._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
		let l = this.minAzimuthAngle,
			c = this.maxAzimuthAngle;
		isFinite(l) && isFinite(c) && (l < -Math.PI ? l += _twoPI : l > Math.PI && (l -= _twoPI), c < -Math.PI ?
				c += _twoPI : c > Math.PI && (c -= _twoPI), l <= c ? this._spherical.theta = Math.max(l, Math.min(c,
					this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (l + c) / 2 ? Math
				.max(l, this._spherical.theta) : Math.min(c, this._spherical.theta)), this._spherical.phi = Math
			.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(),
			this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this
			.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this
				.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
		let d = !1;
		if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical
			.radius = this._clampDistance(this._spherical.radius);
		else {
			const f = this._spherical.radius;
			this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), d = f != this
				._spherical.radius
		}
		if (_v.setFromSpherical(this._spherical), _v.applyQuaternion(this._quatInverse), a.copy(this.target).add(
			_v), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 -
				this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset
				.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(
				0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
			let f = null;
			if (this.object.isPerspectiveCamera) {
				const m = _v.length();
				f = this._clampDistance(m * this._scale);
				const g = m - f;
				this.object.position.addScaledVector(this._dollyDirection, g), this.object.updateMatrixWorld(),
					d = !!g
			} else if (this.object.isOrthographicCamera) {
				const m = new Vector3$1(this._mouse.x, this._mouse.y, 0);
				m.unproject(this.object);
				const g = this.object.zoom;
				this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
					this.object.updateProjectionMatrix(), d = g !== this.object.zoom;
				const v = new Vector3$1(this._mouse.x, this._mouse.y, 0);
				v.unproject(this.object), this.object.position.sub(v).add(m), this.object.updateMatrixWorld(), f =
					_v.length()
			} else console.warn(
					"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this
				.zoomToCursor = !1;
			f !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object
				.matrix).multiplyScalar(f).add(this.object.position) : (_ray$1.origin.copy(this.object
					.position), _ray$1.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math
				.abs(this.object.up.dot(_ray$1.direction)) < _TILT_LIMIT ? this.object.lookAt(this.target) :
				(_plane.setFromNormalAndCoplanarPoint(this.object.up, this.target), _ray$1.intersectPlane(
					_plane, this.target))))
		} else if (this.object.isOrthographicCamera) {
			const f = this.object.zoom;
			this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), f !==
				this.object.zoom && (this.object.updateProjectionMatrix(), d = !0)
		}
		return this._scale = 1, this._performCursorZoom = !1, d || this._lastPosition.distanceToSquared(this.object
				.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this
			._lastTargetPosition.distanceToSquared(this.target) > _EPS ? (this.dispatchEvent(_changeEvent), this
				._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this
				._lastTargetPosition.copy(this.target), !0) : !1
	}
	_getAutoRotationAngle(s) {
		return s !== null ? _twoPI / 60 * this.autoRotateSpeed * s : _twoPI / 60 / 60 * this.autoRotateSpeed
	}
	_getZoomScale(s) {
		const a = Math.abs(s * .01);
		return Math.pow(.95, this.zoomSpeed * a)
	}
	_rotateLeft(s) {
		this._sphericalDelta.theta -= s
	}
	_rotateUp(s) {
		this._sphericalDelta.phi -= s
	}
	_panLeft(s, a) {
		_v.setFromMatrixColumn(a, 0), _v.multiplyScalar(-s), this._panOffset.add(_v)
	}
	_panUp(s, a) {
		this.screenSpacePanning === !0 ? _v.setFromMatrixColumn(a, 1) : (_v.setFromMatrixColumn(a, 0), _v
			.crossVectors(this.object.up, _v)), _v.multiplyScalar(s), this._panOffset.add(_v)
	}
	_pan(s, a) {
		const l = this.domElement;
		if (this.object.isPerspectiveCamera) {
			const c = this.object.position;
			_v.copy(c).sub(this.target);
			let d = _v.length();
			d *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * s * d / l.clientHeight, this
				.object.matrix), this._panUp(2 * a * d / l.clientHeight, this.object.matrix)
		} else this.object.isOrthographicCamera ? (this._panLeft(s * (this.object.right - this.object.left) / this
			.object.zoom / l.clientWidth, this.object.matrix), this._panUp(a * (this.object.top - this
			.object.bottom) / this.object.zoom / l.clientHeight, this.object.matrix)) : (console.warn(
				"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this
			.enablePan = !1)
	}
	_dollyOut(s) {
		this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= s : (console.warn(
				"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this
			.enableZoom = !1)
	}
	_dollyIn(s) {
		this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= s : (console.warn(
				"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this
			.enableZoom = !1)
	}
	_updateZoomParameters(s, a) {
		if (!this.zoomToCursor) return;
		this._performCursorZoom = !0;
		const l = this.domElement.getBoundingClientRect(),
			c = s - l.left,
			d = a - l.top,
			f = l.width,
			m = l.height;
		this._mouse.x = c / f * 2 - 1, this._mouse.y = -(d / m) * 2 + 1, this._dollyDirection.set(this._mouse.x,
			this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize()
	}
	_clampDistance(s) {
		return Math.max(this.minDistance, Math.min(this.maxDistance, s))
	}
	_handleMouseDownRotate(s) {
		this._rotateStart.set(s.clientX, s.clientY)
	}
	_handleMouseDownDolly(s) {
		this._updateZoomParameters(s.clientX, s.clientX), this._dollyStart.set(s.clientX, s.clientY)
	}
	_handleMouseDownPan(s) {
		this._panStart.set(s.clientX, s.clientY)
	}
	_handleMouseMoveRotate(s) {
		this._rotateEnd.set(s.clientX, s.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart)
			.multiplyScalar(this.rotateSpeed);
		const a = this.domElement;
		this._rotateLeft(_twoPI * this._rotateDelta.x / a.clientHeight), this._rotateUp(_twoPI * this._rotateDelta
			.y / a.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update()
	}
	_handleMouseMoveDolly(s) {
		this._dollyEnd.set(s.clientX, s.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
			this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y <
			0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this
			.update()
	}
	_handleMouseMovePan(s) {
		this._panEnd.set(s.clientX, s.clientY), this._panDelta.subVectors(this._panEnd, this._panStart)
			.multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this
				._panEnd), this.update()
	}
	_handleMouseWheel(s) {
		this._updateZoomParameters(s.clientX, s.clientY), s.deltaY < 0 ? this._dollyIn(this._getZoomScale(s
			.deltaY)) : s.deltaY > 0 && this._dollyOut(this._getZoomScale(s.deltaY)), this.update()
	}
	_handleKeyDown(s) {
		let a = !1;
		switch (s.code) {
			case this.keys.UP:
				s.ctrlKey || s.metaKey || s.shiftKey ? this.enableRotate && this._rotateUp(_twoPI * this
					.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this
					.keyPanSpeed), a = !0;
				break;
			case this.keys.BOTTOM:
				s.ctrlKey || s.metaKey || s.shiftKey ? this.enableRotate && this._rotateUp(-_twoPI * this
					.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this
					.keyPanSpeed), a = !0;
				break;
			case this.keys.LEFT:
				s.ctrlKey || s.metaKey || s.shiftKey ? this.enableRotate && this._rotateLeft(_twoPI * this
					.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this
					.keyPanSpeed, 0), a = !0;
				break;
			case this.keys.RIGHT:
				s.ctrlKey || s.metaKey || s.shiftKey ? this.enableRotate && this._rotateLeft(-_twoPI * this
					.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this
					.keyPanSpeed, 0), a = !0;
				break
		}
		a && (s.preventDefault(), this.update())
	}
	_handleTouchStartRotate(s) {
		if (this._pointers.length === 1) this._rotateStart.set(s.pageX, s.pageY);
		else {
			const a = this._getSecondPointerPosition(s),
				l = .5 * (s.pageX + a.x),
				c = .5 * (s.pageY + a.y);
			this._rotateStart.set(l, c)
		}
	}
	_handleTouchStartPan(s) {
		if (this._pointers.length === 1) this._panStart.set(s.pageX, s.pageY);
		else {
			const a = this._getSecondPointerPosition(s),
				l = .5 * (s.pageX + a.x),
				c = .5 * (s.pageY + a.y);
			this._panStart.set(l, c)
		}
	}
	_handleTouchStartDolly(s) {
		const a = this._getSecondPointerPosition(s),
			l = s.pageX - a.x,
			c = s.pageY - a.y,
			d = Math.sqrt(l * l + c * c);
		this._dollyStart.set(0, d)
	}
	_handleTouchStartDollyPan(s) {
		this.enableZoom && this._handleTouchStartDolly(s), this.enablePan && this._handleTouchStartPan(s)
	}
	_handleTouchStartDollyRotate(s) {
		this.enableZoom && this._handleTouchStartDolly(s), this.enableRotate && this._handleTouchStartRotate(s)
	}
	_handleTouchMoveRotate(s) {
		if (this._pointers.length == 1) this._rotateEnd.set(s.pageX, s.pageY);
		else {
			const l = this._getSecondPointerPosition(s),
				c = .5 * (s.pageX + l.x),
				d = .5 * (s.pageY + l.y);
			this._rotateEnd.set(c, d)
		}
		this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
		const a = this.domElement;
		this._rotateLeft(_twoPI * this._rotateDelta.x / a.clientHeight), this._rotateUp(_twoPI * this._rotateDelta
			.y / a.clientHeight), this._rotateStart.copy(this._rotateEnd)
	}
	_handleTouchMovePan(s) {
		if (this._pointers.length === 1) this._panEnd.set(s.pageX, s.pageY);
		else {
			const a = this._getSecondPointerPosition(s),
				l = .5 * (s.pageX + a.x),
				c = .5 * (s.pageY + a.y);
			this._panEnd.set(l, c)
		}
		this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this
			._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd)
	}
	_handleTouchMoveDolly(s) {
		const a = this._getSecondPointerPosition(s),
			l = s.pageX - a.x,
			c = s.pageY - a.y,
			d = Math.sqrt(l * l + c * c);
		this._dollyEnd.set(0, d), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this
			.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
		const f = (s.pageX + a.x) * .5,
			m = (s.pageY + a.y) * .5;
		this._updateZoomParameters(f, m)
	}
	_handleTouchMoveDollyPan(s) {
		this.enableZoom && this._handleTouchMoveDolly(s), this.enablePan && this._handleTouchMovePan(s)
	}
	_handleTouchMoveDollyRotate(s) {
		this.enableZoom && this._handleTouchMoveDolly(s), this.enableRotate && this._handleTouchMoveRotate(s)
	}
	_addPointer(s) {
		this._pointers.push(s.pointerId)
	}
	_removePointer(s) {
		delete this._pointerPositions[s.pointerId];
		for (let a = 0; a < this._pointers.length; a++)
			if (this._pointers[a] == s.pointerId) {
				this._pointers.splice(a, 1);
				return
			}
	}
	_isTrackingPointer(s) {
		for (let a = 0; a < this._pointers.length; a++)
			if (this._pointers[a] == s.pointerId) return !0;
		return !1
	}
	_trackPointer(s) {
		let a = this._pointerPositions[s.pointerId];
		a === void 0 && (a = new Vector2, this._pointerPositions[s.pointerId] = a), a.set(s.pageX, s.pageY)
	}
	_getSecondPointerPosition(s) {
		const a = s.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
		return this._pointerPositions[a]
	}
	_customWheelEvent(s) {
		const a = s.deltaMode,
			l = {
				clientX: s.clientX,
				clientY: s.clientY,
				deltaY: s.deltaY
			};
		switch (a) {
			case 1:
				l.deltaY *= 16;
				break;
			case 2:
				l.deltaY *= 100;
				break
		}
		return s.ctrlKey && !this._controlActive && (l.deltaY *= 10), l
	}
}

function onPointerDown(o) {
	this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(o.pointerId), this
		.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener(
			"pointerup", this._onPointerUp)), !this._isTrackingPointer(o) && (this._addPointer(o), o
		.pointerType === "touch" ? this._onTouchStart(o) : this._onMouseDown(o)))
}

function onPointerMove(o) {
	this.enabled !== !1 && (o.pointerType === "touch" ? this._onTouchMove(o) : this._onMouseMove(o))
}

function onPointerUp(o) {
	switch (this._removePointer(o), this._pointers.length) {
		case 0:
			this.domElement.releasePointerCapture(o.pointerId), this.domElement.removeEventListener("pointermove", this
					._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this
				.dispatchEvent(_endEvent), this.state = _STATE.NONE;
			break;
		case 1:
			const s = this._pointers[0],
				a = this._pointerPositions[s];
			this._onTouchStart({
				pointerId: s,
				pageX: a.x,
				pageY: a.y
			});
			break
	}
}

function onMouseDown(o) {
	let s;
	switch (o.button) {
		case 0:
			s = this.mouseButtons.LEFT;
			break;
		case 1:
			s = this.mouseButtons.MIDDLE;
			break;
		case 2:
			s = this.mouseButtons.RIGHT;
			break;
		default:
			s = -1
	}
	switch (s) {
		case MOUSE.DOLLY:
			if (this.enableZoom === !1) return;
			this._handleMouseDownDolly(o), this.state = _STATE.DOLLY;
			break;
		case MOUSE.ROTATE:
			if (o.ctrlKey || o.metaKey || o.shiftKey) {
				if (this.enablePan === !1) return;
				this._handleMouseDownPan(o), this.state = _STATE.PAN
			} else {
				if (this.enableRotate === !1) return;
				this._handleMouseDownRotate(o), this.state = _STATE.ROTATE
			}
			break;
		case MOUSE.PAN:
			if (o.ctrlKey || o.metaKey || o.shiftKey) {
				if (this.enableRotate === !1) return;
				this._handleMouseDownRotate(o), this.state = _STATE.ROTATE
			} else {
				if (this.enablePan === !1) return;
				this._handleMouseDownPan(o), this.state = _STATE.PAN
			}
			break;
		default:
			this.state = _STATE.NONE
	}
	this.state !== _STATE.NONE && this.dispatchEvent(_startEvent)
}

function onMouseMove(o) {
	switch (this.state) {
		case _STATE.ROTATE:
			if (this.enableRotate === !1) return;
			this._handleMouseMoveRotate(o);
			break;
		case _STATE.DOLLY:
			if (this.enableZoom === !1) return;
			this._handleMouseMoveDolly(o);
			break;
		case _STATE.PAN:
			if (this.enablePan === !1) return;
			this._handleMouseMovePan(o);
			break
	}
}

function onMouseWheel(o) {
	this.enabled === !1 || this.enableZoom === !1 || this.state !== _STATE.NONE || (o.preventDefault(), this
		.dispatchEvent(_startEvent), this._handleMouseWheel(this._customWheelEvent(o)), this.dispatchEvent(
			_endEvent))
}

function onKeyDown(o) {
	this.enabled !== !1 && this._handleKeyDown(o)
}

function onTouchStart(o) {
	switch (this._trackPointer(o), this._pointers.length) {
		case 1:
			switch (this.touches.ONE) {
				case TOUCH.ROTATE:
					if (this.enableRotate === !1) return;
					this._handleTouchStartRotate(o), this.state = _STATE.TOUCH_ROTATE;
					break;
				case TOUCH.PAN:
					if (this.enablePan === !1) return;
					this._handleTouchStartPan(o), this.state = _STATE.TOUCH_PAN;
					break;
				default:
					this.state = _STATE.NONE
			}
			break;
		case 2:
			switch (this.touches.TWO) {
				case TOUCH.DOLLY_PAN:
					if (this.enableZoom === !1 && this.enablePan === !1) return;
					this._handleTouchStartDollyPan(o), this.state = _STATE.TOUCH_DOLLY_PAN;
					break;
				case TOUCH.DOLLY_ROTATE:
					if (this.enableZoom === !1 && this.enableRotate === !1) return;
					this._handleTouchStartDollyRotate(o), this.state = _STATE.TOUCH_DOLLY_ROTATE;
					break;
				default:
					this.state = _STATE.NONE
			}
			break;
		default:
			this.state = _STATE.NONE
	}
	this.state !== _STATE.NONE && this.dispatchEvent(_startEvent)
}

function onTouchMove(o) {
	switch (this._trackPointer(o), this.state) {
		case _STATE.TOUCH_ROTATE:
			if (this.enableRotate === !1) return;
			this._handleTouchMoveRotate(o), this.update();
			break;
		case _STATE.TOUCH_PAN:
			if (this.enablePan === !1) return;
			this._handleTouchMovePan(o), this.update();
			break;
		case _STATE.TOUCH_DOLLY_PAN:
			if (this.enableZoom === !1 && this.enablePan === !1) return;
			this._handleTouchMoveDollyPan(o), this.update();
			break;
		case _STATE.TOUCH_DOLLY_ROTATE:
			if (this.enableZoom === !1 && this.enableRotate === !1) return;
			this._handleTouchMoveDollyRotate(o), this.update();
			break;
		default:
			this.state = _STATE.NONE
	}
}

function onContextMenu(o) {
	this.enabled !== !1 && o.preventDefault()
}

function interceptControlDown(o) {
	o.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this
		._interceptControlUp, {
			passive: !0,
			capture: !0
		}))
}

function interceptControlUp(o) {
	o.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this
		._interceptControlUp, {
			passive: !0,
			capture: !0
		}))
}
class TGALoader extends DataTextureLoader {
	constructor(s) {
		super(s)
	}
	parse(s) {
		function a(ae) {
			switch (ae.image_type) {
				case C:
				case w:
					if (ae.colormap_length > 256 || ae.colormap_size !== 24 || ae.colormap_type !== 1)
					throw new Error("THREE.TGALoader: Invalid type colormap data for indexed type.");
					break;
				case _:
				case S:
				case T:
				case A:
					if (ae.colormap_type) throw new Error(
						"THREE.TGALoader: Invalid type colormap data for colormap type.");
					break;
				case b:
					throw new Error("THREE.TGALoader: No data.");
				default:
					throw new Error("THREE.TGALoader: Invalid type " + ae.image_type)
			}
			if (ae.width <= 0 || ae.height <= 0) throw new Error("THREE.TGALoader: Invalid image size.");
			if (ae.pixel_size !== 8 && ae.pixel_size !== 16 && ae.pixel_size !== 24 && ae.pixel_size !== 32)
			throw new Error("THREE.TGALoader: Invalid pixel size " + ae.pixel_size)
		}

		function l(ae, fe, q, le, de) {
			let _e, ke;
			const De = q.pixel_size >> 3,
				Se = q.width * q.height * De;
			if (fe && (ke = de.subarray(le, le += q.colormap_length * (q.colormap_size >> 3))), ae) {
				_e = new Uint8Array(Se);
				let be, Me, Ve, it = 0;
				const pt = new Uint8Array(De);
				for (; it < Se;)
					if (be = de[le++], Me = (be & 127) + 1, be & 128) {
						for (Ve = 0; Ve < De; ++Ve) pt[Ve] = de[le++];
						for (Ve = 0; Ve < Me; ++Ve) _e.set(pt, it + Ve * De);
						it += De * Me
					} else {
						for (Me *= De, Ve = 0; Ve < Me; ++Ve) _e[it + Ve] = de[le++];
						it += Me
					}
			} else _e = de.subarray(le, le += fe ? q.width * q.height : Se);
			return {
				pixel_data: _e,
				palettes: ke
			}
		}

		function c(ae, fe, q, le, de, _e, ke, De, Se) {
			const be = Se;
			let Me, Ve = 0,
				it, pt;
			const dt = z.width;
			for (pt = fe; pt !== le; pt += q)
				for (it = de; it !== ke; it += _e, Ve++) Me = De[Ve], ae[(it + dt * pt) * 4 + 3] = 255, ae[(it +
					dt * pt) * 4 + 2] = be[Me * 3 + 0], ae[(it + dt * pt) * 4 + 1] = be[Me * 3 + 1], ae[(it +
					dt * pt) * 4 + 0] = be[Me * 3 + 2];
			return ae
		}

		function d(ae, fe, q, le, de, _e, ke, De) {
			let Se, be = 0,
				Me, Ve;
			const it = z.width;
			for (Ve = fe; Ve !== le; Ve += q)
				for (Me = de; Me !== ke; Me += _e, be += 2) Se = De[be + 0] + (De[be + 1] << 8), ae[(Me + it * Ve) *
					4 + 0] = (Se & 31744) >> 7, ae[(Me + it * Ve) * 4 + 1] = (Se & 992) >> 2, ae[(Me + it *
					Ve) * 4 + 2] = (Se & 31) << 3, ae[(Me + it * Ve) * 4 + 3] = Se & 32768 ? 0 : 255;
			return ae
		}

		function f(ae, fe, q, le, de, _e, ke, De) {
			let Se = 0,
				be, Me;
			const Ve = z.width;
			for (Me = fe; Me !== le; Me += q)
				for (be = de; be !== ke; be += _e, Se += 3) ae[(be + Ve * Me) * 4 + 3] = 255, ae[(be + Ve * Me) *
						4 + 2] = De[Se + 0], ae[(be + Ve * Me) * 4 + 1] = De[Se + 1], ae[(be + Ve * Me) * 4 + 0] =
					De[Se + 2];
			return ae
		}

		function m(ae, fe, q, le, de, _e, ke, De) {
			let Se = 0,
				be, Me;
			const Ve = z.width;
			for (Me = fe; Me !== le; Me += q)
				for (be = de; be !== ke; be += _e, Se += 4) ae[(be + Ve * Me) * 4 + 2] = De[Se + 0], ae[(be + Ve *
					Me) * 4 + 1] = De[Se + 1], ae[(be + Ve * Me) * 4 + 0] = De[Se + 2], ae[(be + Ve * Me) * 4 +
					3] = De[Se + 3];
			return ae
		}

		function g(ae, fe, q, le, de, _e, ke, De) {
			let Se, be = 0,
				Me, Ve;
			const it = z.width;
			for (Ve = fe; Ve !== le; Ve += q)
				for (Me = de; Me !== ke; Me += _e, be++) Se = De[be], ae[(Me + it * Ve) * 4 + 0] = Se, ae[(Me + it *
					Ve) * 4 + 1] = Se, ae[(Me + it * Ve) * 4 + 2] = Se, ae[(Me + it * Ve) * 4 + 3] = 255;
			return ae
		}

		function v(ae, fe, q, le, de, _e, ke, De) {
			let Se = 0,
				be, Me;
			const Ve = z.width;
			for (Me = fe; Me !== le; Me += q)
				for (be = de; be !== ke; be += _e, Se += 2) ae[(be + Ve * Me) * 4 + 0] = De[Se + 0], ae[(be + Ve *
					Me) * 4 + 1] = De[Se + 0], ae[(be + Ve * Me) * 4 + 2] = De[Se + 0], ae[(be + Ve * Me) * 4 +
					3] = De[Se + 1];
			return ae
		}

		function y(ae, fe, q, le, de) {
			let _e, ke, De, Se, be, Me;
			switch ((z.flags & k) >> M) {
				default:
				case R:
					_e = 0, De = 1, be = fe, ke = 0, Se = 1, Me = q;
					break;
				case D:
					_e = 0, De = 1, be = fe, ke = q - 1, Se = -1, Me = -1;
					break;
				case O:
					_e = fe - 1, De = -1, be = -1, ke = 0, Se = 1, Me = q;
					break;
				case F:
					_e = fe - 1, De = -1, be = -1, ke = q - 1, Se = -1, Me = -1;
					break
			}
			if (me) switch (z.pixel_size) {
				case 8:
					g(ae, ke, Se, Me, _e, De, be, le);
					break;
				case 16:
					v(ae, ke, Se, Me, _e, De, be, le);
					break;
				default:
					throw new Error("THREE.TGALoader: Format not supported.")
			} else switch (z.pixel_size) {
				case 8:
					c(ae, ke, Se, Me, _e, De, be, le, de);
					break;
				case 16:
					d(ae, ke, Se, Me, _e, De, be, le);
					break;
				case 24:
					f(ae, ke, Se, Me, _e, De, be, le);
					break;
				case 32:
					m(ae, ke, Se, Me, _e, De, be, le);
					break;
				default:
					throw new Error("THREE.TGALoader: Format not supported.")
			}
			return ae
		}
		const b = 0,
			C = 1,
			_ = 2,
			S = 3,
			w = 9,
			T = 10,
			A = 11,
			k = 48,
			M = 4,
			D = 0,
			F = 1,
			R = 2,
			O = 3;
		if (s.length < 19) throw new Error("THREE.TGALoader: Not enough data to contain header.");
		let U = 0;
		const V = new Uint8Array(s),
			z = {
				id_length: V[U++],
				colormap_type: V[U++],
				image_type: V[U++],
				colormap_index: V[U++] | V[U++] << 8,
				colormap_length: V[U++] | V[U++] << 8,
				colormap_size: V[U++],
				origin: [V[U++] | V[U++] << 8, V[U++] | V[U++] << 8],
				width: V[U++] | V[U++] << 8,
				height: V[U++] | V[U++] << 8,
				pixel_size: V[U++],
				flags: V[U++]
			};
		if (a(z), z.id_length + U > s.length) throw new Error("THREE.TGALoader: No data.");
		U += z.id_length;
		let j = !1,
			ge = !1,
			me = !1;
		switch (z.image_type) {
			case w:
				j = !0, ge = !0;
				break;
			case C:
				ge = !0;
				break;
			case T:
				j = !0;
				break;
			case _:
				break;
			case A:
				j = !0, me = !0;
				break;
			case S:
				me = !0;
				break
		}
		const he = new Uint8Array(z.width * z.height * 4),
			ce = l(j, ge, z, U, V);
		return y(he, z.width, z.height, ce.pixel_data, ce.palettes), {
			data: he,
			width: z.width,
			height: z.height,
			flipY: !0,
			generateMipmaps: !0,
			minFilter: LinearMipmapLinearFilter
		}
	}
}
class ColladaLoader extends Loader {
	load(s, a, l, c) {
		const d = this,
			f = d.path === "" ? LoaderUtils.extractUrlBase(s) : d.path,
			m = new FileLoader(d.manager);
		m.setPath(d.path), m.setRequestHeader(d.requestHeader), m.setWithCredentials(d.withCredentials), m.load(s,
			function(g) {
				try {
					a(d.parse(g, f))
				} catch (v) {
					c ? c(v) : console.error(v), d.manager.itemError(s)
				}
			}, l, c)
	}
	parse(s, a) {
		function l(Be, Ie) {
			const qe = [],
				je = Be.childNodes;
			for (let Ke = 0, St = je.length; Ke < St; Ke++) {
				const Tt = je[Ke];
				Tt.nodeName === Ie && qe.push(Tt)
			}
			return qe
		}

		function c(Be) {
			if (Be.length === 0) return [];
			const Ie = Be.trim().split(/\s+/),
				qe = new Array(Ie.length);
			for (let je = 0, Ke = Ie.length; je < Ke; je++) qe[je] = Ie[je];
			return qe
		}

		function d(Be) {
			if (Be.length === 0) return [];
			const Ie = Be.trim().split(/\s+/),
				qe = new Array(Ie.length);
			for (let je = 0, Ke = Ie.length; je < Ke; je++) qe[je] = parseFloat(Ie[je]);
			return qe
		}

		function f(Be) {
			if (Be.length === 0) return [];
			const Ie = Be.trim().split(/\s+/),
				qe = new Array(Ie.length);
			for (let je = 0, Ke = Ie.length; je < Ke; je++) qe[je] = parseInt(Ie[je]);
			return qe
		}

		function m(Be) {
			return Be.substring(1)
		}

		function g() {
			return "three_default_" + Kn++
		}

		function v(Be) {
			return Object.keys(Be).length === 0
		}

		function y(Be) {
			return {
				unit: b(l(Be, "unit")[0]),
				upAxis: C(l(Be, "up_axis")[0])
			}
		}

		function b(Be) {
			return Be !== void 0 && Be.hasAttribute("meter") === !0 ? parseFloat(Be.getAttribute("meter")) : 1
		}

		function C(Be) {
			return Be !== void 0 ? Be.textContent : "Y_UP"
		}

		function _(Be, Ie, qe, je) {
			const Ke = l(Be, Ie)[0];
			if (Ke !== void 0) {
				const St = l(Ke, qe);
				for (let Tt = 0; Tt < St.length; Tt++) je(St[Tt])
			}
		}

		function S(Be, Ie) {
			for (const qe in Be) {
				const je = Be[qe];
				je.build = Ie(Be[qe])
			}
		}

		function w(Be, Ie) {
			return Be.build !== void 0 || (Be.build = Ie(Be)), Be.build
		}

		function T(Be) {
			const Ie = {
				sources: {},
				samplers: {},
				channels: {}
			};
			let qe = !1;
			for (let je = 0, Ke = Be.childNodes.length; je < Ke; je++) {
				const St = Be.childNodes[je];
				if (St.nodeType !== 1) continue;
				let Tt;
				switch (St.nodeName) {
					case "source":
						Tt = St.getAttribute("id"), Ie.sources[Tt] = Ct(St);
						break;
					case "sampler":
						Tt = St.getAttribute("id"), Ie.samplers[Tt] = A(St);
						break;
					case "channel":
						Tt = St.getAttribute("target"), Ie.channels[Tt] = k(St);
						break;
					case "animation":
						T(St), qe = !0;
						break;
					default:
						console.log(St)
				}
			}
			qe === !1 && (tn.animations[Be.getAttribute("id") || MathUtils.generateUUID()] = Ie)
		}

		function A(Be) {
			const Ie = {
				inputs: {}
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "input":
						const St = m(Ke.getAttribute("source")),
							Tt = Ke.getAttribute("semantic");
						Ie.inputs[Tt] = St;
						break
				}
			}
			return Ie
		}

		function k(Be) {
			const Ie = {};
			let je = Be.getAttribute("target").split("/");
			const Ke = je.shift();
			let St = je.shift();
			const Tt = St.indexOf("(") !== -1,
				jt = St.indexOf(".") !== -1;
			if (jt) je = St.split("."), St = je.shift(), Ie.member = je.shift();
			else if (Tt) {
				const Ft = St.split("(");
				St = Ft.shift();
				for (let Ut = 0; Ut < Ft.length; Ut++) Ft[Ut] = parseInt(Ft[Ut].replace(/\)/, ""));
				Ie.indices = Ft
			}
			return Ie.id = Ke, Ie.sid = St, Ie.arraySyntax = Tt, Ie.memberSyntax = jt, Ie.sampler = m(Be
				.getAttribute("source")), Ie
		}

		function M(Be) {
			const Ie = [],
				qe = Be.channels,
				je = Be.samplers,
				Ke = Be.sources;
			for (const St in qe)
				if (qe.hasOwnProperty(St)) {
					const Tt = qe[St],
						jt = je[Tt.sampler],
						Ft = jt.inputs.INPUT,
						Ut = jt.inputs.OUTPUT,
						Kt = Ke[Ft],
						It = Ke[Ut],
						Yt = F(Tt, Kt, It);
					z(Yt, Ie)
				} return Ie
		}

		function D(Be) {
			return w(tn.animations[Be], M)
		}

		function F(Be, Ie, qe) {
			const je = tn.nodes[Be.id],
				Ke = un(je.id),
				St = je.transforms[Be.sid],
				Tt = je.matrix.clone().transpose();
			let jt, Ft, Ut, Kt, It, Yt;
			const Gt = {};
			switch (St) {
				case "matrix":
					for (Ut = 0, Kt = Ie.array.length; Ut < Kt; Ut++)
						if (jt = Ie.array[Ut], Ft = Ut * qe.stride, Gt[jt] === void 0 && (Gt[jt] = {}), Be
							.arraySyntax === !0) {
							const kn = qe.array[Ft],
								_n = Be.indices[0] + 4 * Be.indices[1];
							Gt[jt][_n] = kn
						} else
							for (It = 0, Yt = qe.stride; It < Yt; It++) Gt[jt][It] = qe.array[Ft + It];
					break;
				case "translate":
					console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', St);
					break;
				case "rotate":
					console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', St);
					break;
				case "scale":
					console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', St);
					break
			}
			const Qt = R(Gt, Tt);
			return {
				name: Ke.uuid,
				keyframes: Qt
			}
		}

		function R(Be, Ie) {
			const qe = [];
			for (const Ke in Be) qe.push({
				time: parseFloat(Ke),
				value: Be[Ke]
			});
			qe.sort(je);
			for (let Ke = 0; Ke < 16; Ke++) j(qe, Ke, Ie.elements[Ke]);
			return qe;

			function je(Ke, St) {
				return Ke.time - St.time
			}
		}
		const O = new Vector3$1,
			U = new Vector3$1,
			V = new Quaternion$1;

		function z(Be, Ie) {
			const qe = Be.keyframes,
				je = Be.name,
				Ke = [],
				St = [],
				Tt = [],
				jt = [];
			for (let Ft = 0, Ut = qe.length; Ft < Ut; Ft++) {
				const Kt = qe[Ft],
					It = Kt.time,
					Yt = Kt.value;
				et.fromArray(Yt).transpose(), et.decompose(O, V, U), Ke.push(It), St.push(O.x, O.y, O.z), Tt.push(V
					.x, V.y, V.z, V.w), jt.push(U.x, U.y, U.z)
			}
			return St.length > 0 && Ie.push(new VectorKeyframeTrack(je + ".position", Ke, St)), Tt.length > 0 && Ie
				.push(new QuaternionKeyframeTrack(je + ".quaternion", Ke, Tt)), jt.length > 0 && Ie.push(
					new VectorKeyframeTrack(je + ".scale", Ke, jt)), Ie
		}

		function j(Be, Ie, qe) {
			let je, Ke = !0,
				St, Tt;
			for (St = 0, Tt = Be.length; St < Tt; St++) je = Be[St], je.value[Ie] === void 0 ? je.value[Ie] = null :
				Ke = !1;
			if (Ke === !0)
				for (St = 0, Tt = Be.length; St < Tt; St++) je = Be[St], je.value[Ie] = qe;
			else ge(Be, Ie)
		}

		function ge(Be, Ie) {
			let qe, je;
			for (let Ke = 0, St = Be.length; Ke < St; Ke++) {
				const Tt = Be[Ke];
				if (Tt.value[Ie] === null) {
					if (qe = me(Be, Ke, Ie), je = he(Be, Ke, Ie), qe === null) {
						Tt.value[Ie] = je.value[Ie];
						continue
					}
					if (je === null) {
						Tt.value[Ie] = qe.value[Ie];
						continue
					}
					ce(Tt, qe, je, Ie)
				}
			}
		}

		function me(Be, Ie, qe) {
			for (; Ie >= 0;) {
				const je = Be[Ie];
				if (je.value[qe] !== null) return je;
				Ie--
			}
			return null
		}

		function he(Be, Ie, qe) {
			for (; Ie < Be.length;) {
				const je = Be[Ie];
				if (je.value[qe] !== null) return je;
				Ie++
			}
			return null
		}

		function ce(Be, Ie, qe, je) {
			if (qe.time - Ie.time === 0) {
				Be.value[je] = Ie.value[je];
				return
			}
			Be.value[je] = (Be.time - Ie.time) * (qe.value[je] - Ie.value[je]) / (qe.time - Ie.time) + Ie.value[je]
		}

		function ae(Be) {
			const Ie = {
				name: Be.getAttribute("id") || "default",
				start: parseFloat(Be.getAttribute("start") || 0),
				end: parseFloat(Be.getAttribute("end") || 0),
				animations: []
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "instance_animation":
						Ie.animations.push(m(Ke.getAttribute("url")));
						break
				}
			}
			tn.clips[Be.getAttribute("id")] = Ie
		}

		function fe(Be) {
			const Ie = [],
				qe = Be.name,
				je = Be.end - Be.start || -1,
				Ke = Be.animations;
			for (let St = 0, Tt = Ke.length; St < Tt; St++) {
				const jt = D(Ke[St]);
				for (let Ft = 0, Ut = jt.length; Ft < Ut; Ft++) Ie.push(jt[Ft])
			}
			return new AnimationClip(qe, je, Ie)
		}

		function q(Be) {
			return w(tn.clips[Be], fe)
		}

		function le(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "skin":
						Ie.id = m(Ke.getAttribute("source")), Ie.skin = de(Ke);
						break;
					case "morph":
						Ie.id = m(Ke.getAttribute("source")), console.warn(
							"THREE.ColladaLoader: Morph target animation not supported yet.");
						break
				}
			}
			tn.controllers[Be.getAttribute("id")] = Ie
		}

		function de(Be) {
			const Ie = {
				sources: {}
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "bind_shape_matrix":
						Ie.bindShapeMatrix = d(Ke.textContent);
						break;
					case "source":
						const St = Ke.getAttribute("id");
						Ie.sources[St] = Ct(Ke);
						break;
					case "joints":
						Ie.joints = _e(Ke);
						break;
					case "vertex_weights":
						Ie.vertexWeights = ke(Ke);
						break
				}
			}
			return Ie
		}

		function _e(Be) {
			const Ie = {
				inputs: {}
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "input":
						const St = Ke.getAttribute("semantic"),
							Tt = m(Ke.getAttribute("source"));
						Ie.inputs[St] = Tt;
						break
				}
			}
			return Ie
		}

		function ke(Be) {
			const Ie = {
				inputs: {}
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "input":
						const St = Ke.getAttribute("semantic"),
							Tt = m(Ke.getAttribute("source")),
							jt = parseInt(Ke.getAttribute("offset"));
						Ie.inputs[St] = {
							id: Tt,
							offset: jt
						};
						break;
					case "vcount":
						Ie.vcount = f(Ke.textContent);
						break;
					case "v":
						Ie.v = f(Ke.textContent);
						break
				}
			}
			return Ie
		}

		function De(Be) {
			const Ie = {
					id: Be.id
				},
				qe = tn.geometries[Ie.id];
			return Be.skin !== void 0 && (Ie.skin = Se(Be.skin), qe.sources.skinIndices = Ie.skin.indices, qe
				.sources.skinWeights = Ie.skin.weights), Ie
		}

		function Se(Be) {
			const qe = {
					joints: [],
					indices: {
						array: [],
						stride: 4
					},
					weights: {
						array: [],
						stride: 4
					}
				},
				je = Be.sources,
				Ke = Be.vertexWeights,
				St = Ke.vcount,
				Tt = Ke.v,
				jt = Ke.inputs.JOINT.offset,
				Ft = Ke.inputs.WEIGHT.offset,
				Ut = Be.sources[Be.joints.inputs.JOINT],
				Kt = Be.sources[Be.joints.inputs.INV_BIND_MATRIX],
				It = je[Ke.inputs.WEIGHT.id].array;
			let Yt = 0,
				Gt, Qt, Jt;
			for (Gt = 0, Jt = St.length; Gt < Jt; Gt++) {
				const _n = St[Gt],
					ht = [];
				for (Qt = 0; Qt < _n; Qt++) {
					const _t = Tt[Yt + jt],
						kt = Tt[Yt + Ft],
						Bt = It[kt];
					ht.push({
						index: _t,
						weight: Bt
					}), Yt += 2
				}
				for (ht.sort(kn), Qt = 0; Qt < 4; Qt++) {
					const _t = ht[Qt];
					_t !== void 0 ? (qe.indices.array.push(_t.index), qe.weights.array.push(_t.weight)) : (qe
						.indices.array.push(0), qe.weights.array.push(0))
				}
			}
			for (Be.bindShapeMatrix ? qe.bindMatrix = new Matrix4().fromArray(Be.bindShapeMatrix).transpose() : qe
				.bindMatrix = new Matrix4().identity(), Gt = 0, Jt = Ut.array.length; Gt < Jt; Gt++) {
				const _n = Ut.array[Gt],
					ht = new Matrix4().fromArray(Kt.array, Gt * Kt.stride).transpose();
				qe.joints.push({
					name: _n,
					boneInverse: ht
				})
			}
			return qe;

			function kn(_n, ht) {
				return ht.weight - _n.weight
			}
		}

		function be(Be) {
			return w(tn.controllers[Be], De)
		}

		function Me(Be) {
			const Ie = {
				init_from: l(Be, "init_from")[0].textContent
			};
			tn.images[Be.getAttribute("id")] = Ie
		}

		function Ve(Be) {
			return Be.build !== void 0 ? Be.build : Be.init_from
		}

		function it(Be) {
			const Ie = tn.images[Be];
			return Ie !== void 0 ? w(Ie, Ve) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:",
				Be), null)
		}

		function pt(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "profile_COMMON":
						Ie.profile = dt(Ke);
						break
				}
			}
			tn.effects[Be.getAttribute("id")] = Ie
		}

		function dt(Be) {
			const Ie = {
				surfaces: {},
				samplers: {}
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "newparam":
						He(Ke, Ie);
						break;
					case "technique":
						Ie.technique = ye(Ke);
						break;
					case "extra":
						Ie.extra = Je(Ke);
						break
				}
			}
			return Ie
		}

		function He(Be, Ie) {
			const qe = Be.getAttribute("sid");
			for (let je = 0, Ke = Be.childNodes.length; je < Ke; je++) {
				const St = Be.childNodes[je];
				if (St.nodeType === 1) switch (St.nodeName) {
					case "surface":
						Ie.surfaces[qe] = Ae(St);
						break;
					case "sampler2D":
						Ie.samplers[qe] = xe(St);
						break
				}
			}
		}

		function Ae(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "init_from":
						Ie.init_from = Ke.textContent;
						break
				}
			}
			return Ie
		}

		function xe(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "source":
						Ie.source = Ke.textContent;
						break
				}
			}
			return Ie
		}

		function ye(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "constant":
					case "lambert":
					case "blinn":
					case "phong":
						Ie.type = Ke.nodeName, Ie.parameters = Le(Ke);
						break;
					case "extra":
						Ie.extra = Je(Ke);
						break
				}
			}
			return Ie
		}

		function Le(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "emission":
					case "diffuse":
					case "specular":
					case "bump":
					case "ambient":
					case "shininess":
					case "transparency":
						Ie[Ke.nodeName] = Ue(Ke);
						break;
					case "transparent":
						Ie[Ke.nodeName] = {
							opaque: Ke.hasAttribute("opaque") ? Ke.getAttribute("opaque") : "A_ONE",
							data: Ue(Ke)
						};
						break
				}
			}
			return Ie
		}

		function Ue(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "color":
						Ie[Ke.nodeName] = d(Ke.textContent);
						break;
					case "float":
						Ie[Ke.nodeName] = parseFloat(Ke.textContent);
						break;
					case "texture":
						Ie[Ke.nodeName] = {
							id: Ke.getAttribute("texture"),
							extra: nt(Ke)
						};
						break
				}
			}
			return Ie
		}

		function nt(Be) {
			const Ie = {
				technique: {}
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "extra":
						ot(Ke, Ie);
						break
				}
			}
			return Ie
		}

		function ot(Be, Ie) {
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "technique":
						at(Ke, Ie);
						break
				}
			}
		}

		function at(Be, Ie) {
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "repeatU":
					case "repeatV":
					case "offsetU":
					case "offsetV":
						Ie.technique[Ke.nodeName] = parseFloat(Ke.textContent);
						break;
					case "wrapU":
					case "wrapV":
						Ke.textContent.toUpperCase() === "TRUE" ? Ie.technique[Ke.nodeName] = 1 : Ke.textContent
							.toUpperCase() === "FALSE" ? Ie.technique[Ke.nodeName] = 0 : Ie.technique[Ke
								.nodeName] = parseInt(Ke.textContent);
						break;
					case "bump":
						Ie[Ke.nodeName] = we(Ke);
						break
				}
			}
		}

		function Je(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "technique":
						Ie.technique = Ne(Ke);
						break
				}
			}
			return Ie
		}

		function Ne(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "double_sided":
						Ie[Ke.nodeName] = parseInt(Ke.textContent);
						break;
					case "bump":
						Ie[Ke.nodeName] = we(Ke);
						break
				}
			}
			return Ie
		}

		function we(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "texture":
						Ie[Ke.nodeName] = {
							id: Ke.getAttribute("texture"),
							texcoord: Ke.getAttribute("texcoord"),
							extra: nt(Ke)
						};
						break
				}
			}
			return Ie
		}

		function Ce(Be) {
			return Be
		}

		function $e(Be) {
			return w(tn.effects[Be], Ce)
		}

		function Fe(Be) {
			const Ie = {
				name: Be.getAttribute("name")
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "instance_effect":
						Ie.url = m(Ke.getAttribute("url"));
						break
				}
			}
			tn.materials[Be.getAttribute("id")] = Ie
		}

		function Ge(Be) {
			let Ie, qe = Be.slice((Be.lastIndexOf(".") - 1 >>> 0) + 2);
			switch (qe = qe.toLowerCase(), qe) {
				case "tga":
					Ie = Bn;
					break;
				default:
					Ie = Un
			}
			return Ie
		}

		function ze(Be) {
			const Ie = $e(Be.url),
				qe = Ie.profile.technique;
			let je;
			switch (qe.type) {
				case "phong":
				case "blinn":
					je = new MeshPhongMaterial;
					break;
				case "lambert":
					je = new MeshLambertMaterial;
					break;
				default:
					je = new MeshBasicMaterial;
					break
			}
			je.name = Be.name || "";

			function Ke(Ft, Ut = null) {
				const Kt = Ie.profile.samplers[Ft.id];
				let It = null;
				if (Kt !== void 0) {
					const Yt = Ie.profile.surfaces[Kt.source];
					It = it(Yt.init_from)
				} else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."),
					It = it(Ft.id);
				if (It !== null) {
					const Yt = Ge(It);
					if (Yt !== void 0) {
						const Gt = Yt.load(It),
							Qt = Ft.extra;
						if (Qt !== void 0 && Qt.technique !== void 0 && v(Qt.technique) === !1) {
							const Jt = Qt.technique;
							Gt.wrapS = Jt.wrapU ? RepeatWrapping : ClampToEdgeWrapping, Gt.wrapT = Jt.wrapV ?
								RepeatWrapping : ClampToEdgeWrapping, Gt.offset.set(Jt.offsetU || 0, Jt.offsetV ||
									0), Gt.repeat.set(Jt.repeatU || 1, Jt.repeatV || 1)
						} else Gt.wrapS = RepeatWrapping, Gt.wrapT = RepeatWrapping;
						return Ut !== null && (Gt.colorSpace = Ut), Gt
					} else return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", It), null
				} else return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", Ft.id), null
			}
			const St = qe.parameters;
			for (const Ft in St) {
				const Ut = St[Ft];
				switch (Ft) {
					case "diffuse":
						Ut.color && je.color.fromArray(Ut.color), Ut.texture && (je.map = Ke(Ut.texture,
							SRGBColorSpace));
						break;
					case "specular":
						Ut.color && je.specular && je.specular.fromArray(Ut.color), Ut.texture && (je.specularMap =
							Ke(Ut.texture));
						break;
					case "bump":
						Ut.texture && (je.normalMap = Ke(Ut.texture));
						break;
					case "ambient":
						Ut.texture && (je.lightMap = Ke(Ut.texture, SRGBColorSpace));
						break;
					case "shininess":
						Ut.float && je.shininess && (je.shininess = Ut.float);
						break;
					case "emission":
						Ut.color && je.emissive && je.emissive.fromArray(Ut.color), Ut.texture && (je.emissiveMap =
							Ke(Ut.texture, SRGBColorSpace));
						break
				}
			}
			ColorManagement.toWorkingColorSpace(je.color, SRGBColorSpace), je.specular && ColorManagement
				.toWorkingColorSpace(je.specular, SRGBColorSpace), je.emissive && ColorManagement
				.toWorkingColorSpace(je.emissive, SRGBColorSpace);
			let Tt = St.transparent,
				jt = St.transparency;
			if (jt === void 0 && Tt && (jt = {
					float: 1
				}), Tt === void 0 && jt && (Tt = {
					opaque: "A_ONE",
					data: {
						color: [1, 1, 1, 1]
					}
				}), Tt && jt)
				if (Tt.data.texture) je.transparent = !0;
				else {
					const Ft = Tt.data.color;
					switch (Tt.opaque) {
						case "A_ONE":
							je.opacity = Ft[3] * jt.float;
							break;
						case "RGB_ZERO":
							je.opacity = 1 - Ft[0] * jt.float;
							break;
						case "A_ZERO":
							je.opacity = 1 - Ft[3] * jt.float;
							break;
						case "RGB_ONE":
							je.opacity = Ft[0] * jt.float;
							break;
						default:
							console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', Tt
								.opaque)
					}
					je.opacity < 1 && (je.transparent = !0)
				} if (qe.extra !== void 0 && qe.extra.technique !== void 0) {
				const Ft = qe.extra.technique;
				for (const Ut in Ft) {
					const Kt = Ft[Ut];
					switch (Ut) {
						case "double_sided":
							je.side = Kt === 1 ? DoubleSide : FrontSide;
							break;
						case "bump":
							je.normalMap = Ke(Kt.texture), je.normalScale = new Vector2(1, 1);
							break
					}
				}
			}
			return je
		}

		function Oe(Be) {
			return w(tn.materials[Be], ze)
		}

		function Xe(Be) {
			const Ie = {
				name: Be.getAttribute("name")
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "optics":
						Ie.optics = rt(Ke);
						break
				}
			}
			tn.cameras[Be.getAttribute("id")] = Ie
		}

		function rt(Be) {
			for (let Ie = 0; Ie < Be.childNodes.length; Ie++) {
				const qe = Be.childNodes[Ie];
				switch (qe.nodeName) {
					case "technique_common":
						return ut(qe)
				}
			}
			return {}
		}

		function ut(Be) {
			const Ie = {};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				switch (je.nodeName) {
					case "perspective":
					case "orthographic":
						Ie.technique = je.nodeName, Ie.parameters = gt(je);
						break
				}
			}
			return Ie
		}

		function gt(Be) {
			const Ie = {};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				switch (je.nodeName) {
					case "xfov":
					case "yfov":
					case "xmag":
					case "ymag":
					case "znear":
					case "zfar":
					case "aspect_ratio":
						Ie[je.nodeName] = parseFloat(je.textContent);
						break
				}
			}
			return Ie
		}

		function Et(Be) {
			let Ie;
			switch (Be.optics.technique) {
				case "perspective":
					Ie = new PerspectiveCamera(Be.optics.parameters.yfov, Be.optics.parameters.aspect_ratio, Be
						.optics.parameters.znear, Be.optics.parameters.zfar);
					break;
				case "orthographic":
					let qe = Be.optics.parameters.ymag,
						je = Be.optics.parameters.xmag;
					const Ke = Be.optics.parameters.aspect_ratio;
					je = je === void 0 ? qe * Ke : je, qe = qe === void 0 ? je / Ke : qe, je *= .5, qe *= .5, Ie =
						new OrthographicCamera(-je, je, qe, -qe, Be.optics.parameters.znear, Be.optics.parameters
							.zfar);
					break;
				default:
					Ie = new PerspectiveCamera;
					break
			}
			return Ie.name = Be.name || "", Ie
		}

		function Ze(Be) {
			const Ie = tn.cameras[Be];
			return Ie !== void 0 ? w(Ie, Et) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:",
				Be), null)
		}

		function Ye(Be) {
			let Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "technique_common":
						Ie = ct(Ke);
						break
				}
			}
			tn.lights[Be.getAttribute("id")] = Ie
		}

		function ct(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "directional":
					case "point":
					case "spot":
					case "ambient":
						Ie.technique = Ke.nodeName, Ie.parameters = yt(Ke)
				}
			}
			return Ie
		}

		function yt(Be) {
			const Ie = {};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "color":
						const St = d(Ke.textContent);
						Ie.color = new Color().fromArray(St), ColorManagement.toWorkingColorSpace(Ie.color,
							SRGBColorSpace);
						break;
					case "falloff_angle":
						Ie.falloffAngle = parseFloat(Ke.textContent);
						break;
					case "quadratic_attenuation":
						const Tt = parseFloat(Ke.textContent);
						Ie.distance = Tt ? Math.sqrt(1 / Tt) : 0;
						break
				}
			}
			return Ie
		}

		function wt(Be) {
			let Ie;
			switch (Be.technique) {
				case "directional":
					Ie = new DirectionalLight;
					break;
				case "point":
					Ie = new PointLight;
					break;
				case "spot":
					Ie = new SpotLight;
					break;
				case "ambient":
					Ie = new AmbientLight;
					break
			}
			return Be.parameters.color && Ie.color.copy(Be.parameters.color), Be.parameters.distance && (Ie
				.distance = Be.parameters.distance), Ie
		}

		function Qe(Be) {
			const Ie = tn.lights[Be];
			return Ie !== void 0 ? w(Ie, wt) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:",
				Be), null)
		}

		function At(Be) {
			const Ie = {
					name: Be.getAttribute("name"),
					sources: {},
					vertices: {},
					primitives: []
				},
				qe = l(Be, "mesh")[0];
			if (qe !== void 0) {
				for (let je = 0; je < qe.childNodes.length; je++) {
					const Ke = qe.childNodes[je];
					if (Ke.nodeType !== 1) continue;
					const St = Ke.getAttribute("id");
					switch (Ke.nodeName) {
						case "source":
							Ie.sources[St] = Ct(Ke);
							break;
						case "vertices":
							Ie.vertices = xt(Ke);
							break;
						case "polygons":
							console.warn("THREE.ColladaLoader: Unsupported primitive type: ", Ke.nodeName);
							break;
						case "lines":
						case "linestrips":
						case "polylist":
						case "triangles":
							Ie.primitives.push(Rt(Ke));
							break;
						default:
							console.log(Ke)
					}
				}
				tn.geometries[Be.getAttribute("id")] = Ie
			}
		}

		function Ct(Be) {
			const Ie = {
				array: [],
				stride: 3
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "float_array":
						Ie.array = d(je.textContent);
						break;
					case "Name_array":
						Ie.array = c(je.textContent);
						break;
					case "technique_common":
						const Ke = l(je, "accessor")[0];
						Ke !== void 0 && (Ie.stride = parseInt(Ke.getAttribute("stride")));
						break
				}
			}
			return Ie
		}

		function xt(Be) {
			const Ie = {};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				je.nodeType === 1 && (Ie[je.getAttribute("semantic")] = m(je.getAttribute("source")))
			}
			return Ie
		}

		function Rt(Be) {
			const Ie = {
				type: Be.nodeName,
				material: Be.getAttribute("material"),
				count: parseInt(Be.getAttribute("count")),
				inputs: {},
				stride: 0,
				hasUV: !1
			};
			for (let qe = 0, je = Be.childNodes.length; qe < je; qe++) {
				const Ke = Be.childNodes[qe];
				if (Ke.nodeType === 1) switch (Ke.nodeName) {
					case "input":
						const St = m(Ke.getAttribute("source")),
							Tt = Ke.getAttribute("semantic"),
							jt = parseInt(Ke.getAttribute("offset")),
							Ft = parseInt(Ke.getAttribute("set")),
							Ut = Ft > 0 ? Tt + Ft : Tt;
						Ie.inputs[Ut] = {
							id: St,
							offset: jt
						}, Ie.stride = Math.max(Ie.stride, jt + 1), Tt === "TEXCOORD" && (Ie.hasUV = !0);
						break;
					case "vcount":
						Ie.vcount = f(Ke.textContent);
						break;
					case "p":
						Ie.p = f(Ke.textContent);
						break
				}
			}
			return Ie
		}

		function $t(Be) {
			const Ie = {};
			for (let qe = 0; qe < Be.length; qe++) {
				const je = Be[qe];
				Ie[je.type] === void 0 && (Ie[je.type] = []), Ie[je.type].push(je)
			}
			return Ie
		}

		function zt(Be) {
			let Ie = 0;
			for (let qe = 0, je = Be.length; qe < je; qe++) Be[qe].hasUV === !0 && Ie++;
			Ie > 0 && Ie < Be.length && (Be.uvsNeedsFix = !0)
		}

		function sn(Be) {
			const Ie = {},
				qe = Be.sources,
				je = Be.vertices,
				Ke = Be.primitives;
			if (Ke.length === 0) return {};
			const St = $t(Ke);
			for (const Tt in St) {
				const jt = St[Tt];
				zt(jt), Ie[Tt] = dn(jt, qe, je)
			}
			return Ie
		}

		function dn(Be, Ie, qe) {
			const je = {},
				Ke = {
					array: [],
					stride: 0
				},
				St = {
					array: [],
					stride: 0
				},
				Tt = {
					array: [],
					stride: 0
				},
				jt = {
					array: [],
					stride: 0
				},
				Ft = {
					array: [],
					stride: 0
				},
				Ut = {
					array: [],
					stride: 4
				},
				Kt = {
					array: [],
					stride: 4
				},
				It = new BufferGeometry,
				Yt = [];
			let Gt = 0;
			for (let Qt = 0; Qt < Be.length; Qt++) {
				const Jt = Be[Qt],
					kn = Jt.inputs;
				let _n = 0;
				switch (Jt.type) {
					case "lines":
					case "linestrips":
						_n = Jt.count * 2;
						break;
					case "triangles":
						_n = Jt.count * 3;
						break;
					case "polylist":
						for (let ht = 0; ht < Jt.count; ht++) {
							const _t = Jt.vcount[ht];
							switch (_t) {
								case 3:
									_n += 3;
									break;
								case 4:
									_n += 6;
									break;
								default:
									_n += (_t - 2) * 3;
									break
							}
						}
						break;
					default:
						console.warn("THREE.ColladaLoader: Unknown primitive type:", Jt.type)
				}
				It.addGroup(Gt, _n, Qt), Gt += _n, Jt.material && Yt.push(Jt.material);
				for (const ht in kn) {
					const _t = kn[ht];
					switch (ht) {
						case "VERTEX":
							for (const kt in qe) {
								const Bt = qe[kt];
								switch (kt) {
									case "POSITION":
										const Vt = Ke.array.length;
										if (Mt(Jt, Ie[Bt], _t.offset, Ke.array), Ke.stride = Ie[Bt].stride, Ie
											.skinWeights && Ie.skinIndices && (Mt(Jt, Ie.skinIndices, _t.offset, Ut
												.array), Mt(Jt, Ie.skinWeights, _t.offset, Kt.array)), Jt.hasUV ===
											!1 && Be.uvsNeedsFix === !0) {
											const Wt = (Ke.array.length - Vt) / Ke.stride;
											for (let an = 0; an < Wt; an++) Tt.array.push(0, 0)
										}
										break;
									case "NORMAL":
										Mt(Jt, Ie[Bt], _t.offset, St.array), St.stride = Ie[Bt].stride;
										break;
									case "COLOR":
										Mt(Jt, Ie[Bt], _t.offset, Ft.array), Ft.stride = Ie[Bt].stride;
										break;
									case "TEXCOORD":
										Mt(Jt, Ie[Bt], _t.offset, Tt.array), Tt.stride = Ie[Bt].stride;
										break;
									case "TEXCOORD1":
										Mt(Jt, Ie[Bt], _t.offset, jt.array), Tt.stride = Ie[Bt].stride;
										break;
									default:
										console.warn(
											'THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',
											kt)
								}
							}
							break;
						case "NORMAL":
							Mt(Jt, Ie[_t.id], _t.offset, St.array), St.stride = Ie[_t.id].stride;
							break;
						case "COLOR":
							Mt(Jt, Ie[_t.id], _t.offset, Ft.array, !0), Ft.stride = Ie[_t.id].stride;
							break;
						case "TEXCOORD":
							Mt(Jt, Ie[_t.id], _t.offset, Tt.array), Tt.stride = Ie[_t.id].stride;
							break;
						case "TEXCOORD1":
							Mt(Jt, Ie[_t.id], _t.offset, jt.array), jt.stride = Ie[_t.id].stride;
							break
					}
				}
			}
			return Ke.array.length > 0 && It.setAttribute("position", new Float32BufferAttribute(Ke.array, Ke
					.stride)), St.array.length > 0 && It.setAttribute("normal", new Float32BufferAttribute(St.array,
					St.stride)), Ft.array.length > 0 && It.setAttribute("color", new Float32BufferAttribute(Ft
					.array, Ft.stride)), Tt.array.length > 0 && It.setAttribute("uv", new Float32BufferAttribute(Tt
					.array, Tt.stride)), jt.array.length > 0 && It.setAttribute("uv1", new Float32BufferAttribute(jt
					.array, jt.stride)), Ut.array.length > 0 && It.setAttribute("skinIndex",
					new Float32BufferAttribute(Ut.array, Ut.stride)), Kt.array.length > 0 && It.setAttribute(
					"skinWeight", new Float32BufferAttribute(Kt.array, Kt.stride)), je.data = It, je.type = Be[0]
				.type, je.materialKeys = Yt, je
		}

		function Mt(Be, Ie, qe, je, Ke = !1) {
			const St = Be.p,
				Tt = Be.stride,
				jt = Be.vcount;

			function Ft(It) {
				let Yt = St[It + qe] * Kt;
				const Gt = Yt + Kt;
				for (; Yt < Gt; Yt++) je.push(Ut[Yt]);
				if (Ke) {
					const Qt = je.length - Kt - 1;
					In.setRGB(je[Qt + 0], je[Qt + 1], je[Qt + 2], SRGBColorSpace), je[Qt + 0] = In.r, je[Qt + 1] =
						In.g, je[Qt + 2] = In.b
				}
			}
			const Ut = Ie.array,
				Kt = Ie.stride;
			if (Be.vcount !== void 0) {
				let It = 0;
				for (let Yt = 0, Gt = jt.length; Yt < Gt; Yt++) {
					const Qt = jt[Yt];
					if (Qt === 4) {
						const Jt = It + Tt * 0,
							kn = It + Tt * 1,
							_n = It + Tt * 2,
							ht = It + Tt * 3;
						Ft(Jt), Ft(kn), Ft(ht), Ft(kn), Ft(_n), Ft(ht)
					} else if (Qt === 3) {
						const Jt = It + Tt * 0,
							kn = It + Tt * 1,
							_n = It + Tt * 2;
						Ft(Jt), Ft(kn), Ft(_n)
					} else if (Qt > 4)
						for (let Jt = 1, kn = Qt - 2; Jt <= kn; Jt++) {
							const _n = It + Tt * 0,
								ht = It + Tt * Jt,
								_t = It + Tt * (Jt + 1);
							Ft(_n), Ft(ht), Ft(_t)
						}
					It += Tt * Qt
				}
			} else
				for (let It = 0, Yt = St.length; It < Yt; It += Tt) Ft(It)
		}

		function qt(Be) {
			return w(tn.geometries[Be], sn)
		}

		function pn(Be) {
			const Ie = {
				name: Be.getAttribute("name") || "",
				joints: {},
				links: []
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "technique_common":
						lt(je, Ie);
						break
				}
			}
			tn.kinematicsModels[Be.getAttribute("id")] = Ie
		}

		function Te(Be) {
			return Be.build !== void 0 ? Be.build : Be
		}

		function Pe(Be) {
			return w(tn.kinematicsModels[Be], Te)
		}

		function lt(Be, Ie) {
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "joint":
						Ie.joints[je.getAttribute("sid")] = bt(je);
						break;
					case "link":
						Ie.links.push(Ot(je));
						break
				}
			}
		}

		function bt(Be) {
			let Ie;
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "prismatic":
					case "revolute":
						Ie = Nt(je);
						break
				}
			}
			return Ie
		}

		function Nt(Be) {
			const Ie = {
				sid: Be.getAttribute("sid"),
				name: Be.getAttribute("name") || "",
				axis: new Vector3$1,
				limits: {
					min: 0,
					max: 0
				},
				type: Be.nodeName,
				static: !1,
				zeroPosition: 0,
				middlePosition: 0
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "axis":
						const Ke = d(je.textContent);
						Ie.axis.fromArray(Ke);
						break;
					case "limits":
						const St = je.getElementsByTagName("max")[0],
							Tt = je.getElementsByTagName("min")[0];
						Ie.limits.max = parseFloat(St.textContent), Ie.limits.min = parseFloat(Tt.textContent);
						break
				}
			}
			return Ie.limits.min >= Ie.limits.max && (Ie.static = !0), Ie.middlePosition = (Ie.limits.min + Ie
				.limits.max) / 2, Ie
		}

		function Ot(Be) {
			const Ie = {
				sid: Be.getAttribute("sid"),
				name: Be.getAttribute("name") || "",
				attachments: [],
				transforms: []
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "attachment_full":
						Ie.attachments.push(nn(je));
						break;
					case "matrix":
					case "translate":
					case "rotate":
						Ie.transforms.push(Cn(je));
						break
				}
			}
			return Ie
		}

		function nn(Be) {
			const Ie = {
				joint: Be.getAttribute("joint").split("/").pop(),
				transforms: [],
				links: []
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "link":
						Ie.links.push(Ot(je));
						break;
					case "matrix":
					case "translate":
					case "rotate":
						Ie.transforms.push(Cn(je));
						break
				}
			}
			return Ie
		}

		function Cn(Be) {
			const Ie = {
					type: Be.nodeName
				},
				qe = d(Be.textContent);
			switch (Ie.type) {
				case "matrix":
					Ie.obj = new Matrix4, Ie.obj.fromArray(qe).transpose();
					break;
				case "translate":
					Ie.obj = new Vector3$1, Ie.obj.fromArray(qe);
					break;
				case "rotate":
					Ie.obj = new Vector3$1, Ie.obj.fromArray(qe), Ie.angle = MathUtils.degToRad(qe[3]);
					break
			}
			return Ie
		}

		function wn(Be) {
			const Ie = {
				name: Be.getAttribute("name") || "",
				rigidBodies: {}
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "rigid_body":
						Ie.rigidBodies[je.getAttribute("name")] = {}, Mn(je, Ie.rigidBodies[je.getAttribute(
							"name")]);
						break
				}
			}
			tn.physicsModels[Be.getAttribute("id")] = Ie
		}

		function Mn(Be, Ie) {
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "technique_common":
						fn(je, Ie);
						break
				}
			}
		}

		function fn(Be, Ie) {
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "inertia":
						Ie.inertia = d(je.textContent);
						break;
					case "mass":
						Ie.mass = d(je.textContent)[0];
						break
				}
			}
		}

		function zn(Be) {
			const Ie = {
				bindJointAxis: []
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "bind_joint_axis":
						Ie.bindJointAxis.push(On(je));
						break
				}
			}
			tn.kinematicsScenes[m(Be.getAttribute("url"))] = Ie
		}

		function On(Be) {
			const Ie = {
				target: Be.getAttribute("target").split("/").pop()
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType === 1) switch (je.nodeName) {
					case "axis":
						const Ke = je.getElementsByTagName("param")[0];
						Ie.axis = Ke.textContent;
						const St = Ie.axis.split("inst_").pop().split("axis")[0];
						Ie.jointIndex = St.substring(0, St.length - 1);
						break
				}
			}
			return Ie
		}

		function Nn(Be) {
			return Be.build !== void 0 ? Be.build : Be
		}

		function An(Be) {
			return w(tn.kinematicsScenes[Be], Nn)
		}

		function $n() {
			const Be = Object.keys(tn.kinematicsModels)[0],
				Ie = Object.keys(tn.kinematicsScenes)[0],
				qe = Object.keys(tn.visualScenes)[0];
			if (Be === void 0 || Ie === void 0) return;
			const je = Pe(Be),
				Ke = An(Ie),
				St = hn(qe),
				Tt = Ke.bindJointAxis,
				jt = {};
			for (let Kt = 0, It = Tt.length; Kt < It; Kt++) {
				const Yt = Tt[Kt],
					Gt = Sn.querySelector('[sid="' + Yt.target + '"]');
				if (Gt) {
					const Qt = Gt.parentElement;
					Ft(Yt.jointIndex, Qt)
				}
			}

			function Ft(Kt, It) {
				const Yt = It.getAttribute("name"),
					Gt = je.joints[Kt];
				St.traverse(function(Qt) {
					Qt.name === Yt && (jt[Kt] = {
						object: Qt,
						transforms: Rn(It),
						joint: Gt,
						position: Gt.zeroPosition
					})
				})
			}
			const Ut = new Matrix4;
			er = {
				joints: je && je.joints,
				getJointValue: function(Kt) {
					const It = jt[Kt];
					if (It) return It.position;
					console.warn("THREE.ColladaLoader: Joint " + Kt + " doesn't exist.")
				},
				setJointValue: function(Kt, It) {
					const Yt = jt[Kt];
					if (Yt) {
						const Gt = Yt.joint;
						if (It > Gt.limits.max || It < Gt.limits.min) console.warn(
							"THREE.ColladaLoader: Joint " + Kt + " value " + It +
							" outside of limits (min: " + Gt.limits.min + ", max: " + Gt.limits.max +
							").");
						else if (Gt.static) console.warn("THREE.ColladaLoader: Joint " + Kt +
						" is static.");
						else {
							const Qt = Yt.object,
								Jt = Gt.axis,
								kn = Yt.transforms;
							et.identity();
							for (let _n = 0; _n < kn.length; _n++) {
								const ht = kn[_n];
								if (ht.sid && ht.sid.indexOf(Kt) !== -1) switch (Gt.type) {
									case "revolute":
										et.multiply(Ut.makeRotationAxis(Jt, MathUtils.degToRad(It)));
										break;
									case "prismatic":
										et.multiply(Ut.makeTranslation(Jt.x * It, Jt.y * It, Jt.z *
										It));
										break;
									default:
										console.warn("THREE.ColladaLoader: Unknown joint type: " + Gt
											.type);
										break
								} else switch (ht.type) {
									case "matrix":
										et.multiply(ht.obj);
										break;
									case "translate":
										et.multiply(Ut.makeTranslation(ht.obj.x, ht.obj.y, ht.obj
											.z));
										break;
									case "scale":
										et.scale(ht.obj);
										break;
									case "rotate":
										et.multiply(Ut.makeRotationAxis(ht.obj, ht.angle));
										break
								}
							}
							Qt.matrix.copy(et), Qt.matrix.decompose(Qt.position, Qt.quaternion, Qt.scale),
								jt[Kt].position = It
						}
					} else console.log("THREE.ColladaLoader: " + Kt + " does not exist.")
				}
			}
		}

		function Rn(Be) {
			const Ie = [],
				qe = Sn.querySelector('[id="' + Be.id + '"]');
			for (let je = 0; je < qe.childNodes.length; je++) {
				const Ke = qe.childNodes[je];
				if (Ke.nodeType !== 1) continue;
				let St, Tt;
				switch (Ke.nodeName) {
					case "matrix":
						St = d(Ke.textContent);
						const jt = new Matrix4().fromArray(St).transpose();
						Ie.push({
							sid: Ke.getAttribute("sid"),
							type: Ke.nodeName,
							obj: jt
						});
						break;
					case "translate":
					case "scale":
						St = d(Ke.textContent), Tt = new Vector3$1().fromArray(St), Ie.push({
							sid: Ke.getAttribute("sid"),
							type: Ke.nodeName,
							obj: Tt
						});
						break;
					case "rotate":
						St = d(Ke.textContent), Tt = new Vector3$1().fromArray(St);
						const Ft = MathUtils.degToRad(St[3]);
						Ie.push({
							sid: Ke.getAttribute("sid"),
							type: Ke.nodeName,
							obj: Tt,
							angle: Ft
						});
						break
				}
			}
			return Ie
		}

		function We(Be) {
			const Ie = Be.getElementsByTagName("node");
			for (let qe = 0; qe < Ie.length; qe++) {
				const je = Ie[qe];
				je.hasAttribute("id") === !1 && je.setAttribute("id", g())
			}
		}
		const et = new Matrix4,
			ft = new Vector3$1;

		function vt(Be) {
			const Ie = {
				name: Be.getAttribute("name") || "",
				type: Be.getAttribute("type"),
				id: Be.getAttribute("id"),
				sid: Be.getAttribute("sid"),
				matrix: new Matrix4,
				nodes: [],
				instanceCameras: [],
				instanceControllers: [],
				instanceLights: [],
				instanceGeometries: [],
				instanceNodes: [],
				transforms: {}
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				if (je.nodeType !== 1) continue;
				let Ke;
				switch (je.nodeName) {
					case "node":
						Ie.nodes.push(je.getAttribute("id")), vt(je);
						break;
					case "instance_camera":
						Ie.instanceCameras.push(m(je.getAttribute("url")));
						break;
					case "instance_controller":
						Ie.instanceControllers.push(mt(je));
						break;
					case "instance_light":
						Ie.instanceLights.push(m(je.getAttribute("url")));
						break;
					case "instance_geometry":
						Ie.instanceGeometries.push(mt(je));
						break;
					case "instance_node":
						Ie.instanceNodes.push(m(je.getAttribute("url")));
						break;
					case "matrix":
						Ke = d(je.textContent), Ie.matrix.multiply(et.fromArray(Ke).transpose()), Ie.transforms[je
							.getAttribute("sid")] = je.nodeName;
						break;
					case "translate":
						Ke = d(je.textContent), ft.fromArray(Ke), Ie.matrix.multiply(et.makeTranslation(ft.x, ft.y,
							ft.z)), Ie.transforms[je.getAttribute("sid")] = je.nodeName;
						break;
					case "rotate":
						Ke = d(je.textContent);
						const St = MathUtils.degToRad(Ke[3]);
						Ie.matrix.multiply(et.makeRotationAxis(ft.fromArray(Ke), St)), Ie.transforms[je
							.getAttribute("sid")] = je.nodeName;
						break;
					case "scale":
						Ke = d(je.textContent), Ie.matrix.scale(ft.fromArray(Ke)), Ie.transforms[je.getAttribute(
							"sid")] = je.nodeName;
						break;
					case "extra":
						break;
					default:
						console.log(je)
				}
			}
			return Xt(Ie.id) ? console.warn(
				"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",
				Ie.id) : tn.nodes[Ie.id] = Ie, Ie
		}

		function mt(Be) {
			const Ie = {
				id: m(Be.getAttribute("url")),
				materials: {},
				skeletons: []
			};
			for (let qe = 0; qe < Be.childNodes.length; qe++) {
				const je = Be.childNodes[qe];
				switch (je.nodeName) {
					case "bind_material":
						const Ke = je.getElementsByTagName("instance_material");
						for (let St = 0; St < Ke.length; St++) {
							const Tt = Ke[St],
								jt = Tt.getAttribute("symbol"),
								Ft = Tt.getAttribute("target");
							Ie.materials[jt] = m(Ft)
						}
						break;
					case "skeleton":
						Ie.skeletons.push(m(je.textContent));
						break
				}
			}
			return Ie
		}

		function Dt(Be, Ie) {
			const qe = [],
				je = [];
			let Ke, St, Tt;
			for (Ke = 0; Ke < Be.length; Ke++) {
				const Ut = Be[Ke];
				let Kt;
				if (Xt(Ut)) Kt = un(Ut), Pt(Kt, Ie, qe);
				else if (cn(Ut)) {
					const Yt = tn.visualScenes[Ut].children;
					for (let Gt = 0; Gt < Yt.length; Gt++) {
						const Qt = Yt[Gt];
						if (Qt.type === "JOINT") {
							const Jt = un(Qt.id);
							Pt(Jt, Ie, qe)
						}
					}
				} else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", Ut)
			}
			for (Ke = 0; Ke < Ie.length; Ke++)
				for (St = 0; St < qe.length; St++)
					if (Tt = qe[St], Tt.bone.name === Ie[Ke].name) {
						je[Ke] = Tt, Tt.processed = !0;
						break
					} for (Ke = 0; Ke < qe.length; Ke++) Tt = qe[Ke], Tt.processed === !1 && (je.push(Tt), Tt
				.processed = !0);
			const jt = [],
				Ft = [];
			for (Ke = 0; Ke < je.length; Ke++) Tt = je[Ke], jt.push(Tt.bone), Ft.push(Tt.boneInverse);
			return new Skeleton(jt, Ft)
		}

		function Pt(Be, Ie, qe) {
			Be.traverse(function(je) {
				if (je.isBone === !0) {
					let Ke;
					for (let St = 0; St < Ie.length; St++) {
						const Tt = Ie[St];
						if (Tt.name === je.name) {
							Ke = Tt.boneInverse;
							break
						}
					}
					Ke === void 0 && (Ke = new Matrix4), qe.push({
						bone: je,
						boneInverse: Ke,
						processed: !1
					})
				}
			})
		}

		function Lt(Be) {
			const Ie = [],
				qe = Be.matrix,
				je = Be.nodes,
				Ke = Be.type,
				St = Be.instanceCameras,
				Tt = Be.instanceControllers,
				jt = Be.instanceLights,
				Ft = Be.instanceGeometries,
				Ut = Be.instanceNodes;
			for (let It = 0, Yt = je.length; It < Yt; It++) Ie.push(un(je[It]));
			for (let It = 0, Yt = St.length; It < Yt; It++) {
				const Gt = Ze(St[It]);
				Gt !== null && Ie.push(Gt.clone())
			}
			for (let It = 0, Yt = Tt.length; It < Yt; It++) {
				const Gt = Tt[It],
					Qt = be(Gt.id),
					Jt = qt(Qt.id),
					kn = en(Jt, Gt.materials),
					_n = Gt.skeletons,
					ht = Qt.skin.joints,
					_t = Dt(_n, ht);
				for (let kt = 0, Bt = kn.length; kt < Bt; kt++) {
					const Vt = kn[kt];
					Vt.isSkinnedMesh && (Vt.bind(_t, Qt.skin.bindMatrix), Vt.normalizeSkinWeights()), Ie.push(Vt)
				}
			}
			for (let It = 0, Yt = jt.length; It < Yt; It++) {
				const Gt = Qe(jt[It]);
				Gt !== null && Ie.push(Gt.clone())
			}
			for (let It = 0, Yt = Ft.length; It < Yt; It++) {
				const Gt = Ft[It],
					Qt = qt(Gt.id),
					Jt = en(Qt, Gt.materials);
				for (let kn = 0, _n = Jt.length; kn < _n; kn++) Ie.push(Jt[kn])
			}
			for (let It = 0, Yt = Ut.length; It < Yt; It++) Ie.push(un(Ut[It]).clone());
			let Kt;
			if (je.length === 0 && Ie.length === 1) Kt = Ie[0];
			else {
				Kt = Ke === "JOINT" ? new Bone : new Group;
				for (let It = 0; It < Ie.length; It++) Kt.add(Ie[It])
			}
			return Kt.name = Ke === "JOINT" ? Be.sid : Be.name, Kt.matrix.copy(qe), Kt.matrix.decompose(Kt.position,
				Kt.quaternion, Kt.scale), Kt
		}
		const Ht = new MeshBasicMaterial({
			name: Loader.DEFAULT_MATERIAL_NAME,
			color: 16711935
		});

		function rn(Be, Ie) {
			const qe = [];
			for (let je = 0, Ke = Be.length; je < Ke; je++) {
				const St = Ie[Be[je]];
				St === void 0 ? (console.warn(
						"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", Be[je]
						), qe.push(Ht)) : qe.push(Oe(St))
			}
			return qe
		}

		function en(Be, Ie) {
			const qe = [];
			for (const je in Be) {
				const Ke = Be[je],
					St = rn(Ke.materialKeys, Ie);
				if (St.length === 0 && (je === "lines" || je === "linestrips" ? St.push(new LineBasicMaterial) : St
						.push(new MeshPhongMaterial)), je === "lines" || je === "linestrips")
					for (let Ut = 0, Kt = St.length; Ut < Kt; Ut++) {
						const It = St[Ut];
						if (It.isMeshPhongMaterial === !0 || It.isMeshLambertMaterial === !0) {
							const Yt = new LineBasicMaterial;
							Yt.color.copy(It.color), Yt.opacity = It.opacity, Yt.transparent = It.transparent, St[
								Ut] = Yt
						}
					}
				const Tt = Ke.data.attributes.skinIndex !== void 0,
					jt = St.length === 1 ? St[0] : St;
				let Ft;
				switch (je) {
					case "lines":
						Ft = new LineSegments(Ke.data, jt);
						break;
					case "linestrips":
						Ft = new Line(Ke.data, jt);
						break;
					case "triangles":
					case "polylist":
						Tt ? Ft = new SkinnedMesh(Ke.data, jt) : Ft = new Mesh(Ke.data, jt);
						break
				}
				qe.push(Ft)
			}
			return qe
		}

		function Xt(Be) {
			return tn.nodes[Be] !== void 0
		}

		function un(Be) {
			return w(tn.nodes[Be], Lt)
		}

		function mn(Be) {
			const Ie = {
				name: Be.getAttribute("name"),
				children: []
			};
			We(Be);
			const qe = l(Be, "node");
			for (let je = 0; je < qe.length; je++) Ie.children.push(vt(qe[je]));
			tn.visualScenes[Be.getAttribute("id")] = Ie
		}

		function Tn(Be) {
			const Ie = new Group;
			Ie.name = Be.name;
			const qe = Be.children;
			for (let je = 0; je < qe.length; je++) {
				const Ke = qe[je];
				Ie.add(un(Ke.id))
			}
			return Ie
		}

		function cn(Be) {
			return tn.visualScenes[Be] !== void 0
		}

		function hn(Be) {
			return w(tn.visualScenes[Be], Tn)
		}

		function Zt(Be) {
			const Ie = l(Be, "instance_visual_scene")[0];
			return hn(m(Ie.getAttribute("url")))
		}

		function Fn() {
			const Be = tn.clips;
			if (v(Be) === !0) {
				if (v(tn.animations) === !1) {
					const Ie = [];
					for (const qe in tn.animations) {
						const je = D(qe);
						for (let Ke = 0, St = je.length; Ke < St; Ke++) Ie.push(je[Ke])
					}
					Pn.push(new AnimationClip("default", -1, Ie))
				}
			} else
				for (const Ie in Be) Pn.push(q(Ie))
		}

		function gn(Be) {
			let Ie = "";
			const qe = [Be];
			for (; qe.length;) {
				const je = qe.shift();
				je.nodeType === Node.TEXT_NODE ? Ie += je.textContent : (Ie += `
`, qe.push(...je.childNodes))
			}
			return Ie.trim()
		}
		if (s.length === 0) return {
			scene: new Scene
		};
		const jn = new DOMParser().parseFromString(s, "application/xml"),
			Sn = l(jn, "COLLADA")[0],
			Vn = jn.getElementsByTagName("parsererror")[0];
		if (Vn !== void 0) {
			const Be = l(Vn, "div")[0];
			let Ie;
			return Be ? Ie = Be.textContent : Ie = gn(Vn), console.error(`THREE.ColladaLoader: Failed to parse collada file.
`, Ie), null
		}
		const qn = Sn.getAttribute("version");
		console.debug("THREE.ColladaLoader: File version", qn);
		const yn = y(l(Sn, "asset")[0]),
			Un = new TextureLoader(this.manager);
		Un.setPath(this.resourcePath || a).setCrossOrigin(this.crossOrigin);
		let Bn;
		TGALoader && (Bn = new TGALoader(this.manager), Bn.setPath(this.resourcePath || a));
		const In = new Color,
			Pn = [];
		let er = {},
			Kn = 0;
		const tn = {
			animations: {},
			clips: {},
			controllers: {},
			images: {},
			effects: {},
			materials: {},
			cameras: {},
			lights: {},
			geometries: {},
			nodes: {},
			visualScenes: {},
			kinematicsModels: {},
			physicsModels: {},
			kinematicsScenes: {}
		};
		_(Sn, "library_animations", "animation", T), _(Sn, "library_animation_clips", "animation_clip", ae), _(Sn,
			"library_controllers", "controller", le), _(Sn, "library_images", "image", Me), _(Sn,
			"library_effects", "effect", pt), _(Sn, "library_materials", "material", Fe), _(Sn,
			"library_cameras", "camera", Xe), _(Sn, "library_lights", "light", Ye), _(Sn, "library_geometries",
			"geometry", At), _(Sn, "library_nodes", "node", vt), _(Sn, "library_visual_scenes", "visual_scene",
			mn), _(Sn, "library_kinematics_models", "kinematics_model", pn), _(Sn, "library_physics_models",
			"physics_model", wn), _(Sn, "scene", "instance_kinematics_scene", zn), S(tn.animations, M), S(tn
			.clips, fe), S(tn.controllers, De), S(tn.images, Ve), S(tn.effects, Ce), S(tn.materials, ze), S(tn
			.cameras, Et), S(tn.lights, wt), S(tn.geometries, sn), S(tn.visualScenes, Tn), Fn(), $n();
		const nr = Zt(l(Sn, "scene")[0]);
		return nr.animations = Pn, yn.upAxis === "Z_UP" && (console.warn(
			"THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289."
			), nr.rotation.set(-Math.PI / 2, 0, 0)), nr.scale.multiplyScalar(yn.unit), {
			get animations() {
				return console.warn(
					"THREE.ColladaLoader: Please access animations over scene.animations now."), Pn
			},
			kinematics: er,
			library: tn,
			scene: nr
		}
	}
}
const _object_pattern = /^[og]\s*(.+)?/,
	_material_library_pattern = /^mtllib /,
	_material_use_pattern = /^usemtl /,
	_map_use_pattern = /^usemap /,
	_face_vertex_data_separator_pattern = /\s+/,
	_vA = new Vector3$1,
	_vB = new Vector3$1,
	_vC = new Vector3$1,
	_ab = new Vector3$1,
	_cb = new Vector3$1,
	_color = new Color;

function ParserState() {
	const o = {
		objects: [],
		object: {},
		vertices: [],
		normals: [],
		colors: [],
		uvs: [],
		materials: {},
		materialLibraries: [],
		startObject: function(s, a) {
			if (this.object && this.object.fromDeclaration === !1) {
				this.object.name = s, this.object.fromDeclaration = a !== !1;
				return
			}
			const l = this.object && typeof this.object.currentMaterial == "function" ? this.object
				.currentMaterial() : void 0;
			if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this
				.object = {
					name: s || "",
					fromDeclaration: a !== !1,
					geometry: {
						vertices: [],
						normals: [],
						colors: [],
						uvs: [],
						hasUVIndices: !1
					},
					materials: [],
					smooth: !0,
					startMaterial: function(c, d) {
						const f = this._finalize(!1);
						f && (f.inherited || f.groupCount <= 0) && this.materials.splice(f.index, 1);
						const m = {
							index: this.materials.length,
							name: c || "",
							mtllib: Array.isArray(d) && d.length > 0 ? d[d.length - 1] : "",
							smooth: f !== void 0 ? f.smooth : this.smooth,
							groupStart: f !== void 0 ? f.groupEnd : 0,
							groupEnd: -1,
							groupCount: -1,
							inherited: !1,
							clone: function(g) {
								const v = {
									index: typeof g == "number" ? g : this.index,
									name: this.name,
									mtllib: this.mtllib,
									smooth: this.smooth,
									groupStart: 0,
									groupEnd: -1,
									groupCount: -1,
									inherited: !1
								};
								return v.clone = this.clone.bind(v), v
							}
						};
						return this.materials.push(m), m
					},
					currentMaterial: function() {
						if (this.materials.length > 0) return this.materials[this.materials.length - 1]
					},
					_finalize: function(c) {
						const d = this.currentMaterial();
						if (d && d.groupEnd === -1 && (d.groupEnd = this.geometry.vertices.length / 3, d
								.groupCount = d.groupEnd - d.groupStart, d.inherited = !1), c && this
							.materials.length > 1)
							for (let f = this.materials.length - 1; f >= 0; f--) this.materials[f]
								.groupCount <= 0 && this.materials.splice(f, 1);
						return c && this.materials.length === 0 && this.materials.push({
							name: "",
							smooth: this.smooth
						}), d
					}
				}, l && l.name && typeof l.clone == "function") {
				const c = l.clone(0);
				c.inherited = !0, this.object.materials.push(c)
			}
			this.objects.push(this.object)
		},
		finalize: function() {
			this.object && typeof this.object._finalize == "function" && this.object._finalize(!0)
		},
		parseVertexIndex: function(s, a) {
			const l = parseInt(s, 10);
			return (l >= 0 ? l - 1 : l + a / 3) * 3
		},
		parseNormalIndex: function(s, a) {
			const l = parseInt(s, 10);
			return (l >= 0 ? l - 1 : l + a / 3) * 3
		},
		parseUVIndex: function(s, a) {
			const l = parseInt(s, 10);
			return (l >= 0 ? l - 1 : l + a / 2) * 2
		},
		addVertex: function(s, a, l) {
			const c = this.vertices,
				d = this.object.geometry.vertices;
			d.push(c[s + 0], c[s + 1], c[s + 2]), d.push(c[a + 0], c[a + 1], c[a + 2]), d.push(c[l + 0], c[l +
				1], c[l + 2])
		},
		addVertexPoint: function(s) {
			const a = this.vertices;
			this.object.geometry.vertices.push(a[s + 0], a[s + 1], a[s + 2])
		},
		addVertexLine: function(s) {
			const a = this.vertices;
			this.object.geometry.vertices.push(a[s + 0], a[s + 1], a[s + 2])
		},
		addNormal: function(s, a, l) {
			const c = this.normals,
				d = this.object.geometry.normals;
			d.push(c[s + 0], c[s + 1], c[s + 2]), d.push(c[a + 0], c[a + 1], c[a + 2]), d.push(c[l + 0], c[l +
				1], c[l + 2])
		},
		addFaceNormal: function(s, a, l) {
			const c = this.vertices,
				d = this.object.geometry.normals;
			_vA.fromArray(c, s), _vB.fromArray(c, a), _vC.fromArray(c, l), _cb.subVectors(_vC, _vB), _ab
				.subVectors(_vA, _vB), _cb.cross(_ab), _cb.normalize(), d.push(_cb.x, _cb.y, _cb.z), d.push(_cb
					.x, _cb.y, _cb.z), d.push(_cb.x, _cb.y, _cb.z)
		},
		addColor: function(s, a, l) {
			const c = this.colors,
				d = this.object.geometry.colors;
			c[s] !== void 0 && d.push(c[s + 0], c[s + 1], c[s + 2]), c[a] !== void 0 && d.push(c[a + 0], c[a +
				1], c[a + 2]), c[l] !== void 0 && d.push(c[l + 0], c[l + 1], c[l + 2])
		},
		addUV: function(s, a, l) {
			const c = this.uvs,
				d = this.object.geometry.uvs;
			d.push(c[s + 0], c[s + 1]), d.push(c[a + 0], c[a + 1]), d.push(c[l + 0], c[l + 1])
		},
		addDefaultUV: function() {
			const s = this.object.geometry.uvs;
			s.push(0, 0), s.push(0, 0), s.push(0, 0)
		},
		addUVLine: function(s) {
			const a = this.uvs;
			this.object.geometry.uvs.push(a[s + 0], a[s + 1])
		},
		addFace: function(s, a, l, c, d, f, m, g, v) {
			const y = this.vertices.length;
			let b = this.parseVertexIndex(s, y),
				C = this.parseVertexIndex(a, y),
				_ = this.parseVertexIndex(l, y);
			if (this.addVertex(b, C, _), this.addColor(b, C, _), m !== void 0 && m !== "") {
				const S = this.normals.length;
				b = this.parseNormalIndex(m, S), C = this.parseNormalIndex(g, S), _ = this.parseNormalIndex(v,
					S), this.addNormal(b, C, _)
			} else this.addFaceNormal(b, C, _);
			if (c !== void 0 && c !== "") {
				const S = this.uvs.length;
				b = this.parseUVIndex(c, S), C = this.parseUVIndex(d, S), _ = this.parseUVIndex(f, S), this
					.addUV(b, C, _), this.object.geometry.hasUVIndices = !0
			} else this.addDefaultUV()
		},
		addPointGeometry: function(s) {
			this.object.geometry.type = "Points";
			const a = this.vertices.length;
			for (let l = 0, c = s.length; l < c; l++) {
				const d = this.parseVertexIndex(s[l], a);
				this.addVertexPoint(d), this.addColor(d)
			}
		},
		addLineGeometry: function(s, a) {
			this.object.geometry.type = "Line";
			const l = this.vertices.length,
				c = this.uvs.length;
			for (let d = 0, f = s.length; d < f; d++) this.addVertexLine(this.parseVertexIndex(s[d], l));
			for (let d = 0, f = a.length; d < f; d++) this.addUVLine(this.parseUVIndex(a[d], c))
		}
	};
	return o.startObject("", !1), o
}
class OBJLoader extends Loader {
	constructor(s) {
		super(s), this.materials = null
	}
	load(s, a, l, c) {
		const d = this,
			f = new FileLoader(this.manager);
		f.setPath(this.path), f.setRequestHeader(this.requestHeader), f.setWithCredentials(this.withCredentials), f
			.load(s, function(m) {
				try {
					a(d.parse(m))
				} catch (g) {
					c ? c(g) : console.error(g), d.manager.itemError(s)
				}
			}, l, c)
	}
	setMaterials(s) {
		return this.materials = s, this
	}
	parse(s) {
		const a = new ParserState;
		s.indexOf(`\r
`) !== -1 && (s = s.replace(/\r\n/g, `
`)), s.indexOf(`\\
`) !== -1 && (s = s.replace(/\\\n/g, ""));
		const l = s.split(`
`);
		let c = [];
		for (let m = 0, g = l.length; m < g; m++) {
			const v = l[m].trimStart();
			if (v.length === 0) continue;
			const y = v.charAt(0);
			if (y !== "#")
				if (y === "v") {
					const b = v.split(_face_vertex_data_separator_pattern);
					switch (b[0]) {
						case "v":
							a.vertices.push(parseFloat(b[1]), parseFloat(b[2]), parseFloat(b[3])), b.length >= 7 ? (
									_color.setRGB(parseFloat(b[4]), parseFloat(b[5]), parseFloat(b[6]),
										SRGBColorSpace), a.colors.push(_color.r, _color.g, _color.b)) : a.colors
								.push(void 0, void 0, void 0);
							break;
						case "vn":
							a.normals.push(parseFloat(b[1]), parseFloat(b[2]), parseFloat(b[3]));
							break;
						case "vt":
							a.uvs.push(parseFloat(b[1]), parseFloat(b[2]));
							break
					}
				} else if (y === "f") {
				const C = v.slice(1).trim().split(_face_vertex_data_separator_pattern),
					_ = [];
				for (let w = 0, T = C.length; w < T; w++) {
					const A = C[w];
					if (A.length > 0) {
						const k = A.split("/");
						_.push(k)
					}
				}
				const S = _[0];
				for (let w = 1, T = _.length - 1; w < T; w++) {
					const A = _[w],
						k = _[w + 1];
					a.addFace(S[0], A[0], k[0], S[1], A[1], k[1], S[2], A[2], k[2])
				}
			} else if (y === "l") {
				const b = v.substring(1).trim().split(" ");
				let C = [];
				const _ = [];
				if (v.indexOf("/") === -1) C = b;
				else
					for (let S = 0, w = b.length; S < w; S++) {
						const T = b[S].split("/");
						T[0] !== "" && C.push(T[0]), T[1] !== "" && _.push(T[1])
					}
				a.addLineGeometry(C, _)
			} else if (y === "p") {
				const C = v.slice(1).trim().split(" ");
				a.addPointGeometry(C)
			} else if ((c = _object_pattern.exec(v)) !== null) {
				const b = (" " + c[0].slice(1).trim()).slice(1);
				a.startObject(b)
			} else if (_material_use_pattern.test(v)) a.object.startMaterial(v.substring(7).trim(), a
				.materialLibraries);
			else if (_material_library_pattern.test(v)) a.materialLibraries.push(v.substring(7).trim());
			else if (_map_use_pattern.test(v)) console.warn(
				'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
				);
			else if (y === "s") {
				if (c = v.split(" "), c.length > 1) {
					const C = c[1].trim().toLowerCase();
					a.object.smooth = C !== "0" && C !== "off"
				} else a.object.smooth = !0;
				const b = a.object.currentMaterial();
				b && (b.smooth = a.object.smooth)
			} else {
				if (v === "\0") continue;
				console.warn('THREE.OBJLoader: Unexpected line: "' + v + '"')
			}
		}
		a.finalize();
		const d = new Group;
		if (d.materialLibraries = [].concat(a.materialLibraries), !(a.objects.length === 1 && a.objects[0].geometry
				.vertices.length === 0) === !0)
			for (let m = 0, g = a.objects.length; m < g; m++) {
				const v = a.objects[m],
					y = v.geometry,
					b = v.materials,
					C = y.type === "Line",
					_ = y.type === "Points";
				let S = !1;
				if (y.vertices.length === 0) continue;
				const w = new BufferGeometry;
				w.setAttribute("position", new Float32BufferAttribute(y.vertices, 3)), y.normals.length > 0 && w
					.setAttribute("normal", new Float32BufferAttribute(y.normals, 3)), y.colors.length > 0 && (S = !
						0, w.setAttribute("color", new Float32BufferAttribute(y.colors, 3))), y.hasUVIndices === !
					0 && w.setAttribute("uv", new Float32BufferAttribute(y.uvs, 2));
				const T = [];
				for (let k = 0, M = b.length; k < M; k++) {
					const D = b[k],
						F = D.name + "_" + D.smooth + "_" + S;
					let R = a.materials[F];
					if (this.materials !== null) {
						if (R = this.materials.create(D.name), C && R && !(R instanceof LineBasicMaterial)) {
							const O = new LineBasicMaterial;
							Material.prototype.copy.call(O, R), O.color.copy(R.color), R = O
						} else if (_ && R && !(R instanceof PointsMaterial)) {
							const O = new PointsMaterial({
								size: 10,
								sizeAttenuation: !1
							});
							Material.prototype.copy.call(O, R), O.color.copy(R.color), O.map = R.map, R = O
						}
					}
					R === void 0 && (C ? R = new LineBasicMaterial : _ ? R = new PointsMaterial({
							size: 1,
							sizeAttenuation: !1
						}) : R = new MeshPhongMaterial, R.name = D.name, R.flatShading = !D.smooth, R
						.vertexColors = S, a.materials[F] = R), T.push(R)
				}
				let A;
				if (T.length > 1) {
					for (let k = 0, M = b.length; k < M; k++) {
						const D = b[k];
						w.addGroup(D.groupStart, D.groupCount, k)
					}
					C ? A = new LineSegments(w, T) : _ ? A = new Points$1(w, T) : A = new Mesh(w, T)
				} else C ? A = new LineSegments(w, T[0]) : _ ? A = new Points$1(w, T[0]) : A = new Mesh(w, T[0]);
				A.name = v.name, d.add(A)
			} else if (a.vertices.length > 0) {
				const m = new PointsMaterial({
						size: 1,
						sizeAttenuation: !1
					}),
					g = new BufferGeometry;
				g.setAttribute("position", new Float32BufferAttribute(a.vertices, 3)), a.colors.length > 0 && a
					.colors[0] !== void 0 && (g.setAttribute("color", new Float32BufferAttribute(a.colors, 3)), m
						.vertexColors = !0);
				const v = new Points$1(g, m);
				d.add(v)
			} return d
	}
}
class STLLoader extends Loader {
	constructor(s) {
		super(s)
	}
	load(s, a, l, c) {
		const d = this,
			f = new FileLoader(this.manager);
		f.setPath(this.path), f.setResponseType("arraybuffer"), f.setRequestHeader(this.requestHeader), f
			.setWithCredentials(this.withCredentials), f.load(s, function(m) {
				try {
					a(d.parse(m))
				} catch (g) {
					c ? c(g) : console.error(g), d.manager.itemError(s)
				}
			}, l, c)
	}
	parse(s) {
		function a(v) {
			const y = new DataView(v),
				b = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8,
				C = y.getUint32(80, !0);
			if (80 + 32 / 8 + C * b === y.byteLength) return !0;
			const S = [115, 111, 108, 105, 100];
			for (let w = 0; w < 5; w++)
				if (l(S, y, w)) return !1;
			return !0
		}

		function l(v, y, b) {
			for (let C = 0, _ = v.length; C < _; C++)
				if (v[C] !== y.getUint8(b + C)) return !1;
			return !0
		}

		function c(v) {
			const y = new DataView(v),
				b = y.getUint32(80, !0);
			let C, _, S, w = !1,
				T, A, k, M, D;
			for (let j = 0; j < 70; j++) y.getUint32(j, !1) == 1129270351 && y.getUint8(j + 4) == 82 && y.getUint8(
				j + 5) == 61 && (w = !0, T = new Float32Array(b * 3 * 3), A = y.getUint8(j + 6) / 255, k = y
				.getUint8(j + 7) / 255, M = y.getUint8(j + 8) / 255, D = y.getUint8(j + 9) / 255);
			const F = 84,
				R = 12 * 4 + 2,
				O = new BufferGeometry,
				U = new Float32Array(b * 3 * 3),
				V = new Float32Array(b * 3 * 3),
				z = new Color;
			for (let j = 0; j < b; j++) {
				const ge = F + j * R,
					me = y.getFloat32(ge, !0),
					he = y.getFloat32(ge + 4, !0),
					ce = y.getFloat32(ge + 8, !0);
				if (w) {
					const ae = y.getUint16(ge + 48, !0);
					(ae & 32768) === 0 ? (C = (ae & 31) / 31, _ = (ae >> 5 & 31) / 31, S = (ae >> 10 & 31) / 31) : (
						C = A, _ = k, S = M)
				}
				for (let ae = 1; ae <= 3; ae++) {
					const fe = ge + ae * 12,
						q = j * 3 * 3 + (ae - 1) * 3;
					U[q] = y.getFloat32(fe, !0), U[q + 1] = y.getFloat32(fe + 4, !0), U[q + 2] = y.getFloat32(fe +
						8, !0), V[q] = me, V[q + 1] = he, V[q + 2] = ce, w && (z.setRGB(C, _, S,
						SRGBColorSpace), T[q] = z.r, T[q + 1] = z.g, T[q + 2] = z.b)
				}
			}
			return O.setAttribute("position", new BufferAttribute(U, 3)), O.setAttribute("normal",
				new BufferAttribute(V, 3)), w && (O.setAttribute("color", new BufferAttribute(T, 3)), O
				.hasColors = !0, O.alpha = D), O
		}

		function d(v) {
			const y = new BufferGeometry,
				b = /solid([\s\S]*?)endsolid/g,
				C = /facet([\s\S]*?)endfacet/g,
				_ = /solid\s(.+)/;
			let S = 0;
			const w = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,
				T = new RegExp("vertex" + w + w + w, "g"),
				A = new RegExp("normal" + w + w + w, "g"),
				k = [],
				M = [],
				D = [],
				F = new Vector3$1;
			let R, O = 0,
				U = 0,
				V = 0;
			for (;
				(R = b.exec(v)) !== null;) {
				U = V;
				const z = R[0],
					j = (R = _.exec(z)) !== null ? R[1] : "";
				for (D.push(j);
					(R = C.exec(z)) !== null;) {
					let he = 0,
						ce = 0;
					const ae = R[0];
					for (;
						(R = A.exec(ae)) !== null;) F.x = parseFloat(R[1]), F.y = parseFloat(R[2]), F.z =
						parseFloat(R[3]), ce++;
					for (;
						(R = T.exec(ae)) !== null;) k.push(parseFloat(R[1]), parseFloat(R[2]), parseFloat(R[3])), M
						.push(F.x, F.y, F.z), he++, V++;
					ce !== 1 && console.error(
							"THREE.STLLoader: Something isn't right with the normal of face number " + S), he !==
						3 && console.error(
							"THREE.STLLoader: Something isn't right with the vertices of face number " + S), S++
				}
				const ge = U,
					me = V - U;
				y.userData.groupNames = D, y.addGroup(ge, me, O), O++
			}
			return y.setAttribute("position", new Float32BufferAttribute(k, 3)), y.setAttribute("normal",
				new Float32BufferAttribute(M, 3)), y
		}

		function f(v) {
			return typeof v != "string" ? new TextDecoder().decode(v) : v
		}

		function m(v) {
			if (typeof v == "string") {
				const y = new Uint8Array(v.length);
				for (let b = 0; b < v.length; b++) y[b] = v.charCodeAt(b) & 255;
				return y.buffer || y
			} else return v
		}
		const g = m(s);
		return a(g) ? c(g) : d(f(s))
	}
}

function mergeGeometries(o, s = !1) {
	const a = o[0].index !== null,
		l = new Set(Object.keys(o[0].attributes)),
		c = new Set(Object.keys(o[0].morphAttributes)),
		d = {},
		f = {},
		m = o[0].morphTargetsRelative,
		g = new BufferGeometry;
	let v = 0;
	for (let y = 0; y < o.length; ++y) {
		const b = o[y];
		let C = 0;
		if (a !== (b.index !== null)) return console.error(
			"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + y +
			". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
			), null;
		for (const _ in b.attributes) {
			if (!l.has(_)) return console.error(
				"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + y +
				'. All geometries must have compatible attributes; make sure "' + _ +
				'" attribute exists among all geometries, or in none of them.'), null;
			d[_] === void 0 && (d[_] = []), d[_].push(b.attributes[_]), C++
		}
		if (C !== l.size) return console.error(
			"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + y +
			". Make sure all geometries have the same number of attributes."), null;
		if (m !== b.morphTargetsRelative) return console.error(
			"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + y +
			". .morphTargetsRelative must be consistent throughout all geometries."), null;
		for (const _ in b.morphAttributes) {
			if (!c.has(_)) return console.error(
				"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + y +
				".  .morphAttributes must be consistent throughout all geometries."), null;
			f[_] === void 0 && (f[_] = []), f[_].push(b.morphAttributes[_])
		}
		if (s) {
			let _;
			if (a) _ = b.index.count;
			else if (b.attributes.position !== void 0) _ = b.attributes.position.count;
			else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
				y + ". The geometry must have either an index or a position attribute"), null;
			g.addGroup(v, _, y), v += _
		}
	}
	if (a) {
		let y = 0;
		const b = [];
		for (let C = 0; C < o.length; ++C) {
			const _ = o[C].index;
			for (let S = 0; S < _.count; ++S) b.push(_.getX(S) + y);
			y += o[C].attributes.position.count
		}
		g.setIndex(b)
	}
	for (const y in d) {
		const b = mergeAttributes(d[y]);
		if (!b) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " +
			y + " attribute."), null;
		g.setAttribute(y, b)
	}
	for (const y in f) {
		const b = f[y][0].length;
		if (b === 0) break;
		g.morphAttributes = g.morphAttributes || {}, g.morphAttributes[y] = [];
		for (let C = 0; C < b; ++C) {
			const _ = [];
			for (let w = 0; w < f[y].length; ++w) _.push(f[y][w][C]);
			const S = mergeAttributes(_);
			if (!S) return console.error(
				"THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + y +
				" morphAttribute."), null;
			g.morphAttributes[y].push(S)
		}
	}
	return g
}

function mergeAttributes(o) {
	let s, a, l, c = -1,
		d = 0;
	for (let v = 0; v < o.length; ++v) {
		const y = o[v];
		if (s === void 0 && (s = y.array.constructor), s !== y.array.constructor) return console.error(
			"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
			), null;
		if (a === void 0 && (a = y.itemSize), a !== y.itemSize) return console.error(
			"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
			), null;
		if (l === void 0 && (l = y.normalized), l !== y.normalized) return console.error(
			"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
			), null;
		if (c === -1 && (c = y.gpuType), c !== y.gpuType) return console.error(
			"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."
			), null;
		d += y.count * a
	}
	const f = new s(d),
		m = new BufferAttribute(f, a, l);
	let g = 0;
	for (let v = 0; v < o.length; ++v) {
		const y = o[v];
		if (y.isInterleavedBufferAttribute) {
			const b = g / a;
			for (let C = 0, _ = y.count; C < _; C++)
				for (let S = 0; S < a; S++) {
					const w = y.getComponent(C, S);
					m.setComponent(C + b, S, w)
				}
		} else f.set(y.array, g);
		g += y.count * a
	}
	return c !== void 0 && (m.gpuType = c), m
}
var stats_min$1 = {
		exports: {}
	},
	stats_min = stats_min$1.exports,
	hasRequiredStats_min;

function requireStats_min() {
	return hasRequiredStats_min || (hasRequiredStats_min = 1, function(o, s) {
		(function(a, l) {
			o.exports = l()
		})(stats_min, function() {
			var a = function() {
				function l(_) {
					return f.appendChild(_.dom), _
				}

				function c(_) {
					for (var S = 0; S < f.children.length; S++) f.children[S].style.display = S === _ ?
						"block" : "none";
					d = _
				}
				var d = 0,
					f = document.createElement("div");
				f.style.cssText =
					"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", f
					.addEventListener("click", function(_) {
						_.preventDefault(), c(++d % f.children.length)
					}, !1);
				var m = (performance || Date).now(),
					g = m,
					v = 0,
					y = l(new a.Panel("FPS", "#0ff", "#002")),
					b = l(new a.Panel("MS", "#0f0", "#020"));
				if (self.performance && self.performance.memory) var C = l(new a.Panel("MB", "#f08",
					"#201"));
				return c(0), {
					REVISION: 16,
					dom: f,
					addPanel: l,
					showPanel: c,
					begin: function() {
						m = (performance || Date).now()
					},
					end: function() {
						v++;
						var _ = (performance || Date).now();
						if (b.update(_ - m, 200), _ > g + 1e3 && (y.update(1e3 * v / (_ - g),
								100), g = _, v = 0, C)) {
							var S = performance.memory;
							C.update(S.usedJSHeapSize / 1048576, S.jsHeapSizeLimit / 1048576)
						}
						return _
					},
					update: function() {
						m = this.end()
					},
					domElement: f,
					setMode: c
				}
			};
			return a.Panel = function(l, c, d) {
				var f = 1 / 0,
					m = 0,
					g = Math.round,
					v = g(window.devicePixelRatio || 1),
					y = 80 * v,
					b = 48 * v,
					C = 3 * v,
					_ = 2 * v,
					S = 3 * v,
					w = 15 * v,
					T = 74 * v,
					A = 30 * v,
					k = document.createElement("canvas");
				k.width = y, k.height = b, k.style.cssText = "width:80px;height:48px";
				var M = k.getContext("2d");
				return M.font = "bold " + 9 * v + "px Helvetica,Arial,sans-serif", M.textBaseline =
					"top", M.fillStyle = d, M.fillRect(0, 0, y, b), M.fillStyle = c, M.fillText(l, C,
					_), M.fillRect(S, w, T, A), M.fillStyle = d, M.globalAlpha = .9, M.fillRect(S, w, T,
						A), {
						dom: k,
						update: function(D, F) {
							f = Math.min(f, D), m = Math.max(m, D), M.fillStyle = d, M.globalAlpha =
								1, M.fillRect(0, 0, y, w), M.fillStyle = c, M.fillText(g(D) + " " +
									l + " (" + g(f) + "-" + g(m) + ")", C, _), M.drawImage(k, S + v,
									w, T - v, A, S, w, T - v, A), M.fillRect(S + T - v, w, v, A), M
								.fillStyle = d, M.globalAlpha = .9, M.fillRect(S + T - v, w, v, g((
									1 - D / F) * A))
						}
					}
			}, a
		})
	}(stats_min$1)), stats_min$1.exports
}
var stats_minExports = requireStats_min();
const Stats = getDefaultExportFromCjs(stats_minExports);
var eventemitter3 = {
		exports: {}
	},
	hasRequiredEventemitter3;

function requireEventemitter3() {
	return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function(o) {
		var s = Object.prototype.hasOwnProperty,
			a = "~";

		function l() {}
		Object.create && (l.prototype = Object.create(null), new l().__proto__ || (a = !1));

		function c(g, v, y) {
			this.fn = g, this.context = v, this.once = y || !1
		}

		function d(g, v, y, b, C) {
			if (typeof y != "function") throw new TypeError("The listener must be a function");
			var _ = new c(y, b || g, C),
				S = a ? a + v : v;
			return g._events[S] ? g._events[S].fn ? g._events[S] = [g._events[S], _] : g._events[S].push(_) : (g
				._events[S] = _, g._eventsCount++), g
		}

		function f(g, v) {
			--g._eventsCount === 0 ? g._events = new l : delete g._events[v]
		}

		function m() {
			this._events = new l, this._eventsCount = 0
		}
		m.prototype.eventNames = function() {
				var v = [],
					y, b;
				if (this._eventsCount === 0) return v;
				for (b in y = this._events) s.call(y, b) && v.push(a ? b.slice(1) : b);
				return Object.getOwnPropertySymbols ? v.concat(Object.getOwnPropertySymbols(y)) : v
			}, m.prototype.listeners = function(v) {
				var y = a ? a + v : v,
					b = this._events[y];
				if (!b) return [];
				if (b.fn) return [b.fn];
				for (var C = 0, _ = b.length, S = new Array(_); C < _; C++) S[C] = b[C].fn;
				return S
			}, m.prototype.listenerCount = function(v) {
				var y = a ? a + v : v,
					b = this._events[y];
				return b ? b.fn ? 1 : b.length : 0
			}, m.prototype.emit = function(v, y, b, C, _, S) {
				var w = a ? a + v : v;
				if (!this._events[w]) return !1;
				var T = this._events[w],
					A = arguments.length,
					k, M;
				if (T.fn) {
					switch (T.once && this.removeListener(v, T.fn, void 0, !0), A) {
						case 1:
							return T.fn.call(T.context), !0;
						case 2:
							return T.fn.call(T.context, y), !0;
						case 3:
							return T.fn.call(T.context, y, b), !0;
						case 4:
							return T.fn.call(T.context, y, b, C), !0;
						case 5:
							return T.fn.call(T.context, y, b, C, _), !0;
						case 6:
							return T.fn.call(T.context, y, b, C, _, S), !0
					}
					for (M = 1, k = new Array(A - 1); M < A; M++) k[M - 1] = arguments[M];
					T.fn.apply(T.context, k)
				} else {
					var D = T.length,
						F;
					for (M = 0; M < D; M++) switch (T[M].once && this.removeListener(v, T[M].fn, void 0, !0),
						A) {
						case 1:
							T[M].fn.call(T[M].context);
							break;
						case 2:
							T[M].fn.call(T[M].context, y);
							break;
						case 3:
							T[M].fn.call(T[M].context, y, b);
							break;
						case 4:
							T[M].fn.call(T[M].context, y, b, C);
							break;
						default:
							if (!k)
								for (F = 1, k = new Array(A - 1); F < A; F++) k[F - 1] = arguments[F];
							T[M].fn.apply(T[M].context, k)
					}
				}
				return !0
			}, m.prototype.on = function(v, y, b) {
				return d(this, v, y, b, !1)
			}, m.prototype.once = function(v, y, b) {
				return d(this, v, y, b, !0)
			}, m.prototype.removeListener = function(v, y, b, C) {
				var _ = a ? a + v : v;
				if (!this._events[_]) return this;
				if (!y) return f(this, _), this;
				var S = this._events[_];
				if (S.fn) S.fn === y && (!C || S.once) && (!b || S.context === b) && f(this, _);
				else {
					for (var w = 0, T = [], A = S.length; w < A; w++)(S[w].fn !== y || C && !S[w].once || b &&
						S[w].context !== b) && T.push(S[w]);
					T.length ? this._events[_] = T.length === 1 ? T[0] : T : f(this, _)
				}
				return this
			}, m.prototype.removeAllListeners = function(v) {
				var y;
				return v ? (y = a ? a + v : v, this._events[y] && f(this, y)) : (this._events = new l, this
					._eventsCount = 0), this
			}, m.prototype.off = m.prototype.removeListener, m.prototype.addListener = m.prototype.on, m
			.prefixed = a, m.EventEmitter = m, o.exports = m
	}(eventemitter3)), eventemitter3.exports
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter = getDefaultExportFromCjs(eventemitter3Exports);
var BinaryOpcode;
(function(o) {
	o[o.MESSAGE_DATA = 1] = "MESSAGE_DATA", o[o.TIME = 2] = "TIME", o[o.SERVICE_CALL_RESPONSE = 3] =
		"SERVICE_CALL_RESPONSE", o[o.FETCH_ASSET_RESPONSE = 4] = "FETCH_ASSET_RESPONSE"
})(BinaryOpcode || (BinaryOpcode = {}));
var ClientBinaryOpcode;
(function(o) {
	o[o.MESSAGE_DATA = 1] = "MESSAGE_DATA", o[o.SERVICE_CALL_REQUEST = 2] = "SERVICE_CALL_REQUEST"
})(ClientBinaryOpcode || (ClientBinaryOpcode = {}));
var StatusLevel;
(function(o) {
	o[o.INFO = 0] = "INFO", o[o.WARNING = 1] = "WARNING", o[o.ERROR = 2] = "ERROR"
})(StatusLevel || (StatusLevel = {}));
var ServerCapability;
(function(o) {
	o.clientPublish = "clientPublish", o.time = "time", o.parameters = "parameters", o.parametersSubscribe =
		"parametersSubscribe", o.services = "services", o.connectionGraph = "connectionGraph", o.assets = "assets"
})(ServerCapability || (ServerCapability = {}));
var FetchAssetStatus;
(function(o) {
	o[o.SUCCESS = 0] = "SUCCESS", o[o.ERROR = 1] = "ERROR"
})(FetchAssetStatus || (FetchAssetStatus = {}));
const textDecoder = new TextDecoder;

function parseServerMessage(o) {
	const s = o instanceof ArrayBuffer ? new DataView(o) : o instanceof DataView ? o : new DataView(o.buffer, o
		.byteOffset, o.byteLength);
	let a = 0;
	const l = s.getUint8(a);
	switch (a += 1, l) {
		case BinaryOpcode.MESSAGE_DATA: {
			const c = s.getUint32(a, !0);
			a += 4;
			const d = s.getBigUint64(a, !0);
			a += 8;
			const f = new DataView(s.buffer, s.byteOffset + a, s.byteLength - a);
			return {
				op: l,
				subscriptionId: c,
				timestamp: d,
				data: f
			}
		}
		case BinaryOpcode.TIME: {
			const c = s.getBigUint64(a, !0);
			return {
				op: l,
				timestamp: c
			}
		}
		case BinaryOpcode.SERVICE_CALL_RESPONSE: {
			const c = s.getUint32(a, !0);
			a += 4;
			const d = s.getUint32(a, !0);
			a += 4;
			const f = s.getUint32(a, !0);
			a += 4;
			const m = new DataView(s.buffer, s.byteOffset + a, f),
				g = textDecoder.decode(m);
			a += f;
			const v = new Uint8Array(s.buffer, s.byteOffset + a, s.byteLength - a);
			return {
				op: l,
				serviceId: c,
				callId: d,
				encoding: g,
				data: v
			}
		}
		case BinaryOpcode.FETCH_ASSET_RESPONSE: {
			const c = s.getUint32(a, !0);
			a += 4;
			const d = s.getUint8(a);
			a += 1;
			const f = s.getUint32(a, !0);
			a += 4;
			const m = textDecoder.decode(new DataView(s.buffer, s.byteOffset + a, f));
			switch (a += f, d) {
				case FetchAssetStatus.SUCCESS: {
					const g = new DataView(s.buffer, s.byteOffset + a, s.byteLength - a);
					return {
						op: l,
						requestId: c,
						status: d,
						data: g
					}
				}
				case FetchAssetStatus.ERROR:
					return {
						op: l, requestId: c, status: d, error: m
					};
				default:
					throw new Error(`Unrecognized fetch asset status: ${d}`)
			}
		}
	}
	throw new Error(`Unrecognized server opcode in binary message: ${l.toString(16)}`)
}
const textEncoder = new TextEncoder;
var Dn, Wn, sr, ar, Hn, yr, Yn;
class FoxgloveClient {
	constructor({
		ws: s
	}) {
		rr(this, Hn);
		rr(this, Dn, new EventEmitter);
		rr(this, Wn);
		rr(this, sr, 0);
		rr(this, ar, 0);
		pr(this, Wn, s), Gn(this, Hn, yr).call(this)
	}
	on(s, a) {
		vn(this, Dn).on(s, a)
	}
	off(s, a) {
		vn(this, Dn).off(s, a)
	}
	close() {
		vn(this, Wn).close()
	}
	subscribe(s) {
		const a = hr(this, sr)._++,
			l = [{
				id: a,
				channelId: s
			}];
		return Gn(this, Hn, Yn).call(this, {
			op: "subscribe",
			subscriptions: l
		}), a
	}
	unsubscribe(s) {
		Gn(this, Hn, Yn).call(this, {
			op: "unsubscribe",
			subscriptionIds: [s]
		})
	}
	advertise(s) {
		const a = ++hr(this, ar)._,
			l = [{
				id: a,
				...s
			}];
		return Gn(this, Hn, Yn).call(this, {
			op: "advertise",
			channels: l
		}), a
	}
	unadvertise(s) {
		Gn(this, Hn, Yn).call(this, {
			op: "unadvertise",
			channelIds: [s]
		})
	}
	getParameters(s, a) {
		Gn(this, Hn, Yn).call(this, {
			op: "getParameters",
			parameterNames: s,
			id: a
		})
	}
	setParameters(s, a) {
		Gn(this, Hn, Yn).call(this, {
			op: "setParameters",
			parameters: s,
			id: a
		})
	}
	subscribeParameterUpdates(s) {
		Gn(this, Hn, Yn).call(this, {
			op: "subscribeParameterUpdates",
			parameterNames: s
		})
	}
	unsubscribeParameterUpdates(s) {
		Gn(this, Hn, Yn).call(this, {
			op: "unsubscribeParameterUpdates",
			parameterNames: s
		})
	}
	sendMessage(s, a) {
		const l = new Uint8Array(5 + a.byteLength),
			c = new DataView(l.buffer, l.byteOffset, l.byteLength);
		c.setUint8(0, ClientBinaryOpcode.MESSAGE_DATA), c.setUint32(1, s, !0), l.set(a, 5), vn(this, Wn).send(l)
	}
	sendServiceCallRequest(s) {
		const a = textEncoder.encode(s.encoding),
			l = new Uint8Array(13 + a.length + s.data.byteLength),
			c = new DataView(l.buffer, l.byteOffset, l.byteLength);
		let d = 0;
		c.setUint8(d, ClientBinaryOpcode.SERVICE_CALL_REQUEST), d += 1, c.setUint32(d, s.serviceId, !0), d += 4, c
			.setUint32(d, s.callId, !0), d += 4, c.setUint32(d, s.encoding.length, !0), d += 4, l.set(a, d), d += a
			.length;
		const f = new Uint8Array(s.data.buffer, s.data.byteOffset, s.data.byteLength);
		l.set(f, d), vn(this, Wn).send(l)
	}
	subscribeConnectionGraph() {
		Gn(this, Hn, Yn).call(this, {
			op: "subscribeConnectionGraph"
		})
	}
	unsubscribeConnectionGraph() {
		Gn(this, Hn, Yn).call(this, {
			op: "unsubscribeConnectionGraph"
		})
	}
	fetchAsset(s, a) {
		Gn(this, Hn, Yn).call(this, {
			op: "fetchAsset",
			uri: s,
			requestId: a
		})
	}
	sendCallServiceRequest(s) {
		this.sendServiceCallRequest(s)
	}
}
Dn = new WeakMap, Wn = new WeakMap, sr = new WeakMap, ar = new WeakMap, Hn = new WeakSet, yr = function() {
	vn(this, Wn).binaryType = "arraybuffer", vn(this, Wn).onerror = s => {
		vn(this, Dn).emit("error", s.error ?? new Error("WebSocket error"))
	}, vn(this, Wn).onopen = s => {
		vn(this, Dn).emit("open")
	}, vn(this, Wn).onmessage = s => {
		let a;
		try {
			s.data instanceof ArrayBuffer || ArrayBuffer.isView(s.data) ? a = parseServerMessage(s.data) : a =
				JSON.parse(s.data)
		} catch (l) {
			vn(this, Dn).emit("error", l);
			return
		}
		switch (a.op) {
			case "serverInfo":
				vn(this, Dn).emit("serverInfo", a);
				return;
			case "status":
				vn(this, Dn).emit("status", a);
				return;
			case "removeStatus":
				vn(this, Dn).emit("removeStatus", a);
				return;
			case "advertise":
				vn(this, Dn).emit("advertise", a.channels);
				return;
			case "unadvertise":
				vn(this, Dn).emit("unadvertise", a.channelIds);
				return;
			case "parameterValues":
				vn(this, Dn).emit("parameterValues", a);
				return;
			case "advertiseServices":
				vn(this, Dn).emit("advertiseServices", a.services);
				return;
			case "unadvertiseServices":
				vn(this, Dn).emit("unadvertiseServices", a.serviceIds);
				return;
			case "connectionGraphUpdate":
				vn(this, Dn).emit("connectionGraphUpdate", a);
				return;
			case "serviceCallFailure":
				vn(this, Dn).emit("serviceCallFailure", a);
				return;
			case BinaryOpcode.MESSAGE_DATA:
				vn(this, Dn).emit("message", a);
				return;
			case BinaryOpcode.TIME:
				vn(this, Dn).emit("time", a);
				return;
			case BinaryOpcode.SERVICE_CALL_RESPONSE:
				vn(this, Dn).emit("serviceCallResponse", a);
				return;
			case BinaryOpcode.FETCH_ASSET_RESPONSE:
				vn(this, Dn).emit("fetchAssetResponse", a);
				return
		}
		vn(this, Dn).emit("error", new Error(`Unrecognized server opcode: ${a.op}`))
	}, vn(this, Wn).onclose = s => {
		vn(this, Dn).emit("close", s)
	}
}, Yn = function(s) {
	vn(this, Wn).send(JSON.stringify(s))
}, gr(FoxgloveClient, "SUPPORTED_SUBPROTOCOL", "foxglove.websocket.v1");
var browser = {
		exports: {}
	},
	ms, hasRequiredMs;

function requireMs() {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var o = 1e3,
		s = o * 60,
		a = s * 60,
		l = a * 24,
		c = l * 7,
		d = l * 365.25;
	ms = function(y, b) {
		b = b || {};
		var C = typeof y;
		if (C === "string" && y.length > 0) return f(y);
		if (C === "number" && isFinite(y)) return b.long ? g(y) : m(y);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(y))
	};

	function f(y) {
		if (y = String(y), !(y.length > 100)) {
			var b =
				/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i
				.exec(y);
			if (b) {
				var C = parseFloat(b[1]),
					_ = (b[2] || "ms").toLowerCase();
				switch (_) {
					case "years":
					case "year":
					case "yrs":
					case "yr":
					case "y":
						return C * d;
					case "weeks":
					case "week":
					case "w":
						return C * c;
					case "days":
					case "day":
					case "d":
						return C * l;
					case "hours":
					case "hour":
					case "hrs":
					case "hr":
					case "h":
						return C * a;
					case "minutes":
					case "minute":
					case "mins":
					case "min":
					case "m":
						return C * s;
					case "seconds":
					case "second":
					case "secs":
					case "sec":
					case "s":
						return C * o;
					case "milliseconds":
					case "millisecond":
					case "msecs":
					case "msec":
					case "ms":
						return C;
					default:
						return
				}
			}
		}
	}

	function m(y) {
		var b = Math.abs(y);
		return b >= l ? Math.round(y / l) + "d" : b >= a ? Math.round(y / a) + "h" : b >= s ? Math.round(y / s) + "m" :
			b >= o ? Math.round(y / o) + "s" : y + "ms"
	}

	function g(y) {
		var b = Math.abs(y);
		return b >= l ? v(y, b, l, "day") : b >= a ? v(y, b, a, "hour") : b >= s ? v(y, b, s, "minute") : b >= o ? v(y,
			b, o, "second") : y + " ms"
	}

	function v(y, b, C, _) {
		var S = b >= C * 1.5;
		return Math.round(y / C) + " " + _ + (S ? "s" : "")
	}
	return ms
}
var common, hasRequiredCommon$2;

function requireCommon$2() {
	if (hasRequiredCommon$2) return common;
	hasRequiredCommon$2 = 1;

	function o(s) {
		l.debug = l, l.default = l, l.coerce = v, l.disable = m, l.enable = d, l.enabled = g, l.humanize = requireMs(),
			l.destroy = y, Object.keys(s).forEach(b => {
				l[b] = s[b]
			}), l.names = [], l.skips = [], l.formatters = {};

		function a(b) {
			let C = 0;
			for (let _ = 0; _ < b.length; _++) C = (C << 5) - C + b.charCodeAt(_), C |= 0;
			return l.colors[Math.abs(C) % l.colors.length]
		}
		l.selectColor = a;

		function l(b) {
			let C, _ = null,
				S, w;

			function T(...A) {
				if (!T.enabled) return;
				const k = T,
					M = Number(new Date),
					D = M - (C || M);
				k.diff = D, k.prev = C, k.curr = M, C = M, A[0] = l.coerce(A[0]), typeof A[0] != "string" && A.unshift(
					"%O");
				let F = 0;
				A[0] = A[0].replace(/%([a-zA-Z%])/g, (O, U) => {
					if (O === "%%") return "%";
					F++;
					const V = l.formatters[U];
					if (typeof V == "function") {
						const z = A[F];
						O = V.call(k, z), A.splice(F, 1), F--
					}
					return O
				}), l.formatArgs.call(k, A), (k.log || l.log).apply(k, A)
			}
			return T.namespace = b, T.useColors = l.useColors(), T.color = l.selectColor(b), T.extend = c, T.destroy = l
				.destroy, Object.defineProperty(T, "enabled", {
					enumerable: !0,
					configurable: !1,
					get: () => _ !== null ? _ : (S !== l.namespaces && (S = l.namespaces, w = l.enabled(b)), w),
					set: A => {
						_ = A
					}
				}), typeof l.init == "function" && l.init(T), T
		}

		function c(b, C) {
			const _ = l(this.namespace + (typeof C > "u" ? ":" : C) + b);
			return _.log = this.log, _
		}

		function d(b) {
			l.save(b), l.namespaces = b, l.names = [], l.skips = [];
			const C = (typeof b == "string" ? b : "").trim().replace(" ", ",").split(",").filter(Boolean);
			for (const _ of C) _[0] === "-" ? l.skips.push(_.slice(1)) : l.names.push(_)
		}

		function f(b, C) {
			let _ = 0,
				S = 0,
				w = -1,
				T = 0;
			for (; _ < b.length;)
				if (S < C.length && (C[S] === b[_] || C[S] === "*")) C[S] === "*" ? (w = S, T = _, S++) : (_++, S++);
				else if (w !== -1) S = w + 1, T++, _ = T;
			else return !1;
			for (; S < C.length && C[S] === "*";) S++;
			return S === C.length
		}

		function m() {
			const b = [...l.names, ...l.skips.map(C => "-" + C)].join(",");
			return l.enable(""), b
		}

		function g(b) {
			for (const C of l.skips)
				if (f(b, C)) return !1;
			for (const C of l.names)
				if (f(b, C)) return !0;
			return !1
		}

		function v(b) {
			return b instanceof Error ? b.stack || b.message : b
		}

		function y() {
			console.warn(
				"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
				)
		}
		return l.enable(l.load()), l
	}
	return common = o, common
}
var hasRequiredBrowser;

function requireBrowser() {
	return hasRequiredBrowser || (hasRequiredBrowser = 1, function(o, s) {
		var a = {};
		s.formatArgs = c, s.save = d, s.load = f, s.useColors = l, s.storage = m(), s.destroy = (() => {
			let v = !1;
			return () => {
				v || (v = !0, console.warn(
					"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
					))
			}
		})(), s.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC",
			"#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC",
			"#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00",
			"#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC",
			"#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00",
			"#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300",
			"#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900",
			"#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC",
			"#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600",
			"#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"
		];

		function l() {
			if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process
					.__nwjs)) return !0;
			if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(
					/(edge|trident)\/(\d+)/)) return !1;
			let v;
			return typeof document < "u" && document.documentElement && document.documentElement.style &&
				document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (
					window.console.firebug || window.console.exception && window.console.table) ||
				typeof navigator < "u" && navigator.userAgent && (v = navigator.userAgent.toLowerCase().match(
					/firefox\/(\d+)/)) && parseInt(v[1], 10) >= 31 || typeof navigator < "u" && navigator
				.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
		}

		function c(v) {
			if (v[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + v[0] + (
					this.useColors ? "%c " : " ") + "+" + o.exports.humanize(this.diff), !this.useColors)
		return;
			const y = "color: " + this.color;
			v.splice(1, 0, y, "color: inherit");
			let b = 0,
				C = 0;
			v[0].replace(/%[a-zA-Z%]/g, _ => {
				_ !== "%%" && (b++, _ === "%c" && (C = b))
			}), v.splice(C, 0, y)
		}
		s.log = console.debug || console.log || (() => {});

		function d(v) {
			try {
				v ? s.storage.setItem("debug", v) : s.storage.removeItem("debug")
			} catch {}
		}

		function f() {
			let v;
			try {
				v = s.storage.getItem("debug")
			} catch {}
			return !v && typeof process < "u" && "env" in process && (v = a.DEBUG), v
		}

		function m() {
			try {
				return localStorage
			} catch {}
		}
		o.exports = requireCommon$2()(s);
		const {
			formatters: g
		} = o.exports;
		g.j = function(v) {
			try {
				return JSON.stringify(v)
			} catch (y) {
				return "[UnexpectedJSONParseError]: " + y.message
			}
		}
	}(browser, browser.exports)), browser.exports
}
var browserExports = requireBrowser();
const createDebug = getDefaultExportFromCjs(browserExports);
createDebug("foxglove:server");
new TextEncoder;
ServerCapability.clientPublish, ServerCapability.clientPublish, ClientBinaryOpcode.MESSAGE_DATA + "", ServerCapability
	.clientPublish, ServerCapability.parameters, ServerCapability.parameters, ServerCapability.parametersSubscribe,
	ServerCapability.parametersSubscribe, ClientBinaryOpcode.SERVICE_CALL_REQUEST + "", ServerCapability.services,
	ServerCapability.connectionGraph, ServerCapability.connectionGraph, ServerCapability.assets;

function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(o) {
		for (var s = 1; s < arguments.length; s++) {
			var a = arguments[s];
			for (var l in a)({}).hasOwnProperty.call(a, l) && (o[l] = a[l])
		}
		return o
	}, _extends.apply(null, arguments)
}
var DEFAULT_CONFIG = {
	relTol: 1e-12,
	absTol: 1e-15,
	matrix: "Matrix",
	number: "number",
	numberFallback: "number",
	precision: 64,
	predictable: !1,
	randomSeed: null
};

function getSafeProperty(o, s) {
	if (isSafeProperty(o, s)) return o[s];
	throw typeof o[s] == "function" && isSafeMethod(o, s) ? new Error('Cannot access method "' + s +
		'" as a property') : new Error('No access to property "' + s + '"')
}

function setSafeProperty(o, s, a) {
	if (isSafeProperty(o, s)) return o[s] = a, a;
	throw new Error('No access to property "' + s + '"')
}

function isSafeProperty(o, s) {
	return !isPlainObject(o) && !Array.isArray(o) ? !1 : hasOwnProperty(safeNativeProperties, s) ? !0 : !(s in Object
		.prototype || s in Function.prototype)
}

function isSafeMethod(o, s) {
	return o == null || typeof o[s] != "function" || hasOwnProperty(o, s) && Object.getPrototypeOf && s in Object
		.getPrototypeOf(o) ? !1 : hasOwnProperty(safeNativeMethods, s) ? !0 : !(s in Object.prototype || s in Function
			.prototype)
}

function isPlainObject(o) {
	return typeof o == "object" && o && o.constructor === Object
}
var safeNativeProperties = {
		length: !0,
		name: !0
	},
	safeNativeMethods = {
		toString: !0,
		valueOf: !0,
		toLocaleString: !0
	};
class ObjectWrappingMap {
	constructor(s) {
		this.wrappedObject = s, this[Symbol.iterator] = this.entries
	}
	keys() {
		return Object.keys(this.wrappedObject).filter(s => this.has(s)).values()
	}
	get(s) {
		return getSafeProperty(this.wrappedObject, s)
	}
	set(s, a) {
		return setSafeProperty(this.wrappedObject, s, a), this
	}
	has(s) {
		return isSafeProperty(this.wrappedObject, s) && s in this.wrappedObject
	}
	entries() {
		return mapIterator(this.keys(), s => [s, this.get(s)])
	}
	forEach(s) {
		for (var a of this.keys()) s(this.get(a), a, this)
	}
	delete(s) {
		isSafeProperty(this.wrappedObject, s) && delete this.wrappedObject[s]
	}
	clear() {
		for (var s of this.keys()) this.delete(s)
	}
	get size() {
		return Object.keys(this.wrappedObject).length
	}
}

function mapIterator(o, s) {
	return {
		next: () => {
			var a = o.next();
			return a.done ? a : {
				value: s(a.value),
				done: !1
			}
		}
	}
}

function isNumber(o) {
	return typeof o == "number"
}

function isBigNumber(o) {
	return !o || typeof o != "object" || typeof o.constructor != "function" ? !1 : o.isBigNumber === !0 && typeof o
		.constructor.prototype == "object" && o.constructor.prototype.isBigNumber === !0 || typeof o.constructor
		.isDecimal == "function" && o.constructor.isDecimal(o) === !0
}

function isBigInt(o) {
	return typeof o == "bigint"
}

function isComplex(o) {
	return o && typeof o == "object" && Object.getPrototypeOf(o).isComplex === !0 || !1
}

function isFraction(o) {
	return o && typeof o == "object" && Object.getPrototypeOf(o).isFraction === !0 || !1
}

function isUnit(o) {
	return o && o.constructor.prototype.isUnit === !0 || !1
}

function isString(o) {
	return typeof o == "string"
}
var isArray = Array.isArray;

function isMatrix(o) {
	return o && o.constructor.prototype.isMatrix === !0 || !1
}

function isCollection(o) {
	return Array.isArray(o) || isMatrix(o)
}

function isDenseMatrix(o) {
	return o && o.isDenseMatrix && o.constructor.prototype.isMatrix === !0 || !1
}

function isSparseMatrix(o) {
	return o && o.isSparseMatrix && o.constructor.prototype.isMatrix === !0 || !1
}

function isRange(o) {
	return o && o.constructor.prototype.isRange === !0 || !1
}

function isIndex(o) {
	return o && o.constructor.prototype.isIndex === !0 || !1
}

function isBoolean(o) {
	return typeof o == "boolean"
}

function isResultSet(o) {
	return o && o.constructor.prototype.isResultSet === !0 || !1
}

function isHelp(o) {
	return o && o.constructor.prototype.isHelp === !0 || !1
}

function isFunction(o) {
	return typeof o == "function"
}

function isDate(o) {
	return o instanceof Date
}

function isRegExp(o) {
	return o instanceof RegExp
}

function isObject(o) {
	return !!(o && typeof o == "object" && o.constructor === Object && !isComplex(o) && !isFraction(o))
}

function isMap(o) {
	return o ? o instanceof Map || o instanceof ObjectWrappingMap || typeof o.set == "function" && typeof o.get ==
		"function" && typeof o.keys == "function" && typeof o.has == "function" : !1
}

function isNull(o) {
	return o === null
}

function isUndefined(o) {
	return o === void 0
}

function isAccessorNode(o) {
	return o && o.isAccessorNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isArrayNode(o) {
	return o && o.isArrayNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isAssignmentNode(o) {
	return o && o.isAssignmentNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isBlockNode(o) {
	return o && o.isBlockNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isConditionalNode(o) {
	return o && o.isConditionalNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isConstantNode(o) {
	return o && o.isConstantNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isFunctionAssignmentNode(o) {
	return o && o.isFunctionAssignmentNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isFunctionNode(o) {
	return o && o.isFunctionNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isIndexNode(o) {
	return o && o.isIndexNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isNode(o) {
	return o && o.isNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isObjectNode(o) {
	return o && o.isObjectNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isOperatorNode(o) {
	return o && o.isOperatorNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isParenthesisNode(o) {
	return o && o.isParenthesisNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isRangeNode(o) {
	return o && o.isRangeNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isRelationalNode(o) {
	return o && o.isRelationalNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isSymbolNode(o) {
	return o && o.isSymbolNode === !0 && o.constructor.prototype.isNode === !0 || !1
}

function isChain(o) {
	return o && o.constructor.prototype.isChain === !0 || !1
}

function typeOf(o) {
	var s = typeof o;
	return s === "object" ? o === null ? "null" : isBigNumber(o) ? "BigNumber" : o.constructor && o.constructor.name ? o
		.constructor.name : "Object" : s
}

function clone$2(o) {
	var s = typeof o;
	if (s === "number" || s === "bigint" || s === "string" || s === "boolean" || o === null || o === void 0) return o;
	if (typeof o.clone == "function") return o.clone();
	if (Array.isArray(o)) return o.map(function(a) {
		return clone$2(a)
	});
	if (o instanceof Date) return new Date(o.valueOf());
	if (isBigNumber(o)) return o;
	if (isObject(o)) return mapObject(o, clone$2);
	if (s === "function") return o;
	throw new TypeError("Cannot clone: unknown type of value (value: ".concat(o, ")"))
}

function mapObject(o, s) {
	var a = {};
	for (var l in o) hasOwnProperty(o, l) && (a[l] = s(o[l]));
	return a
}

function deepStrictEqual(o, s) {
	var a, l, c;
	if (Array.isArray(o)) {
		if (!Array.isArray(s) || o.length !== s.length) return !1;
		for (l = 0, c = o.length; l < c; l++)
			if (!deepStrictEqual(o[l], s[l])) return !1;
		return !0
	} else {
		if (typeof o == "function") return o === s;
		if (o instanceof Object) {
			if (Array.isArray(s) || !(s instanceof Object)) return !1;
			for (a in o)
				if (!(a in s) || !deepStrictEqual(o[a], s[a])) return !1;
			for (a in s)
				if (!(a in o)) return !1;
			return !0
		} else return o === s
	}
}

function hasOwnProperty(o, s) {
	return o && Object.hasOwnProperty.call(o, s)
}

function pickShallow(o, s) {
	for (var a = {}, l = 0; l < s.length; l++) {
		var c = s[l],
			d = o[c];
		d !== void 0 && (a[c] = d)
	}
	return a
}
var MATRIX_OPTIONS = ["Matrix", "Array"],
	NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"],
	config$1 = function(s) {
		if (s) throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);
		return Object.freeze(DEFAULT_CONFIG)
	};
_extends(config$1, DEFAULT_CONFIG, {
	MATRIX_OPTIONS,
	NUMBER_OPTIONS
});

function ok() {
	return !0
}

function notOk() {
	return !1
}

function undef() {}
const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";

function create() {
	function o(Ce) {
		return typeof Ce == "object" && Ce !== null && Ce.constructor === Object
	}
	const s = [{
			name: "number",
			test: function(Ce) {
				return typeof Ce == "number"
			}
		}, {
			name: "string",
			test: function(Ce) {
				return typeof Ce == "string"
			}
		}, {
			name: "boolean",
			test: function(Ce) {
				return typeof Ce == "boolean"
			}
		}, {
			name: "Function",
			test: function(Ce) {
				return typeof Ce == "function"
			}
		}, {
			name: "Array",
			test: Array.isArray
		}, {
			name: "Date",
			test: function(Ce) {
				return Ce instanceof Date
			}
		}, {
			name: "RegExp",
			test: function(Ce) {
				return Ce instanceof RegExp
			}
		}, {
			name: "Object",
			test: o
		}, {
			name: "null",
			test: function(Ce) {
				return Ce === null
			}
		}, {
			name: "undefined",
			test: function(Ce) {
				return Ce === void 0
			}
		}],
		a = {
			name: "any",
			test: ok,
			isAny: !0
		};
	let l, c, d = 0,
		f = {
			createCount: 0
		};

	function m(Ce) {
		const $e = l.get(Ce);
		if ($e) return $e;
		let Fe = 'Unknown type "' + Ce + '"';
		const Ge = Ce.toLowerCase();
		let ze;
		for (ze of c)
			if (ze.toLowerCase() === Ge) {
				Fe += '. Did you mean "' + ze + '" ?';
				break
			} throw new TypeError(Fe)
	}

	function g(Ce) {
		let $e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
		const Fe = $e ? m($e).index : c.length,
			Ge = [];
		for (let Oe = 0; Oe < Ce.length; ++Oe) {
			if (!Ce[Oe] || typeof Ce[Oe].name != "string" || typeof Ce[Oe].test != "function") throw new TypeError(
				"Object with properties {name: string, test: function} expected");
			const Xe = Ce[Oe].name;
			if (l.has(Xe)) throw new TypeError('Duplicate type name "' + Xe + '"');
			Ge.push(Xe), l.set(Xe, {
				name: Xe,
				test: Ce[Oe].test,
				isAny: Ce[Oe].isAny,
				index: Fe + Oe,
				conversionsTo: []
			})
		}
		const ze = c.slice(Fe);
		c = c.slice(0, Fe).concat(Ge).concat(ze);
		for (let Oe = Fe + Ge.length; Oe < c.length; ++Oe) l.get(c[Oe]).index = Oe
	}

	function v() {
		l = new Map, c = [], d = 0, g([a], !1)
	}
	v(), g(s);

	function y() {
		let Ce;
		for (Ce of c) l.get(Ce).conversionsTo = [];
		d = 0
	}

	function b(Ce) {
		const $e = c.filter(Fe => {
			const Ge = l.get(Fe);
			return !Ge.isAny && Ge.test(Ce)
		});
		return $e.length ? $e : ["any"]
	}

	function C(Ce) {
		return Ce && typeof Ce == "function" && "_typedFunctionData" in Ce
	}

	function _(Ce, $e, Fe) {
		if (!C(Ce)) throw new TypeError(NOT_TYPED_FUNCTION);
		const Ge = Fe && Fe.exact,
			ze = Array.isArray($e) ? $e.join(",") : $e,
			Oe = D(ze),
			Xe = T(Oe);
		if (!Ge || Xe in Ce.signatures) {
			const Et = Ce._typedFunctionData.signatureMap.get(Xe);
			if (Et) return Et
		}
		const rt = Oe.length;
		let ut;
		if (Ge) {
			ut = [];
			let Et;
			for (Et in Ce.signatures) ut.push(Ce._typedFunctionData.signatureMap.get(Et))
		} else ut = Ce._typedFunctionData.signatures;
		for (let Et = 0; Et < rt; ++Et) {
			const Ze = Oe[Et],
				Ye = [];
			let ct;
			for (ct of ut) {
				const yt = U(ct.params, Et);
				if (!(!yt || Ze.restParam && !yt.restParam)) {
					if (!yt.hasAny) {
						const wt = M(yt);
						if (Ze.types.some(Qe => !wt.has(Qe.name))) continue
					}
					Ye.push(ct)
				}
			}
			if (ut = Ye, ut.length === 0) break
		}
		let gt;
		for (gt of ut)
			if (gt.params.length <= rt) return gt;
		throw new TypeError("Signature not found (signature: " + (Ce.name || "unnamed") + "(" + T(Oe, ", ") + "))")
	}

	function S(Ce, $e, Fe) {
		return _(Ce, $e, Fe).implementation
	}

	function w(Ce, $e) {
		const Fe = m($e);
		if (Fe.test(Ce)) return Ce;
		const Ge = Fe.conversionsTo;
		if (Ge.length === 0) throw new Error("There are no conversions to " + $e + " defined.");
		for (let ze = 0; ze < Ge.length; ze++)
			if (m(Ge[ze].from).test(Ce)) return Ge[ze].convert(Ce);
		throw new Error("Cannot convert " + Ce + " to " + $e)
	}

	function T(Ce) {
		let $e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
		return Ce.map(Fe => Fe.name).join($e)
	}

	function A(Ce) {
		const $e = Ce.indexOf("...") === 0,
			Ge = ($e ? Ce.length > 3 ? Ce.slice(3) : "any" : Ce).split("|").map(rt => m(rt.trim()));
		let ze = !1,
			Oe = $e ? "..." : "";
		return {
			types: Ge.map(function(rt) {
				return ze = rt.isAny || ze, Oe += rt.name + "|", {
					name: rt.name,
					typeIndex: rt.index,
					test: rt.test,
					isAny: rt.isAny,
					conversion: null,
					conversionIndex: -1
				}
			}),
			name: Oe.slice(0, -1),
			hasAny: ze,
			hasConversion: !1,
			restParam: $e
		}
	}

	function k(Ce) {
		const $e = Ce.types.map(Xe => Xe.name),
			Fe = fe($e);
		let Ge = Ce.hasAny,
			ze = Ce.name;
		const Oe = Fe.map(function(Xe) {
			const rt = m(Xe.from);
			return Ge = rt.isAny || Ge, ze += "|" + Xe.from, {
				name: Xe.from,
				typeIndex: rt.index,
				test: rt.test,
				isAny: rt.isAny,
				conversion: Xe,
				conversionIndex: Xe.index
			}
		});
		return {
			types: Ce.types.concat(Oe),
			name: ze,
			hasAny: Ge,
			hasConversion: Oe.length > 0,
			restParam: Ce.restParam
		}
	}

	function M(Ce) {
		return Ce.typeSet || (Ce.typeSet = new Set, Ce.types.forEach($e => Ce.typeSet.add($e.name))), Ce.typeSet
	}

	function D(Ce) {
		const $e = [];
		if (typeof Ce != "string") throw new TypeError("Signatures must be strings");
		const Fe = Ce.trim();
		if (Fe === "") return $e;
		const Ge = Fe.split(",");
		for (let ze = 0; ze < Ge.length; ++ze) {
			const Oe = A(Ge[ze].trim());
			if (Oe.restParam && ze !== Ge.length - 1) throw new SyntaxError('Unexpected rest parameter "' + Ge[ze] +
				'": only allowed for the last parameter');
			if (Oe.types.length === 0) return null;
			$e.push(Oe)
		}
		return $e
	}

	function F(Ce) {
		const $e = pt(Ce);
		return $e ? $e.restParam : !1
	}

	function R(Ce) {
		if (!Ce || Ce.types.length === 0) return ok;
		if (Ce.types.length === 1) return m(Ce.types[0].name).test;
		if (Ce.types.length === 2) {
			const $e = m(Ce.types[0].name).test,
				Fe = m(Ce.types[1].name).test;
			return function(ze) {
				return $e(ze) || Fe(ze)
			}
		} else {
			const $e = Ce.types.map(function(Fe) {
				return m(Fe.name).test
			});
			return function(Ge) {
				for (let ze = 0; ze < $e.length; ze++)
					if ($e[ze](Ge)) return !0;
				return !1
			}
		}
	}

	function O(Ce) {
		let $e, Fe, Ge;
		if (F(Ce)) {
			$e = it(Ce).map(R);
			const ze = $e.length,
				Oe = R(pt(Ce)),
				Xe = function(rt) {
					for (let ut = ze; ut < rt.length; ut++)
						if (!Oe(rt[ut])) return !1;
					return !0
				};
			return function(ut) {
				for (let gt = 0; gt < $e.length; gt++)
					if (!$e[gt](ut[gt])) return !1;
				return Xe(ut) && ut.length >= ze + 1
			}
		} else return Ce.length === 0 ? function(Oe) {
			return Oe.length === 0
		} : Ce.length === 1 ? (Fe = R(Ce[0]), function(Oe) {
			return Fe(Oe[0]) && Oe.length === 1
		}) : Ce.length === 2 ? (Fe = R(Ce[0]), Ge = R(Ce[1]), function(Oe) {
			return Fe(Oe[0]) && Ge(Oe[1]) && Oe.length === 2
		}) : ($e = Ce.map(R), function(Oe) {
			for (let Xe = 0; Xe < $e.length; Xe++)
				if (!$e[Xe](Oe[Xe])) return !1;
			return Oe.length === $e.length
		})
	}

	function U(Ce, $e) {
		return $e < Ce.length ? Ce[$e] : F(Ce) ? pt(Ce) : null
	}

	function V(Ce, $e) {
		const Fe = U(Ce, $e);
		return Fe ? M(Fe) : new Set
	}

	function z(Ce) {
		return Ce.conversion === null || Ce.conversion === void 0
	}

	function j(Ce, $e) {
		const Fe = new Set;
		return Ce.forEach(Ge => {
			const ze = V(Ge.params, $e);
			let Oe;
			for (Oe of ze) Fe.add(Oe)
		}), Fe.has("any") ? ["any"] : Array.from(Fe)
	}

	function ge(Ce, $e, Fe) {
		let Ge, ze;
		const Oe = Ce || "unnamed";
		let Xe = Fe,
			rt;
		for (rt = 0; rt < $e.length; rt++) {
			const Ze = [];
			if (Xe.forEach(Ye => {
					const ct = U(Ye.params, rt),
						yt = R(ct);
					(rt < Ye.params.length || F(Ye.params)) && yt($e[rt]) && Ze.push(Ye)
				}), Ze.length === 0) {
				if (ze = j(Xe, rt), ze.length > 0) {
					const Ye = b($e[rt]);
					return Ge = new TypeError("Unexpected type of argument in function " + Oe + " (expected: " + ze
						.join(" or ") + ", actual: " + Ye.join(" | ") + ", index: " + rt + ")"), Ge.data = {
						category: "wrongType",
						fn: Oe,
						index: rt,
						actual: Ye,
						expected: ze
					}, Ge
				}
			} else Xe = Ze
		}
		const ut = Xe.map(function(Ze) {
			return F(Ze.params) ? 1 / 0 : Ze.params.length
		});
		if ($e.length < Math.min.apply(null, ut)) return ze = j(Xe, rt), Ge = new TypeError(
			"Too few arguments in function " + Oe + " (expected: " + ze.join(" or ") + ", index: " + $e.length +
			")"), Ge.data = {
			category: "tooFewArgs",
			fn: Oe,
			index: $e.length,
			expected: ze
		}, Ge;
		const gt = Math.max.apply(null, ut);
		if ($e.length > gt) return Ge = new TypeError("Too many arguments in function " + Oe + " (expected: " + gt +
			", actual: " + $e.length + ")"), Ge.data = {
			category: "tooManyArgs",
			fn: Oe,
			index: $e.length,
			expectedLength: gt
		}, Ge;
		const Et = [];
		for (let Ze = 0; Ze < $e.length; ++Ze) Et.push(b($e[Ze]).join("|"));
		return Ge = new TypeError('Arguments of type "' + Et.join(", ") +
			'" do not match any of the defined signatures of function ' + Oe + "."), Ge.data = {
			category: "mismatch",
			actual: Et
		}, Ge
	}

	function me(Ce) {
		let $e = c.length + 1;
		for (let Fe = 0; Fe < Ce.types.length; Fe++) z(Ce.types[Fe]) && ($e = Math.min($e, Ce.types[Fe].typeIndex));
		return $e
	}

	function he(Ce) {
		let $e = d + 1;
		for (let Fe = 0; Fe < Ce.types.length; Fe++) z(Ce.types[Fe]) || ($e = Math.min($e, Ce.types[Fe]
			.conversionIndex));
		return $e
	}

	function ce(Ce, $e) {
		if (Ce.hasAny) {
			if (!$e.hasAny) return 1
		} else if ($e.hasAny) return -1;
		if (Ce.restParam) {
			if (!$e.restParam) return 1
		} else if ($e.restParam) return -1;
		if (Ce.hasConversion) {
			if (!$e.hasConversion) return 1
		} else if ($e.hasConversion) return -1;
		const Fe = me(Ce) - me($e);
		if (Fe < 0) return -1;
		if (Fe > 0) return 1;
		const Ge = he(Ce) - he($e);
		return Ge < 0 ? -1 : Ge > 0 ? 1 : 0
	}

	function ae(Ce, $e) {
		const Fe = Ce.params,
			Ge = $e.params,
			ze = pt(Fe),
			Oe = pt(Ge),
			Xe = F(Fe),
			rt = F(Ge);
		if (Xe && ze.hasAny) {
			if (!rt || !Oe.hasAny) return 1
		} else if (rt && Oe.hasAny) return -1;
		let ut = 0,
			gt = 0,
			Et;
		for (Et of Fe) Et.hasAny && ++ut, Et.hasConversion && ++gt;
		let Ze = 0,
			Ye = 0;
		for (Et of Ge) Et.hasAny && ++Ze, Et.hasConversion && ++Ye;
		if (ut !== Ze) return ut - Ze;
		if (Xe && ze.hasConversion) {
			if (!rt || !Oe.hasConversion) return 1
		} else if (rt && Oe.hasConversion) return -1;
		if (gt !== Ye) return gt - Ye;
		if (Xe) {
			if (!rt) return 1
		} else if (rt) return -1;
		const ct = (Fe.length - Ge.length) * (Xe ? -1 : 1);
		if (ct !== 0) return ct;
		const yt = [];
		let wt = 0;
		for (let At = 0; At < Fe.length; ++At) {
			const Ct = ce(Fe[At], Ge[At]);
			yt.push(Ct), wt += Ct
		}
		if (wt !== 0) return wt;
		let Qe;
		for (Qe of yt)
			if (Qe !== 0) return Qe;
		return 0
	}

	function fe(Ce) {
		if (Ce.length === 0) return [];
		const $e = Ce.map(m);
		Ce.length > 1 && $e.sort((ze, Oe) => ze.index - Oe.index);
		let Fe = $e[0].conversionsTo;
		if (Ce.length === 1) return Fe;
		Fe = Fe.concat([]);
		const Ge = new Set(Ce);
		for (let ze = 1; ze < $e.length; ++ze) {
			let Oe;
			for (Oe of $e[ze].conversionsTo) Ge.has(Oe.from) || (Fe.push(Oe), Ge.add(Oe.from))
		}
		return Fe
	}

	function q(Ce, $e) {
		let Fe = $e;
		if (Ce.some(ze => ze.hasConversion)) {
			const ze = F(Ce),
				Oe = Ce.map(le);
			Fe = function() {
				const rt = [],
					ut = ze ? arguments.length - 1 : arguments.length;
				for (let gt = 0; gt < ut; gt++) rt[gt] = Oe[gt](arguments[gt]);
				return ze && (rt[ut] = arguments[ut].map(Oe[ut])), $e.apply(this, rt)
			}
		}
		let Ge = Fe;
		if (F(Ce)) {
			const ze = Ce.length - 1;
			Ge = function() {
				return Fe.apply(this, dt(arguments, 0, ze).concat([dt(arguments, ze)]))
			}
		}
		return Ge
	}

	function le(Ce) {
		let $e, Fe, Ge, ze;
		const Oe = [],
			Xe = [];
		switch (Ce.types.forEach(function(rt) {
				rt.conversion && (Oe.push(m(rt.conversion.from).test), Xe.push(rt.conversion.convert))
			}), Xe.length) {
			case 0:
				return function(ut) {
					return ut
				};
			case 1:
				return $e = Oe[0], Ge = Xe[0],
					function(ut) {
						return $e(ut) ? Ge(ut) : ut
					};
			case 2:
				return $e = Oe[0], Fe = Oe[1], Ge = Xe[0], ze = Xe[1],
					function(ut) {
						return $e(ut) ? Ge(ut) : Fe(ut) ? ze(ut) : ut
					};
			default:
				return function(ut) {
					for (let gt = 0; gt < Xe.length; gt++)
						if (Oe[gt](ut)) return Xe[gt](ut);
					return ut
				}
		}
	}

	function de(Ce) {
		function $e(Fe, Ge, ze) {
			if (Ge < Fe.length) {
				const Oe = Fe[Ge];
				let Xe = [];
				if (Oe.restParam) {
					const rt = Oe.types.filter(z);
					rt.length < Oe.types.length && Xe.push({
						types: rt,
						name: "..." + rt.map(ut => ut.name).join("|"),
						hasAny: rt.some(ut => ut.isAny),
						hasConversion: !1,
						restParam: !0
					}), Xe.push(Oe)
				} else Xe = Oe.types.map(function(rt) {
					return {
						types: [rt],
						name: rt.name,
						hasAny: rt.isAny,
						hasConversion: rt.conversion,
						restParam: !1
					}
				});
				return Ae(Xe, function(rt) {
					return $e(Fe, Ge + 1, ze.concat([rt]))
				})
			} else return [ze]
		}
		return $e(Ce, 0, [])
	}

	function _e(Ce, $e) {
		const Fe = Math.max(Ce.length, $e.length);
		for (let rt = 0; rt < Fe; rt++) {
			const ut = V(Ce, rt),
				gt = V($e, rt);
			let Et = !1,
				Ze;
			for (Ze of gt)
				if (ut.has(Ze)) {
					Et = !0;
					break
				} if (!Et) return !1
		}
		const Ge = Ce.length,
			ze = $e.length,
			Oe = F(Ce),
			Xe = F($e);
		return Oe ? Xe ? Ge === ze : ze >= Ge : Xe ? Ge >= ze : Ge === ze
	}

	function ke(Ce) {
		return Ce.map($e => nt($e) ? Le($e.referToSelf.callback) : Ue($e) ? ye($e.referTo.references, $e.referTo
			.callback) : $e)
	}

	function De(Ce, $e, Fe) {
		const Ge = [];
		let ze;
		for (ze of Ce) {
			let Oe = Fe[ze];
			if (typeof Oe != "number") throw new TypeError('No definition for referenced signature "' + ze + '"');
			if (Oe = $e[Oe], typeof Oe != "function") return !1;
			Ge.push(Oe)
		}
		return Ge
	}

	function Se(Ce, $e, Fe) {
		const Ge = ke(Ce),
			ze = new Array(Ge.length).fill(!1);
		let Oe = !0;
		for (; Oe;) {
			Oe = !1;
			let Xe = !0;
			for (let rt = 0; rt < Ge.length; ++rt) {
				if (ze[rt]) continue;
				const ut = Ge[rt];
				if (nt(ut)) Ge[rt] = ut.referToSelf.callback(Fe), Ge[rt].referToSelf = ut.referToSelf, ze[rt] = !0,
					Xe = !1;
				else if (Ue(ut)) {
					const gt = De(ut.referTo.references, Ge, $e);
					gt ? (Ge[rt] = ut.referTo.callback.apply(this, gt), Ge[rt].referTo = ut.referTo, ze[rt] = !0, Xe = !
						1) : Oe = !0
				}
			}
			if (Xe && Oe) throw new SyntaxError("Circular reference detected in resolving typed.referTo")
		}
		return Ge
	}

	function be(Ce) {
		const $e = /\bthis(\(|\.signatures\b)/;
		Object.keys(Ce).forEach(Fe => {
			const Ge = Ce[Fe];
			if ($e.test(Ge.toString())) throw new SyntaxError(
				"Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead."
				)
		})
	}

	function Me(Ce, $e) {
		if (f.createCount++, Object.keys($e).length === 0) throw new SyntaxError("No signatures provided");
		f.warnAgainstDeprecatedThis && be($e);
		const Fe = [],
			Ge = [],
			ze = {},
			Oe = [];
		let Xe;
		for (Xe in $e) {
			if (!Object.prototype.hasOwnProperty.call($e, Xe)) continue;
			const vt = D(Xe);
			if (!vt) continue;
			Fe.forEach(function(Lt) {
				if (_e(Lt, vt)) throw new TypeError('Conflicting signatures "' + T(Lt) + '" and "' + T(vt) +
					'".')
			}), Fe.push(vt);
			const mt = Ge.length;
			Ge.push($e[Xe]);
			const Dt = vt.map(k);
			let Pt;
			for (Pt of de(Dt)) {
				const Lt = T(Pt);
				Oe.push({
					params: Pt,
					name: Lt,
					fn: mt
				}), Pt.every(Ht => !Ht.hasConversion) && (ze[Lt] = mt)
			}
		}
		Oe.sort(ae);
		const rt = Se(Ge, ze, ft);
		let ut;
		for (ut in ze) Object.prototype.hasOwnProperty.call(ze, ut) && (ze[ut] = rt[ze[ut]]);
		const gt = [],
			Et = new Map;
		for (ut of Oe) Et.has(ut.name) || (ut.fn = rt[ut.fn], gt.push(ut), Et.set(ut.name, ut));
		const Ze = gt[0] && gt[0].params.length <= 2 && !F(gt[0].params),
			Ye = gt[1] && gt[1].params.length <= 2 && !F(gt[1].params),
			ct = gt[2] && gt[2].params.length <= 2 && !F(gt[2].params),
			yt = gt[3] && gt[3].params.length <= 2 && !F(gt[3].params),
			wt = gt[4] && gt[4].params.length <= 2 && !F(gt[4].params),
			Qe = gt[5] && gt[5].params.length <= 2 && !F(gt[5].params),
			At = Ze && Ye && ct && yt && wt && Qe;
		for (let vt = 0; vt < gt.length; ++vt) gt[vt].test = O(gt[vt].params);
		const Ct = Ze ? R(gt[0].params[0]) : notOk,
			xt = Ye ? R(gt[1].params[0]) : notOk,
			Rt = ct ? R(gt[2].params[0]) : notOk,
			$t = yt ? R(gt[3].params[0]) : notOk,
			zt = wt ? R(gt[4].params[0]) : notOk,
			sn = Qe ? R(gt[5].params[0]) : notOk,
			dn = Ze ? R(gt[0].params[1]) : notOk,
			Mt = Ye ? R(gt[1].params[1]) : notOk,
			qt = ct ? R(gt[2].params[1]) : notOk,
			pn = yt ? R(gt[3].params[1]) : notOk,
			Te = wt ? R(gt[4].params[1]) : notOk,
			Pe = Qe ? R(gt[5].params[1]) : notOk;
		for (let vt = 0; vt < gt.length; ++vt) gt[vt].implementation = q(gt[vt].params, gt[vt].fn);
		const lt = Ze ? gt[0].implementation : undef,
			bt = Ye ? gt[1].implementation : undef,
			Nt = ct ? gt[2].implementation : undef,
			Ot = yt ? gt[3].implementation : undef,
			nn = wt ? gt[4].implementation : undef,
			Cn = Qe ? gt[5].implementation : undef,
			wn = Ze ? gt[0].params.length : -1,
			Mn = Ye ? gt[1].params.length : -1,
			fn = ct ? gt[2].params.length : -1,
			zn = yt ? gt[3].params.length : -1,
			On = wt ? gt[4].params.length : -1,
			Nn = Qe ? gt[5].params.length : -1,
			An = At ? 6 : 0,
			$n = gt.length,
			Rn = gt.map(vt => vt.test),
			We = gt.map(vt => vt.implementation),
			et = function() {
				for (let mt = An; mt < $n; mt++)
					if (Rn[mt](arguments)) return We[mt].apply(this, arguments);
				return f.onMismatch(Ce, arguments, gt)
			};

		function ft(vt, mt) {
			return arguments.length === wn && Ct(vt) && dn(mt) ? lt.apply(this, arguments) : arguments.length === Mn &&
				xt(vt) && Mt(mt) ? bt.apply(this, arguments) : arguments.length === fn && Rt(vt) && qt(mt) ? Nt.apply(
					this, arguments) : arguments.length === zn && $t(vt) && pn(mt) ? Ot.apply(this, arguments) :
				arguments.length === On && zt(vt) && Te(mt) ? nn.apply(this, arguments) : arguments.length === Nn && sn(
					vt) && Pe(mt) ? Cn.apply(this, arguments) : et.apply(this, arguments)
		}
		try {
			Object.defineProperty(ft, "name", {
				value: Ce
			})
		} catch {}
		return ft.signatures = ze, ft._typedFunctionData = {
			signatures: gt,
			signatureMap: Et
		}, ft
	}

	function Ve(Ce, $e, Fe) {
		throw ge(Ce, $e, Fe)
	}

	function it(Ce) {
		return dt(Ce, 0, Ce.length - 1)
	}

	function pt(Ce) {
		return Ce[Ce.length - 1]
	}

	function dt(Ce, $e, Fe) {
		return Array.prototype.slice.call(Ce, $e, Fe)
	}

	function He(Ce, $e) {
		for (let Fe = 0; Fe < Ce.length; Fe++)
			if ($e(Ce[Fe])) return Ce[Fe]
	}

	function Ae(Ce, $e) {
		return Array.prototype.concat.apply([], Ce.map($e))
	}

	function xe() {
		const Ce = it(arguments).map(Fe => T(D(Fe))),
			$e = pt(arguments);
		if (typeof $e != "function") throw new TypeError("Callback function expected as last argument");
		return ye(Ce, $e)
	}

	function ye(Ce, $e) {
		return {
			referTo: {
				references: Ce,
				callback: $e
			}
		}
	}

	function Le(Ce) {
		if (typeof Ce != "function") throw new TypeError("Callback function expected as first argument");
		return {
			referToSelf: {
				callback: Ce
			}
		}
	}

	function Ue(Ce) {
		return Ce && typeof Ce.referTo == "object" && Array.isArray(Ce.referTo.references) && typeof Ce.referTo
			.callback == "function"
	}

	function nt(Ce) {
		return Ce && typeof Ce.referToSelf == "object" && typeof Ce.referToSelf.callback == "function"
	}

	function ot(Ce, $e) {
		if (!Ce) return $e;
		if ($e && $e !== Ce) {
			const Fe = new Error("Function names do not match (expected: " + Ce + ", actual: " + $e + ")");
			throw Fe.data = {
				actual: $e,
				expected: Ce
			}, Fe
		}
		return Ce
	}

	function at(Ce) {
		let $e;
		for (const Fe in Ce) Object.prototype.hasOwnProperty.call(Ce, Fe) && (C(Ce[Fe]) || typeof Ce[Fe].signature ==
			"string") && ($e = ot($e, Ce[Fe].name));
		return $e
	}

	function Je(Ce, $e) {
		let Fe;
		for (Fe in $e)
			if (Object.prototype.hasOwnProperty.call($e, Fe)) {
				if (Fe in Ce && $e[Fe] !== Ce[Fe]) {
					const Ge = new Error('Signature "' + Fe + '" is defined twice');
					throw Ge.data = {
						signature: Fe,
						sourceFunction: $e[Fe],
						destFunction: Ce[Fe]
					}, Ge
				}
				Ce[Fe] = $e[Fe]
			}
	}
	const Ne = f;
	f = function(Ce) {
			const $e = typeof Ce == "string",
				Fe = $e ? 1 : 0;
			let Ge = $e ? Ce : "";
			const ze = {};
			for (let Oe = Fe; Oe < arguments.length; ++Oe) {
				const Xe = arguments[Oe];
				let rt = {},
					ut;
				if (typeof Xe == "function" ? (ut = Xe.name, typeof Xe.signature == "string" ? rt[Xe.signature] = Xe :
						C(Xe) && (rt = Xe.signatures)) : o(Xe) && (rt = Xe, $e || (ut = at(Xe))), Object.keys(rt)
					.length === 0) {
					const gt = new TypeError("Argument to 'typed' at index " + Oe +
						" is not a (typed) function, nor an object with signatures as keys and functions as values."
						);
					throw gt.data = {
						index: Oe,
						argument: Xe
					}, gt
				}
				$e || (Ge = ot(Ge, ut)), Je(ze, rt)
			}
			return Me(Ge || "", ze)
		}, f.create = create, f.createCount = Ne.createCount, f.onMismatch = Ve, f.throwMismatchError = Ve, f
		.createError = ge, f.clear = v, f.clearConversions = y, f.addTypes = g, f._findType = m, f.referTo = xe, f
		.referToSelf = Le, f.convert = w, f.findSignature = _, f.find = S, f.isTypedFunction = C, f
		.warnAgainstDeprecatedThis = !0, f.addType = function(Ce, $e) {
			let Fe = "any";
			$e !== !1 && l.has("Object") && (Fe = "Object"), f.addTypes([Ce], Fe)
		};

	function we(Ce) {
		if (!Ce || typeof Ce.from != "string" || typeof Ce.to != "string" || typeof Ce.convert != "function")
		throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
		if (Ce.to === Ce.from) throw new SyntaxError('Illegal to define conversion from "' + Ce.from + '" to itself.')
	}
	return f.addConversion = function(Ce) {
		let $e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
			override: !1
		};
		we(Ce);
		const Fe = m(Ce.to),
			Ge = Fe.conversionsTo.find(ze => ze.from === Ce.from);
		if (Ge)
			if ($e && $e.override) f.removeConversion({
				from: Ge.from,
				to: Ce.to,
				convert: Ge.convert
			});
			else throw new Error('There is already a conversion from "' + Ce.from + '" to "' + Fe.name + '"');
		Fe.conversionsTo.push({
			from: Ce.from,
			convert: Ce.convert,
			index: d++
		})
	}, f.addConversions = function(Ce, $e) {
		Ce.forEach(Fe => f.addConversion(Fe, $e))
	}, f.removeConversion = function(Ce) {
		we(Ce);
		const $e = m(Ce.to),
			Fe = He($e.conversionsTo, ze => ze.from === Ce.from);
		if (!Fe) throw new Error("Attempt to remove nonexistent conversion from " + Ce.from + " to " + Ce.to);
		if (Fe.convert !== Ce.convert) throw new Error("Conversion to remove does not match existing conversion");
		const Ge = $e.conversionsTo.indexOf(Fe);
		$e.conversionsTo.splice(Ge, 1)
	}, f.resolve = function(Ce, $e) {
		if (!C(Ce)) throw new TypeError(NOT_TYPED_FUNCTION);
		const Fe = Ce._typedFunctionData.signatures;
		for (let Ge = 0; Ge < Fe.length; ++Ge)
			if (Fe[Ge].test($e)) return Fe[Ge];
		return null
	}, f
}
const typedFunction = create();

function factory(o, s, a, l) {
	function c(d) {
		var f = pickShallow(d, s.map(stripOptionalNotation));
		return assertDependencies(o, s, d), a(f)
	}
	return c.isFactory = !0, c.fn = o, c.dependencies = s.slice().sort(), l && (c.meta = l), c
}

function assertDependencies(o, s, a) {
	var l = s.filter(d => !isOptionalDependency(d)).every(d => a[d] !== void 0);
	if (!l) {
		var c = s.filter(d => a[d] === void 0);
		throw new Error('Cannot create function "'.concat(o, '", ') + "some dependencies are missing: ".concat(c.map(
			d => '"'.concat(d, '"')).join(", "), "."))
	}
}

function isOptionalDependency(o) {
	return o && o[0] === "?"
}

function stripOptionalNotation(o) {
	return o && o[0] === "?" ? o.slice(1) : o
}

function isInteger(o) {
	return typeof o == "boolean" ? !0 : isFinite(o) ? o === Math.round(o) : !1
}

function formatNumberToBase(o, s, a) {
	var l = {
			2: "0b",
			8: "0o",
			16: "0x"
		},
		c = l[s],
		d = "";
	if (a) {
		if (a < 1) throw new Error("size must be in greater than 0");
		if (!isInteger(a)) throw new Error("size must be an integer");
		if (o > 2 ** (a - 1) - 1 || o < -(2 ** (a - 1))) throw new Error("Value must be in range [-2^".concat(a - 1,
			", 2^").concat(a - 1, "-1]"));
		if (!isInteger(o)) throw new Error("Value must be an integer");
		o < 0 && (o = o + 2 ** a), d = "i".concat(a)
	}
	var f = "";
	return o < 0 && (o = -o, f = "-"), "".concat(f).concat(c).concat(o.toString(s)).concat(d)
}

function format$2(o, s) {
	if (typeof s == "function") return s(o);
	if (o === 1 / 0) return "Infinity";
	if (o === -1 / 0) return "-Infinity";
	if (isNaN(o)) return "NaN";
	var {
		notation: a,
		precision: l,
		wordSize: c
	} = normalizeFormatOptions(s);
	switch (a) {
		case "fixed":
			return toFixed$1(o, l);
		case "exponential":
			return toExponential$1(o, l);
		case "engineering":
			return toEngineering$1(o, l);
		case "bin":
			return formatNumberToBase(o, 2, c);
		case "oct":
			return formatNumberToBase(o, 8, c);
		case "hex":
			return formatNumberToBase(o, 16, c);
		case "auto":
			return toPrecision(o, l, s).replace(/((\.\d*?)(0+))($|e)/, function() {
				var d = arguments[2],
					f = arguments[4];
				return d !== "." ? d + f : f
			});
		default:
			throw new Error('Unknown notation "' + a +
				'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')
	}
}

function normalizeFormatOptions(o) {
	var s = "auto",
		a, l;
	if (o !== void 0)
		if (isNumber(o)) a = o;
		else if (isBigNumber(o)) a = o.toNumber();
	else if (isObject(o)) o.precision !== void 0 && (a = _toNumberOrThrow(o.precision, () => {
		throw new Error('Option "precision" must be a number or BigNumber')
	})), o.wordSize !== void 0 && (l = _toNumberOrThrow(o.wordSize, () => {
		throw new Error('Option "wordSize" must be a number or BigNumber')
	})), o.notation && (s = o.notation);
	else throw new Error("Unsupported type of options, number, BigNumber, or object expected");
	return {
		notation: s,
		precision: a,
		wordSize: l
	}
}

function splitNumber(o) {
	var s = String(o).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
	if (!s) throw new SyntaxError("Invalid number " + o);
	var a = s[1],
		l = s[2],
		c = parseFloat(s[4] || "0"),
		d = l.indexOf(".");
	c += d !== -1 ? d - 1 : l.length - 1;
	var f = l.replace(".", "").replace(/^0*/, function(m) {
		return c -= m.length, ""
	}).replace(/0*$/, "").split("").map(function(m) {
		return parseInt(m)
	});
	return f.length === 0 && (f.push(0), c++), {
		sign: a,
		coefficients: f,
		exponent: c
	}
}

function toEngineering$1(o, s) {
	if (isNaN(o) || !isFinite(o)) return String(o);
	var a = splitNumber(o),
		l = roundDigits(a, s),
		c = l.exponent,
		d = l.coefficients,
		f = c % 3 === 0 ? c : c < 0 ? c - 3 - c % 3 : c - c % 3;
	if (isNumber(s))
		for (; s > d.length || c - f + 1 > d.length;) d.push(0);
	else
		for (var m = Math.abs(c - f) - (d.length - 1), g = 0; g < m; g++) d.push(0);
	for (var v = Math.abs(c - f), y = 1; v > 0;) y++, v--;
	var b = d.slice(y).join(""),
		C = isNumber(s) && b.length || b.match(/[1-9]/) ? "." + b : "",
		_ = d.slice(0, y).join("") + C + "e" + (c >= 0 ? "+" : "") + f.toString();
	return l.sign + _
}

function toFixed$1(o, s) {
	if (isNaN(o) || !isFinite(o)) return String(o);
	var a = splitNumber(o),
		l = typeof s == "number" ? roundDigits(a, a.exponent + 1 + s) : a,
		c = l.coefficients,
		d = l.exponent + 1,
		f = d + (s || 0);
	return c.length < f && (c = c.concat(zeros(f - c.length))), d < 0 && (c = zeros(-d + 1).concat(c), d = 1), d < c
		.length && c.splice(d, 0, d === 0 ? "0." : "."), l.sign + c.join("")
}

function toExponential$1(o, s) {
	if (isNaN(o) || !isFinite(o)) return String(o);
	var a = splitNumber(o),
		l = s ? roundDigits(a, s) : a,
		c = l.coefficients,
		d = l.exponent;
	c.length < s && (c = c.concat(zeros(s - c.length)));
	var f = c.shift();
	return l.sign + f + (c.length > 0 ? "." + c.join("") : "") + "e" + (d >= 0 ? "+" : "") + d
}

function toPrecision(o, s, a) {
	if (isNaN(o) || !isFinite(o)) return String(o);
	var l = _toNumberOrDefault$1(a == null ? void 0 : a.lowerExp, -3),
		c = _toNumberOrDefault$1(a == null ? void 0 : a.upperExp, 5),
		d = splitNumber(o),
		f = s ? roundDigits(d, s) : d;
	if (f.exponent < l || f.exponent >= c) return toExponential$1(o, s);
	var m = f.coefficients,
		g = f.exponent;
	m.length < s && (m = m.concat(zeros(s - m.length))), m = m.concat(zeros(g - m.length + 1 + (m.length < s ? s - m
		.length : 0))), m = zeros(-g).concat(m);
	var v = g > 0 ? g : 0;
	return v < m.length - 1 && m.splice(v + 1, 0, "."), f.sign + m.join("")
}

function roundDigits(o, s) {
	for (var a = {
			sign: o.sign,
			coefficients: o.coefficients,
			exponent: o.exponent
		}, l = a.coefficients; s <= 0;) l.unshift(0), a.exponent++, s++;
	if (l.length > s) {
		var c = l.splice(s, l.length - s);
		if (c[0] >= 5) {
			var d = s - 1;
			for (l[d]++; l[d] === 10;) l.pop(), d === 0 && (l.unshift(0), a.exponent++, d++), d--, l[d]++
		}
	}
	return a
}

function zeros(o) {
	for (var s = [], a = 0; a < o; a++) s.push(0);
	return s
}

function digits(o) {
	return o.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length
}

function nearlyEqual$1(o, s) {
	var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-8,
		l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
	if (a <= 0) throw new Error("Relative tolerance must be greater than 0");
	if (l < 0) throw new Error("Absolute tolerance must be at least 0");
	return isNaN(o) || isNaN(s) ? !1 : !isFinite(o) || !isFinite(s) ? o === s : o === s ? !0 : Math.abs(o - s) <= Math
		.max(a * Math.max(Math.abs(o), Math.abs(s)), l)
}

function _toNumberOrThrow(o, s) {
	if (isNumber(o)) return o;
	if (isBigNumber(o)) return o.toNumber();
	s()
}

function _toNumberOrDefault$1(o, s) {
	return isNumber(o) ? o : isBigNumber(o) ? o.toNumber() : s
}
var _createTyped2 = function() {
		return _createTyped2 = typedFunction.create, typedFunction
	},
	dependencies$s = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"],
	createTyped = factory("typed", dependencies$s, function(s) {
		var {
			BigNumber: a,
			Complex: l,
			DenseMatrix: c,
			Fraction: d
		} = s, f = _createTyped2();
		return f.clear(), f.addTypes([{
			name: "number",
			test: isNumber
		}, {
			name: "Complex",
			test: isComplex
		}, {
			name: "BigNumber",
			test: isBigNumber
		}, {
			name: "bigint",
			test: isBigInt
		}, {
			name: "Fraction",
			test: isFraction
		}, {
			name: "Unit",
			test: isUnit
		}, {
			name: "identifier",
			test: m => isString &&
				/^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/
				.test(m)
		}, {
			name: "string",
			test: isString
		}, {
			name: "Chain",
			test: isChain
		}, {
			name: "Array",
			test: isArray
		}, {
			name: "Matrix",
			test: isMatrix
		}, {
			name: "DenseMatrix",
			test: isDenseMatrix
		}, {
			name: "SparseMatrix",
			test: isSparseMatrix
		}, {
			name: "Range",
			test: isRange
		}, {
			name: "Index",
			test: isIndex
		}, {
			name: "boolean",
			test: isBoolean
		}, {
			name: "ResultSet",
			test: isResultSet
		}, {
			name: "Help",
			test: isHelp
		}, {
			name: "function",
			test: isFunction
		}, {
			name: "Date",
			test: isDate
		}, {
			name: "RegExp",
			test: isRegExp
		}, {
			name: "null",
			test: isNull
		}, {
			name: "undefined",
			test: isUndefined
		}, {
			name: "AccessorNode",
			test: isAccessorNode
		}, {
			name: "ArrayNode",
			test: isArrayNode
		}, {
			name: "AssignmentNode",
			test: isAssignmentNode
		}, {
			name: "BlockNode",
			test: isBlockNode
		}, {
			name: "ConditionalNode",
			test: isConditionalNode
		}, {
			name: "ConstantNode",
			test: isConstantNode
		}, {
			name: "FunctionNode",
			test: isFunctionNode
		}, {
			name: "FunctionAssignmentNode",
			test: isFunctionAssignmentNode
		}, {
			name: "IndexNode",
			test: isIndexNode
		}, {
			name: "Node",
			test: isNode
		}, {
			name: "ObjectNode",
			test: isObjectNode
		}, {
			name: "OperatorNode",
			test: isOperatorNode
		}, {
			name: "ParenthesisNode",
			test: isParenthesisNode
		}, {
			name: "RangeNode",
			test: isRangeNode
		}, {
			name: "RelationalNode",
			test: isRelationalNode
		}, {
			name: "SymbolNode",
			test: isSymbolNode
		}, {
			name: "Map",
			test: isMap
		}, {
			name: "Object",
			test: isObject
		}]), f.addConversions([{
			from: "number",
			to: "BigNumber",
			convert: function(g) {
				if (a || throwNoBignumber(g), digits(g) > 15) throw new TypeError(
					"Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " +
					g + "). Use function bignumber(x) to convert to BigNumber.");
				return new a(g)
			}
		}, {
			from: "number",
			to: "Complex",
			convert: function(g) {
				return l || throwNoComplex(g), new l(g, 0)
			}
		}, {
			from: "BigNumber",
			to: "Complex",
			convert: function(g) {
				return l || throwNoComplex(g), new l(g.toNumber(), 0)
			}
		}, {
			from: "bigint",
			to: "number",
			convert: function(g) {
				if (g > Number.MAX_SAFE_INTEGER) throw new TypeError(
					"Cannot implicitly convert bigint to number: value exceeds the max safe integer value (value: " +
					g + ")");
				return Number(g)
			}
		}, {
			from: "bigint",
			to: "BigNumber",
			convert: function(g) {
				return a || throwNoBignumber(g), new a(g.toString())
			}
		}, {
			from: "bigint",
			to: "Fraction",
			convert: function(g) {
				return d || throwNoFraction(g), new d(g)
			}
		}, {
			from: "Fraction",
			to: "BigNumber",
			convert: function(g) {
				throw new TypeError(
					"Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction."
					)
			}
		}, {
			from: "Fraction",
			to: "Complex",
			convert: function(g) {
				return l || throwNoComplex(g), new l(g.valueOf(), 0)
			}
		}, {
			from: "number",
			to: "Fraction",
			convert: function(g) {
				d || throwNoFraction(g);
				var v = new d(g);
				if (v.valueOf() !== g) throw new TypeError(
					"Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " +
					g + "). Use function fraction(x) to convert to Fraction.");
				return v
			}
		}, {
			from: "string",
			to: "number",
			convert: function(g) {
				var v = Number(g);
				if (isNaN(v)) throw new Error('Cannot convert "' + g + '" to a number');
				return v
			}
		}, {
			from: "string",
			to: "BigNumber",
			convert: function(g) {
				a || throwNoBignumber(g);
				try {
					return new a(g)
				} catch {
					throw new Error('Cannot convert "' + g + '" to BigNumber')
				}
			}
		}, {
			from: "string",
			to: "bigint",
			convert: function(g) {
				try {
					return BigInt(g)
				} catch {
					throw new Error('Cannot convert "' + g + '" to BigInt')
				}
			}
		}, {
			from: "string",
			to: "Fraction",
			convert: function(g) {
				d || throwNoFraction(g);
				try {
					return new d(g)
				} catch {
					throw new Error('Cannot convert "' + g + '" to Fraction')
				}
			}
		}, {
			from: "string",
			to: "Complex",
			convert: function(g) {
				l || throwNoComplex(g);
				try {
					return new l(g)
				} catch {
					throw new Error('Cannot convert "' + g + '" to Complex')
				}
			}
		}, {
			from: "boolean",
			to: "number",
			convert: function(g) {
				return +g
			}
		}, {
			from: "boolean",
			to: "BigNumber",
			convert: function(g) {
				return a || throwNoBignumber(g), new a(+g)
			}
		}, {
			from: "boolean",
			to: "bigint",
			convert: function(g) {
				return BigInt(+g)
			}
		}, {
			from: "boolean",
			to: "Fraction",
			convert: function(g) {
				return d || throwNoFraction(g), new d(+g)
			}
		}, {
			from: "boolean",
			to: "string",
			convert: function(g) {
				return String(g)
			}
		}, {
			from: "Array",
			to: "Matrix",
			convert: function(g) {
				return c || throwNoMatrix(), new c(g)
			}
		}, {
			from: "Matrix",
			to: "Array",
			convert: function(g) {
				return g.valueOf()
			}
		}]), f.onMismatch = (m, g, v) => {
			var y = f.createError(m, g, v);
			if (["wrongType", "mismatch"].includes(y.data.category) && g.length === 1 && isCollection(g[0]) && v
				.some(C => !C.params.includes(","))) {
				var b = new TypeError("Function '".concat(m, "' doesn't apply to matrices. To call it ") +
					"elementwise on a matrix 'M', try 'map(M, ".concat(m, ")'."));
				throw b.data = y.data, b
			}
			throw y
		}, f.onMismatch = (m, g, v) => {
			var y = f.createError(m, g, v);
			if (["wrongType", "mismatch"].includes(y.data.category) && g.length === 1 && isCollection(g[0]) && v
				.some(C => !C.params.includes(","))) {
				var b = new TypeError("Function '".concat(m, "' doesn't apply to matrices. To call it ") +
					"elementwise on a matrix 'M', try 'map(M, ".concat(m, ")'."));
				throw b.data = y.data, b
			}
			throw y
		}, f
	});

function throwNoBignumber(o) {
	throw new Error("Cannot convert value ".concat(o, " into a BigNumber: no class 'BigNumber' provided"))
}

function throwNoComplex(o) {
	throw new Error("Cannot convert value ".concat(o, " into a Complex number: no class 'Complex' provided"))
}

function throwNoMatrix() {
	throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")
}

function throwNoFraction(o) {
	throw new Error("Cannot convert value ".concat(o, " into a Fraction, no class 'Fraction' provided."))
}
/*!
 *  decimal.js v10.5.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9e15,
	MAX_DIGITS = 1e9,
	NUMERALS = "0123456789abcdef",
	LN10 =
	"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
	PI =
	"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
	DEFAULTS = {
		precision: 20,
		rounding: 4,
		modulo: 1,
		toExpNeg: -7,
		toExpPos: 21,
		minE: -9e15,
		maxE: EXP_LIMIT,
		crypto: !1
	},
	inexact, quadrant, external = !0,
	decimalError = "[DecimalError] ",
	invalidArgument = decimalError + "Invalid argument: ",
	precisionLimitExceeded = decimalError + "Precision limit exceeded",
	cryptoUnavailable = decimalError + "crypto unavailable",
	tag = "[object Decimal]",
	mathfloor = Math.floor,
	mathpow = Math.pow,
	isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
	isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
	isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
	isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
	BASE = 1e7,
	LOG_BASE = 7,
	MAX_SAFE_INTEGER = 9007199254740991,
	LN10_PRECISION = LN10.length - 1,
	PI_PRECISION = PI.length - 1,
	P$2 = {
		toStringTag: tag
	};
P$2.absoluteValue = P$2.abs = function() {
	var o = new this.constructor(this);
	return o.s < 0 && (o.s = 1), finalise(o)
};
P$2.ceil = function() {
	return finalise(new this.constructor(this), this.e + 1, 2)
};
P$2.clampedTo = P$2.clamp = function(o, s) {
	var a, l = this,
		c = l.constructor;
	if (o = new c(o), s = new c(s), !o.s || !s.s) return new c(NaN);
	if (o.gt(s)) throw Error(invalidArgument + s);
	return a = l.cmp(o), a < 0 ? o : l.cmp(s) > 0 ? s : new c(l)
};
P$2.comparedTo = P$2.cmp = function(o) {
	var s, a, l, c, d = this,
		f = d.d,
		m = (o = new d.constructor(o)).d,
		g = d.s,
		v = o.s;
	if (!f || !m) return !g || !v ? NaN : g !== v ? g : f === m ? 0 : !f ^ g < 0 ? 1 : -1;
	if (!f[0] || !m[0]) return f[0] ? g : m[0] ? -v : 0;
	if (g !== v) return g;
	if (d.e !== o.e) return d.e > o.e ^ g < 0 ? 1 : -1;
	for (l = f.length, c = m.length, s = 0, a = l < c ? l : c; s < a; ++s)
		if (f[s] !== m[s]) return f[s] > m[s] ^ g < 0 ? 1 : -1;
	return l === c ? 0 : l > c ^ g < 0 ? 1 : -1
};
P$2.cosine = P$2.cos = function() {
	var o, s, a = this,
		l = a.constructor;
	return a.d ? a.d[0] ? (o = l.precision, s = l.rounding, l.precision = o + Math.max(a.e, a.sd()) + LOG_BASE, l
		.rounding = 1, a = cosine(l, toLessThanHalfPi(l, a)), l.precision = o, l.rounding = s, finalise(
			quadrant == 2 || quadrant == 3 ? a.neg() : a, o, s, !0)) : new l(1) : new l(NaN)
};
P$2.cubeRoot = P$2.cbrt = function() {
	var o, s, a, l, c, d, f, m, g, v, y = this,
		b = y.constructor;
	if (!y.isFinite() || y.isZero()) return new b(y);
	for (external = !1, d = y.s * mathpow(y.s * y, 1 / 3), !d || Math.abs(d) == 1 / 0 ? (a = digitsToString(y.d),
			o = y.e, (d = (o - a.length + 1) % 3) && (a += d == 1 || d == -2 ? "0" : "00"), d = mathpow(a, 1 / 3),
			o = mathfloor((o + 1) / 3) - (o % 3 == (o < 0 ? -1 : 2)), d == 1 / 0 ? a = "5e" + o : (a = d
				.toExponential(), a = a.slice(0, a.indexOf("e") + 1) + o), l = new b(a), l.s = y.s) : l = new b(d
			.toString()), f = (o = b.precision) + 3;;)
		if (m = l, g = m.times(m).times(m), v = g.plus(y), l = divide(v.plus(y).times(m), v.plus(g), f + 2, 1),
			digitsToString(m.d).slice(0, f) === (a = digitsToString(l.d)).slice(0, f))
			if (a = a.slice(f - 3, f + 1), a == "9999" || !c && a == "4999") {
				if (!c && (finalise(m, o + 1, 0), m.times(m).times(m).eq(y))) {
					l = m;
					break
				}
				f += 4, c = 1
			} else {
				(!+a || !+a.slice(1) && a.charAt(0) == "5") && (finalise(l, o + 1, 1), s = !l.times(l).times(l).eq(
					y));
				break
			} return external = !0, finalise(l, o, b.rounding, s)
};
P$2.decimalPlaces = P$2.dp = function() {
	var o, s = this.d,
		a = NaN;
	if (s) {
		if (o = s.length - 1, a = (o - mathfloor(this.e / LOG_BASE)) * LOG_BASE, o = s[o], o)
			for (; o % 10 == 0; o /= 10) a--;
		a < 0 && (a = 0)
	}
	return a
};
P$2.dividedBy = P$2.div = function(o) {
	return divide(this, new this.constructor(o))
};
P$2.dividedToIntegerBy = P$2.divToInt = function(o) {
	var s = this,
		a = s.constructor;
	return finalise(divide(s, new a(o), 0, 1, 1), a.precision, a.rounding)
};
P$2.equals = P$2.eq = function(o) {
	return this.cmp(o) === 0
};
P$2.floor = function() {
	return finalise(new this.constructor(this), this.e + 1, 3)
};
P$2.greaterThan = P$2.gt = function(o) {
	return this.cmp(o) > 0
};
P$2.greaterThanOrEqualTo = P$2.gte = function(o) {
	var s = this.cmp(o);
	return s == 1 || s === 0
};
P$2.hyperbolicCosine = P$2.cosh = function() {
	var o, s, a, l, c, d = this,
		f = d.constructor,
		m = new f(1);
	if (!d.isFinite()) return new f(d.s ? 1 / 0 : NaN);
	if (d.isZero()) return m;
	a = f.precision, l = f.rounding, f.precision = a + Math.max(d.e, d.sd()) + 4, f.rounding = 1, c = d.d.length,
		c < 32 ? (o = Math.ceil(c / 3), s = (1 / tinyPow(4, o)).toString()) : (o = 16, s =
			"2.3283064365386962890625e-10"), d = taylorSeries(f, 1, d.times(s), new f(1), !0);
	for (var g, v = o, y = new f(8); v--;) g = d.times(d), d = m.minus(g.times(y.minus(g.times(y))));
	return finalise(d, f.precision = a, f.rounding = l, !0)
};
P$2.hyperbolicSine = P$2.sinh = function() {
	var o, s, a, l, c = this,
		d = c.constructor;
	if (!c.isFinite() || c.isZero()) return new d(c);
	if (s = d.precision, a = d.rounding, d.precision = s + Math.max(c.e, c.sd()) + 4, d.rounding = 1, l = c.d
		.length, l < 3) c = taylorSeries(d, 2, c, c, !0);
	else {
		o = 1.4 * Math.sqrt(l), o = o > 16 ? 16 : o | 0, c = c.times(1 / tinyPow(5, o)), c = taylorSeries(d, 2, c,
			c, !0);
		for (var f, m = new d(5), g = new d(16), v = new d(20); o--;) f = c.times(c), c = c.times(m.plus(f.times(g
			.times(f).plus(v))))
	}
	return d.precision = s, d.rounding = a, finalise(c, s, a, !0)
};
P$2.hyperbolicTangent = P$2.tanh = function() {
	var o, s, a = this,
		l = a.constructor;
	return a.isFinite() ? a.isZero() ? new l(a) : (o = l.precision, s = l.rounding, l.precision = o + 7, l
		.rounding = 1, divide(a.sinh(), a.cosh(), l.precision = o, l.rounding = s)) : new l(a.s)
};
P$2.inverseCosine = P$2.acos = function() {
	var o = this,
		s = o.constructor,
		a = o.abs().cmp(1),
		l = s.precision,
		c = s.rounding;
	return a !== -1 ? a === 0 ? o.isNeg() ? getPi(s, l, c) : new s(0) : new s(NaN) : o.isZero() ? getPi(s, l + 4, c)
		.times(.5) : (s.precision = l + 6, s.rounding = 1, o = new s(1).minus(o).div(o.plus(1)).sqrt().atan(), s
			.precision = l, s.rounding = c, o.times(2))
};
P$2.inverseHyperbolicCosine = P$2.acosh = function() {
	var o, s, a = this,
		l = a.constructor;
	return a.lte(1) ? new l(a.eq(1) ? 0 : NaN) : a.isFinite() ? (o = l.precision, s = l.rounding, l.precision = o +
		Math.max(Math.abs(a.e), a.sd()) + 4, l.rounding = 1, external = !1, a = a.times(a).minus(1).sqrt().plus(
			a), external = !0, l.precision = o, l.rounding = s, a.ln()) : new l(a)
};
P$2.inverseHyperbolicSine = P$2.asinh = function() {
	var o, s, a = this,
		l = a.constructor;
	return !a.isFinite() || a.isZero() ? new l(a) : (o = l.precision, s = l.rounding, l.precision = o + 2 * Math
		.max(Math.abs(a.e), a.sd()) + 6, l.rounding = 1, external = !1, a = a.times(a).plus(1).sqrt().plus(a),
		external = !0, l.precision = o, l.rounding = s, a.ln())
};
P$2.inverseHyperbolicTangent = P$2.atanh = function() {
	var o, s, a, l, c = this,
		d = c.constructor;
	return c.isFinite() ? c.e >= 0 ? new d(c.abs().eq(1) ? c.s / 0 : c.isZero() ? c : NaN) : (o = d.precision, s = d
		.rounding, l = c.sd(), Math.max(l, o) < 2 * -c.e - 1 ? finalise(new d(c), o, s, !0) : (d.precision = a =
			l - c.e, c = divide(c.plus(1), new d(1).minus(c), a + o, 1), d.precision = o + 4, d.rounding = 1,
			c = c.ln(), d.precision = o, d.rounding = s, c.times(.5))) : new d(NaN)
};
P$2.inverseSine = P$2.asin = function() {
	var o, s, a, l, c = this,
		d = c.constructor;
	return c.isZero() ? new d(c) : (s = c.abs().cmp(1), a = d.precision, l = d.rounding, s !== -1 ? s === 0 ? (o =
		getPi(d, a + 4, l).times(.5), o.s = c.s, o) : new d(NaN) : (d.precision = a + 6, d.rounding = 1, c =
		c.div(new d(1).minus(c.times(c)).sqrt().plus(1)).atan(), d.precision = a, d.rounding = l, c.times(2)
		))
};
P$2.inverseTangent = P$2.atan = function() {
	var o, s, a, l, c, d, f, m, g, v = this,
		y = v.constructor,
		b = y.precision,
		C = y.rounding;
	if (v.isFinite()) {
		if (v.isZero()) return new y(v);
		if (v.abs().eq(1) && b + 4 <= PI_PRECISION) return f = getPi(y, b + 4, C).times(.25), f.s = v.s, f
	} else {
		if (!v.s) return new y(NaN);
		if (b + 4 <= PI_PRECISION) return f = getPi(y, b + 4, C).times(.5), f.s = v.s, f
	}
	for (y.precision = m = b + 10, y.rounding = 1, a = Math.min(28, m / LOG_BASE + 2 | 0), o = a; o; --o) v = v.div(
		v.times(v).plus(1).sqrt().plus(1));
	for (external = !1, s = Math.ceil(m / LOG_BASE), l = 1, g = v.times(v), f = new y(v), c = v; o !== -1;)
		if (c = c.times(g), d = f.minus(c.div(l += 2)), c = c.times(g), f = d.plus(c.div(l += 2)), f.d[s] !==
			void 0)
			for (o = s; f.d[o] === d.d[o] && o--;);
	return a && (f = f.times(2 << a - 1)), external = !0, finalise(f, y.precision = b, y.rounding = C, !0)
};
P$2.isFinite = function() {
	return !!this.d
};
P$2.isInteger = P$2.isInt = function() {
	return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2
};
P$2.isNaN = function() {
	return !this.s
};
P$2.isNegative = P$2.isNeg = function() {
	return this.s < 0
};
P$2.isPositive = P$2.isPos = function() {
	return this.s > 0
};
P$2.isZero = function() {
	return !!this.d && this.d[0] === 0
};
P$2.lessThan = P$2.lt = function(o) {
	return this.cmp(o) < 0
};
P$2.lessThanOrEqualTo = P$2.lte = function(o) {
	return this.cmp(o) < 1
};
P$2.logarithm = P$2.log = function(o) {
	var s, a, l, c, d, f, m, g, v = this,
		y = v.constructor,
		b = y.precision,
		C = y.rounding,
		_ = 5;
	if (o == null) o = new y(10), s = !0;
	else {
		if (o = new y(o), a = o.d, o.s < 0 || !a || !a[0] || o.eq(1)) return new y(NaN);
		s = o.eq(10)
	}
	if (a = v.d, v.s < 0 || !a || !a[0] || v.eq(1)) return new y(a && !a[0] ? -1 / 0 : v.s != 1 ? NaN : a ? 0 : 1 /
		0);
	if (s)
		if (a.length > 1) d = !0;
		else {
			for (c = a[0]; c % 10 === 0;) c /= 10;
			d = c !== 1
		} if (external = !1, m = b + _, f = naturalLogarithm(v, m), l = s ? getLn10(y, m + 10) : naturalLogarithm(o,
			m), g = divide(f, l, m, 1), checkRoundingDigits(g.d, c = b, C))
		do
			if (m += 10, f = naturalLogarithm(v, m), l = s ? getLn10(y, m + 10) : naturalLogarithm(o, m), g =
				divide(f, l, m, 1), !d) {
				+digitsToString(g.d).slice(c + 1, c + 15) + 1 == 1e14 && (g = finalise(g, b + 1, 0));
				break
			} while (checkRoundingDigits(g.d, c += 10, C));
	return external = !0, finalise(g, b, C)
};
P$2.minus = P$2.sub = function(o) {
	var s, a, l, c, d, f, m, g, v, y, b, C, _ = this,
		S = _.constructor;
	if (o = new S(o), !_.d || !o.d) return !_.s || !o.s ? o = new S(NaN) : _.d ? o.s = -o.s : o = new S(o.d || _
		.s !== o.s ? _ : NaN), o;
	if (_.s != o.s) return o.s = -o.s, _.plus(o);
	if (v = _.d, C = o.d, m = S.precision, g = S.rounding, !v[0] || !C[0]) {
		if (C[0]) o.s = -o.s;
		else if (v[0]) o = new S(_);
		else return new S(g === 3 ? -0 : 0);
		return external ? finalise(o, m, g) : o
	}
	if (a = mathfloor(o.e / LOG_BASE), y = mathfloor(_.e / LOG_BASE), v = v.slice(), d = y - a, d) {
		for (b = d < 0, b ? (s = v, d = -d, f = C.length) : (s = C, a = y, f = v.length), l = Math.max(Math.ceil(m /
				LOG_BASE), f) + 2, d > l && (d = l, s.length = 1), s.reverse(), l = d; l--;) s.push(0);
		s.reverse()
	} else {
		for (l = v.length, f = C.length, b = l < f, b && (f = l), l = 0; l < f; l++)
			if (v[l] != C[l]) {
				b = v[l] < C[l];
				break
			} d = 0
	}
	for (b && (s = v, v = C, C = s, o.s = -o.s), f = v.length, l = C.length - f; l > 0; --l) v[f++] = 0;
	for (l = C.length; l > d;) {
		if (v[--l] < C[l]) {
			for (c = l; c && v[--c] === 0;) v[c] = BASE - 1;
			--v[c], v[l] += BASE
		}
		v[l] -= C[l]
	}
	for (; v[--f] === 0;) v.pop();
	for (; v[0] === 0; v.shift()) --a;
	return v[0] ? (o.d = v, o.e = getBase10Exponent(v, a), external ? finalise(o, m, g) : o) : new S(g === 3 ? -0 :
		0)
};
P$2.modulo = P$2.mod = function(o) {
	var s, a = this,
		l = a.constructor;
	return o = new l(o), !a.d || !o.s || o.d && !o.d[0] ? new l(NaN) : !o.d || a.d && !a.d[0] ? finalise(new l(a), l
		.precision, l.rounding) : (external = !1, l.modulo == 9 ? (s = divide(a, o.abs(), 0, 3, 1), s.s *= o
		.s) : s = divide(a, o, 0, l.modulo, 1), s = s.times(o), external = !0, a.minus(s))
};
P$2.naturalExponential = P$2.exp = function() {
	return naturalExponential(this)
};
P$2.naturalLogarithm = P$2.ln = function() {
	return naturalLogarithm(this)
};
P$2.negated = P$2.neg = function() {
	var o = new this.constructor(this);
	return o.s = -o.s, finalise(o)
};
P$2.plus = P$2.add = function(o) {
	var s, a, l, c, d, f, m, g, v, y, b = this,
		C = b.constructor;
	if (o = new C(o), !b.d || !o.d) return !b.s || !o.s ? o = new C(NaN) : b.d || (o = new C(o.d || b.s === o.s ?
		b : NaN)), o;
	if (b.s != o.s) return o.s = -o.s, b.minus(o);
	if (v = b.d, y = o.d, m = C.precision, g = C.rounding, !v[0] || !y[0]) return y[0] || (o = new C(b)), external ?
		finalise(o, m, g) : o;
	if (d = mathfloor(b.e / LOG_BASE), l = mathfloor(o.e / LOG_BASE), v = v.slice(), c = d - l, c) {
		for (c < 0 ? (a = v, c = -c, f = y.length) : (a = y, l = d, f = v.length), d = Math.ceil(m / LOG_BASE), f =
			d > f ? d + 1 : f + 1, c > f && (c = f, a.length = 1), a.reverse(); c--;) a.push(0);
		a.reverse()
	}
	for (f = v.length, c = y.length, f - c < 0 && (c = f, a = y, y = v, v = a), s = 0; c;) s = (v[--c] = v[c] + y[
		c] + s) / BASE | 0, v[c] %= BASE;
	for (s && (v.unshift(s), ++l), f = v.length; v[--f] == 0;) v.pop();
	return o.d = v, o.e = getBase10Exponent(v, l), external ? finalise(o, m, g) : o
};
P$2.precision = P$2.sd = function(o) {
	var s, a = this;
	if (o !== void 0 && o !== !!o && o !== 1 && o !== 0) throw Error(invalidArgument + o);
	return a.d ? (s = getPrecision(a.d), o && a.e + 1 > s && (s = a.e + 1)) : s = NaN, s
};
P$2.round = function() {
	var o = this,
		s = o.constructor;
	return finalise(new s(o), o.e + 1, s.rounding)
};
P$2.sine = P$2.sin = function() {
	var o, s, a = this,
		l = a.constructor;
	return a.isFinite() ? a.isZero() ? new l(a) : (o = l.precision, s = l.rounding, l.precision = o + Math.max(a.e,
			a.sd()) + LOG_BASE, l.rounding = 1, a = sine(l, toLessThanHalfPi(l, a)), l.precision = o, l
		.rounding = s, finalise(quadrant > 2 ? a.neg() : a, o, s, !0)) : new l(NaN)
};
P$2.squareRoot = P$2.sqrt = function() {
	var o, s, a, l, c, d, f = this,
		m = f.d,
		g = f.e,
		v = f.s,
		y = f.constructor;
	if (v !== 1 || !m || !m[0]) return new y(!v || v < 0 && (!m || m[0]) ? NaN : m ? f : 1 / 0);
	for (external = !1, v = Math.sqrt(+f), v == 0 || v == 1 / 0 ? (s = digitsToString(m), (s.length + g) % 2 == 0 &&
			(s += "0"), v = Math.sqrt(s), g = mathfloor((g + 1) / 2) - (g < 0 || g % 2), v == 1 / 0 ? s = "5e" + g :
			(s = v.toExponential(), s = s.slice(0, s.indexOf("e") + 1) + g), l = new y(s)) : l = new y(v
	.toString()), a = (g = y.precision) + 3;;)
		if (d = l, l = d.plus(divide(f, d, a + 2, 1)).times(.5), digitsToString(d.d).slice(0, a) === (s =
				digitsToString(l.d)).slice(0, a))
			if (s = s.slice(a - 3, a + 1), s == "9999" || !c && s == "4999") {
				if (!c && (finalise(d, g + 1, 0), d.times(d).eq(f))) {
					l = d;
					break
				}
				a += 4, c = 1
			} else {
				(!+s || !+s.slice(1) && s.charAt(0) == "5") && (finalise(l, g + 1, 1), o = !l.times(l).eq(f));
				break
			} return external = !0, finalise(l, g, y.rounding, o)
};
P$2.tangent = P$2.tan = function() {
	var o, s, a = this,
		l = a.constructor;
	return a.isFinite() ? a.isZero() ? new l(a) : (o = l.precision, s = l.rounding, l.precision = o + 10, l
			.rounding = 1, a = a.sin(), a.s = 1, a = divide(a, new l(1).minus(a.times(a)).sqrt(), o + 10, 0), l
			.precision = o, l.rounding = s, finalise(quadrant == 2 || quadrant == 4 ? a.neg() : a, o, s, !0)) :
		new l(NaN)
};
P$2.times = P$2.mul = function(o) {
	var s, a, l, c, d, f, m, g, v, y = this,
		b = y.constructor,
		C = y.d,
		_ = (o = new b(o)).d;
	if (o.s *= y.s, !C || !C[0] || !_ || !_[0]) return new b(!o.s || C && !C[0] && !_ || _ && !_[0] && !C ? NaN : !
		C || !_ ? o.s / 0 : o.s * 0);
	for (a = mathfloor(y.e / LOG_BASE) + mathfloor(o.e / LOG_BASE), g = C.length, v = _.length, g < v && (d = C, C =
			_, _ = d, f = g, g = v, v = f), d = [], f = g + v, l = f; l--;) d.push(0);
	for (l = v; --l >= 0;) {
		for (s = 0, c = g + l; c > l;) m = d[c] + _[l] * C[c - l - 1] + s, d[c--] = m % BASE | 0, s = m / BASE | 0;
		d[c] = (d[c] + s) % BASE | 0
	}
	for (; !d[--f];) d.pop();
	return s ? ++a : d.shift(), o.d = d, o.e = getBase10Exponent(d, a), external ? finalise(o, b.precision, b
		.rounding) : o
};
P$2.toBinary = function(o, s) {
	return toStringBinary(this, 2, o, s)
};
P$2.toDecimalPlaces = P$2.toDP = function(o, s) {
	var a = this,
		l = a.constructor;
	return a = new l(a), o === void 0 ? a : (checkInt32(o, 0, MAX_DIGITS), s === void 0 ? s = l.rounding :
		checkInt32(s, 0, 8), finalise(a, o + a.e + 1, s))
};
P$2.toExponential = function(o, s) {
	var a, l = this,
		c = l.constructor;
	return o === void 0 ? a = finiteToString(l, !0) : (checkInt32(o, 0, MAX_DIGITS), s === void 0 ? s = c.rounding :
			checkInt32(s, 0, 8), l = finalise(new c(l), o + 1, s), a = finiteToString(l, !0, o + 1)), l.isNeg() && !
		l.isZero() ? "-" + a : a
};
P$2.toFixed = function(o, s) {
	var a, l, c = this,
		d = c.constructor;
	return o === void 0 ? a = finiteToString(c) : (checkInt32(o, 0, MAX_DIGITS), s === void 0 ? s = d.rounding :
			checkInt32(s, 0, 8), l = finalise(new d(c), o + c.e + 1, s), a = finiteToString(l, !1, o + l.e + 1)), c
		.isNeg() && !c.isZero() ? "-" + a : a
};
P$2.toFraction = function(o) {
	var s, a, l, c, d, f, m, g, v, y, b, C, _ = this,
		S = _.d,
		w = _.constructor;
	if (!S) return new w(_);
	if (v = a = new w(1), l = g = new w(0), s = new w(l), d = s.e = getPrecision(S) - _.e - 1, f = d % LOG_BASE, s
		.d[0] = mathpow(10, f < 0 ? LOG_BASE + f : f), o == null) o = d > 0 ? s : v;
	else {
		if (m = new w(o), !m.isInt() || m.lt(v)) throw Error(invalidArgument + m);
		o = m.gt(s) ? d > 0 ? s : v : m
	}
	for (external = !1, m = new w(digitsToString(S)), y = w.precision, w.precision = d = S.length * LOG_BASE *
		2; b = divide(m, s, 0, 1, 1), c = a.plus(b.times(l)), c.cmp(o) != 1;) a = l, l = c, c = v, v = g.plus(b
		.times(c)), g = c, c = s, s = m.minus(b.times(c)), m = c;
	return c = divide(o.minus(a), l, 0, 1, 1), g = g.plus(c.times(v)), a = a.plus(c.times(l)), g.s = v.s = _.s, C =
		divide(v, l, d, 1).minus(_).abs().cmp(divide(g, a, d, 1).minus(_).abs()) < 1 ? [v, l] : [g, a], w
		.precision = y, external = !0, C
};
P$2.toHexadecimal = P$2.toHex = function(o, s) {
	return toStringBinary(this, 16, o, s)
};
P$2.toNearest = function(o, s) {
	var a = this,
		l = a.constructor;
	if (a = new l(a), o == null) {
		if (!a.d) return a;
		o = new l(1), s = l.rounding
	} else {
		if (o = new l(o), s === void 0 ? s = l.rounding : checkInt32(s, 0, 8), !a.d) return o.s ? a : o;
		if (!o.d) return o.s && (o.s = a.s), o
	}
	return o.d[0] ? (external = !1, a = divide(a, o, 0, s, 1).times(o), external = !0, finalise(a)) : (o.s = a.s,
		a = o), a
};
P$2.toNumber = function() {
	return +this
};
P$2.toOctal = function(o, s) {
	return toStringBinary(this, 8, o, s)
};
P$2.toPower = P$2.pow = function(o) {
	var s, a, l, c, d, f, m = this,
		g = m.constructor,
		v = +(o = new g(o));
	if (!m.d || !o.d || !m.d[0] || !o.d[0]) return new g(mathpow(+m, v));
	if (m = new g(m), m.eq(1)) return m;
	if (l = g.precision, d = g.rounding, o.eq(1)) return finalise(m, l, d);
	if (s = mathfloor(o.e / LOG_BASE), s >= o.d.length - 1 && (a = v < 0 ? -v : v) <= MAX_SAFE_INTEGER) return c =
		intPow(g, m, a, l), o.s < 0 ? new g(1).div(c) : finalise(c, l, d);
	if (f = m.s, f < 0) {
		if (s < o.d.length - 1) return new g(NaN);
		if ((o.d[s] & 1) == 0 && (f = 1), m.e == 0 && m.d[0] == 1 && m.d.length == 1) return m.s = f, m
	}
	return a = mathpow(+m, v), s = a == 0 || !isFinite(a) ? mathfloor(v * (Math.log("0." + digitsToString(m.d)) /
		Math.LN10 + m.e + 1)) : new g(a + "").e, s > g.maxE + 1 || s < g.minE - 1 ? new g(s > 0 ? f / 0 : 0) : (
		external = !1, g.rounding = m.s = 1, a = Math.min(12, (s + "").length), c = naturalExponential(o.times(
			naturalLogarithm(m, l + a)), l), c.d && (c = finalise(c, l + 5, 1), checkRoundingDigits(c.d, l,
			d) && (s = l + 10, c = finalise(naturalExponential(o.times(naturalLogarithm(m, s + a)), s), s + 5,
				1), +digitsToString(c.d).slice(l + 1, l + 15) + 1 == 1e14 && (c = finalise(c, l + 1, 0)))), c
		.s = f, external = !0, g.rounding = d, finalise(c, l, d))
};
P$2.toPrecision = function(o, s) {
	var a, l = this,
		c = l.constructor;
	return o === void 0 ? a = finiteToString(l, l.e <= c.toExpNeg || l.e >= c.toExpPos) : (checkInt32(o, 1,
			MAX_DIGITS), s === void 0 ? s = c.rounding : checkInt32(s, 0, 8), l = finalise(new c(l), o, s), a =
		finiteToString(l, o <= l.e || l.e <= c.toExpNeg, o)), l.isNeg() && !l.isZero() ? "-" + a : a
};
P$2.toSignificantDigits = P$2.toSD = function(o, s) {
	var a = this,
		l = a.constructor;
	return o === void 0 ? (o = l.precision, s = l.rounding) : (checkInt32(o, 1, MAX_DIGITS), s === void 0 ? s = l
		.rounding : checkInt32(s, 0, 8)), finalise(new l(a), o, s)
};
P$2.toString = function() {
	var o = this,
		s = o.constructor,
		a = finiteToString(o, o.e <= s.toExpNeg || o.e >= s.toExpPos);
	return o.isNeg() && !o.isZero() ? "-" + a : a
};
P$2.truncated = P$2.trunc = function() {
	return finalise(new this.constructor(this), this.e + 1, 1)
};
P$2.valueOf = P$2.toJSON = function() {
	var o = this,
		s = o.constructor,
		a = finiteToString(o, o.e <= s.toExpNeg || o.e >= s.toExpPos);
	return o.isNeg() ? "-" + a : a
};

function digitsToString(o) {
	var s, a, l, c = o.length - 1,
		d = "",
		f = o[0];
	if (c > 0) {
		for (d += f, s = 1; s < c; s++) l = o[s] + "", a = LOG_BASE - l.length, a && (d += getZeroString(a)), d += l;
		f = o[s], l = f + "", a = LOG_BASE - l.length, a && (d += getZeroString(a))
	} else if (f === 0) return "0";
	for (; f % 10 === 0;) f /= 10;
	return d + f
}

function checkInt32(o, s, a) {
	if (o !== ~~o || o < s || o > a) throw Error(invalidArgument + o)
}

function checkRoundingDigits(o, s, a, l) {
	var c, d, f, m;
	for (d = o[0]; d >= 10; d /= 10) --s;
	return --s < 0 ? (s += LOG_BASE, c = 0) : (c = Math.ceil((s + 1) / LOG_BASE), s %= LOG_BASE), d = mathpow(10,
		LOG_BASE - s), m = o[c] % d | 0, l == null ? s < 3 ? (s == 0 ? m = m / 100 | 0 : s == 1 && (m = m / 10 | 0),
		f = a < 4 && m == 99999 || a > 3 && m == 49999 || m == 5e4 || m == 0) : f = (a < 4 && m + 1 == d || a > 3 &&
		m + 1 == d / 2) && (o[c + 1] / d / 100 | 0) == mathpow(10, s - 2) - 1 || (m == d / 2 || m == 0) && (o[c +
		1] / d / 100 | 0) == 0 : s < 4 ? (s == 0 ? m = m / 1e3 | 0 : s == 1 ? m = m / 100 | 0 : s == 2 && (m = m /
		10 | 0), f = (l || a < 4) && m == 9999 || !l && a > 3 && m == 4999) : f = ((l || a < 4) && m + 1 == d || !
		l && a > 3 && m + 1 == d / 2) && (o[c + 1] / d / 1e3 | 0) == mathpow(10, s - 3) - 1, f
}

function convertBase(o, s, a) {
	for (var l, c = [0], d, f = 0, m = o.length; f < m;) {
		for (d = c.length; d--;) c[d] *= s;
		for (c[0] += NUMERALS.indexOf(o.charAt(f++)), l = 0; l < c.length; l++) c[l] > a - 1 && (c[l + 1] === void 0 &&
			(c[l + 1] = 0), c[l + 1] += c[l] / a | 0, c[l] %= a)
	}
	return c.reverse()
}

function cosine(o, s) {
	var a, l, c;
	if (s.isZero()) return s;
	l = s.d.length, l < 32 ? (a = Math.ceil(l / 3), c = (1 / tinyPow(4, a)).toString()) : (a = 16, c =
		"2.3283064365386962890625e-10"), o.precision += a, s = taylorSeries(o, 1, s.times(c), new o(1));
	for (var d = a; d--;) {
		var f = s.times(s);
		s = f.times(f).minus(f).times(8).plus(1)
	}
	return o.precision -= a, s
}
var divide = function() {
	function o(l, c, d) {
		var f, m = 0,
			g = l.length;
		for (l = l.slice(); g--;) f = l[g] * c + m, l[g] = f % d | 0, m = f / d | 0;
		return m && l.unshift(m), l
	}

	function s(l, c, d, f) {
		var m, g;
		if (d != f) g = d > f ? 1 : -1;
		else
			for (m = g = 0; m < d; m++)
				if (l[m] != c[m]) {
					g = l[m] > c[m] ? 1 : -1;
					break
				} return g
	}

	function a(l, c, d, f) {
		for (var m = 0; d--;) l[d] -= m, m = l[d] < c[d] ? 1 : 0, l[d] = m * f + l[d] - c[d];
		for (; !l[0] && l.length > 1;) l.shift()
	}
	return function(l, c, d, f, m, g) {
		var v, y, b, C, _, S, w, T, A, k, M, D, F, R, O, U, V, z, j, ge, me = l.constructor,
			he = l.s == c.s ? 1 : -1,
			ce = l.d,
			ae = c.d;
		if (!ce || !ce[0] || !ae || !ae[0]) return new me(!l.s || !c.s || (ce ? ae && ce[0] == ae[0] : !ae) ?
			NaN : ce && ce[0] == 0 || !ae ? he * 0 : he / 0);
		for (g ? (_ = 1, y = l.e - c.e) : (g = BASE, _ = LOG_BASE, y = mathfloor(l.e / _) - mathfloor(c.e / _)),
			j = ae.length, V = ce.length, A = new me(he), k = A.d = [], b = 0; ae[b] == (ce[b] || 0); b++);
		if (ae[b] > (ce[b] || 0) && y--, d == null ? (R = d = me.precision, f = me.rounding) : m ? R = d + (l
				.e - c.e) + 1 : R = d, R < 0) k.push(1), S = !0;
		else {
			if (R = R / _ + 2 | 0, b = 0, j == 1) {
				for (C = 0, ae = ae[0], R++;
					(b < V || C) && R--; b++) O = C * g + (ce[b] || 0), k[b] = O / ae | 0, C = O % ae | 0;
				S = C || b < V
			} else {
				for (C = g / (ae[0] + 1) | 0, C > 1 && (ae = o(ae, C, g), ce = o(ce, C, g), j = ae.length, V =
						ce.length), U = j, M = ce.slice(0, j), D = M.length; D < j;) M[D++] = 0;
				ge = ae.slice(), ge.unshift(0), z = ae[0], ae[1] >= g / 2 && ++z;
				do C = 0, v = s(ae, M, j, D), v < 0 ? (F = M[0], j != D && (F = F * g + (M[1] || 0)), C = F /
					z | 0, C > 1 ? (C >= g && (C = g - 1), w = o(ae, C, g), T = w.length, D = M.length, v =
						s(w, M, T, D), v == 1 && (C--, a(w, j < T ? ge : ae, T, g))) : (C == 0 && (v = C =
						1), w = ae.slice()), T = w.length, T < D && w.unshift(0), a(M, w, D, g), v == -1 &&
					(D = M.length, v = s(ae, M, j, D), v < 1 && (C++, a(M, j < D ? ge : ae, D, g))), D = M
					.length) : v === 0 && (C++, M = [0]), k[b++] = C, v && M[0] ? M[D++] = ce[U] || 0 : (
					M = [ce[U]], D = 1); while ((U++ < V || M[0] !== void 0) && R--);
				S = M[0] !== void 0
			}
			k[0] || k.shift()
		}
		if (_ == 1) A.e = y, inexact = S;
		else {
			for (b = 1, C = k[0]; C >= 10; C /= 10) b++;
			A.e = b + y * _ - 1, finalise(A, m ? d + A.e + 1 : d, f, S)
		}
		return A
	}
}();

function finalise(o, s, a, l) {
	var c, d, f, m, g, v, y, b, C, _ = o.constructor;
	e: if (s != null) {
		if (b = o.d, !b) return o;
		for (c = 1, m = b[0]; m >= 10; m /= 10) c++;
		if (d = s - c, d < 0) d += LOG_BASE, f = s, y = b[C = 0], g = y / mathpow(10, c - f - 1) % 10 | 0;
		else if (C = Math.ceil((d + 1) / LOG_BASE), m = b.length, C >= m)
			if (l) {
				for (; m++ <= C;) b.push(0);
				y = g = 0, c = 1, d %= LOG_BASE, f = d - LOG_BASE + 1
			} else break e;
		else {
			for (y = m = b[C], c = 1; m >= 10; m /= 10) c++;
			d %= LOG_BASE, f = d - LOG_BASE + c, g = f < 0 ? 0 : y / mathpow(10, c - f - 1) % 10 | 0
		}
		if (l = l || s < 0 || b[C + 1] !== void 0 || (f < 0 ? y : y % mathpow(10, c - f - 1)), v = a < 4 ? (g ||
			l) && (a == 0 || a == (o.s < 0 ? 3 : 2)) : g > 5 || g == 5 && (a == 4 || l || a == 6 && (d > 0 ? f > 0 ?
				y / mathpow(10, c - f) : 0 : b[C - 1]) % 10 & 1 || a == (o.s < 0 ? 8 : 7)), s < 1 || !b[0]) return b
			.length = 0, v ? (s -= o.e + 1, b[0] = mathpow(10, (LOG_BASE - s % LOG_BASE) % LOG_BASE), o.e = -
				s || 0) : b[0] = o.e = 0, o;
		if (d == 0 ? (b.length = C, m = 1, C--) : (b.length = C + 1, m = mathpow(10, LOG_BASE - d), b[C] = f > 0 ? (
				y / mathpow(10, c - f) % mathpow(10, f) | 0) * m : 0), v)
			for (;;)
				if (C == 0) {
					for (d = 1, f = b[0]; f >= 10; f /= 10) d++;
					for (f = b[0] += m, m = 1; f >= 10; f /= 10) m++;
					d != m && (o.e++, b[0] == BASE && (b[0] = 1));
					break
				} else {
					if (b[C] += m, b[C] != BASE) break;
					b[C--] = 0, m = 1
				} for (d = b.length; b[--d] === 0;) b.pop()
	}
	return external && (o.e > _.maxE ? (o.d = null, o.e = NaN) : o.e < _.minE && (o.e = 0, o.d = [0])), o
}

function finiteToString(o, s, a) {
	if (!o.isFinite()) return nonFiniteToString(o);
	var l, c = o.e,
		d = digitsToString(o.d),
		f = d.length;
	return s ? (a && (l = a - f) > 0 ? d = d.charAt(0) + "." + d.slice(1) + getZeroString(l) : f > 1 && (d = d.charAt(
		0) + "." + d.slice(1)), d = d + (o.e < 0 ? "e" : "e+") + o.e) : c < 0 ? (d = "0." + getZeroString(-c - 1) +
		d, a && (l = a - f) > 0 && (d += getZeroString(l))) : c >= f ? (d += getZeroString(c + 1 - f), a && (l = a -
		c - 1) > 0 && (d = d + "." + getZeroString(l))) : ((l = c + 1) < f && (d = d.slice(0, l) + "." + d.slice(
		l)), a && (l = a - f) > 0 && (c + 1 === f && (d += "."), d += getZeroString(l))), d
}

function getBase10Exponent(o, s) {
	var a = o[0];
	for (s *= LOG_BASE; a >= 10; a /= 10) s++;
	return s
}

function getLn10(o, s, a) {
	if (s > LN10_PRECISION) throw external = !0, a && (o.precision = a), Error(precisionLimitExceeded);
	return finalise(new o(LN10), s, 1, !0)
}

function getPi(o, s, a) {
	if (s > PI_PRECISION) throw Error(precisionLimitExceeded);
	return finalise(new o(PI), s, a, !0)
}

function getPrecision(o) {
	var s = o.length - 1,
		a = s * LOG_BASE + 1;
	if (s = o[s], s) {
		for (; s % 10 == 0; s /= 10) a--;
		for (s = o[0]; s >= 10; s /= 10) a++
	}
	return a
}

function getZeroString(o) {
	for (var s = ""; o--;) s += "0";
	return s
}

function intPow(o, s, a, l) {
	var c, d = new o(1),
		f = Math.ceil(l / LOG_BASE + 4);
	for (external = !1;;) {
		if (a % 2 && (d = d.times(s), truncate(d.d, f) && (c = !0)), a = mathfloor(a / 2), a === 0) {
			a = d.d.length - 1, c && d.d[a] === 0 && ++d.d[a];
			break
		}
		s = s.times(s), truncate(s.d, f)
	}
	return external = !0, d
}

function isOdd(o) {
	return o.d[o.d.length - 1] & 1
}

function maxOrMin(o, s, a) {
	for (var l, c, d = new o(s[0]), f = 0; ++f < s.length;) {
		if (c = new o(s[f]), !c.s) {
			d = c;
			break
		}
		l = d.cmp(c), (l === a || l === 0 && d.s === a) && (d = c)
	}
	return d
}

function naturalExponential(o, s) {
	var a, l, c, d, f, m, g, v = 0,
		y = 0,
		b = 0,
		C = o.constructor,
		_ = C.rounding,
		S = C.precision;
	if (!o.d || !o.d[0] || o.e > 17) return new C(o.d ? o.d[0] ? o.s < 0 ? 0 : 1 / 0 : 1 : o.s ? o.s < 0 ? 0 : o : NaN);
	for (s == null ? (external = !1, g = S) : g = s, m = new C(.03125); o.e > -2;) o = o.times(m), b += 5;
	for (l = Math.log(mathpow(2, b)) / Math.LN10 * 2 + 5 | 0, g += l, a = d = f = new C(1), C.precision = g;;) {
		if (d = finalise(d.times(o), g, 1), a = a.times(++y), m = f.plus(divide(d, a, g, 1)), digitsToString(m.d).slice(
				0, g) === digitsToString(f.d).slice(0, g)) {
			for (c = b; c--;) f = finalise(f.times(f), g, 1);
			if (s == null)
				if (v < 3 && checkRoundingDigits(f.d, g - l, _, v)) C.precision = g += 10, a = d = m = new C(1), y = 0,
					v++;
				else return finalise(f, C.precision = S, _, external = !0);
			else return C.precision = S, f
		}
		f = m
	}
}

function naturalLogarithm(o, s) {
	var a, l, c, d, f, m, g, v, y, b, C, _ = 1,
		S = 10,
		w = o,
		T = w.d,
		A = w.constructor,
		k = A.rounding,
		M = A.precision;
	if (w.s < 0 || !T || !T[0] || !w.e && T[0] == 1 && T.length == 1) return new A(T && !T[0] ? -1 / 0 : w.s != 1 ?
		NaN : T ? 0 : w);
	if (s == null ? (external = !1, y = M) : y = s, A.precision = y += S, a = digitsToString(T), l = a.charAt(0), Math
		.abs(d = w.e) < 15e14) {
		for (; l < 7 && l != 1 || l == 1 && a.charAt(1) > 3;) w = w.times(o), a = digitsToString(w.d), l = a.charAt(0),
			_++;
		d = w.e, l > 1 ? (w = new A("0." + a), d++) : w = new A(l + "." + a.slice(1))
	} else return v = getLn10(A, y + 2, M).times(d + ""), w = naturalLogarithm(new A(l + "." + a.slice(1)), y - S).plus(
		v), A.precision = M, s == null ? finalise(w, M, k, external = !0) : w;
	for (b = w, g = f = w = divide(w.minus(1), w.plus(1), y, 1), C = finalise(w.times(w), y, 1), c = 3;;) {
		if (f = finalise(f.times(C), y, 1), v = g.plus(divide(f, new A(c), y, 1)), digitsToString(v.d).slice(0, y) ===
			digitsToString(g.d).slice(0, y))
			if (g = g.times(2), d !== 0 && (g = g.plus(getLn10(A, y + 2, M).times(d + ""))), g = divide(g, new A(_), y,
					1), s == null)
				if (checkRoundingDigits(g.d, y - S, k, m)) A.precision = y += S, v = f = w = divide(b.minus(1), b.plus(
					1), y, 1), C = finalise(w.times(w), y, 1), c = m = 1;
				else return finalise(g, A.precision = M, k, external = !0);
		else return A.precision = M, g;
		g = v, c += 2
	}
}

function nonFiniteToString(o) {
	return String(o.s * o.s / 0)
}

function parseDecimal(o, s) {
	var a, l, c;
	for ((a = s.indexOf(".")) > -1 && (s = s.replace(".", "")), (l = s.search(/e/i)) > 0 ? (a < 0 && (a = l), a += +s
			.slice(l + 1), s = s.substring(0, l)) : a < 0 && (a = s.length), l = 0; s.charCodeAt(l) === 48; l++);
	for (c = s.length; s.charCodeAt(c - 1) === 48; --c);
	if (s = s.slice(l, c), s) {
		if (c -= l, o.e = a = a - l - 1, o.d = [], l = (a + 1) % LOG_BASE, a < 0 && (l += LOG_BASE), l < c) {
			for (l && o.d.push(+s.slice(0, l)), c -= LOG_BASE; l < c;) o.d.push(+s.slice(l, l += LOG_BASE));
			s = s.slice(l), l = LOG_BASE - s.length
		} else l -= c;
		for (; l--;) s += "0";
		o.d.push(+s), external && (o.e > o.constructor.maxE ? (o.d = null, o.e = NaN) : o.e < o.constructor.minE && (o
			.e = 0, o.d = [0]))
	} else o.e = 0, o.d = [0];
	return o
}

function parseOther(o, s) {
	var a, l, c, d, f, m, g, v, y;
	if (s.indexOf("_") > -1) {
		if (s = s.replace(/(\d)_(?=\d)/g, "$1"), isDecimal.test(s)) return parseDecimal(o, s)
	} else if (s === "Infinity" || s === "NaN") return +s || (o.s = NaN), o.e = NaN, o.d = null, o;
	if (isHex.test(s)) a = 16, s = s.toLowerCase();
	else if (isBinary.test(s)) a = 2;
	else if (isOctal.test(s)) a = 8;
	else throw Error(invalidArgument + s);
	for (d = s.search(/p/i), d > 0 ? (g = +s.slice(d + 1), s = s.substring(2, d)) : s = s.slice(2), d = s.indexOf("."),
		f = d >= 0, l = o.constructor, f && (s = s.replace(".", ""), m = s.length, d = m - d, c = intPow(l, new l(a), d,
			d * 2)), v = convertBase(s, a, BASE), y = v.length - 1, d = y; v[d] === 0; --d) v.pop();
	return d < 0 ? new l(o.s * 0) : (o.e = getBase10Exponent(v, y), o.d = v, external = !1, f && (o = divide(o, c, m *
		4)), g && (o = o.times(Math.abs(g) < 54 ? mathpow(2, g) : Decimal.pow(2, g))), external = !0, o)
}

function sine(o, s) {
	var a, l = s.d.length;
	if (l < 3) return s.isZero() ? s : taylorSeries(o, 2, s, s);
	a = 1.4 * Math.sqrt(l), a = a > 16 ? 16 : a | 0, s = s.times(1 / tinyPow(5, a)), s = taylorSeries(o, 2, s, s);
	for (var c, d = new o(5), f = new o(16), m = new o(20); a--;) c = s.times(s), s = s.times(d.plus(c.times(f.times(c)
		.minus(m))));
	return s
}

function taylorSeries(o, s, a, l, c) {
	var d, f, m, g, v = o.precision,
		y = Math.ceil(v / LOG_BASE);
	for (external = !1, g = a.times(a), m = new o(l);;) {
		if (f = divide(m.times(g), new o(s++ * s++), v, 1), m = c ? l.plus(f) : l.minus(f), l = divide(f.times(g),
				new o(s++ * s++), v, 1), f = m.plus(l), f.d[y] !== void 0) {
			for (d = y; f.d[d] === m.d[d] && d--;);
			if (d == -1) break
		}
		d = m, m = l, l = f, f = d
	}
	return external = !0, f.d.length = y + 1, f
}

function tinyPow(o, s) {
	for (var a = o; --s;) a *= o;
	return a
}

function toLessThanHalfPi(o, s) {
	var a, l = s.s < 0,
		c = getPi(o, o.precision, 1),
		d = c.times(.5);
	if (s = s.abs(), s.lte(d)) return quadrant = l ? 4 : 1, s;
	if (a = s.divToInt(c), a.isZero()) quadrant = l ? 3 : 2;
	else {
		if (s = s.minus(a.times(c)), s.lte(d)) return quadrant = isOdd(a) ? l ? 2 : 3 : l ? 4 : 1, s;
		quadrant = isOdd(a) ? l ? 1 : 4 : l ? 3 : 2
	}
	return s.minus(c).abs()
}

function toStringBinary(o, s, a, l) {
	var c, d, f, m, g, v, y, b, C, _ = o.constructor,
		S = a !== void 0;
	if (S ? (checkInt32(a, 1, MAX_DIGITS), l === void 0 ? l = _.rounding : checkInt32(l, 0, 8)) : (a = _.precision, l =
			_.rounding), !o.isFinite()) y = nonFiniteToString(o);
	else {
		for (y = finiteToString(o), f = y.indexOf("."), S ? (c = 2, s == 16 ? a = a * 4 - 3 : s == 8 && (a = a * 3 -
			2)) : c = s, f >= 0 && (y = y.replace(".", ""), C = new _(1), C.e = y.length - f, C.d = convertBase(
				finiteToString(C), 10, c), C.e = C.d.length), b = convertBase(y, 10, c), d = g = b.length; b[--g] == 0;)
			b.pop();
		if (!b[0]) y = S ? "0p+0" : "0";
		else {
			if (f < 0 ? d-- : (o = new _(o), o.d = b, o.e = d, o = divide(o, C, a, l, 0, c), b = o.d, d = o.e, v =
					inexact), f = b[a], m = c / 2, v = v || b[a + 1] !== void 0, v = l < 4 ? (f !== void 0 || v) && (
					l === 0 || l === (o.s < 0 ? 3 : 2)) : f > m || f === m && (l === 4 || v || l === 6 && b[a - 1] &
					1 || l === (o.s < 0 ? 8 : 7)), b.length = a, v)
				for (; ++b[--a] > c - 1;) b[a] = 0, a || (++d, b.unshift(1));
			for (g = b.length; !b[g - 1]; --g);
			for (f = 0, y = ""; f < g; f++) y += NUMERALS.charAt(b[f]);
			if (S) {
				if (g > 1)
					if (s == 16 || s == 8) {
						for (f = s == 16 ? 4 : 3, --g; g % f; g++) y += "0";
						for (b = convertBase(y, c, s), g = b.length; !b[g - 1]; --g);
						for (f = 1, y = "1."; f < g; f++) y += NUMERALS.charAt(b[f])
					} else y = y.charAt(0) + "." + y.slice(1);
				y = y + (d < 0 ? "p" : "p+") + d
			} else if (d < 0) {
				for (; ++d;) y = "0" + y;
				y = "0." + y
			} else if (++d > g)
				for (d -= g; d--;) y += "0";
			else d < g && (y = y.slice(0, d) + "." + y.slice(d))
		}
		y = (s == 16 ? "0x" : s == 2 ? "0b" : s == 8 ? "0o" : "") + y
	}
	return o.s < 0 ? "-" + y : y
}

function truncate(o, s) {
	if (o.length > s) return o.length = s, !0
}

function abs$1(o) {
	return new this(o).abs()
}

function acos(o) {
	return new this(o).acos()
}

function acosh(o) {
	return new this(o).acosh()
}

function add(o, s) {
	return new this(o).plus(s)
}

function asin(o) {
	return new this(o).asin()
}

function asinh(o) {
	return new this(o).asinh()
}

function atan(o) {
	return new this(o).atan()
}

function atanh(o) {
	return new this(o).atanh()
}

function atan2(o, s) {
	o = new this(o), s = new this(s);
	var a, l = this.precision,
		c = this.rounding,
		d = l + 4;
	return !o.s || !s.s ? a = new this(NaN) : !o.d && !s.d ? (a = getPi(this, d, 1).times(s.s > 0 ? .25 : .75), a.s = o
			.s) : !s.d || o.isZero() ? (a = s.s < 0 ? getPi(this, l, c) : new this(0), a.s = o.s) : !o.d || s.isZero() ?
		(a = getPi(this, d, 1).times(.5), a.s = o.s) : s.s < 0 ? (this.precision = d, this.rounding = 1, a = this.atan(
				divide(o, s, d, 1)), s = getPi(this, d, 1), this.precision = l, this.rounding = c, a = o.s < 0 ? a
			.minus(s) : a.plus(s)) : a = this.atan(divide(o, s, d, 1)), a
}

function cbrt(o) {
	return new this(o).cbrt()
}

function ceil(o) {
	return finalise(o = new this(o), o.e + 1, 2)
}

function clamp(o, s, a) {
	return new this(o).clamp(s, a)
}

function config(o) {
	if (!o || typeof o != "object") throw Error(decimalError + "Object expected");
	var s, a, l, c = o.defaults === !0,
		d = ["precision", 1, MAX_DIGITS, "rounding", 0, 8, "toExpNeg", -9e15, 0, "toExpPos", 0, EXP_LIMIT, "maxE", 0,
			EXP_LIMIT, "minE", -9e15, 0, "modulo", 0, 9
		];
	for (s = 0; s < d.length; s += 3)
		if (a = d[s], c && (this[a] = DEFAULTS[a]), (l = o[a]) !== void 0)
			if (mathfloor(l) === l && l >= d[s + 1] && l <= d[s + 2]) this[a] = l;
			else throw Error(invalidArgument + a + ": " + l);
	if (a = "crypto", c && (this[a] = DEFAULTS[a]), (l = o[a]) !== void 0)
		if (l === !0 || l === !1 || l === 0 || l === 1)
			if (l)
				if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[a] = !0;
				else throw Error(cryptoUnavailable);
	else this[a] = !1;
	else throw Error(invalidArgument + a + ": " + l);
	return this
}

function cos(o) {
	return new this(o).cos()
}

function cosh$1(o) {
	return new this(o).cosh()
}

function clone$1(o) {
	var s, a, l;

	function c(d) {
		var f, m, g, v = this;
		if (!(v instanceof c)) return new c(d);
		if (v.constructor = c, isDecimalInstance(d)) {
			v.s = d.s, external ? !d.d || d.e > c.maxE ? (v.e = NaN, v.d = null) : d.e < c.minE ? (v.e = 0, v.d = [0]) :
				(v.e = d.e, v.d = d.d.slice()) : (v.e = d.e, v.d = d.d ? d.d.slice() : d.d);
			return
		}
		if (g = typeof d, g === "number") {
			if (d === 0) {
				v.s = 1 / d < 0 ? -1 : 1, v.e = 0, v.d = [0];
				return
			}
			if (d < 0 ? (d = -d, v.s = -1) : v.s = 1, d === ~~d && d < 1e7) {
				for (f = 0, m = d; m >= 10; m /= 10) f++;
				external ? f > c.maxE ? (v.e = NaN, v.d = null) : f < c.minE ? (v.e = 0, v.d = [0]) : (v.e = f, v.d = [
					d]) : (v.e = f, v.d = [d]);
				return
			}
			if (d * 0 !== 0) {
				d || (v.s = NaN), v.e = NaN, v.d = null;
				return
			}
			return parseDecimal(v, d.toString())
		}
		if (g === "string") return (m = d.charCodeAt(0)) === 45 ? (d = d.slice(1), v.s = -1) : (m === 43 && (d = d
			.slice(1)), v.s = 1), isDecimal.test(d) ? parseDecimal(v, d) : parseOther(v, d);
		if (g === "bigint") return d < 0 ? (d = -d, v.s = -1) : v.s = 1, parseDecimal(v, d.toString());
		throw Error(invalidArgument + d)
	}
	if (c.prototype = P$2, c.ROUND_UP = 0, c.ROUND_DOWN = 1, c.ROUND_CEIL = 2, c.ROUND_FLOOR = 3, c.ROUND_HALF_UP = 4, c
		.ROUND_HALF_DOWN = 5, c.ROUND_HALF_EVEN = 6, c.ROUND_HALF_CEIL = 7, c.ROUND_HALF_FLOOR = 8, c.EUCLID = 9, c
		.config = c.set = config, c.clone = clone$1, c.isDecimal = isDecimalInstance, c.abs = abs$1, c.acos = acos, c
		.acosh = acosh, c.add = add, c.asin = asin, c.asinh = asinh, c.atan = atan, c.atanh = atanh, c.atan2 = atan2, c
		.cbrt = cbrt, c.ceil = ceil, c.clamp = clamp, c.cos = cos, c.cosh = cosh$1, c.div = div, c.exp = exp, c.floor =
		floor, c.hypot = hypot$1, c.ln = ln, c.log = log, c.log10 = log10, c.log2 = log2, c.max = max, c.min = min, c
		.mod = mod, c.mul = mul, c.pow = pow, c.random = random, c.round = round, c.sign = sign, c.sin = sin, c.sinh =
		sinh$1, c.sqrt = sqrt, c.sub = sub, c.sum = sum, c.tan = tan, c.tanh = tanh, c.trunc = trunc$1, o === void 0 &&
		(o = {}), o && o.defaults !== !0)
		for (l = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], s = 0; s < l
			.length;) o.hasOwnProperty(a = l[s++]) || (o[a] = this[a]);
	return c.config(o), c
}

function div(o, s) {
	return new this(o).div(s)
}

function exp(o) {
	return new this(o).exp()
}

function floor(o) {
	return finalise(o = new this(o), o.e + 1, 3)
}

function hypot$1() {
	var o, s, a = new this(0);
	for (external = !1, o = 0; o < arguments.length;)
		if (s = new this(arguments[o++]), s.d) a.d && (a = a.plus(s.times(s)));
		else {
			if (s.s) return external = !0, new this(1 / 0);
			a = s
		} return external = !0, a.sqrt()
}

function isDecimalInstance(o) {
	return o instanceof Decimal || o && o.toStringTag === tag || !1
}

function ln(o) {
	return new this(o).ln()
}

function log(o, s) {
	return new this(o).log(s)
}

function log2(o) {
	return new this(o).log(2)
}

function log10(o) {
	return new this(o).log(10)
}

function max() {
	return maxOrMin(this, arguments, -1)
}

function min() {
	return maxOrMin(this, arguments, 1)
}

function mod(o, s) {
	return new this(o).mod(s)
}

function mul(o, s) {
	return new this(o).mul(s)
}

function pow(o, s) {
	return new this(o).pow(s)
}

function random(o) {
	var s, a, l, c, d = 0,
		f = new this(1),
		m = [];
	if (o === void 0 ? o = this.precision : checkInt32(o, 1, MAX_DIGITS), l = Math.ceil(o / LOG_BASE), this.crypto)
		if (crypto.getRandomValues)
			for (s = crypto.getRandomValues(new Uint32Array(l)); d < l;) c = s[d], c >= 429e7 ? s[d] = crypto
				.getRandomValues(new Uint32Array(1))[0] : m[d++] = c % 1e7;
		else if (crypto.randomBytes) {
		for (s = crypto.randomBytes(l *= 4); d < l;) c = s[d] + (s[d + 1] << 8) + (s[d + 2] << 16) + ((s[d + 3] &
			127) << 24), c >= 214e7 ? crypto.randomBytes(4).copy(s, d) : (m.push(c % 1e7), d += 4);
		d = l / 4
	} else throw Error(cryptoUnavailable);
	else
		for (; d < l;) m[d++] = Math.random() * 1e7 | 0;
	for (l = m[--d], o %= LOG_BASE, l && o && (c = mathpow(10, LOG_BASE - o), m[d] = (l / c | 0) * c); m[d] === 0; d--)
		m.pop();
	if (d < 0) a = 0, m = [0];
	else {
		for (a = -1; m[0] === 0; a -= LOG_BASE) m.shift();
		for (l = 1, c = m[0]; c >= 10; c /= 10) l++;
		l < LOG_BASE && (a -= LOG_BASE - l)
	}
	return f.e = a, f.d = m, f
}

function round(o) {
	return finalise(o = new this(o), o.e + 1, this.rounding)
}

function sign(o) {
	return o = new this(o), o.d ? o.d[0] ? o.s : 0 * o.s : o.s || NaN
}

function sin(o) {
	return new this(o).sin()
}

function sinh$1(o) {
	return new this(o).sinh()
}

function sqrt(o) {
	return new this(o).sqrt()
}

function sub(o, s) {
	return new this(o).sub(s)
}

function sum() {
	var o = 0,
		s = arguments,
		a = new this(s[o]);
	for (external = !1; a.s && ++o < s.length;) a = a.plus(s[o]);
	return external = !0, finalise(a, this.precision, this.rounding)
}

function tan(o) {
	return new this(o).tan()
}

function tanh(o) {
	return new this(o).tanh()
}

function trunc$1(o) {
	return finalise(o = new this(o), o.e + 1, 1)
}
P$2[Symbol.for("nodejs.util.inspect.custom")] = P$2.toString;
P$2[Symbol.toStringTag] = "Decimal";
var Decimal = P$2.constructor = clone$1(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var name$r = "BigNumber",
	dependencies$r = ["?on", "config"],
	createBigNumberClass = factory(name$r, dependencies$r, o => {
		var {
			on: s,
			config: a
		} = o, l = Decimal.clone({
			precision: a.precision,
			modulo: Decimal.EUCLID
		});
		return l.prototype = Object.create(l.prototype), l.prototype.type = "BigNumber", l.prototype.isBigNumber = !
			0, l.prototype.toJSON = function() {
				return {
					mathjs: "BigNumber",
					value: this.toString()
				}
			}, l.fromJSON = function(c) {
				return new l(c.value)
			}, s && s("config", function(c, d) {
				c.precision !== d.precision && l.config({
					precision: c.precision
				})
			}), l
	}, {
		isClass: !0
	});
const cosh = Math.cosh || function(o) {
		return Math.abs(o) < 1e-9 ? 1 - o : (Math.exp(o) + Math.exp(-o)) * .5
	},
	sinh = Math.sinh || function(o) {
		return Math.abs(o) < 1e-9 ? o : (Math.exp(o) - Math.exp(-o)) * .5
	},
	cosm1 = function(o) {
		const s = Math.PI / 4;
		if (-s > o || o > s) return Math.cos(o) - 1;
		const a = o * o;
		return a * (a * (a * (a * (a * (a * (a * (a / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) +
			1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2)
	},
	hypot = function(o, s) {
		return o = Math.abs(o), s = Math.abs(s), o < s && ([o, s] = [s, o]), o < 1e8 ? Math.sqrt(o * o + s * s) : (s /=
			o, o * Math.sqrt(1 + s * s))
	},
	parser_exit = function() {
		throw SyntaxError("Invalid Param")
	};

function logHypot(o, s) {
	const a = Math.abs(o),
		l = Math.abs(s);
	return o === 0 ? Math.log(l) : s === 0 ? Math.log(a) : a < 3e3 && l < 3e3 ? Math.log(o * o + s * s) * .5 : (o = o *
		.5, s = s * .5, .5 * Math.log(o * o + s * s) + Math.LN2)
}
const P$1 = {
		re: 0,
		im: 0
	},
	parse$1 = function(o, s) {
		const a = P$1;
		if (o == null) a.re = a.im = 0;
		else if (s !== void 0) a.re = o, a.im = s;
		else switch (typeof o) {
			case "object":
				if ("im" in o && "re" in o) a.re = o.re, a.im = o.im;
				else if ("abs" in o && "arg" in o) {
					if (!isFinite(o.abs) && isFinite(o.arg)) return Complex$1.INFINITY;
					a.re = o.abs * Math.cos(o.arg), a.im = o.abs * Math.sin(o.arg)
				} else if ("r" in o && "phi" in o) {
					if (!isFinite(o.r) && isFinite(o.phi)) return Complex$1.INFINITY;
					a.re = o.r * Math.cos(o.phi), a.im = o.r * Math.sin(o.phi)
				} else o.length === 2 ? (a.re = o[0], a.im = o[1]) : parser_exit();
				break;
			case "string":
				a.im = a.re = 0;
				const l = o.replace(/_/g, "").match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
				let c = 1,
					d = 0;
				l === null && parser_exit();
				for (let f = 0; f < l.length; f++) {
					const m = l[f];
					m === " " || m === "	" || m === `
` || (m === "+" ? c++ : m === "-" ? d++ : m === "i" || m === "I" ? (c + d === 0 && parser_exit(), l[f + 1] !== " " && !
						isNaN(l[f + 1]) ? (a.im += parseFloat((d % 2 ? "-" : "") + l[f + 1]), f++) : a.im +=
						parseFloat((d % 2 ? "-" : "") + "1"), c = d = 0) : ((c + d === 0 || isNaN(m)) &&
						parser_exit(), l[f + 1] === "i" || l[f + 1] === "I" ? (a.im += parseFloat((d % 2 ?
							"-" : "") + m), f++) : a.re += parseFloat((d % 2 ? "-" : "") + m), c = d = 0))
				}
				c + d > 0 && parser_exit();
				break;
			case "number":
				a.im = 0, a.re = o;
				break;
			default:
				parser_exit()
		}
		return isNaN(a.re) || isNaN(a.im), a
	};

function Complex$1(o, s) {
	if (!(this instanceof Complex$1)) return new Complex$1(o, s);
	const a = parse$1(o, s);
	this.re = a.re, this.im = a.im
}
Complex$1.prototype = {
	re: 0,
	im: 0,
	sign: function() {
		const o = hypot(this.re, this.im);
		return new Complex$1(this.re / o, this.im / o)
	},
	add: function(o, s) {
		const a = parse$1(o, s),
			l = this.isInfinite(),
			c = !(isFinite(a.re) && isFinite(a.im));
		return l || c ? l && c ? Complex$1.NAN : Complex$1.INFINITY : new Complex$1(this.re + a.re, this.im + a
			.im)
	},
	sub: function(o, s) {
		const a = parse$1(o, s),
			l = this.isInfinite(),
			c = !(isFinite(a.re) && isFinite(a.im));
		return l || c ? l && c ? Complex$1.NAN : Complex$1.INFINITY : new Complex$1(this.re - a.re, this.im - a
			.im)
	},
	mul: function(o, s) {
		const a = parse$1(o, s),
			l = this.isInfinite(),
			c = !(isFinite(a.re) && isFinite(a.im)),
			d = this.re === 0 && this.im === 0,
			f = a.re === 0 && a.im === 0;
		return l && f || c && d ? Complex$1.NAN : l || c ? Complex$1.INFINITY : a.im === 0 && this.im === 0 ?
			new Complex$1(this.re * a.re, 0) : new Complex$1(this.re * a.re - this.im * a.im, this.re * a.im +
				this.im * a.re)
	},
	div: function(o, s) {
		const a = parse$1(o, s),
			l = this.isInfinite(),
			c = !(isFinite(a.re) && isFinite(a.im)),
			d = this.re === 0 && this.im === 0,
			f = a.re === 0 && a.im === 0;
		if (d && f || l && c) return Complex$1.NAN;
		if (f || l) return Complex$1.INFINITY;
		if (d || c) return Complex$1.ZERO;
		if (a.im === 0) return new Complex$1(this.re / a.re, this.im / a.re);
		if (Math.abs(a.re) < Math.abs(a.im)) {
			const m = a.re / a.im,
				g = a.re * m + a.im;
			return new Complex$1((this.re * m + this.im) / g, (this.im * m - this.re) / g)
		} else {
			const m = a.im / a.re,
				g = a.im * m + a.re;
			return new Complex$1((this.re + this.im * m) / g, (this.im - this.re * m) / g)
		}
	},
	pow: function(o, s) {
		const a = parse$1(o, s),
			l = this.re === 0 && this.im === 0;
		if (a.re === 0 && a.im === 0) return Complex$1.ONE;
		if (a.im === 0) {
			if (this.im === 0 && this.re > 0) return new Complex$1(Math.pow(this.re, a.re), 0);
			if (this.re === 0) switch ((a.re % 4 + 4) % 4) {
				case 0:
					return new Complex$1(Math.pow(this.im, a.re), 0);
				case 1:
					return new Complex$1(0, Math.pow(this.im, a.re));
				case 2:
					return new Complex$1(-Math.pow(this.im, a.re), 0);
				case 3:
					return new Complex$1(0, -Math.pow(this.im, a.re))
			}
		}
		if (l && a.re > 0) return Complex$1.ZERO;
		const d = Math.atan2(this.im, this.re),
			f = logHypot(this.re, this.im);
		let m = Math.exp(a.re * f - a.im * d),
			g = a.im * f + a.re * d;
		return new Complex$1(m * Math.cos(g), m * Math.sin(g))
	},
	sqrt: function() {
		const o = this.re,
			s = this.im;
		if (s === 0) return o >= 0 ? new Complex$1(Math.sqrt(o), 0) : new Complex$1(0, Math.sqrt(-o));
		const a = hypot(o, s);
		let l = Math.sqrt(.5 * (a + Math.abs(o))),
			c = Math.abs(s) / (2 * l);
		return o >= 0 ? new Complex$1(l, s < 0 ? -c : c) : new Complex$1(c, s < 0 ? -l : l)
	},
	exp: function() {
		const o = Math.exp(this.re);
		return this.im === 0 ? new Complex$1(o, 0) : new Complex$1(o * Math.cos(this.im), o * Math.sin(this.im))
	},
	expm1: function() {
		const o = this.re,
			s = this.im;
		return new Complex$1(Math.expm1(o) * Math.cos(s) + cosm1(s), Math.exp(o) * Math.sin(s))
	},
	log: function() {
		const o = this.re,
			s = this.im;
		return s === 0 && o > 0 ? new Complex$1(Math.log(o), 0) : new Complex$1(logHypot(o, s), Math.atan2(s,
			o))
	},
	abs: function() {
		return hypot(this.re, this.im)
	},
	arg: function() {
		return Math.atan2(this.im, this.re)
	},
	sin: function() {
		const o = this.re,
			s = this.im;
		return new Complex$1(Math.sin(o) * cosh(s), Math.cos(o) * sinh(s))
	},
	cos: function() {
		const o = this.re,
			s = this.im;
		return new Complex$1(Math.cos(o) * cosh(s), -Math.sin(o) * sinh(s))
	},
	tan: function() {
		const o = 2 * this.re,
			s = 2 * this.im,
			a = Math.cos(o) + cosh(s);
		return new Complex$1(Math.sin(o) / a, sinh(s) / a)
	},
	cot: function() {
		const o = 2 * this.re,
			s = 2 * this.im,
			a = Math.cos(o) - cosh(s);
		return new Complex$1(-Math.sin(o) / a, sinh(s) / a)
	},
	sec: function() {
		const o = this.re,
			s = this.im,
			a = .5 * cosh(2 * s) + .5 * Math.cos(2 * o);
		return new Complex$1(Math.cos(o) * cosh(s) / a, Math.sin(o) * sinh(s) / a)
	},
	csc: function() {
		const o = this.re,
			s = this.im,
			a = .5 * cosh(2 * s) - .5 * Math.cos(2 * o);
		return new Complex$1(Math.sin(o) * cosh(s) / a, -Math.cos(o) * sinh(s) / a)
	},
	asin: function() {
		const o = this.re,
			s = this.im,
			a = new Complex$1(s * s - o * o + 1, -2 * o * s).sqrt(),
			l = new Complex$1(a.re - s, a.im + o).log();
		return new Complex$1(l.im, -l.re)
	},
	acos: function() {
		const o = this.re,
			s = this.im,
			a = new Complex$1(s * s - o * o + 1, -2 * o * s).sqrt(),
			l = new Complex$1(a.re - s, a.im + o).log();
		return new Complex$1(Math.PI / 2 - l.im, l.re)
	},
	atan: function() {
		const o = this.re,
			s = this.im;
		if (o === 0) {
			if (s === 1) return new Complex$1(0, 1 / 0);
			if (s === -1) return new Complex$1(0, -1 / 0)
		}
		const a = o * o + (1 - s) * (1 - s),
			l = new Complex$1((1 - s * s - o * o) / a, -2 * o / a).log();
		return new Complex$1(-.5 * l.im, .5 * l.re)
	},
	acot: function() {
		const o = this.re,
			s = this.im;
		if (s === 0) return new Complex$1(Math.atan2(1, o), 0);
		const a = o * o + s * s;
		return a !== 0 ? new Complex$1(o / a, -s / a).atan() : new Complex$1(o !== 0 ? o / 0 : 0, s !== 0 ? -s /
			0 : 0).atan()
	},
	asec: function() {
		const o = this.re,
			s = this.im;
		if (o === 0 && s === 0) return new Complex$1(0, 1 / 0);
		const a = o * o + s * s;
		return a !== 0 ? new Complex$1(o / a, -s / a).acos() : new Complex$1(o !== 0 ? o / 0 : 0, s !== 0 ? -s /
			0 : 0).acos()
	},
	acsc: function() {
		const o = this.re,
			s = this.im;
		if (o === 0 && s === 0) return new Complex$1(Math.PI / 2, 1 / 0);
		const a = o * o + s * s;
		return a !== 0 ? new Complex$1(o / a, -s / a).asin() : new Complex$1(o !== 0 ? o / 0 : 0, s !== 0 ? -s /
			0 : 0).asin()
	},
	sinh: function() {
		const o = this.re,
			s = this.im;
		return new Complex$1(sinh(o) * Math.cos(s), cosh(o) * Math.sin(s))
	},
	cosh: function() {
		const o = this.re,
			s = this.im;
		return new Complex$1(cosh(o) * Math.cos(s), sinh(o) * Math.sin(s))
	},
	tanh: function() {
		const o = 2 * this.re,
			s = 2 * this.im,
			a = cosh(o) + Math.cos(s);
		return new Complex$1(sinh(o) / a, Math.sin(s) / a)
	},
	coth: function() {
		const o = 2 * this.re,
			s = 2 * this.im,
			a = cosh(o) - Math.cos(s);
		return new Complex$1(sinh(o) / a, -Math.sin(s) / a)
	},
	csch: function() {
		const o = this.re,
			s = this.im,
			a = Math.cos(2 * s) - cosh(2 * o);
		return new Complex$1(-2 * sinh(o) * Math.cos(s) / a, 2 * cosh(o) * Math.sin(s) / a)
	},
	sech: function() {
		const o = this.re,
			s = this.im,
			a = Math.cos(2 * s) + cosh(2 * o);
		return new Complex$1(2 * cosh(o) * Math.cos(s) / a, -2 * sinh(o) * Math.sin(s) / a)
	},
	asinh: function() {
		let o = this.im;
		this.im = -this.re, this.re = o;
		const s = this.asin();
		return this.re = -this.im, this.im = o, o = s.re, s.re = -s.im, s.im = o, s
	},
	acosh: function() {
		const o = this.acos();
		if (o.im <= 0) {
			const s = o.re;
			o.re = -o.im, o.im = s
		} else {
			const s = o.im;
			o.im = -o.re, o.re = s
		}
		return o
	},
	atanh: function() {
		const o = this.re,
			s = this.im,
			a = o > 1 && s === 0,
			l = 1 - o,
			c = 1 + o,
			d = l * l + s * s,
			f = d !== 0 ? new Complex$1((c * l - s * s) / d, (s * l + c * s) / d) : new Complex$1(o !== -1 ? o /
				0 : 0, s !== 0 ? s / 0 : 0),
			m = f.re;
		return f.re = logHypot(f.re, f.im) / 2, f.im = Math.atan2(f.im, m) / 2, a && (f.im = -f.im), f
	},
	acoth: function() {
		const o = this.re,
			s = this.im;
		if (o === 0 && s === 0) return new Complex$1(0, Math.PI / 2);
		const a = o * o + s * s;
		return a !== 0 ? new Complex$1(o / a, -s / a).atanh() : new Complex$1(o !== 0 ? o / 0 : 0, s !== 0 ? -
			s / 0 : 0).atanh()
	},
	acsch: function() {
		const o = this.re,
			s = this.im;
		if (s === 0) return new Complex$1(o !== 0 ? Math.log(o + Math.sqrt(o * o + 1)) : 1 / 0, 0);
		const a = o * o + s * s;
		return a !== 0 ? new Complex$1(o / a, -s / a).asinh() : new Complex$1(o !== 0 ? o / 0 : 0, s !== 0 ? -
			s / 0 : 0).asinh()
	},
	asech: function() {
		const o = this.re,
			s = this.im;
		if (this.isZero()) return Complex$1.INFINITY;
		const a = o * o + s * s;
		return a !== 0 ? new Complex$1(o / a, -s / a).acosh() : new Complex$1(o !== 0 ? o / 0 : 0, s !== 0 ? -
			s / 0 : 0).acosh()
	},
	inverse: function() {
		if (this.isZero()) return Complex$1.INFINITY;
		if (this.isInfinite()) return Complex$1.ZERO;
		const o = this.re,
			s = this.im,
			a = o * o + s * s;
		return new Complex$1(o / a, -s / a)
	},
	conjugate: function() {
		return new Complex$1(this.re, -this.im)
	},
	neg: function() {
		return new Complex$1(-this.re, -this.im)
	},
	ceil: function(o) {
		return o = Math.pow(10, o || 0), new Complex$1(Math.ceil(this.re * o) / o, Math.ceil(this.im * o) / o)
	},
	floor: function(o) {
		return o = Math.pow(10, o || 0), new Complex$1(Math.floor(this.re * o) / o, Math.floor(this.im * o) / o)
	},
	round: function(o) {
		return o = Math.pow(10, o || 0), new Complex$1(Math.round(this.re * o) / o, Math.round(this.im * o) / o)
	},
	equals: function(o, s) {
		const a = parse$1(o, s);
		return Math.abs(a.re - this.re) <= Complex$1.EPSILON && Math.abs(a.im - this.im) <= Complex$1.EPSILON
	},
	clone: function() {
		return new Complex$1(this.re, this.im)
	},
	toString: function() {
		let o = this.re,
			s = this.im,
			a = "";
		return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(o) < Complex$1.EPSILON && (o =
			0), Math.abs(s) < Complex$1.EPSILON && (s = 0), s === 0 ? a + o : (o !== 0 ? (a += o, a +=
				" ", s < 0 ? (s = -s, a += "-") : a += "+", a += " ") : s < 0 && (s = -s, a += "-"),
			s !== 1 && (a += s), a + "i"))
	},
	toVector: function() {
		return [this.re, this.im]
	},
	valueOf: function() {
		return this.im === 0 ? this.re : null
	},
	isNaN: function() {
		return isNaN(this.re) || isNaN(this.im)
	},
	isZero: function() {
		return this.im === 0 && this.re === 0
	},
	isFinite: function() {
		return isFinite(this.re) && isFinite(this.im)
	},
	isInfinite: function() {
		return !this.isFinite()
	}
};
Complex$1.ZERO = new Complex$1(0, 0);
Complex$1.ONE = new Complex$1(1, 0);
Complex$1.I = new Complex$1(0, 1);
Complex$1.PI = new Complex$1(Math.PI, 0);
Complex$1.E = new Complex$1(Math.E, 0);
Complex$1.INFINITY = new Complex$1(1 / 0, 1 / 0);
Complex$1.NAN = new Complex$1(NaN, NaN);
Complex$1.EPSILON = 1e-15;
var name$q = "Complex",
	dependencies$q = [],
	createComplexClass = factory(name$q, dependencies$q, () => (Object.defineProperty(Complex$1, "name", {
			value: "Complex"
		}), Complex$1.prototype.constructor = Complex$1, Complex$1.prototype.type = "Complex", Complex$1.prototype
		.isComplex = !0, Complex$1.prototype.toJSON = function() {
			return {
				mathjs: "Complex",
				re: this.re,
				im: this.im
			}
		}, Complex$1.prototype.toPolar = function() {
			return {
				r: this.abs(),
				phi: this.arg()
			}
		}, Complex$1.prototype.format = function(o) {
			var s = "",
				a = this.im,
				l = this.re,
				c = format$2(this.re, o),
				d = format$2(this.im, o),
				f = isNumber(o) ? o : o ? o.precision : null;
			if (f !== null) {
				var m = Math.pow(10, -f);
				Math.abs(l / a) < m && (l = 0), Math.abs(a / l) < m && (a = 0)
			}
			return a === 0 ? s = c : l === 0 ? a === 1 ? s = "i" : a === -1 ? s = "-i" : s = d + "i" : a < 0 ? a ===
				-1 ? s = c + " - i" : s = c + " - " + d.substring(1) + "i" : a === 1 ? s = c + " + i" : s = c +
				" + " + d + "i", s
		}, Complex$1.fromPolar = function(o) {
			switch (arguments.length) {
				case 1: {
					var s = arguments[0];
					if (typeof s == "object") return Complex$1(s);
					throw new TypeError("Input has to be an object with r and phi keys.")
				}
				case 2: {
					var a = arguments[0],
						l = arguments[1];
					if (isNumber(a)) {
						if (isUnit(l) && l.hasBase("ANGLE") && (l = l.toNumber("rad")), isNumber(l))
						return new Complex$1({
								r: a,
								phi: l
							});
						throw new TypeError("Phi is not a number nor an angle unit.")
					} else throw new TypeError("Radius r is not a number.")
				}
				default:
					throw new SyntaxError("Wrong number of arguments in function fromPolar")
			}
		}, Complex$1.prototype.valueOf = Complex$1.prototype.toString, Complex$1.fromJSON = function(o) {
			return new Complex$1(o)
		}, Complex$1.compare = function(o, s) {
			return o.re > s.re ? 1 : o.re < s.re ? -1 : o.im > s.im ? 1 : o.im < s.im ? -1 : 0
		}, Complex$1), {
		isClass: !0
	});
typeof BigInt > "u" && (BigInt = function(o) {
	if (isNaN(o)) throw new Error("");
	return o
});
const C_ZERO = BigInt(0),
	C_ONE = BigInt(1),
	C_TWO = BigInt(2),
	C_FIVE = BigInt(5),
	C_TEN = BigInt(10),
	MAX_CYCLE_LEN = 2e3,
	P = {
		s: C_ONE,
		n: C_ZERO,
		d: C_ONE
	};

function assign(o, s) {
	try {
		o = BigInt(o)
	} catch {
		throw InvalidParameter()
	}
	return o * s
}

function trunc(o) {
	return typeof o == "bigint" ? o : Math.floor(o)
}

function newFraction(o, s) {
	if (s === C_ZERO) throw DivisionByZero();
	const a = Object.create(Fraction$1.prototype);
	a.s = o < C_ZERO ? -C_ONE : C_ONE, o = o < C_ZERO ? -o : o;
	const l = gcd(o, s);
	return a.n = o / l, a.d = s / l, a
}

function factorize(o) {
	const s = {};
	let a = o,
		l = C_TWO,
		c = C_FIVE - C_ONE;
	for (; c <= a;) {
		for (; a % l === C_ZERO;) a /= l, s[l] = (s[l] || C_ZERO) + C_ONE;
		c += C_ONE + C_TWO * l++
	}
	return a !== o ? a > 1 && (s[a] = (s[a] || C_ZERO) + C_ONE) : s[o] = (s[o] || C_ZERO) + C_ONE, s
}
const parse = function(o, s) {
	let a = C_ZERO,
		l = C_ONE,
		c = C_ONE;
	if (o != null)
		if (s !== void 0) {
			if (typeof o == "bigint") a = o;
			else {
				if (isNaN(o)) throw InvalidParameter();
				if (o % 1 !== 0) throw NonIntegerParameter();
				a = BigInt(o)
			}
			if (typeof s == "bigint") l = s;
			else {
				if (isNaN(s)) throw InvalidParameter();
				if (s % 1 !== 0) throw NonIntegerParameter();
				l = BigInt(s)
			}
			c = a * l
		} else if (typeof o == "object") {
		if ("d" in o && "n" in o) a = BigInt(o.n), l = BigInt(o.d), "s" in o && (a *= BigInt(o.s));
		else if (0 in o) a = BigInt(o[0]), 1 in o && (l = BigInt(o[1]));
		else if (typeof o == "bigint") a = o;
		else throw InvalidParameter();
		c = a * l
	} else if (typeof o == "number") {
		if (isNaN(o)) throw InvalidParameter();
		if (o < 0 && (c = -C_ONE, o = -o), o % 1 === 0) a = BigInt(o);
		else {
			let d = 1,
				f = 0,
				m = 1,
				g = 1,
				v = 1,
				y = 1e7;
			for (o >= 1 && (d = 10 ** Math.floor(1 + Math.log10(o)), o /= d); m <= y && v <= y;) {
				let b = (f + g) / (m + v);
				if (o === b) {
					m + v <= y ? (a = f + g, l = m + v) : v > m ? (a = g, l = v) : (a = f, l = m);
					break
				} else o > b ? (f += g, m += v) : (g += f, v += m), m > y ? (a = g, l = v) : (a = f, l = m)
			}
			a = BigInt(a) * BigInt(d), l = BigInt(l)
		}
	} else if (typeof o == "string") {
		let d = 0,
			f = C_ZERO,
			m = C_ZERO,
			g = C_ZERO,
			v = C_ONE,
			y = C_ONE,
			b = o.replace(/_/g, "").match(/\d+|./g);
		if (b === null) throw InvalidParameter();
		if (b[d] === "-" ? (c = -C_ONE, d++) : b[d] === "+" && d++, b.length === d + 1 ? m = assign(b[d++], c) : b[
				d + 1] === "." || b[d] === "." ? (b[d] !== "." && (f = assign(b[d++], c)), d++, (d + 1 === b
				.length || b[d + 1] === "(" && b[d + 3] === ")" || b[d + 1] === "'" && b[d + 3] === "'") && (m =
				assign(b[d], c), v = C_TEN ** BigInt(b[d].length), d++), (b[d] === "(" && b[d + 2] === ")" || b[
				d] === "'" && b[d + 2] === "'") && (g = assign(b[d + 1], c), y = C_TEN ** BigInt(b[d + 1]
				.length) - C_ONE, d += 3)) : b[d + 1] === "/" || b[d + 1] === ":" ? (m = assign(b[d], c), v =
				assign(b[d + 2], C_ONE), d += 3) : b[d + 3] === "/" && b[d + 1] === " " && (f = assign(b[d], c), m =
				assign(b[d + 2], c), v = assign(b[d + 4], C_ONE), d += 5), b.length <= d) l = v * y, c = a = g + l *
			f + y * m;
		else throw InvalidParameter()
	} else if (typeof o == "bigint") a = o, c = o, l = C_ONE;
	else throw InvalidParameter();
	if (l === C_ZERO) throw DivisionByZero();
	P.s = c < C_ZERO ? -C_ONE : C_ONE, P.n = a < C_ZERO ? -a : a, P.d = l < C_ZERO ? -l : l
};

function modpow(o, s, a) {
	let l = C_ONE;
	for (; s > C_ZERO; o = o * o % a, s >>= C_ONE) s & C_ONE && (l = l * o % a);
	return l
}

function cycleLen(o, s) {
	for (; s % C_TWO === C_ZERO; s /= C_TWO);
	for (; s % C_FIVE === C_ZERO; s /= C_FIVE);
	if (s === C_ONE) return C_ZERO;
	let a = C_TEN % s,
		l = 1;
	for (; a !== C_ONE; l++)
		if (a = a * C_TEN % s, l > MAX_CYCLE_LEN) return C_ZERO;
	return BigInt(l)
}

function cycleStart(o, s, a) {
	let l = C_ONE,
		c = modpow(C_TEN, a, s);
	for (let d = 0; d < 300; d++) {
		if (l === c) return BigInt(d);
		l = l * C_TEN % s, c = c * C_TEN % s
	}
	return 0
}

function gcd(o, s) {
	if (!o) return s;
	if (!s) return o;
	for (;;) {
		if (o %= s, !o) return s;
		if (s %= o, !s) return o
	}
}

function Fraction$1(o, s) {
	if (parse(o, s), this instanceof Fraction$1) o = gcd(P.d, P.n), this.s = P.s, this.n = P.n / o, this.d = P.d / o;
	else return newFraction(P.s * P.n, P.d)
}
var DivisionByZero = function() {
		return new Error("Division by Zero")
	},
	InvalidParameter = function() {
		return new Error("Invalid argument")
	},
	NonIntegerParameter = function() {
		return new Error("Parameters must be integer")
	};
Fraction$1.prototype = {
	s: C_ONE,
	n: C_ZERO,
	d: C_ONE,
	abs: function() {
		return newFraction(this.n, this.d)
	},
	neg: function() {
		return newFraction(-this.s * this.n, this.d)
	},
	add: function(o, s) {
		return parse(o, s), newFraction(this.s * this.n * P.d + P.s * this.d * P.n, this.d * P.d)
	},
	sub: function(o, s) {
		return parse(o, s), newFraction(this.s * this.n * P.d - P.s * this.d * P.n, this.d * P.d)
	},
	mul: function(o, s) {
		return parse(o, s), newFraction(this.s * P.s * this.n * P.n, this.d * P.d)
	},
	div: function(o, s) {
		return parse(o, s), newFraction(this.s * P.s * this.n * P.d, this.d * P.n)
	},
	clone: function() {
		return newFraction(this.s * this.n, this.d)
	},
	mod: function(o, s) {
		if (o === void 0) return newFraction(this.s * this.n % this.d, C_ONE);
		if (parse(o, s), C_ZERO === P.n * this.d) throw DivisionByZero();
		return newFraction(this.s * (P.d * this.n) % (P.n * this.d), P.d * this.d)
	},
	gcd: function(o, s) {
		return parse(o, s), newFraction(gcd(P.n, this.n) * gcd(P.d, this.d), P.d * this.d)
	},
	lcm: function(o, s) {
		return parse(o, s), P.n === C_ZERO && this.n === C_ZERO ? newFraction(C_ZERO, C_ONE) : newFraction(P.n *
			this.n, gcd(P.n, this.n) * gcd(P.d, this.d))
	},
	inverse: function() {
		return newFraction(this.s * this.d, this.n)
	},
	pow: function(o, s) {
		if (parse(o, s), P.d === C_ONE) return P.s < C_ZERO ? newFraction((this.s * this.d) ** P.n, this.n ** P
			.n) : newFraction((this.s * this.n) ** P.n, this.d ** P.n);
		if (this.s < C_ZERO) return null;
		let a = factorize(this.n),
			l = factorize(this.d),
			c = C_ONE,
			d = C_ONE;
		for (let f in a)
			if (f !== "1") {
				if (f === "0") {
					c = C_ZERO;
					break
				}
				if (a[f] *= P.n, a[f] % P.d === C_ZERO) a[f] /= P.d;
				else return null;
				c *= BigInt(f) ** a[f]
			} for (let f in l)
			if (f !== "1") {
				if (l[f] *= P.n, l[f] % P.d === C_ZERO) l[f] /= P.d;
				else return null;
				d *= BigInt(f) ** l[f]
			} return P.s < C_ZERO ? newFraction(d, c) : newFraction(c, d)
	},
	log: function(o, s) {
		if (parse(o, s), this.s <= C_ZERO || P.s <= C_ZERO) return null;
		const a = {},
			l = factorize(P.n),
			c = factorize(P.d),
			d = factorize(this.n),
			f = factorize(this.d);
		for (const v in c) l[v] = (l[v] || C_ZERO) - c[v];
		for (const v in f) d[v] = (d[v] || C_ZERO) - f[v];
		for (const v in l) v !== "1" && (a[v] = !0);
		for (const v in d) v !== "1" && (a[v] = !0);
		let m = null,
			g = null;
		for (const v in a) {
			const y = l[v] || C_ZERO,
				b = d[v] || C_ZERO;
			if (y === C_ZERO) {
				if (b !== C_ZERO) return null;
				continue
			}
			let C = b,
				_ = y;
			const S = gcd(C, _);
			if (C /= S, _ /= S, m === null && g === null) m = C, g = _;
			else if (C * g !== m * _) return null
		}
		return m !== null && g !== null ? newFraction(m, g) : null
	},
	equals: function(o, s) {
		return parse(o, s), this.s * this.n * P.d === P.s * P.n * this.d
	},
	lt: function(o, s) {
		return parse(o, s), this.s * this.n * P.d < P.s * P.n * this.d
	},
	lte: function(o, s) {
		return parse(o, s), this.s * this.n * P.d <= P.s * P.n * this.d
	},
	gt: function(o, s) {
		return parse(o, s), this.s * this.n * P.d > P.s * P.n * this.d
	},
	gte: function(o, s) {
		return parse(o, s), this.s * this.n * P.d >= P.s * P.n * this.d
	},
	compare: function(o, s) {
		parse(o, s);
		let a = this.s * this.n * P.d - P.s * P.n * this.d;
		return (C_ZERO < a) - (a < C_ZERO)
	},
	ceil: function(o) {
		return o = C_TEN ** BigInt(o || 0), newFraction(trunc(this.s * o * this.n / this.d) + (o * this.n % this
			.d > C_ZERO && this.s >= C_ZERO ? C_ONE : C_ZERO), o)
	},
	floor: function(o) {
		return o = C_TEN ** BigInt(o || 0), newFraction(trunc(this.s * o * this.n / this.d) - (o * this.n % this
			.d > C_ZERO && this.s < C_ZERO ? C_ONE : C_ZERO), o)
	},
	round: function(o) {
		return o = C_TEN ** BigInt(o || 0), newFraction(trunc(this.s * o * this.n / this.d) + this.s * ((this
				.s >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (o * this.n % this.d) > this.d ? C_ONE :
			C_ZERO), o)
	},
	roundTo: function(o, s) {
		parse(o, s);
		const a = this.n * P.d,
			l = this.d * P.n,
			c = a % l;
		let d = trunc(a / l);
		return c + c >= l && d++, newFraction(this.s * d * P.n, P.d)
	},
	divisible: function(o, s) {
		return parse(o, s), !(!(P.n * this.d) || this.n * P.d % (P.n * this.d))
	},
	valueOf: function() {
		return Number(this.s * this.n) / Number(this.d)
	},
	toString: function(o) {
		let s = this.n,
			a = this.d;
		o = o || 15;
		let l = cycleLen(s, a),
			c = cycleStart(s, a, l),
			d = this.s < C_ZERO ? "-" : "";
		if (d += trunc(s / a), s %= a, s *= C_TEN, s && (d += "."), l) {
			for (let f = c; f--;) d += trunc(s / a), s %= a, s *= C_TEN;
			d += "(";
			for (let f = l; f--;) d += trunc(s / a), s %= a, s *= C_TEN;
			d += ")"
		} else
			for (let f = o; s && f--;) d += trunc(s / a), s %= a, s *= C_TEN;
		return d
	},
	toFraction: function(o) {
		let s = this.n,
			a = this.d,
			l = this.s < C_ZERO ? "-" : "";
		if (a === C_ONE) l += s;
		else {
			let c = trunc(s / a);
			o && c > C_ZERO && (l += c, l += " ", s %= a), l += s, l += "/", l += a
		}
		return l
	},
	toLatex: function(o) {
		let s = this.n,
			a = this.d,
			l = this.s < C_ZERO ? "-" : "";
		if (a === C_ONE) l += s;
		else {
			let c = trunc(s / a);
			o && c > C_ZERO && (l += c, s %= a), l += "\\frac{", l += s, l += "}{", l += a, l += "}"
		}
		return l
	},
	toContinued: function() {
		let o = this.n,
			s = this.d,
			a = [];
		do {
			a.push(trunc(o / s));
			let l = o % s;
			o = s, s = l
		} while (o !== C_ONE);
		return a
	},
	simplify: function(o) {
		const s = BigInt(1 / (o || .001) | 0),
			a = this.abs(),
			l = a.toContinued();
		for (let c = 1; c < l.length; c++) {
			let d = newFraction(l[c - 1], C_ONE);
			for (let m = c - 2; m >= 0; m--) d = d.inverse().add(l[m]);
			let f = d.sub(a);
			if (f.n * s < f.d) return d.mul(this.s)
		}
		return this
	}
};
var name$p = "Fraction",
	dependencies$p = [],
	createFractionClass = factory(name$p, dependencies$p, () => (Object.defineProperty(Fraction$1, "name", {
			value: "Fraction"
		}), Fraction$1.prototype.constructor = Fraction$1, Fraction$1.prototype.type = "Fraction", Fraction$1
		.prototype.isFraction = !0, Fraction$1.prototype.toJSON = function() {
			return {
				mathjs: "Fraction",
				n: String(this.s * this.n),
				d: String(this.d)
			}
		}, Fraction$1.fromJSON = function(o) {
			return new Fraction$1(o)
		}, Fraction$1), {
		isClass: !0
	}),
	name$o = "Matrix",
	dependencies$o = [],
	createMatrixClass = factory(name$o, dependencies$o, () => {
		function o() {
			if (!(this instanceof o)) throw new SyntaxError("Constructor must be called with the new operator")
		}
		return o.prototype.type = "Matrix", o.prototype.isMatrix = !0, o.prototype.storage = function() {
			throw new Error("Cannot invoke storage on a Matrix interface")
		}, o.prototype.datatype = function() {
			throw new Error("Cannot invoke datatype on a Matrix interface")
		}, o.prototype.create = function(s, a) {
			throw new Error("Cannot invoke create on a Matrix interface")
		}, o.prototype.subset = function(s, a, l) {
			throw new Error("Cannot invoke subset on a Matrix interface")
		}, o.prototype.get = function(s) {
			throw new Error("Cannot invoke get on a Matrix interface")
		}, o.prototype.set = function(s, a, l) {
			throw new Error("Cannot invoke set on a Matrix interface")
		}, o.prototype.resize = function(s, a) {
			throw new Error("Cannot invoke resize on a Matrix interface")
		}, o.prototype.reshape = function(s, a) {
			throw new Error("Cannot invoke reshape on a Matrix interface")
		}, o.prototype.clone = function() {
			throw new Error("Cannot invoke clone on a Matrix interface")
		}, o.prototype.size = function() {
			throw new Error("Cannot invoke size on a Matrix interface")
		}, o.prototype.map = function(s, a) {
			throw new Error("Cannot invoke map on a Matrix interface")
		}, o.prototype.forEach = function(s) {
			throw new Error("Cannot invoke forEach on a Matrix interface")
		}, o.prototype[Symbol.iterator] = function() {
			throw new Error("Cannot iterate a Matrix interface")
		}, o.prototype.toArray = function() {
			throw new Error("Cannot invoke toArray on a Matrix interface")
		}, o.prototype.valueOf = function() {
			throw new Error("Cannot invoke valueOf on a Matrix interface")
		}, o.prototype.format = function(s) {
			throw new Error("Cannot invoke format on a Matrix interface")
		}, o.prototype.toString = function() {
			throw new Error("Cannot invoke toString on a Matrix interface")
		}, o
	}, {
		isClass: !0
	});

function formatBigNumberToBase(o, s, a) {
	var l = o.constructor,
		c = new l(2),
		d = "";
	if (a) {
		if (a < 1) throw new Error("size must be in greater than 0");
		if (!isInteger(a)) throw new Error("size must be an integer");
		if (o.greaterThan(c.pow(a - 1).sub(1)) || o.lessThan(c.pow(a - 1).mul(-1))) throw new Error(
			"Value must be in range [-2^".concat(a - 1, ", 2^").concat(a - 1, "-1]"));
		if (!o.isInteger()) throw new Error("Value must be an integer");
		o.lessThan(0) && (o = o.add(c.pow(a))), d = "i".concat(a)
	}
	switch (s) {
		case 2:
			return "".concat(o.toBinary()).concat(d);
		case 8:
			return "".concat(o.toOctal()).concat(d);
		case 16:
			return "".concat(o.toHexadecimal()).concat(d);
		default:
			throw new Error("Base ".concat(s, " not supported "))
	}
}

function format$1(o, s) {
	if (typeof s == "function") return s(o);
	if (!o.isFinite()) return o.isNaN() ? "NaN" : o.gt(0) ? "Infinity" : "-Infinity";
	var {
		notation: a,
		precision: l,
		wordSize: c
	} = normalizeFormatOptions(s);
	switch (a) {
		case "fixed":
			return toFixed(o, l);
		case "exponential":
			return toExponential(o, l);
		case "engineering":
			return toEngineering(o, l);
		case "bin":
			return formatBigNumberToBase(o, 2, c);
		case "oct":
			return formatBigNumberToBase(o, 8, c);
		case "hex":
			return formatBigNumberToBase(o, 16, c);
		case "auto": {
			var d = _toNumberOrDefault(s == null ? void 0 : s.lowerExp, -3),
				f = _toNumberOrDefault(s == null ? void 0 : s.upperExp, 5);
			if (o.isZero()) return "0";
			var m, g = o.toSignificantDigits(l),
				v = g.e;
			return v >= d && v < f ? m = g.toFixed() : m = toExponential(o, l), m.replace(/((\.\d*?)(0+))($|e)/,
				function() {
					var y = arguments[2],
						b = arguments[4];
					return y !== "." ? y + b : b
				})
		}
		default:
			throw new Error('Unknown notation "' + a +
				'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')
	}
}

function toEngineering(o, s) {
	var a = o.e,
		l = a % 3 === 0 ? a : a < 0 ? a - 3 - a % 3 : a - a % 3,
		c = o.mul(Math.pow(10, -l)),
		d = c.toPrecision(s);
	if (d.includes("e")) {
		var f = o.constructor;
		d = new f(d).toFixed()
	}
	return d + "e" + (a >= 0 ? "+" : "") + l.toString()
}

function toExponential(o, s) {
	return s !== void 0 ? o.toExponential(s - 1) : o.toExponential()
}

function toFixed(o, s) {
	return o.toFixed(s)
}

function _toNumberOrDefault(o, s) {
	return isNumber(o) ? o : isBigNumber(o) ? o.toNumber() : s
}

function format(o, s) {
	var a = _format(o, s);
	return s && typeof s == "object" && "truncate" in s && a.length > s.truncate ? a.substring(0, s.truncate - 3) +
		"..." : a
}

function _format(o, s) {
	if (typeof o == "number") return format$2(o, s);
	if (isBigNumber(o)) return format$1(o, s);
	if (looksLikeFraction(o)) return !s || s.fraction !== "decimal" ? "".concat(o.s * o.n, "/").concat(o.d) : o
		.toString();
	if (Array.isArray(o)) return formatArray(o, s);
	if (isString(o)) return stringify(o);
	if (typeof o == "function") return o.syntax ? String(o.syntax) : "function";
	if (o && typeof o == "object") {
		if (typeof o.format == "function") return o.format(s);
		if (o && o.toString(s) !== {}.toString()) return o.toString(s);
		var a = Object.keys(o).map(l => stringify(l) + ": " + format(o[l], s));
		return "{" + a.join(", ") + "}"
	}
	return String(o)
}

function stringify(o) {
	for (var s = String(o), a = "", l = 0; l < s.length;) {
		var c = s.charAt(l);
		a += c in controlCharacters ? controlCharacters[c] : c, l++
	}
	return '"' + a + '"'
}
var controlCharacters = {
	'"': '\\"',
	"\\": "\\\\",
	"\b": "\\b",
	"\f": "\\f",
	"\n": "\\n",
	"\r": "\\r",
	"	": "\\t"
};

function formatArray(o, s) {
	if (Array.isArray(o)) {
		for (var a = "[", l = o.length, c = 0; c < l; c++) c !== 0 && (a += ", "), a += formatArray(o[c], s);
		return a += "]", a
	} else return format(o, s)
}

function looksLikeFraction(o) {
	return o && typeof o == "object" && typeof o.s == "bigint" && typeof o.n == "bigint" && typeof o.d == "bigint" || !1
}

function DimensionError(o, s, a) {
	if (!(this instanceof DimensionError)) throw new SyntaxError("Constructor must be called with the new operator");
	this.actual = o, this.expected = s, this.relation = a, this.message = "Dimension mismatch (" + (Array.isArray(o) ?
		"[" + o.join(", ") + "]" : o) + " " + (this.relation || "!=") + " " + (Array.isArray(s) ? "[" + s.join(
		", ") + "]" : s) + ")", this.stack = new Error().stack
}
DimensionError.prototype = new RangeError;
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = !0;

function IndexError(o, s, a) {
	if (!(this instanceof IndexError)) throw new SyntaxError("Constructor must be called with the new operator");
	this.index = o, arguments.length < 3 ? (this.min = 0, this.max = s) : (this.min = s, this.max = a), this.min !==
		void 0 && this.index < this.min ? this.message = "Index out of range (" + this.index + " < " + this.min + ")" :
		this.max !== void 0 && this.index >= this.max ? this.message = "Index out of range (" + this.index + " > " + (
			this.max - 1) + ")" : this.message = "Index out of range (" + this.index + ")", this.stack = new Error()
		.stack
}
IndexError.prototype = new RangeError;
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = !0;

function arraySize(o) {
	for (var s = []; Array.isArray(o);) s.push(o.length), o = o[0];
	return s
}

function _validate(o, s, a) {
	var l, c = o.length;
	if (c !== s[a]) throw new DimensionError(c, s[a]);
	if (a < s.length - 1) {
		var d = a + 1;
		for (l = 0; l < c; l++) {
			var f = o[l];
			if (!Array.isArray(f)) throw new DimensionError(s.length - 1, s.length, "<");
			_validate(o[l], s, d)
		}
	} else
		for (l = 0; l < c; l++)
			if (Array.isArray(o[l])) throw new DimensionError(s.length + 1, s.length, ">")
}

function validate(o, s) {
	var a = s.length === 0;
	if (a) {
		if (Array.isArray(o)) throw new DimensionError(o.length, 0)
	} else _validate(o, s, 0)
}

function validateIndex(o, s) {
	if (o !== void 0) {
		if (!isNumber(o) || !isInteger(o)) throw new TypeError("Index must be an integer (value: " + o + ")");
		if (o < 0 || typeof s == "number" && o >= s) throw new IndexError(o, s)
	}
}

function resize(o, s, a) {
	if (!Array.isArray(s)) throw new TypeError("Array expected");
	if (s.length === 0) throw new Error("Resizing to scalar is not supported");
	s.forEach(function(c) {
		if (!isNumber(c) || !isInteger(c) || c < 0) throw new TypeError(
			"Invalid size, must contain positive integers (size: " + format(s) + ")")
	}), (isNumber(o) || isBigNumber(o)) && (o = [o]);
	var l = a !== void 0 ? a : 0;
	return _resize(o, s, 0, l), o
}

function _resize(o, s, a, l) {
	var c, d, f = o.length,
		m = s[a],
		g = Math.min(f, m);
	if (o.length = m, a < s.length - 1) {
		var v = a + 1;
		for (c = 0; c < g; c++) d = o[c], Array.isArray(d) || (d = [d], o[c] = d), _resize(d, s, v, l);
		for (c = g; c < m; c++) d = [], o[c] = d, _resize(d, s, v, l)
	} else {
		for (c = 0; c < g; c++)
			for (; Array.isArray(o[c]);) o[c] = o[c][0];
		for (c = g; c < m; c++) o[c] = l
	}
}

function reshape(o, s) {
	var a = flatten(o, !0),
		l = a.length;
	if (!Array.isArray(o) || !Array.isArray(s)) throw new TypeError("Array expected");
	if (s.length === 0) throw new DimensionError(0, l, "!=");
	s = processSizesWildcard(s, l);
	var c = product(s);
	if (l !== c) throw new DimensionError(c, l, "!=");
	try {
		return _reshape(a, s)
	} catch (d) {
		throw d instanceof DimensionError ? new DimensionError(c, l, "!=") : d
	}
}

function processSizesWildcard(o, s) {
	var a = product(o),
		l = o.slice(),
		c = -1,
		d = o.indexOf(c),
		f = o.indexOf(c, d + 1) >= 0;
	if (f) throw new Error("More than one wildcard in sizes");
	var m = d >= 0,
		g = s % a === 0;
	if (m)
		if (g) l[d] = -s / a;
		else throw new Error("Could not replace wildcard, since " + s + " is no multiple of " + -a);
	return l
}

function product(o) {
	return o.reduce((s, a) => s * a, 1)
}

function _reshape(o, s) {
	for (var a = o, l, c = s.length - 1; c > 0; c--) {
		var d = s[c];
		l = [];
		for (var f = a.length / d, m = 0; m < f; m++) l.push(a.slice(m * d, (m + 1) * d));
		a = l
	}
	return a
}

function unsqueeze(o, s, a, l) {
	var c = l || arraySize(o);
	if (a)
		for (var d = 0; d < a; d++) o = [o], c.unshift(1);
	for (o = _unsqueeze(o, s, 0); c.length < s;) c.push(1);
	return o
}

function _unsqueeze(o, s, a) {
	var l, c;
	if (Array.isArray(o)) {
		var d = a + 1;
		for (l = 0, c = o.length; l < c; l++) o[l] = _unsqueeze(o[l], s, d)
	} else
		for (var f = a; f < s; f++) o = [o];
	return o
}

function flatten(o) {
	var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
	if (!Array.isArray(o)) return o;
	if (typeof s != "boolean") throw new TypeError("Boolean expected for second argument of flatten");
	var a = [];
	return s ? c(o) : l(o), a;

	function l(d) {
		for (var f = 0; f < d.length; f++) {
			var m = d[f];
			Array.isArray(m) ? l(m) : a.push(m)
		}
	}

	function c(d) {
		if (Array.isArray(d[0]))
			for (var f = 0; f < d.length; f++) c(d[f]);
		else
			for (var m = 0; m < d.length; m++) a.push(d[m])
	}
}

function getArrayDataType(o, s) {
	for (var a, l = 0, c = 0; c < o.length; c++) {
		var d = o[c],
			f = Array.isArray(d);
		if (c === 0 && f && (l = d.length), f && d.length !== l) return;
		var m = f ? getArrayDataType(d, s) : s(d);
		if (a === void 0) a = m;
		else if (a !== m) return "mixed"
	}
	return a
}

function concatRecursive(o, s, a, l) {
	if (l < a) {
		if (o.length !== s.length) throw new DimensionError(o.length, s.length);
		for (var c = [], d = 0; d < o.length; d++) c[d] = concatRecursive(o[d], s[d], a, l + 1);
		return c
	} else return o.concat(s)
}

function concat() {
	var o = Array.prototype.slice.call(arguments, 0, -1),
		s = Array.prototype.slice.call(arguments, -1);
	if (o.length === 1) return o[0];
	if (o.length > 1) return o.slice(1).reduce(function(a, l) {
		return concatRecursive(a, l, s, 0)
	}, o[0]);
	throw new Error("Wrong number of arguments in function concat")
}

function broadcastSizes() {
	for (var o = arguments.length, s = new Array(o), a = 0; a < o; a++) s[a] = arguments[a];
	for (var l = s.map(C => C.length), c = Math.max(...l), d = new Array(c).fill(null), f = 0; f < s.length; f++)
		for (var m = s[f], g = l[f], v = 0; v < g; v++) {
			var y = c - g + v;
			m[v] > d[y] && (d[y] = m[v])
		}
	for (var b = 0; b < s.length; b++) checkBroadcastingRules(s[b], d);
	return d
}

function checkBroadcastingRules(o, s) {
	for (var a = s.length, l = o.length, c = 0; c < l; c++) {
		var d = a - l + c;
		if (o[c] < s[d] && o[c] > 1 || o[c] > s[d]) throw new Error(
			"shape mismatch: mismatch is found in arg with shape (".concat(o,
				") not possible to broadcast dimension ").concat(l, " with size ").concat(o[c], " to size ")
			.concat(s[d]))
	}
}

function broadcastTo(o, s) {
	var a = arraySize(o);
	if (deepStrictEqual(a, s)) return o;
	checkBroadcastingRules(a, s);
	var l = broadcastSizes(a, s),
		c = l.length,
		d = [...Array(c - a.length).fill(1), ...a],
		f = clone(o);
	a.length < c && (f = reshape(f, d), a = arraySize(f));
	for (var m = 0; m < c; m++) a[m] < l[m] && (f = stretch(f, l[m], m), a = arraySize(f));
	return f
}

function stretch(o, s, a) {
	return concat(...Array(s).fill(o), a)
}

function get(o, s) {
	if (!Array.isArray(o)) throw new Error("Array expected");
	var a = arraySize(o);
	if (s.length !== a.length) throw new DimensionError(s.length, a.length);
	for (var l = 0; l < s.length; l++) validateIndex(s[l], a[l]);
	return s.reduce((c, d) => c[d], o)
}

function deepMap$1(o, s) {
	var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
	if (o.length === 0) return [];
	if (a) return d(o);
	var l = [];
	return c(o, 0);

	function c(f, m) {
		if (Array.isArray(f)) {
			for (var g = f.length, v = Array(g), y = 0; y < g; y++) l[m] = y, v[y] = c(f[y], m + 1);
			return v
		} else return s(f, l.slice(0, m), o)
	}

	function d(f) {
		if (Array.isArray(f)) {
			for (var m = f.length, g = Array(m), v = 0; v < m; v++) g[v] = d(f[v]);
			return g
		} else return s(f)
	}
}

function clone(o) {
	return _extends([], o)
}

function optimizeCallback(o, s, a) {
	var l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
	if (typedFunction.isTypedFunction(o)) {
		var c;
		if (l) c = 1;
		else {
			var d = (s.isMatrix ? s.size() : arraySize(s)).map(() => 0),
				f = s.isMatrix ? s.get(d) : get(s, d);
			c = _findNumberOfArgumentsTyped(o, f, d, s)
		}
		var m;
		if (s.isMatrix && s.dataType !== "mixed" && s.dataType !== void 0) {
			var g = _findSingleSignatureWithArity(o, c);
			m = g !== void 0 ? g : o
		} else m = o;
		return c >= 1 && c <= 3 ? {
			isUnary: c === 1,
			fn: function() {
				for (var y = arguments.length, b = new Array(y), C = 0; C < y; C++) b[C] = arguments[C];
				return _tryFunctionWithArgs(m, b.slice(0, c), a, o.name)
			}
		} : {
			isUnary: !1,
			fn: function() {
				for (var y = arguments.length, b = new Array(y), C = 0; C < y; C++) b[C] = arguments[C];
				return _tryFunctionWithArgs(m, b, a, o.name)
			}
		}
	}
	return l === void 0 ? {
		isUnary: _findIfCallbackIsUnary(o),
		fn: o
	} : {
		isUnary: l,
		fn: o
	}
}

function _findSingleSignatureWithArity(o, s) {
	var a = [];
	if (Object.entries(o.signatures).forEach(l => {
			var [c, d] = l;
			c.split(",").length === s && a.push(d)
		}), a.length === 1) return a[0]
}

function _findIfCallbackIsUnary(o) {
	if (o.length !== 1) return !1;
	var s = o.toString();
	if (/arguments/.test(s)) return !1;
	var a = s.match(/\(.*?\)/);
	return !/\.\.\./.test(a)
}

function _findNumberOfArgumentsTyped(o, s, a, l) {
	for (var c = [s, a, l], d = 3; d > 0; d--) {
		var f = c.slice(0, d);
		if (typedFunction.resolve(o, f) !== null) return d
	}
}

function _tryFunctionWithArgs(o, s, a, l) {
	try {
		return o(...s)
	} catch (c) {
		_createCallbackError(c, s, a, l)
	}
}

function _createCallbackError(o, s, a, l) {
	var c;
	if (o instanceof TypeError && ((c = o.data) === null || c === void 0 ? void 0 : c.category) === "wrongType") {
		var d = [];
		throw d.push("value: ".concat(typeOf(s[0]))), s.length >= 2 && d.push("index: ".concat(typeOf(s[1]))), s
			.length >= 3 && d.push("array: ".concat(typeOf(s[2]))), new TypeError("Function ".concat(a,
				" cannot apply callback arguments ") + "".concat(l, "(").concat(d.join(", "), ") at index ").concat(
				JSON.stringify(s[1])))
	} else throw new TypeError("Function ".concat(a, " cannot apply callback arguments ") + "to function ".concat(l,
		": ").concat(o.message))
}
var name$n = "DenseMatrix",
	dependencies$n = ["Matrix"],
	createDenseMatrixClass = factory(name$n, dependencies$n, o => {
		var {
			Matrix: s
		} = o;

		function a(y, b) {
			if (!(this instanceof a)) throw new SyntaxError("Constructor must be called with the new operator");
			if (b && !isString(b)) throw new Error("Invalid datatype: " + b);
			if (isMatrix(y)) y.type === "DenseMatrix" ? (this._data = clone$2(y._data), this._size = clone$2(y
				._size), this._datatype = b || y._datatype) : (this._data = y.toArray(), this._size = y.size(),
				this._datatype = b || y._datatype);
			else if (y && isArray(y.data) && isArray(y.size)) this._data = y.data, this._size = y.size, validate(
				this._data, this._size), this._datatype = b || y.datatype;
			else if (isArray(y)) this._data = v(y), this._size = arraySize(this._data), validate(this._data, this
				._size), this._datatype = b;
			else {
				if (y) throw new TypeError("Unsupported type of data (" + typeOf(y) + ")");
				this._data = [], this._size = [0], this._datatype = b
			}
		}
		a.prototype = new s, a.prototype.createDenseMatrix = function(y, b) {
				return new a(y, b)
			}, Object.defineProperty(a, "name", {
				value: "DenseMatrix"
			}), a.prototype.constructor = a, a.prototype.type = "DenseMatrix", a.prototype.isDenseMatrix = !0, a
			.prototype.getDataType = function() {
				return getArrayDataType(this._data, typeOf)
			}, a.prototype.storage = function() {
				return "dense"
			}, a.prototype.datatype = function() {
				return this._datatype
			}, a.prototype.create = function(y, b) {
				return new a(y, b)
			}, a.prototype.subset = function(y, b, C) {
				switch (arguments.length) {
					case 1:
						return l(this, y);
					case 2:
					case 3:
						return d(this, y, b, C);
					default:
						throw new SyntaxError("Wrong number of arguments")
				}
			}, a.prototype.get = function(y) {
				return get(this._data, y)
			}, a.prototype.set = function(y, b, C) {
				if (!isArray(y)) throw new TypeError("Array expected");
				if (y.length < this._size.length) throw new DimensionError(y.length, this._size.length, "<");
				var _, S, w, T = y.map(function(k) {
					return k + 1
				});
				g(this, T, C);
				var A = this._data;
				for (_ = 0, S = y.length - 1; _ < S; _++) w = y[_], validateIndex(w, A.length), A = A[w];
				return w = y[y.length - 1], validateIndex(w, A.length), A[w] = b, this
			};

		function l(y, b) {
			if (!isIndex(b)) throw new TypeError("Invalid index");
			var C = b.isScalar();
			if (C) return y.get(b.min());
			var _ = b.size();
			if (_.length !== y._size.length) throw new DimensionError(_.length, y._size.length);
			for (var S = b.min(), w = b.max(), T = 0, A = y._size.length; T < A; T++) validateIndex(S[T], y._size[
				T]), validateIndex(w[T], y._size[T]);
			return new a(c(y._data, b, _.length, 0), y._datatype)
		}

		function c(y, b, C, _) {
			var S = _ === C - 1,
				w = b.dimension(_);
			return S ? w.map(function(T) {
				return validateIndex(T, y.length), y[T]
			}).valueOf() : w.map(function(T) {
				validateIndex(T, y.length);
				var A = y[T];
				return c(A, b, C, _ + 1)
			}).valueOf()
		}

		function d(y, b, C, _) {
			if (!b || b.isIndex !== !0) throw new TypeError("Invalid index");
			var S = b.size(),
				w = b.isScalar(),
				T;
			if (isMatrix(C) ? (T = C.size(), C = C.valueOf()) : T = arraySize(C), w) {
				if (T.length !== 0) throw new TypeError("Scalar expected");
				y.set(b.min(), C, _)
			} else {
				if (!deepStrictEqual(T, S)) try {
					T.length === 0 ? C = broadcastTo([C], S) : C = broadcastTo(C, S), T = arraySize(C)
				} catch {}
				if (S.length < y._size.length) throw new DimensionError(S.length, y._size.length, "<");
				if (T.length < S.length) {
					for (var A = 0, k = 0; S[A] === 1 && T[A] === 1;) A++;
					for (; S[A] === 1;) k++, A++;
					C = unsqueeze(C, S.length, k, T)
				}
				if (!deepStrictEqual(S, T)) throw new DimensionError(S, T, ">");
				var M = b.max().map(function(R) {
					return R + 1
				});
				g(y, M, _);
				var D = S.length,
					F = 0;
				f(y._data, b, C, D, F)
			}
			return y
		}

		function f(y, b, C, _, S) {
			var w = S === _ - 1,
				T = b.dimension(S);
			w ? T.forEach(function(A, k) {
				validateIndex(A), y[A] = C[k[0]]
			}) : T.forEach(function(A, k) {
				validateIndex(A), f(y[A], b, C[k[0]], _, S + 1)
			})
		}
		a.prototype.resize = function(y, b, C) {
			if (!isCollection(y)) throw new TypeError("Array or Matrix expected");
			var _ = y.valueOf().map(w => Array.isArray(w) && w.length === 1 ? w[0] : w),
				S = C ? this.clone() : this;
			return m(S, _, b)
		};

		function m(y, b, C) {
			if (b.length === 0) {
				for (var _ = y._data; isArray(_);) _ = _[0];
				return _
			}
			return y._size = b.slice(0), y._data = resize(y._data, y._size, C), y
		}
		a.prototype.reshape = function(y, b) {
			var C = b ? this.clone() : this;
			C._data = reshape(C._data, y);
			var _ = C._size.reduce((S, w) => S * w);
			return C._size = processSizesWildcard(y, _), C
		};

		function g(y, b, C) {
			for (var _ = y._size.slice(0), S = !1; _.length < b.length;) _.push(0), S = !0;
			for (var w = 0, T = b.length; w < T; w++) b[w] > _[w] && (_[w] = b[w], S = !0);
			S && m(y, _, C)
		}
		a.prototype.clone = function() {
			var y = new a({
				data: clone$2(this._data),
				size: clone$2(this._size),
				datatype: this._datatype
			});
			return y
		}, a.prototype.size = function() {
			return this._size.slice(0)
		}, a.prototype._forEach = function(y) {
			var b = y.length === 2,
				C = this._size.length - 1;
			if (C < 0) return;
			if (b) {
				T(this._data);
				return
			}
			if (C === 0) {
				for (var _ = 0; _ < this._data.length; _++) y(this._data, _, [_]);
				return
			}
			var S = new Array(C + 1);
			w(this._data);

			function w(A) {
				var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
				if (k < C)
					for (var M = 0; M < A.length; M++) S[k] = M, w(A[M], k + 1);
				else
					for (var D = 0; D < A.length; D++) S[k] = D, y(A, D, S.slice())
			}

			function T(A) {
				var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
				if (k < C)
					for (var M = 0; M < A.length; M++) T(A[M], k + 1);
				else
					for (var D = 0; D < A.length; D++) y(A, D)
			}
		}, a.prototype.map = function(y) {
			var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
				C = this,
				_ = new a(C),
				S = optimizeCallback(y, C._data, "map", b),
				w = b || S.isUnary ? (T, A) => {
					T[A] = S.fn(T[A])
				} : (T, A, k) => {
					T[A] = S.fn(T[A], k, C)
				};
			return _._forEach(w), _
		}, a.prototype.forEach = function(y) {
			var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
				C = this,
				_ = optimizeCallback(y, C._data, "map", b),
				S = b || _.isUnary ? (w, T) => {
					_.fn(w[T])
				} : (w, T, A) => {
					_.fn(w[T], A, C)
				};
			C._forEach(S)
		}, a.prototype[Symbol.iterator] = function*() {
			var y = this._size.length - 1;
			if (!(y < 0)) {
				if (y === 0) {
					for (var b = 0; b < this._data.length; b++) yield {
						value: this._data[b],
						index: [b]
					};
					return
				}
				var C = [],
					_ = function*(w, T) {
						if (T < y)
							for (var A = 0; A < w.length; A++) C[T] = A, yield* _(w[A], T + 1);
						else
							for (var k = 0; k < w.length; k++) C[T] = k, yield {
								value: w[k],
								index: C.slice()
							}
					};
				yield* _(this._data, 0)
			}
		}, a.prototype.rows = function() {
			var y = [],
				b = this.size();
			if (b.length !== 2) throw new TypeError("Rows can only be returned for a 2D matrix.");
			var C = this._data;
			for (var _ of C) y.push(new a([_], this._datatype));
			return y
		}, a.prototype.columns = function() {
			var y = this,
				b = [],
				C = this.size();
			if (C.length !== 2) throw new TypeError("Rows can only be returned for a 2D matrix.");
			for (var _ = this._data, S = function(A) {
					var k = _.map(M => [M[A]]);
					b.push(new a(k, y._datatype))
				}, w = 0; w < C[1]; w++) S(w);
			return b
		}, a.prototype.toArray = function() {
			return clone$2(this._data)
		}, a.prototype.valueOf = function() {
			return this._data
		}, a.prototype.format = function(y) {
			return format(this._data, y)
		}, a.prototype.toString = function() {
			return format(this._data)
		}, a.prototype.toJSON = function() {
			return {
				mathjs: "DenseMatrix",
				data: this._data,
				size: this._size,
				datatype: this._datatype
			}
		}, a.prototype.diagonal = function(y) {
			if (y) {
				if (isBigNumber(y) && (y = y.toNumber()), !isNumber(y) || !isInteger(y)) throw new TypeError(
					"The parameter k must be an integer number")
			} else y = 0;
			for (var b = y > 0 ? y : 0, C = y < 0 ? -y : 0, _ = this._size[0], S = this._size[1], w = Math.min(
					_ - C, S - b), T = [], A = 0; A < w; A++) T[A] = this._data[A + C][A + b];
			return new a({
				data: T,
				size: [w],
				datatype: this._datatype
			})
		}, a.diagonal = function(y, b, C, _) {
			if (!isArray(y)) throw new TypeError("Array expected, size parameter");
			if (y.length !== 2) throw new Error("Only two dimensions matrix are supported");
			if (y = y.map(function(O) {
					if (isBigNumber(O) && (O = O.toNumber()), !isNumber(O) || !isInteger(O) || O < 1)
					throw new Error("Size values must be positive integers");
					return O
				}), C) {
				if (isBigNumber(C) && (C = C.toNumber()), !isNumber(C) || !isInteger(C)) throw new TypeError(
					"The parameter k must be an integer number")
			} else C = 0;
			var S = C > 0 ? C : 0,
				w = C < 0 ? -C : 0,
				T = y[0],
				A = y[1],
				k = Math.min(T - w, A - S),
				M;
			if (isArray(b)) {
				if (b.length !== k) throw new Error("Invalid value array length");
				M = function(U) {
					return b[U]
				}
			} else if (isMatrix(b)) {
				var D = b.size();
				if (D.length !== 1 || D[0] !== k) throw new Error("Invalid matrix length");
				M = function(U) {
					return b.get([U])
				}
			} else M = function() {
				return b
			};
			_ || (_ = isBigNumber(M(0)) ? M(0).mul(0) : 0);
			var F = [];
			if (y.length > 0) {
				F = resize(F, y, _);
				for (var R = 0; R < k; R++) F[R + w][R + S] = M(R)
			}
			return new a({
				data: F,
				size: [T, A]
			})
		}, a.fromJSON = function(y) {
			return new a(y)
		}, a.prototype.swapRows = function(y, b) {
			if (!isNumber(y) || !isInteger(y) || !isNumber(b) || !isInteger(b)) throw new Error(
				"Row index must be positive integers");
			if (this._size.length !== 2) throw new Error("Only two dimensional matrix is supported");
			return validateIndex(y, this._size[0]), validateIndex(b, this._size[0]), a._swapRows(y, b, this
				._data), this
		}, a._swapRows = function(y, b, C) {
			var _ = C[y];
			C[y] = C[b], C[b] = _
		};

		function v(y) {
			return isMatrix(y) ? v(y.valueOf()) : isArray(y) ? y.map(v) : y
		}
		return a
	}, {
		isClass: !0
	});

function deepMap(o, s, a) {
	if (!a) return isMatrix(o) ? o.map(c => s(c), !1, !0) : deepMap$1(o, s, !0);
	var l = c => c === 0 ? c : s(c);
	return isMatrix(o) ? o.map(c => l(c), !1, !0) : deepMap$1(o, l, !0)
}
var n1 = "number",
	n2 = "number, number";

function absNumber(o) {
	return Math.abs(o)
}
absNumber.signature = n1;

function addNumber(o, s) {
	return o + s
}
addNumber.signature = n2;

function subtractNumber(o, s) {
	return o - s
}
subtractNumber.signature = n2;

function multiplyNumber(o, s) {
	return o * s
}
multiplyNumber.signature = n2;

function unaryMinusNumber(o) {
	return -o
}
unaryMinusNumber.signature = n1;

function nearlyEqual(o, s) {
	var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-9,
		l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
	if (a <= 0) throw new Error("Relative tolerance must be greater than 0");
	if (l < 0) throw new Error("Absolute tolerance must be at least 0");
	return o.isNaN() || s.isNaN() ? !1 : !o.isFinite() || !s.isFinite() ? o.eq(s) : o.eq(s) ? !0 : o.minus(s).abs().lte(
		o.constructor.max(o.constructor.max(o.abs(), s.abs()).mul(a), l))
}
var name$m = "isZero",
	dependencies$m = ["typed", "equalScalar"],
	createIsZero = factory(name$m, dependencies$m, o => {
		var {
			typed: s,
			equalScalar: a
		} = o;
		return s(name$m, {
			"number | BigNumber | Complex | Fraction": l => a(l, 0),
			bigint: l => l === 0n,
			Unit: s.referToSelf(l => c => s.find(l, c.valueType())(c.value)),
			"Array | Matrix": s.referToSelf(l => c => deepMap(c, l))
		})
	});

function complexEquals(o, s, a, l) {
	return nearlyEqual$1(o.re, s.re, a, l) && nearlyEqual$1(o.im, s.im, a, l)
}
var createCompareUnits = factory("compareUnits", ["typed"], o => {
		var {
			typed: s
		} = o;
		return {
			"Unit, Unit": s.referToSelf(a => (l, c) => {
				if (!l.equalBase(c)) throw new Error("Cannot compare units with different base");
				return s.find(a, [l.valueType(), c.valueType()])(l.value, c.value)
			})
		}
	}),
	name$l = "equalScalar",
	dependencies$l = ["typed", "config"],
	createEqualScalar = factory(name$l, dependencies$l, o => {
		var {
			typed: s,
			config: a
		} = o, l = createCompareUnits({
			typed: s
		});
		return s(name$l, {
			"boolean, boolean": function(d, f) {
				return d === f
			},
			"number, number": function(d, f) {
				return nearlyEqual$1(d, f, a.relTol, a.absTol)
			},
			"BigNumber, BigNumber": function(d, f) {
				return d.eq(f) || nearlyEqual(d, f, a.relTol, a.absTol)
			},
			"bigint, bigint": function(d, f) {
				return d === f
			},
			"Fraction, Fraction": function(d, f) {
				return d.equals(f)
			},
			"Complex, Complex": function(d, f) {
				return complexEquals(d, f, a.relTol, a.absTol)
			}
		}, l)
	});
factory(name$l, ["typed", "config"], o => {
	var {
		typed: s,
		config: a
	} = o;
	return s(name$l, {
		"number, number": function(c, d) {
			return nearlyEqual$1(c, d, a.relTol, a.absTol)
		}
	})
});
var name$k = "SparseMatrix",
	dependencies$k = ["typed", "equalScalar", "Matrix"],
	createSparseMatrixClass = factory(name$k, dependencies$k, o => {
		var {
			typed: s,
			equalScalar: a,
			Matrix: l
		} = o;

		function c(w, T) {
			if (!(this instanceof c)) throw new SyntaxError("Constructor must be called with the new operator");
			if (T && !isString(T)) throw new Error("Invalid datatype: " + T);
			if (isMatrix(w)) d(this, w, T);
			else if (w && isArray(w.index) && isArray(w.ptr) && isArray(w.size)) this._values = w.values, this
				._index = w.index, this._ptr = w.ptr, this._size = w.size, this._datatype = T || w.datatype;
			else if (isArray(w)) f(this, w, T);
			else {
				if (w) throw new TypeError("Unsupported type of data (" + typeOf(w) + ")");
				this._values = [], this._index = [], this._ptr = [0], this._size = [0, 0], this._datatype = T
			}
		}

		function d(w, T, A) {
			T.type === "SparseMatrix" ? (w._values = T._values ? clone$2(T._values) : void 0, w._index = clone$2(T
					._index), w._ptr = clone$2(T._ptr), w._size = clone$2(T._size), w._datatype = A || T
				._datatype) : f(w, T.valueOf(), A || T._datatype)
		}

		function f(w, T, A) {
			w._values = [], w._index = [], w._ptr = [], w._datatype = A;
			var k = T.length,
				M = 0,
				D = a,
				F = 0;
			if (isString(A) && (D = s.find(a, [A, A]) || a, F = s.convert(0, A)), k > 0) {
				var R = 0;
				do {
					w._ptr.push(w._index.length);
					for (var O = 0; O < k; O++) {
						var U = T[O];
						if (isArray(U)) {
							if (R === 0 && M < U.length && (M = U.length), R < U.length) {
								var V = U[R];
								D(V, F) || (w._values.push(V), w._index.push(O))
							}
						} else R === 0 && M < 1 && (M = 1), D(U, F) || (w._values.push(U), w._index.push(O))
					}
					R++
				} while (R < M)
			}
			w._ptr.push(w._index.length), w._size = [k, M]
		}
		c.prototype = new l, c.prototype.createSparseMatrix = function(w, T) {
				return new c(w, T)
			}, Object.defineProperty(c, "name", {
				value: "SparseMatrix"
			}), c.prototype.constructor = c, c.prototype.type = "SparseMatrix", c.prototype.isSparseMatrix = !0, c
			.prototype.getDataType = function() {
				return getArrayDataType(this._values, typeOf)
			}, c.prototype.storage = function() {
				return "sparse"
			}, c.prototype.datatype = function() {
				return this._datatype
			}, c.prototype.create = function(w, T) {
				return new c(w, T)
			}, c.prototype.density = function() {
				var w = this._size[0],
					T = this._size[1];
				return w !== 0 && T !== 0 ? this._index.length / (w * T) : 0
			}, c.prototype.subset = function(w, T, A) {
				if (!this._values) throw new Error("Cannot invoke subset on a Pattern only matrix");
				switch (arguments.length) {
					case 1:
						return m(this, w);
					case 2:
					case 3:
						return g(this, w, T, A);
					default:
						throw new SyntaxError("Wrong number of arguments")
				}
			};

		function m(w, T) {
			if (!isIndex(T)) throw new TypeError("Invalid index");
			var A = T.isScalar();
			if (A) return w.get(T.min());
			var k = T.size();
			if (k.length !== w._size.length) throw new DimensionError(k.length, w._size.length);
			var M, D, F, R, O = T.min(),
				U = T.max();
			for (M = 0, D = w._size.length; M < D; M++) validateIndex(O[M], w._size[M]), validateIndex(U[M], w
				._size[M]);
			var V = w._values,
				z = w._index,
				j = w._ptr,
				ge = T.dimension(0),
				me = T.dimension(1),
				he = [],
				ce = [];
			ge.forEach(function(le, de) {
				ce[le] = de[0], he[le] = !0
			});
			var ae = V ? [] : void 0,
				fe = [],
				q = [];
			return me.forEach(function(le) {
				for (q.push(fe.length), F = j[le], R = j[le + 1]; F < R; F++) M = z[F], he[M] === !0 && (fe
					.push(ce[M]), ae && ae.push(V[F]))
			}), q.push(fe.length), new c({
				values: ae,
				index: fe,
				ptr: q,
				size: k,
				datatype: w._datatype
			})
		}

		function g(w, T, A, k) {
			if (!T || T.isIndex !== !0) throw new TypeError("Invalid index");
			var M = T.size(),
				D = T.isScalar(),
				F;
			if (isMatrix(A) ? (F = A.size(), A = A.toArray()) : F = arraySize(A), D) {
				if (F.length !== 0) throw new TypeError("Scalar expected");
				w.set(T.min(), A, k)
			} else {
				if (M.length !== 1 && M.length !== 2) throw new DimensionError(M.length, w._size.length, "<");
				if (F.length < M.length) {
					for (var R = 0, O = 0; M[R] === 1 && F[R] === 1;) R++;
					for (; M[R] === 1;) O++, R++;
					A = unsqueeze(A, M.length, O, F)
				}
				if (!deepStrictEqual(M, F)) throw new DimensionError(M, F, ">");
				if (M.length === 1) {
					var U = T.dimension(0);
					U.forEach(function(j, ge) {
						validateIndex(j), w.set([j, 0], A[ge[0]], k)
					})
				} else {
					var V = T.dimension(0),
						z = T.dimension(1);
					V.forEach(function(j, ge) {
						validateIndex(j), z.forEach(function(me, he) {
							validateIndex(me), w.set([j, me], A[ge[0]][he[0]], k)
						})
					})
				}
			}
			return w
		}
		c.prototype.get = function(w) {
			if (!isArray(w)) throw new TypeError("Array expected");
			if (w.length !== this._size.length) throw new DimensionError(w.length, this._size.length);
			if (!this._values) throw new Error("Cannot invoke get on a Pattern only matrix");
			var T = w[0],
				A = w[1];
			validateIndex(T, this._size[0]), validateIndex(A, this._size[1]);
			var k = v(T, this._ptr[A], this._ptr[A + 1], this._index);
			return k < this._ptr[A + 1] && this._index[k] === T ? this._values[k] : 0
		}, c.prototype.set = function(w, T, A) {
			if (!isArray(w)) throw new TypeError("Array expected");
			if (w.length !== this._size.length) throw new DimensionError(w.length, this._size.length);
			if (!this._values) throw new Error("Cannot invoke set on a Pattern only matrix");
			var k = w[0],
				M = w[1],
				D = this._size[0],
				F = this._size[1],
				R = a,
				O = 0;
			isString(this._datatype) && (R = s.find(a, [this._datatype, this._datatype]) || a, O = s.convert(0,
				this._datatype)), (k > D - 1 || M > F - 1) && (C(this, Math.max(k + 1, D), Math.max(M + 1,
				F), A), D = this._size[0], F = this._size[1]), validateIndex(k, D), validateIndex(M, F);
			var U = v(k, this._ptr[M], this._ptr[M + 1], this._index);
			return U < this._ptr[M + 1] && this._index[U] === k ? R(T, O) ? y(U, M, this._values, this._index,
				this._ptr) : this._values[U] = T : R(T, O) || b(U, k, M, T, this._values, this._index, this
				._ptr), this
		};

		function v(w, T, A, k) {
			if (A - T === 0) return A;
			for (var M = T; M < A; M++)
				if (k[M] === w) return M;
			return T
		}

		function y(w, T, A, k, M) {
			A.splice(w, 1), k.splice(w, 1);
			for (var D = T + 1; D < M.length; D++) M[D]--
		}

		function b(w, T, A, k, M, D, F) {
			M.splice(w, 0, k), D.splice(w, 0, T);
			for (var R = A + 1; R < F.length; R++) F[R]++
		}
		c.prototype.resize = function(w, T, A) {
			if (!isCollection(w)) throw new TypeError("Array or Matrix expected");
			var k = w.valueOf().map(D => Array.isArray(D) && D.length === 1 ? D[0] : D);
			if (k.length !== 2) throw new Error("Only two dimensions matrix are supported");
			k.forEach(function(D) {
				if (!isNumber(D) || !isInteger(D) || D < 0) throw new TypeError(
					"Invalid size, must contain positive integers (size: " + format(k) + ")")
			});
			var M = A ? this.clone() : this;
			return C(M, k[0], k[1], T)
		};

		function C(w, T, A, k) {
			var M = k || 0,
				D = a,
				F = 0;
			isString(w._datatype) && (D = s.find(a, [w._datatype, w._datatype]) || a, F = s.convert(0, w._datatype),
				M = s.convert(M, w._datatype));
			var R = !D(M, F),
				O = w._size[0],
				U = w._size[1],
				V, z, j;
			if (A > U) {
				for (z = U; z < A; z++)
					if (w._ptr[z] = w._values.length, R)
						for (V = 0; V < O; V++) w._values.push(M), w._index.push(V);
				w._ptr[A] = w._values.length
			} else A < U && (w._ptr.splice(A + 1, U - A), w._values.splice(w._ptr[A], w._values.length), w._index
				.splice(w._ptr[A], w._index.length));
			if (U = A, T > O) {
				if (R) {
					var ge = 0;
					for (z = 0; z < U; z++) {
						w._ptr[z] = w._ptr[z] + ge, j = w._ptr[z + 1] + ge;
						var me = 0;
						for (V = O; V < T; V++, me++) w._values.splice(j + me, 0, M), w._index.splice(j + me, 0, V),
							ge++
					}
					w._ptr[U] = w._values.length
				}
			} else if (T < O) {
				var he = 0;
				for (z = 0; z < U; z++) {
					w._ptr[z] = w._ptr[z] - he;
					var ce = w._ptr[z],
						ae = w._ptr[z + 1] - he;
					for (j = ce; j < ae; j++) V = w._index[j], V > T - 1 && (w._values.splice(j, 1), w._index
						.splice(j, 1), he++)
				}
				w._ptr[z] = w._values.length
			}
			return w._size[0] = T, w._size[1] = A, w
		}
		c.prototype.reshape = function(w, T) {
			if (!isArray(w)) throw new TypeError("Array expected");
			if (w.length !== 2) throw new Error("Sparse matrices can only be reshaped in two dimensions");
			w.forEach(function(le) {
				if (!isNumber(le) || !isInteger(le) || le <= -2 || le === 0) throw new TypeError(
					"Invalid size, must contain positive integers or -1 (size: " + format(w) +
					")")
			});
			var A = this._size[0] * this._size[1];
			w = processSizesWildcard(w, A);
			var k = w[0] * w[1];
			if (A !== k) throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
			var M = T ? this.clone() : this;
			if (this._size[0] === w[0] && this._size[1] === w[1]) return M;
			for (var D = [], F = 0; F < M._ptr.length; F++)
				for (var R = 0; R < M._ptr[F + 1] - M._ptr[F]; R++) D.push(F);
			for (var O = M._values.slice(), U = M._index.slice(), V = 0; V < M._index.length; V++) {
				var z = U[V],
					j = D[V],
					ge = z * M._size[1] + j;
				D[V] = ge % w[1], U[V] = Math.floor(ge / w[1])
			}
			M._values.length = 0, M._index.length = 0, M._ptr.length = w[1] + 1, M._size = w.slice();
			for (var me = 0; me < M._ptr.length; me++) M._ptr[me] = 0;
			for (var he = 0; he < O.length; he++) {
				var ce = U[he],
					ae = D[he],
					fe = O[he],
					q = v(ce, M._ptr[ae], M._ptr[ae + 1], M._index);
				b(q, ce, ae, fe, M._values, M._index, M._ptr)
			}
			return M
		}, c.prototype.clone = function() {
			var w = new c({
				values: this._values ? clone$2(this._values) : void 0,
				index: clone$2(this._index),
				ptr: clone$2(this._ptr),
				size: clone$2(this._size),
				datatype: this._datatype
			});
			return w
		}, c.prototype.size = function() {
			return this._size.slice(0)
		}, c.prototype.map = function(w, T) {
			if (!this._values) throw new Error("Cannot invoke map on a Pattern only matrix");
			var A = this,
				k = this._size[0],
				M = this._size[1],
				D = optimizeCallback(w, A, "map"),
				F = function(O, U, V) {
					return D.fn(O, [U, V], A)
				};
			return _(this, 0, k - 1, 0, M - 1, F, T)
		};

		function _(w, T, A, k, M, D, F) {
			var R = [],
				O = [],
				U = [],
				V = a,
				z = 0;
			isString(w._datatype) && (V = s.find(a, [w._datatype, w._datatype]) || a, z = s.convert(0, w
			._datatype));
			for (var j = function(De, Se, be) {
					var Me = D(De, Se, be);
					V(Me, z) || (R.push(Me), O.push(Se))
				}, ge = k; ge <= M; ge++) {
				U.push(R.length);
				var me = w._ptr[ge],
					he = w._ptr[ge + 1];
				if (F)
					for (var ce = me; ce < he; ce++) {
						var ae = w._index[ce];
						ae >= T && ae <= A && j(w._values[ce], ae - T, ge - k)
					} else {
						for (var fe = {}, q = me; q < he; q++) {
							var le = w._index[q];
							fe[le] = w._values[q]
						}
						for (var de = T; de <= A; de++) {
							var _e = de in fe ? fe[de] : 0;
							j(_e, de - T, ge - k)
						}
					}
			}
			return U.push(R.length), new c({
				values: R,
				index: O,
				ptr: U,
				size: [A - T + 1, M - k + 1]
			})
		}
		c.prototype.forEach = function(w, T) {
			if (!this._values) throw new Error("Cannot invoke forEach on a Pattern only matrix");
			for (var A = this, k = this._size[0], M = this._size[1], D = optimizeCallback(w, A, "forEach"), F =
					0; F < M; F++) {
				var R = this._ptr[F],
					O = this._ptr[F + 1];
				if (T)
					for (var U = R; U < O; U++) {
						var V = this._index[U];
						D.fn(this._values[U], [V, F], A)
					} else {
						for (var z = {}, j = R; j < O; j++) {
							var ge = this._index[j];
							z[ge] = this._values[j]
						}
						for (var me = 0; me < k; me++) {
							var he = me in z ? z[me] : 0;
							D.fn(he, [me, F], A)
						}
					}
			}
		}, c.prototype[Symbol.iterator] = function*() {
			if (!this._values) throw new Error("Cannot iterate a Pattern only matrix");
			for (var w = this._size[1], T = 0; T < w; T++)
				for (var A = this._ptr[T], k = this._ptr[T + 1], M = A; M < k; M++) {
					var D = this._index[M];
					yield {
						value: this._values[M],
						index: [D, T]
					}
				}
		}, c.prototype.toArray = function() {
			return S(this._values, this._index, this._ptr, this._size, !0)
		}, c.prototype.valueOf = function() {
			return S(this._values, this._index, this._ptr, this._size, !1)
		};

		function S(w, T, A, k, M) {
			var D = k[0],
				F = k[1],
				R = [],
				O, U;
			for (O = 0; O < D; O++)
				for (R[O] = [], U = 0; U < F; U++) R[O][U] = 0;
			for (U = 0; U < F; U++)
				for (var V = A[U], z = A[U + 1], j = V; j < z; j++) O = T[j], R[O][U] = w ? M ? clone$2(w[j]) : w[
					j] : 1;
			return R
		}
		return c.prototype.format = function(w) {
			for (var T = this._size[0], A = this._size[1], k = this.density(), M = "Sparse Matrix [" + format(T,
					w) + " x " + format(A, w) + "] density: " + format(k, w) + `
`, D = 0; D < A; D++)
				for (var F = this._ptr[D], R = this._ptr[D + 1], O = F; O < R; O++) {
					var U = this._index[O];
					M += `
    (` + format(U, w) + ", " + format(D, w) + ") ==> " + (this._values ? format(this._values[O], w) : "X")
				}
			return M
		}, c.prototype.toString = function() {
			return format(this.toArray())
		}, c.prototype.toJSON = function() {
			return {
				mathjs: "SparseMatrix",
				values: this._values,
				index: this._index,
				ptr: this._ptr,
				size: this._size,
				datatype: this._datatype
			}
		}, c.prototype.diagonal = function(w) {
			if (w) {
				if (isBigNumber(w) && (w = w.toNumber()), !isNumber(w) || !isInteger(w)) throw new TypeError(
					"The parameter k must be an integer number")
			} else w = 0;
			var T = w > 0 ? w : 0,
				A = w < 0 ? -w : 0,
				k = this._size[0],
				M = this._size[1],
				D = Math.min(k - A, M - T),
				F = [],
				R = [],
				O = [];
			O[0] = 0;
			for (var U = T; U < M && F.length < D; U++)
				for (var V = this._ptr[U], z = this._ptr[U + 1], j = V; j < z; j++) {
					var ge = this._index[j];
					if (ge === U - T + A) {
						F.push(this._values[j]), R[F.length - 1] = ge - A;
						break
					}
				}
			return O.push(F.length), new c({
				values: F,
				index: R,
				ptr: O,
				size: [D, 1]
			})
		}, c.fromJSON = function(w) {
			return new c(w)
		}, c.diagonal = function(w, T, A, k, M) {
			if (!isArray(w)) throw new TypeError("Array expected, size parameter");
			if (w.length !== 2) throw new Error("Only two dimensions matrix are supported");
			if (w = w.map(function(le) {
					if (isBigNumber(le) && (le = le.toNumber()), !isNumber(le) || !isInteger(le) || le < 1)
						throw new Error("Size values must be positive integers");
					return le
				}), A) {
				if (isBigNumber(A) && (A = A.toNumber()), !isNumber(A) || !isInteger(A)) throw new TypeError(
					"The parameter k must be an integer number")
			} else A = 0;
			var D = a,
				F = 0;
			isString(M) && (D = s.find(a, [M, M]) || a, F = s.convert(0, M));
			var R = A > 0 ? A : 0,
				O = A < 0 ? -A : 0,
				U = w[0],
				V = w[1],
				z = Math.min(U - O, V - R),
				j;
			if (isArray(T)) {
				if (T.length !== z) throw new Error("Invalid value array length");
				j = function(de) {
					return T[de]
				}
			} else if (isMatrix(T)) {
				var ge = T.size();
				if (ge.length !== 1 || ge[0] !== z) throw new Error("Invalid matrix length");
				j = function(de) {
					return T.get([de])
				}
			} else j = function() {
				return T
			};
			for (var me = [], he = [], ce = [], ae = 0; ae < V; ae++) {
				ce.push(me.length);
				var fe = ae - R;
				if (fe >= 0 && fe < z) {
					var q = j(fe);
					D(q, F) || (he.push(fe + O), me.push(q))
				}
			}
			return ce.push(me.length), new c({
				values: me,
				index: he,
				ptr: ce,
				size: [U, V]
			})
		}, c.prototype.swapRows = function(w, T) {
			if (!isNumber(w) || !isInteger(w) || !isNumber(T) || !isInteger(T)) throw new Error(
				"Row index must be positive integers");
			if (this._size.length !== 2) throw new Error("Only two dimensional matrix is supported");
			return validateIndex(w, this._size[0]), validateIndex(T, this._size[0]), c._swapRows(w, T, this
				._size[1], this._values, this._index, this._ptr), this
		}, c._forEachRow = function(w, T, A, k, M) {
			for (var D = k[w], F = k[w + 1], R = D; R < F; R++) M(A[R], T[R])
		}, c._swapRows = function(w, T, A, k, M, D) {
			for (var F = 0; F < A; F++) {
				var R = D[F],
					O = D[F + 1],
					U = v(w, R, O, M),
					V = v(T, R, O, M);
				if (U < O && V < O && M[U] === w && M[V] === T) {
					if (k) {
						var z = k[U];
						k[U] = k[V], k[V] = z
					}
					continue
				}
				if (U < O && M[U] === w && (V >= O || M[V] !== T)) {
					var j = k ? k[U] : void 0;
					M.splice(V, 0, T), k && k.splice(V, 0, j), M.splice(V <= U ? U + 1 : U, 1), k && k.splice(
						V <= U ? U + 1 : U, 1);
					continue
				}
				if (V < O && M[V] === T && (U >= O || M[U] !== w)) {
					var ge = k ? k[V] : void 0;
					M.splice(U, 0, w), k && k.splice(U, 0, ge), M.splice(U <= V ? V + 1 : V, 1), k && k.splice(
						U <= V ? V + 1 : V, 1)
				}
			}
		}, c
	}, {
		isClass: !0
	}),
	name$j = "number",
	dependencies$j = ["typed"];

function getNonDecimalNumberParts(o) {
	var s = o.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
	if (s) {
		var a = {
				"0b": 2,
				"0o": 8,
				"0x": 16
			} [s[1]],
			l = s[2],
			c = s[3];
		return {
			input: o,
			radix: a,
			integerPart: l,
			fractionalPart: c
		}
	} else return null
}

function makeNumberFromNonDecimalParts(o) {
	for (var s = parseInt(o.integerPart, o.radix), a = 0, l = 0; l < o.fractionalPart.length; l++) {
		var c = parseInt(o.fractionalPart[l], o.radix);
		a += c / Math.pow(o.radix, l + 1)
	}
	var d = s + a;
	if (isNaN(d)) throw new SyntaxError('String "' + o.input + '" is not a valid number');
	return d
}
var createNumber = factory(name$j, dependencies$j, o => {
		var {
			typed: s
		} = o, a = s("number", {
			"": function() {
				return 0
			},
			number: function(c) {
				return c
			},
			string: function(c) {
				if (c === "NaN") return NaN;
				var d = getNonDecimalNumberParts(c);
				if (d) return makeNumberFromNonDecimalParts(d);
				var f = 0,
					m = c.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
				m && (f = Number(m[2]), c = m[1]);
				var g = Number(c);
				if (isNaN(g)) throw new SyntaxError('String "' + c + '" is not a valid number');
				if (m) {
					if (g > 2 ** f - 1) throw new SyntaxError('String "'.concat(c,
					'" is out of range'));
					g >= 2 ** (f - 1) && (g = g - 2 ** f)
				}
				return g
			},
			BigNumber: function(c) {
				return c.toNumber()
			},
			bigint: function(c) {
				return Number(c)
			},
			Fraction: function(c) {
				return c.valueOf()
			},
			Unit: s.referToSelf(l => c => {
				var d = c.clone();
				return d.value = l(c.value), d
			}),
			null: function(c) {
				return 0
			},
			"Unit, string | Unit": function(c, d) {
				return c.toNumber(d)
			},
			"Array | Matrix": s.referToSelf(l => c => deepMap(c, l))
		});
		return a.fromJSON = function(l) {
			return parseFloat(l.value)
		}, a
	}),
	name$i = "bignumber",
	dependencies$i = ["typed", "BigNumber"],
	createBignumber = factory(name$i, dependencies$i, o => {
		var {
			typed: s,
			BigNumber: a
		} = o;
		return s("bignumber", {
			"": function() {
				return new a(0)
			},
			number: function(c) {
				return new a(c + "")
			},
			string: function(c) {
				var d = c.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
				if (d) {
					var f = d[2],
						m = a(d[1]),
						g = new a(2).pow(Number(f));
					if (m.gt(g.sub(1))) throw new SyntaxError('String "'.concat(c,
					'" is out of range'));
					var v = new a(2).pow(Number(f) - 1);
					return m.gte(v) ? m.sub(g) : m
				}
				return new a(c)
			},
			BigNumber: function(c) {
				return c
			},
			bigint: function(c) {
				return new a(c.toString())
			},
			Unit: s.referToSelf(l => c => {
				var d = c.clone();
				return d.value = l(c.value), d
			}),
			Fraction: function(c) {
				return new a(String(c.n)).div(String(c.d)).times(String(c.s))
			},
			null: function(c) {
				return new a(0)
			},
			"Array | Matrix": s.referToSelf(l => c => deepMap(c, l))
		})
	}),
	name$h = "fraction",
	dependencies$h = ["typed", "Fraction"],
	createFraction = factory(name$h, dependencies$h, o => {
		var {
			typed: s,
			Fraction: a
		} = o;
		return s("fraction", {
			number: function(c) {
				if (!isFinite(c) || isNaN(c)) throw new Error(c +
					" cannot be represented as a fraction");
				return new a(c)
			},
			string: function(c) {
				return new a(c)
			},
			"number, number": function(c, d) {
				return new a(c, d)
			},
			"bigint, bigint": function(c, d) {
				return new a(c, d)
			},
			null: function(c) {
				return new a(0)
			},
			BigNumber: function(c) {
				return new a(c.toString())
			},
			bigint: function(c) {
				return new a(c.toString())
			},
			Fraction: function(c) {
				return c
			},
			Unit: s.referToSelf(l => c => {
				var d = c.clone();
				return d.value = l(c.value), d
			}),
			Object: function(c) {
				return new a(c)
			},
			"Array | Matrix": s.referToSelf(l => c => deepMap(c, l))
		})
	}),
	name$g = "matrix",
	dependencies$g = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"],
	createMatrix = factory(name$g, dependencies$g, o => {
		var {
			typed: s,
			Matrix: a,
			DenseMatrix: l,
			SparseMatrix: c
		} = o;
		return s(name$g, {
			"": function() {
				return d([])
			},
			string: function(m) {
				return d([], m)
			},
			"string, string": function(m, g) {
				return d([], m, g)
			},
			Array: function(m) {
				return d(m)
			},
			Matrix: function(m) {
				return d(m, m.storage())
			},
			"Array | Matrix, string": d,
			"Array | Matrix, string, string": d
		});

		function d(f, m, g) {
			if (m === "dense" || m === "default" || m === void 0) return new l(f, g);
			if (m === "sparse") return new c(f, g);
			throw new TypeError("Unknown matrix type " + JSON.stringify(m) + ".")
		}
	}),
	name$f = "unaryMinus",
	dependencies$f = ["typed"],
	createUnaryMinus = factory(name$f, dependencies$f, o => {
		var {
			typed: s
		} = o;
		return s(name$f, {
			number: unaryMinusNumber,
			"Complex | BigNumber | Fraction": a => a.neg(),
			bigint: a => -a,
			Unit: s.referToSelf(a => l => {
				var c = l.clone();
				return c.value = s.find(a, c.valueType())(l.value), c
			}),
			"Array | Matrix": s.referToSelf(a => l => deepMap(l, a, !0))
		})
	}),
	name$e = "abs",
	dependencies$e = ["typed"],
	createAbs = factory(name$e, dependencies$e, o => {
		var {
			typed: s
		} = o;
		return s(name$e, {
			number: absNumber,
			"Complex | BigNumber | Fraction | Unit": a => a.abs(),
			bigint: a => a < 0n ? -a : a,
			"Array | Matrix": s.referToSelf(a => l => deepMap(l, a, !0))
		})
	}),
	name$d = "addScalar",
	dependencies$d = ["typed"],
	createAddScalar = factory(name$d, dependencies$d, o => {
		var {
			typed: s
		} = o;
		return s(name$d, {
			"number, number": addNumber,
			"Complex, Complex": function(l, c) {
				return l.add(c)
			},
			"BigNumber, BigNumber": function(l, c) {
				return l.plus(c)
			},
			"bigint, bigint": function(l, c) {
				return l + c
			},
			"Fraction, Fraction": function(l, c) {
				return l.add(c)
			},
			"Unit, Unit": s.referToSelf(a => (l, c) => {
				if (l.value === null || l.value === void 0) throw new Error(
					"Parameter x contains a unit with undefined value");
				if (c.value === null || c.value === void 0) throw new Error(
					"Parameter y contains a unit with undefined value");
				if (!l.equalBase(c)) throw new Error("Units do not match");
				var d = l.clone();
				return d.value = s.find(a, [d.valueType(), c.valueType()])(d.value, c.value), d
					.fixPrefix = !1, d
			})
		})
	}),
	name$c = "subtractScalar",
	dependencies$c = ["typed"],
	createSubtractScalar = factory(name$c, dependencies$c, o => {
		var {
			typed: s
		} = o;
		return s(name$c, {
			"number, number": subtractNumber,
			"Complex, Complex": function(l, c) {
				return l.sub(c)
			},
			"BigNumber, BigNumber": function(l, c) {
				return l.minus(c)
			},
			"bigint, bigint": function(l, c) {
				return l - c
			},
			"Fraction, Fraction": function(l, c) {
				return l.sub(c)
			},
			"Unit, Unit": s.referToSelf(a => (l, c) => {
				if (l.value === null || l.value === void 0) throw new Error(
					"Parameter x contains a unit with undefined value");
				if (c.value === null || c.value === void 0) throw new Error(
					"Parameter y contains a unit with undefined value");
				if (!l.equalBase(c)) throw new Error("Units do not match");
				var d = l.clone();
				return d.value = s.find(a, [d.valueType(), c.valueType()])(d.value, c.value), d
					.fixPrefix = !1, d
			})
		})
	}),
	name$b = "matAlgo11xS0s",
	dependencies$b = ["typed", "equalScalar"],
	createMatAlgo11xS0s = factory(name$b, dependencies$b, o => {
		var {
			typed: s,
			equalScalar: a
		} = o;
		return function(c, d, f, m) {
			var g = c._values,
				v = c._index,
				y = c._ptr,
				b = c._size,
				C = c._datatype;
			if (!g) throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
			var _ = b[0],
				S = b[1],
				w, T = a,
				A = 0,
				k = f;
			typeof C == "string" && (w = C, T = s.find(a, [w, w]), A = s.convert(0, w), d = s.convert(d, w), k =
				s.find(f, [w, w]));
			for (var M = [], D = [], F = [], R = 0; R < S; R++) {
				F[R] = D.length;
				for (var O = y[R], U = y[R + 1], V = O; V < U; V++) {
					var z = v[V],
						j = m ? k(d, g[V]) : k(g[V], d);
					T(j, A) || (D.push(z), M.push(j))
				}
			}
			return F[S] = D.length, c.createSparseMatrix({
				values: M,
				index: D,
				ptr: F,
				size: [_, S],
				datatype: w
			})
		}
	}),
	name$a = "matAlgo14xDs",
	dependencies$a = ["typed"],
	createMatAlgo14xDs = factory(name$a, dependencies$a, o => {
		var {
			typed: s
		} = o;
		return function(c, d, f, m) {
			var g = c._data,
				v = c._size,
				y = c._datatype,
				b, C = f;
			typeof y == "string" && (b = y, d = s.convert(d, b), C = s.find(f, [b, b]));
			var _ = v.length > 0 ? a(C, 0, v, v[0], g, d, m) : [];
			return c.createDenseMatrix({
				data: _,
				size: clone$2(v),
				datatype: b
			})
		};

		function a(l, c, d, f, m, g, v) {
			var y = [];
			if (c === d.length - 1)
				for (var b = 0; b < f; b++) y[b] = v ? l(g, m[b]) : l(m[b], g);
			else
				for (var C = 0; C < f; C++) y[C] = a(l, c + 1, d, d[c + 1], m[C], g, v);
			return y
		}
	}),
	name$9 = "multiplyScalar",
	dependencies$9 = ["typed"],
	createMultiplyScalar = factory(name$9, dependencies$9, o => {
		var {
			typed: s
		} = o;
		return s("multiplyScalar", {
			"number, number": multiplyNumber,
			"Complex, Complex": function(l, c) {
				return l.mul(c)
			},
			"BigNumber, BigNumber": function(l, c) {
				return l.times(c)
			},
			"bigint, bigint": function(l, c) {
				return l * c
			},
			"Fraction, Fraction": function(l, c) {
				return l.mul(c)
			},
			"number | Fraction | BigNumber | Complex, Unit": (a, l) => l.multiply(a),
			"Unit, number | Fraction | BigNumber | Complex | Unit": (a, l) => a.multiply(l)
		})
	}),
	name$8 = "multiply",
	dependencies$8 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"],
	createMultiply = factory(name$8, dependencies$8, o => {
		var {
			typed: s,
			matrix: a,
			addScalar: l,
			multiplyScalar: c,
			equalScalar: d,
			dot: f
		} = o, m = createMatAlgo11xS0s({
			typed: s,
			equalScalar: d
		}), g = createMatAlgo14xDs({
			typed: s
		});

		function v(F, R) {
			switch (F.length) {
				case 1:
					switch (R.length) {
						case 1:
							if (F[0] !== R[0]) throw new RangeError(
								"Dimension mismatch in multiplication. Vectors must have the same length");
							break;
						case 2:
							if (F[0] !== R[0]) throw new RangeError(
								"Dimension mismatch in multiplication. Vector length (" + F[0] +
								") must match Matrix rows (" + R[0] + ")");
							break;
						default:
							throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + R
								.length + " dimensions)")
					}
					break;
				case 2:
					switch (R.length) {
						case 1:
							if (F[1] !== R[0]) throw new RangeError(
								"Dimension mismatch in multiplication. Matrix columns (" + F[1] +
								") must match Vector length (" + R[0] + ")");
							break;
						case 2:
							if (F[1] !== R[0]) throw new RangeError(
								"Dimension mismatch in multiplication. Matrix A columns (" + F[1] +
								") must match Matrix B rows (" + R[0] + ")");
							break;
						default:
							throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + R
								.length + " dimensions)")
					}
					break;
				default:
					throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + F.length +
						" dimensions)")
			}
		}

		function y(F, R, O) {
			if (O === 0) throw new Error("Cannot multiply two empty vectors");
			return f(F, R)
		}

		function b(F, R) {
			if (R.storage() !== "dense") throw new Error("Support for SparseMatrix not implemented");
			return C(F, R)
		}

		function C(F, R) {
			var O = F._data,
				U = F._size,
				V = F._datatype || F.getDataType(),
				z = R._data,
				j = R._size,
				ge = R._datatype || R.getDataType(),
				me = U[0],
				he = j[1],
				ce, ae = l,
				fe = c;
			V && ge && V === ge && typeof V == "string" && V !== "mixed" && (ce = V, ae = s.find(l, [ce, ce]), fe =
				s.find(c, [ce, ce]));
			for (var q = [], le = 0; le < he; le++) {
				for (var de = fe(O[0], z[0][le]), _e = 1; _e < me; _e++) de = ae(de, fe(O[_e], z[_e][le]));
				q[le] = de
			}
			return F.createDenseMatrix({
				data: q,
				size: [he],
				datatype: V === F._datatype && ge === R._datatype ? ce : void 0
			})
		}
		var _ = s("_multiplyMatrixVector", {
				"DenseMatrix, any": w,
				"SparseMatrix, any": k
			}),
			S = s("_multiplyMatrixMatrix", {
				"DenseMatrix, DenseMatrix": T,
				"DenseMatrix, SparseMatrix": A,
				"SparseMatrix, DenseMatrix": M,
				"SparseMatrix, SparseMatrix": D
			});

		function w(F, R) {
			var O = F._data,
				U = F._size,
				V = F._datatype || F.getDataType(),
				z = R._data,
				j = R._datatype || R.getDataType(),
				ge = U[0],
				me = U[1],
				he, ce = l,
				ae = c;
			V && j && V === j && typeof V == "string" && V !== "mixed" && (he = V, ce = s.find(l, [he, he]), ae = s
				.find(c, [he, he]));
			for (var fe = [], q = 0; q < ge; q++) {
				for (var le = O[q], de = ae(le[0], z[0]), _e = 1; _e < me; _e++) de = ce(de, ae(le[_e], z[_e]));
				fe[q] = de
			}
			return F.createDenseMatrix({
				data: fe,
				size: [ge],
				datatype: V === F._datatype && j === R._datatype ? he : void 0
			})
		}

		function T(F, R) {
			var O = F._data,
				U = F._size,
				V = F._datatype || F.getDataType(),
				z = R._data,
				j = R._size,
				ge = R._datatype || R.getDataType(),
				me = U[0],
				he = U[1],
				ce = j[1],
				ae, fe = l,
				q = c;
			V && ge && V === ge && typeof V == "string" && V !== "mixed" && V !== "mixed" && (ae = V, fe = s.find(l,
				[ae, ae]), q = s.find(c, [ae, ae]));
			for (var le = [], de = 0; de < me; de++) {
				var _e = O[de];
				le[de] = [];
				for (var ke = 0; ke < ce; ke++) {
					for (var De = q(_e[0], z[0][ke]), Se = 1; Se < he; Se++) De = fe(De, q(_e[Se], z[Se][ke]));
					le[de][ke] = De
				}
			}
			return F.createDenseMatrix({
				data: le,
				size: [me, ce],
				datatype: V === F._datatype && ge === R._datatype ? ae : void 0
			})
		}

		function A(F, R) {
			var O = F._data,
				U = F._size,
				V = F._datatype || F.getDataType(),
				z = R._values,
				j = R._index,
				ge = R._ptr,
				me = R._size,
				he = R._datatype || R._data === void 0 ? R._datatype : R.getDataType();
			if (!z) throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
			var ce = U[0],
				ae = me[1],
				fe, q = l,
				le = c,
				de = d,
				_e = 0;
			V && he && V === he && typeof V == "string" && V !== "mixed" && (fe = V, q = s.find(l, [fe, fe]), le = s
				.find(c, [fe, fe]), de = s.find(d, [fe, fe]), _e = s.convert(0, fe));
			for (var ke = [], De = [], Se = [], be = R.createSparseMatrix({
					values: ke,
					index: De,
					ptr: Se,
					size: [ce, ae],
					datatype: V === F._datatype && he === R._datatype ? fe : void 0
				}), Me = 0; Me < ae; Me++) {
				Se[Me] = De.length;
				var Ve = ge[Me],
					it = ge[Me + 1];
				if (it > Ve)
					for (var pt = 0, dt = 0; dt < ce; dt++) {
						for (var He = dt + 1, Ae = void 0, xe = Ve; xe < it; xe++) {
							var ye = j[xe];
							pt !== He ? (Ae = le(O[dt][ye], z[xe]), pt = He) : Ae = q(Ae, le(O[dt][ye], z[xe]))
						}
						pt === He && !de(Ae, _e) && (De.push(dt), ke.push(Ae))
					}
			}
			return Se[ae] = De.length, be
		}

		function k(F, R) {
			var O = F._values,
				U = F._index,
				V = F._ptr,
				z = F._datatype || F._data === void 0 ? F._datatype : F.getDataType();
			if (!O) throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
			var j = R._data,
				ge = R._datatype || R.getDataType(),
				me = F._size[0],
				he = R._size[0],
				ce = [],
				ae = [],
				fe = [],
				q, le = l,
				de = c,
				_e = d,
				ke = 0;
			z && ge && z === ge && typeof z == "string" && z !== "mixed" && (q = z, le = s.find(l, [q, q]), de = s
				.find(c, [q, q]), _e = s.find(d, [q, q]), ke = s.convert(0, q));
			var De = [],
				Se = [];
			fe[0] = 0;
			for (var be = 0; be < he; be++) {
				var Me = j[be];
				if (!_e(Me, ke))
					for (var Ve = V[be], it = V[be + 1], pt = Ve; pt < it; pt++) {
						var dt = U[pt];
						Se[dt] ? De[dt] = le(De[dt], de(Me, O[pt])) : (Se[dt] = !0, ae.push(dt), De[dt] = de(Me, O[
							pt]))
					}
			}
			for (var He = ae.length, Ae = 0; Ae < He; Ae++) {
				var xe = ae[Ae];
				ce[Ae] = De[xe]
			}
			return fe[1] = ae.length, F.createSparseMatrix({
				values: ce,
				index: ae,
				ptr: fe,
				size: [me, 1],
				datatype: z === F._datatype && ge === R._datatype ? q : void 0
			})
		}

		function M(F, R) {
			var O = F._values,
				U = F._index,
				V = F._ptr,
				z = F._datatype || F._data === void 0 ? F._datatype : F.getDataType();
			if (!O) throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
			var j = R._data,
				ge = R._datatype || R.getDataType(),
				me = F._size[0],
				he = R._size[0],
				ce = R._size[1],
				ae, fe = l,
				q = c,
				le = d,
				de = 0;
			z && ge && z === ge && typeof z == "string" && z !== "mixed" && (ae = z, fe = s.find(l, [ae, ae]), q = s
				.find(c, [ae, ae]), le = s.find(d, [ae, ae]), de = s.convert(0, ae));
			for (var _e = [], ke = [], De = [], Se = F.createSparseMatrix({
					values: _e,
					index: ke,
					ptr: De,
					size: [me, ce],
					datatype: z === F._datatype && ge === R._datatype ? ae : void 0
				}), be = [], Me = [], Ve = 0; Ve < ce; Ve++) {
				De[Ve] = ke.length;
				for (var it = Ve + 1, pt = 0; pt < he; pt++) {
					var dt = j[pt][Ve];
					if (!le(dt, de))
						for (var He = V[pt], Ae = V[pt + 1], xe = He; xe < Ae; xe++) {
							var ye = U[xe];
							Me[ye] !== it ? (Me[ye] = it, ke.push(ye), be[ye] = q(dt, O[xe])) : be[ye] = fe(be[ye],
								q(dt, O[xe]))
						}
				}
				for (var Le = De[Ve], Ue = ke.length, nt = Le; nt < Ue; nt++) {
					var ot = ke[nt];
					_e[nt] = be[ot]
				}
			}
			return De[ce] = ke.length, Se
		}

		function D(F, R) {
			var O = F._values,
				U = F._index,
				V = F._ptr,
				z = F._datatype || F._data === void 0 ? F._datatype : F.getDataType(),
				j = R._values,
				ge = R._index,
				me = R._ptr,
				he = R._datatype || R._data === void 0 ? R._datatype : R.getDataType(),
				ce = F._size[0],
				ae = R._size[1],
				fe = O && j,
				q, le = l,
				de = c;
			z && he && z === he && typeof z == "string" && z !== "mixed" && (q = z, le = s.find(l, [q, q]), de = s
				.find(c, [q, q]));
			for (var _e = fe ? [] : void 0, ke = [], De = [], Se = F.createSparseMatrix({
					values: _e,
					index: ke,
					ptr: De,
					size: [ce, ae],
					datatype: z === F._datatype && he === R._datatype ? q : void 0
				}), be = fe ? [] : void 0, Me = [], Ve, it, pt, dt, He, Ae, xe, ye, Le = 0; Le < ae; Le++) {
				De[Le] = ke.length;
				var Ue = Le + 1;
				for (He = me[Le], Ae = me[Le + 1], dt = He; dt < Ae; dt++)
					if (ye = ge[dt], fe)
						for (it = V[ye], pt = V[ye + 1], Ve = it; Ve < pt; Ve++) xe = U[Ve], Me[xe] !== Ue ? (Me[
							xe] = Ue, ke.push(xe), be[xe] = de(j[dt], O[Ve])) : be[xe] = le(be[xe], de(j[dt], O[
							Ve]));
					else
						for (it = V[ye], pt = V[ye + 1], Ve = it; Ve < pt; Ve++) xe = U[Ve], Me[xe] !== Ue && (Me[
							xe] = Ue, ke.push(xe));
				if (fe)
					for (var nt = De[Le], ot = ke.length, at = nt; at < ot; at++) {
						var Je = ke[at];
						_e[at] = be[Je]
					}
			}
			return De[ae] = ke.length, Se
		}
		return s(name$8, c, {
			"Array, Array": s.referTo("Matrix, Matrix", F => (R, O) => {
				v(arraySize(R), arraySize(O));
				var U = F(a(R), a(O));
				return isMatrix(U) ? U.valueOf() : U
			}),
			"Matrix, Matrix": function(R, O) {
				var U = R.size(),
					V = O.size();
				return v(U, V), U.length === 1 ? V.length === 1 ? y(R, O, U[0]) : b(R, O) : V.length ===
					1 ? _(R, O) : S(R, O)
			},
			"Matrix, Array": s.referTo("Matrix,Matrix", F => (R, O) => F(R, a(O))),
			"Array, Matrix": s.referToSelf(F => (R, O) => F(a(R, O.storage()), O)),
			"SparseMatrix, any": function(R, O) {
				return m(R, O, c, !1)
			},
			"DenseMatrix, any": function(R, O) {
				return g(R, O, c, !1)
			},
			"any, SparseMatrix": function(R, O) {
				return m(O, R, c, !0)
			},
			"any, DenseMatrix": function(R, O) {
				return g(O, R, c, !0)
			},
			"Array, any": function(R, O) {
				return g(a(R), O, c, !1).valueOf()
			},
			"any, Array": function(R, O) {
				return g(a(O), R, c, !0).valueOf()
			},
			"any, any": c,
			"any, any, ...any": s.referToSelf(F => (R, O, U) => {
				for (var V = F(R, O), z = 0; z < U.length; z++) V = F(V, U[z]);
				return V
			})
		})
	}),
	name$7 = "conj",
	dependencies$7 = ["typed"],
	createConj = factory(name$7, dependencies$7, o => {
		var {
			typed: s
		} = o;
		return s(name$7, {
			"number | BigNumber | Fraction": a => a,
			Complex: a => a.conjugate(),
			"Array | Matrix": s.referToSelf(a => l => deepMap(l, a))
		})
	}),
	name$6 = "identity",
	dependencies$6 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"],
	createIdentity = factory(name$6, dependencies$6, o => {
		var {
			typed: s,
			config: a,
			matrix: l,
			BigNumber: c,
			DenseMatrix: d,
			SparseMatrix: f
		} = o;
		return s(name$6, {
			"": function() {
				return a.matrix === "Matrix" ? l([]) : []
			},
			string: function(y) {
				return l(y)
			},
			"number | BigNumber": function(y) {
				return g(y, y, a.matrix === "Matrix" ? "dense" : void 0)
			},
			"number | BigNumber, string": function(y, b) {
				return g(y, y, b)
			},
			"number | BigNumber, number | BigNumber": function(y, b) {
				return g(y, b, a.matrix === "Matrix" ? "dense" : void 0)
			},
			"number | BigNumber, number | BigNumber, string": function(y, b, C) {
				return g(y, b, C)
			},
			Array: function(y) {
				return m(y)
			},
			"Array, string": function(y, b) {
				return m(y, b)
			},
			Matrix: function(y) {
				return m(y.valueOf(), y.storage())
			},
			"Matrix, string": function(y, b) {
				return m(y.valueOf(), b)
			}
		});

		function m(v, y) {
			switch (v.length) {
				case 0:
					return y ? l(y) : [];
				case 1:
					return g(v[0], v[0], y);
				case 2:
					return g(v[0], v[1], y);
				default:
					throw new Error("Vector containing two values expected")
			}
		}

		function g(v, y, b) {
			var C = isBigNumber(v) || isBigNumber(y) ? c : null;
			if (isBigNumber(v) && (v = v.toNumber()), isBigNumber(y) && (y = y.toNumber()), !isInteger(v) || v < 1)
				throw new Error("Parameters in function identity must be positive integers");
			if (!isInteger(y) || y < 1) throw new Error(
			"Parameters in function identity must be positive integers");
			var _ = C ? new c(1) : 1,
				S = C ? new C(0) : 0,
				w = [v, y];
			if (b) {
				if (b === "sparse") return f.diagonal(w, _, 0, S);
				if (b === "dense") return d.diagonal(w, _, 0, S);
				throw new TypeError('Unknown matrix type "'.concat(b, '"'))
			}
			for (var T = resize([], w, S), A = v < y ? v : y, k = 0; k < A; k++) T[k][k] = _;
			return T
		}
	});

function noBignumber() {
	throw new Error('No "bignumber" implementation available')
}

function noFraction() {
	throw new Error('No "fraction" implementation available')
}

function noMatrix() {
	throw new Error('No "matrix" implementation available')
}
var name$5 = "size",
	dependencies$5 = ["typed", "config", "?matrix"],
	createSize = factory(name$5, dependencies$5, o => {
		var {
			typed: s,
			config: a,
			matrix: l
		} = o;
		return s(name$5, {
			Matrix: function(d) {
				return d.create(d.size(), "number")
			},
			Array: arraySize,
			string: function(d) {
				return a.matrix === "Array" ? [d.length] : l([d.length], "dense", "number")
			},
			"number | Complex | BigNumber | Unit | boolean | null": function(d) {
				return a.matrix === "Array" ? [] : l ? l([], "dense", "number") : noMatrix()
			}
		})
	}),
	name$4 = "numeric",
	dependencies$4 = ["number", "?bignumber", "?fraction"],
	createNumeric = factory(name$4, dependencies$4, o => {
		var {
			number: s,
			bignumber: a,
			fraction: l
		} = o, c = {
			string: !0,
			number: !0,
			BigNumber: !0,
			Fraction: !0
		}, d = {
			number: f => s(f),
			BigNumber: a ? f => a(f) : noBignumber,
			bigint: f => BigInt(f),
			Fraction: l ? f => l(f) : noFraction
		};
		return function(m) {
			var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number",
				v = arguments.length > 2 ? arguments[2] : void 0;
			if (v !== void 0) throw new SyntaxError("numeric() takes one or two arguments");
			var y = typeOf(m);
			if (!(y in c)) throw new TypeError("Cannot convert " + m + ' of type "' + y +
				'"; valid input types are ' + Object.keys(c).join(", "));
			if (!(g in d)) throw new TypeError("Cannot convert " + m + ' to type "' + g +
				'"; valid output types are ' + Object.keys(d).join(", "));
			return g === y ? m : d[g](m)
		}
	}),
	name$3 = "divideScalar",
	dependencies$3 = ["typed", "numeric"],
	createDivideScalar = factory(name$3, dependencies$3, o => {
		var {
			typed: s,
			numeric: a
		} = o;
		return s(name$3, {
			"number, number": function(c, d) {
				return c / d
			},
			"Complex, Complex": function(c, d) {
				return c.div(d)
			},
			"BigNumber, BigNumber": function(c, d) {
				return c.div(d)
			},
			"bigint, bigint": function(c, d) {
				return c / d
			},
			"Fraction, Fraction": function(c, d) {
				return c.div(d)
			},
			"Unit, number | Complex | Fraction | BigNumber | Unit": (l, c) => l.divide(c),
			"number | Fraction | Complex | BigNumber, Unit": (l, c) => c.divideInto(l)
		})
	}),
	name$2 = "dot",
	dependencies$2 = ["typed", "addScalar", "multiplyScalar", "conj", "size"],
	createDot = factory(name$2, dependencies$2, o => {
		var {
			typed: s,
			addScalar: a,
			multiplyScalar: l,
			conj: c,
			size: d
		} = o;
		return s(name$2, {
			"Array | DenseMatrix, Array | DenseMatrix": m,
			"SparseMatrix, SparseMatrix": g
		});

		function f(y, b) {
			var C = v(y),
				_ = v(b),
				S, w;
			if (C.length === 1) S = C[0];
			else if (C.length === 2 && C[1] === 1) S = C[0];
			else throw new RangeError("Expected a column vector, instead got a matrix of size (" + C.join(", ") +
				")");
			if (_.length === 1) w = _[0];
			else if (_.length === 2 && _[1] === 1) w = _[0];
			else throw new RangeError("Expected a column vector, instead got a matrix of size (" + _.join(", ") +
				")");
			if (S !== w) throw new RangeError("Vectors must have equal length (" + S + " != " + w + ")");
			if (S === 0) throw new RangeError("Cannot calculate the dot product of empty vectors");
			return S
		}

		function m(y, b) {
			var C = f(y, b),
				_ = isMatrix(y) ? y._data : y,
				S = isMatrix(y) ? y._datatype || y.getDataType() : void 0,
				w = isMatrix(b) ? b._data : b,
				T = isMatrix(b) ? b._datatype || b.getDataType() : void 0,
				A = v(y).length === 2,
				k = v(b).length === 2,
				M = a,
				D = l;
			if (S && T && S === T && typeof S == "string" && S !== "mixed") {
				var F = S;
				M = s.find(a, [F, F]), D = s.find(l, [F, F])
			}
			if (!A && !k) {
				for (var R = D(c(_[0]), w[0]), O = 1; O < C; O++) R = M(R, D(c(_[O]), w[O]));
				return R
			}
			if (!A && k) {
				for (var U = D(c(_[0]), w[0][0]), V = 1; V < C; V++) U = M(U, D(c(_[V]), w[V][0]));
				return U
			}
			if (A && !k) {
				for (var z = D(c(_[0][0]), w[0]), j = 1; j < C; j++) z = M(z, D(c(_[j][0]), w[j]));
				return z
			}
			if (A && k) {
				for (var ge = D(c(_[0][0]), w[0][0]), me = 1; me < C; me++) ge = M(ge, D(c(_[me][0]), w[me][0]));
				return ge
			}
		}

		function g(y, b) {
			f(y, b);
			for (var C = y._index, _ = y._values, S = b._index, w = b._values, T = 0, A = a, k = l, M = 0, D =
				0; M < C.length && D < S.length;) {
				var F = C[M],
					R = S[D];
				if (F < R) {
					M++;
					continue
				}
				if (F > R) {
					D++;
					continue
				}
				F === R && (T = A(T, k(_[M], w[D])), M++, D++)
			}
			return T
		}

		function v(y) {
			return isMatrix(y) ? y.size() : d(y)
		}
	}),
	name$1 = "det",
	dependencies$1 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"],
	createDet = factory(name$1, dependencies$1, o => {
		var {
			typed: s,
			matrix: a,
			subtractScalar: l,
			multiply: c,
			divideScalar: d,
			isZero: f,
			unaryMinus: m
		} = o;
		return s(name$1, {
			any: function(y) {
				return clone$2(y)
			},
			"Array | Matrix": function(y) {
				var b;
				switch (isMatrix(y) ? b = y.size() : Array.isArray(y) ? (y = a(y), b = y.size()) :
					b = [], b.length) {
					case 0:
						return clone$2(y);
					case 1:
						if (b[0] === 1) return clone$2(y.valueOf()[0]);
						if (b[0] === 0) return 1;
						throw new RangeError("Matrix must be square (size: " + format(b) + ")");
					case 2: {
						var C = b[0],
							_ = b[1];
						if (C === _) return g(y.clone().valueOf(), C);
						if (_ === 0) return 1;
						throw new RangeError("Matrix must be square (size: " + format(b) + ")")
					}
					default:
						throw new RangeError("Matrix must be two dimensional (size: " + format(b) + ")")
				}
			}
		});

		function g(v, y, b) {
			if (y === 1) return clone$2(v[0][0]);
			if (y === 2) return l(c(v[0][0], v[1][1]), c(v[1][0], v[0][1]));
			for (var C = !1, _ = new Array(y).fill(0).map((O, U) => U), S = 0; S < y; S++) {
				var w = _[S];
				if (f(v[w][S])) {
					var T = void 0;
					for (T = S + 1; T < y; T++)
						if (!f(v[_[T]][S])) {
							w = _[T], _[T] = _[S], _[S] = w, C = !C;
							break
						} if (T === y) return v[w][S]
				}
				for (var A = v[w][S], k = S === 0 ? 1 : v[_[S - 1]][S - 1], M = S + 1; M < y; M++)
					for (var D = _[M], F = S + 1; F < y; F++) v[D][F] = d(l(c(v[D][F], A), c(v[D][S], v[w][F])), k)
			}
			var R = v[_[y - 1]][y - 1];
			return C ? m(R) : R
		}
	}),
	name = "inv",
	dependencies = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"],
	createInv = factory(name, dependencies, o => {
		var {
			typed: s,
			matrix: a,
			divideScalar: l,
			addScalar: c,
			multiply: d,
			unaryMinus: f,
			det: m,
			identity: g,
			abs: v
		} = o;
		return s(name, {
			"Array | Matrix": function(C) {
				var _ = isMatrix(C) ? C.size() : arraySize(C);
				switch (_.length) {
					case 1:
						if (_[0] === 1) return isMatrix(C) ? a([l(1, C.valueOf()[0])]) : [l(1, C[0])];
						throw new RangeError("Matrix must be square (size: " + format(_) + ")");
					case 2: {
						var S = _[0],
							w = _[1];
						if (S === w) return isMatrix(C) ? a(y(C.valueOf(), S, w), C.storage()) : y(C, S,
							w);
						throw new RangeError("Matrix must be square (size: " + format(_) + ")")
					}
					default:
						throw new RangeError("Matrix must be two dimensional (size: " + format(_) + ")")
				}
			},
			any: function(C) {
				return l(1, C)
			}
		});

		function y(b, C, _) {
			var S, w, T, A, k;
			if (C === 1) {
				if (A = b[0][0], A === 0) throw Error("Cannot calculate inverse, determinant is zero");
				return [
					[l(1, A)]
				]
			} else if (C === 2) {
				var M = m(b);
				if (M === 0) throw Error("Cannot calculate inverse, determinant is zero");
				return [
					[l(b[1][1], M), l(f(b[0][1]), M)],
					[l(f(b[1][0]), M), l(b[0][0], M)]
				]
			} else {
				var D = b.concat();
				for (S = 0; S < C; S++) D[S] = D[S].concat();
				for (var F = g(C).valueOf(), R = 0; R < _; R++) {
					var O = v(D[R][R]),
						U = R;
					for (S = R + 1; S < C;) v(D[S][R]) > O && (O = v(D[S][R]), U = S), S++;
					if (O === 0) throw Error("Cannot calculate inverse, determinant is zero");
					S = U, S !== R && (k = D[R], D[R] = D[S], D[S] = k, k = F[R], F[R] = F[S], F[S] = k);
					var V = D[R],
						z = F[R];
					for (S = 0; S < C; S++) {
						var j = D[S],
							ge = F[S];
						if (S !== R) {
							if (j[R] !== 0) {
								for (T = l(f(j[R]), V[R]), w = R; w < _; w++) j[w] = c(j[w], d(T, V[w]));
								for (w = 0; w < _; w++) ge[w] = c(ge[w], d(T, z[w]))
							}
						} else {
							for (T = V[R], w = R; w < _; w++) j[w] = l(j[w], T);
							for (w = 0; w < _; w++) ge[w] = l(ge[w], T)
						}
					}
				}
				return F
			}
		}
	}),
	BigNumber = createBigNumberClass({
		config: config$1
	}),
	Complex = createComplexClass({}),
	Fraction = createFractionClass({}),
	Matrix = createMatrixClass({}),
	DenseMatrix = createDenseMatrixClass({
		Matrix
	}),
	typed = createTyped({
		BigNumber,
		Complex,
		DenseMatrix,
		Fraction
	}),
	abs = createAbs({
		typed
	}),
	addScalar = createAddScalar({
		typed
	}),
	conj = createConj({
		typed
	}),
	equalScalar = createEqualScalar({
		config: config$1,
		typed
	}),
	isZero = createIsZero({
		equalScalar,
		typed
	}),
	multiplyScalar = createMultiplyScalar({
		typed
	}),
	number$1 = createNumber({
		typed
	}),
	SparseMatrix = createSparseMatrixClass({
		Matrix,
		equalScalar,
		typed
	}),
	subtractScalar = createSubtractScalar({
		typed
	}),
	bignumber = createBignumber({
		BigNumber,
		typed
	}),
	matrix = createMatrix({
		DenseMatrix,
		Matrix,
		SparseMatrix,
		typed
	}),
	fraction = createFraction({
		Fraction,
		typed
	}),
	identity = createIdentity({
		BigNumber,
		DenseMatrix,
		SparseMatrix,
		config: config$1,
		matrix,
		typed
	}),
	numeric = createNumeric({
		bignumber,
		fraction,
		number: number$1
	}),
	size = createSize({
		matrix,
		config: config$1,
		typed
	}),
	unaryMinus = createUnaryMinus({
		typed
	}),
	divideScalar = createDivideScalar({
		numeric,
		typed
	}),
	dot = createDot({
		addScalar,
		conj,
		multiplyScalar,
		size,
		typed
	}),
	multiply = createMultiply({
		addScalar,
		dot,
		equalScalar,
		matrix,
		multiplyScalar,
		typed
	}),
	det = createDet({
		divideScalar,
		isZero,
		matrix,
		multiply,
		subtractScalar,
		typed,
		unaryMinus
	}),
	inv = createInv({
		abs,
		addScalar,
		det,
		divideScalar,
		identity,
		matrix,
		multiply,
		typed,
		unaryMinus
	});
const decoder = new TextDecoder;

function decodeString(o) {
	if (o.length >= 50) return decoder.decode(o);
	for (let s = 0; s < o.length; s++)
		if (o[s] & 128) return decoder.decode(o);
	return String.fromCharCode.apply(null, o)
}

function MakeTypedArrayDeserialze(o, s) {
	return o == null && console.warn("bigint arrays are not supported in this environment"), (a, l, c) => {
		if (o == null) throw new Error("bigint arrays are not supported in this environment");
		let d = l;
		const f = a.byteOffset + d,
			m = o.BYTES_PER_ELEMENT * c,
			g = a.byteLength - l;
		if (m < 0 || m > g) throw new RangeError(`Array(${s}) deserialization error: size ${m}, maxSize ${g}`);
		if (f % o.BYTES_PER_ELEMENT === 0) return new o(a.buffer, f, c);
		if (c < 10) {
			const y = new o(c);
			for (let b = 0; b < c; ++b) y[b] = a[s](d, !0), d += o.BYTES_PER_ELEMENT;
			return y
		}
		const v = new Uint8Array(m);
		return v.set(new Uint8Array(a.buffer, f, m)), new o(v.buffer, v.byteOffset, c)
	}
}
MakeTypedArrayDeserialze(Int8Array, "getInt8"), MakeTypedArrayDeserialze(Uint8Array, "getUint8"),
	MakeTypedArrayDeserialze(Int16Array, "getInt16"), MakeTypedArrayDeserialze(Uint16Array, "getUint16"),
	MakeTypedArrayDeserialze(Int32Array, "getInt32"), MakeTypedArrayDeserialze(Uint32Array, "getUint32"),
	MakeTypedArrayDeserialze(typeof BigInt64Array == "function" ? BigInt64Array : void 0, "getBigInt64"),
	MakeTypedArrayDeserialze(typeof BigUint64Array == "function" ? BigUint64Array : void 0, "getBigUint64"),
	MakeTypedArrayDeserialze(Float32Array, "getFloat32"), MakeTypedArrayDeserialze(Float64Array, "getFloat64");

function isBigEndian$1() {
	const o = new Uint8Array(4),
		s = new Uint32Array(o.buffer);
	return s[0] = 1, o[3] === 1
}
const isLittleEndian = !isBigEndian$1();
if (!isLittleEndian) throw new Error("Only Little Endian architectures are supported");
class StandardTypeReader {
	constructor(s) {
		this.buffer = s, this.offset = 0, this.view = new DataView(s.buffer, s.byteOffset, s.byteLength)
	}
	json() {
		const s = this.string();
		try {
			return JSON.parse(s)
		} catch {
			return `Could not parse ${s}`
		}
	}
	string() {
		const s = this.uint32(),
			a = this.view.byteOffset + this.offset,
			l = this.view.byteLength - this.offset;
		if (s < 0 || s > l) throw new RangeError(`String deserialization error: length ${s}, maxLength ${l}`);
		const c = new Uint8Array(this.view.buffer, a, s);
		return this.offset += s, decodeString(c)
	}
	bool() {
		return this.uint8() !== 0
	}
	int8() {
		return this.view.getInt8(this.offset++)
	}
	uint8() {
		return this.view.getUint8(this.offset++)
	}
	typedArray(s, a) {
		const l = s ?? this.uint32(),
			c = this.view,
			d = this.offset + c.byteOffset;
		if (this.offset += l * a.BYTES_PER_ELEMENT, d % a.BYTES_PER_ELEMENT === 0) return new a(c.buffer, d, l);
		const f = a.BYTES_PER_ELEMENT * l,
			m = new Uint8Array(f);
		return m.set(new Uint8Array(c.buffer, d, f)), new a(m.buffer, m.byteOffset, l)
	}
	int16() {
		const s = this.view.getInt16(this.offset, !0);
		return this.offset += 2, s
	}
	uint16() {
		const s = this.view.getUint16(this.offset, !0);
		return this.offset += 2, s
	}
	int32() {
		const s = this.view.getInt32(this.offset, !0);
		return this.offset += 4, s
	}
	uint32() {
		const s = this.view.getUint32(this.offset, !0);
		return this.offset += 4, s
	}
	float32() {
		const s = this.view.getFloat32(this.offset, !0);
		return this.offset += 4, s
	}
	float64() {
		const s = this.view.getFloat64(this.offset, !0);
		return this.offset += 8, s
	}
	int64() {
		const s = this.offset;
		return this.offset += 8, this.view.getBigInt64(s, !0)
	}
	uint64() {
		const s = this.offset;
		return this.offset += 8, this.view.getBigUint64(s, !0)
	}
	time() {
		const s = this.offset;
		this.offset += 8;
		const a = this.view.getUint32(s, !0),
			l = this.view.getUint32(s + 4, !0);
		return {
			sec: a,
			nsec: l
		}
	}
	duration() {
		const s = this.offset;
		this.offset += 8;
		const a = this.view.getInt32(s, !0),
			l = this.view.getInt32(s + 4, !0);
		return {
			sec: a,
			nsec: l
		}
	}
}
const findTypeByName$1 = (o, s = "") => {
		let a = "";
		const l = o.filter(c => {
			const d = c.name ?? "";
			if (!s) return !d;
			const f = s.includes("/") ? s : `/${s}`;
			return d.endsWith(f) ? (a = d, !0) : !1
		});
		if (l.length !== 1) throw new Error(`Expected 1 top level type definition for '${s}' but found ${l.length}.`);
		return {
			...l[0],
			name: a
		}
	},
	friendlyName$1 = o => o.replace(/\//g, "_");

function toTypedArrayType(o) {
	switch (o) {
		case "int8":
			return "Int8Array";
		case "uint8":
			return "Uint8Array";
		case "int16":
			return "Int16Array";
		case "uint16":
			return "Uint16Array";
		case "int32":
			return "Int32Array";
		case "uint32":
			return "Uint32Array";
		case "int64":
			return "BigInt64Array";
		case "uint64":
			return "BigUint64Array";
		case "float32":
			return "Float32Array";
		case "float64":
			return "Float64Array";
		default:
			return
	}
}
const createParsers = ({
	definitions: o,
	options: s = {},
	topLevelReaderKey: a
}) => {
	if (o.length === 0) throw new Error("no types given");
	const l = o.filter(g => !g.name);
	if (l.length > 1) throw new Error("multiple unnamed types");
	const c = l.length > 0 ? l[0] : o[0],
		d = o.filter(g => !!g.name),
		f = g => {
			const v = [];
			return g.definitions.forEach(y => {
				if (y.isConstant !== !0)
					if (y.isArray === !0) {
						const b = toTypedArrayType(y.type);
						if (b != null) {
							v.push(`this.${y.name} = reader.typedArray(${String(y.arrayLength)}, ${b});`);
							return
						}
						const C = `length_${y.name}`;
						v.push(`var ${C} = ${y.arrayLength!=null?y.arrayLength:"reader.uint32();"}`);
						const _ = `this.${y.name}`;
						if (v.push(`${_} = new Array(${C})`), v.push(`for (var i = 0; i < ${C}; i++) {`), y
							.isComplex === !0) {
							const S = findTypeByName$1(o, y.type);
							v.push(`  ${_}[i] = new Record.${friendlyName$1(S.name)}(reader);`)
						} else v.push(`  ${_}[i] = reader.${y.type}();`);
						v.push("}")
					} else if (y.isComplex === !0) {
					const b = findTypeByName$1(o, y.type);
					v.push(`this.${y.name} = new Record.${friendlyName$1(b.name)}(reader);`)
				} else v.push(`this.${y.name} = reader.${y.type}();`)
			}), s.freeze === !0 && v.push("Object.freeze(this);"), v.join(`
    `)
		};
	let m = `
  const builtReaders = new Map();
  var Record = function (reader) {
    ${f(c)}
  };
  builtReaders.set(topLevelReaderKey, Record);
  `;
	for (const g of d) m += `
  Record.${friendlyName$1(g.name)} = function(reader) {
    ${f(g)}
  };
  builtReaders.set(${JSON.stringify(g.name)}, Record.${friendlyName$1(g.name)});
  `;
	return m += "return builtReaders;", new Function("topLevelReaderKey", m)(a)
};
let MessageReader$1 = class {
	constructor(s, a = {}) {
		this.reader = createParsers({
			definitions: s,
			options: a,
			topLevelReaderKey: "<toplevel>"
		}).get("<toplevel>")
	}
	readMessage(s) {
		const a = new StandardTypeReader(s);
		return new this.reader(a)
	}
};

function stringLengthUtf8(o) {
	let s = 0;
	const a = o.length;
	for (let l = 0; l < a; l++) {
		const c = o.charCodeAt(l);
		if (c <= 127) s += 1;
		else if (c <= 2047) s += 2;
		else if (55296 <= c && c <= 56319) {
			const d = o.charCodeAt(l + 1);
			56320 <= d && d <= 57343 ? (s += 4, l++) : s += 3
		} else s += 3
	}
	return s
}

function writeTime(o, s, a) {
	s.setUint32(a, o.sec, !0), s.setUint32(a + 4, o.nsec, !0)
}
class StandardTypeOffsetCalculator {
	constructor() {
		this.offset = 0
	}
	_incrementAndReturn(s) {
		const a = this.offset;
		return this.offset += s, a
	}
	json(s) {
		return this.string(JSON.stringify(s))
	}
	string(s) {
		if (typeof s != "string") throw new Error(`Expected string but got ${typeof s}`);
		const a = 4 + stringLengthUtf8(s);
		return this._incrementAndReturn(a)
	}
	bool() {
		return this.uint8()
	}
	int8() {
		return this._incrementAndReturn(1)
	}
	uint8() {
		return this._incrementAndReturn(1)
	}
	int16() {
		return this._incrementAndReturn(2)
	}
	uint16() {
		return this._incrementAndReturn(2)
	}
	int32() {
		return this._incrementAndReturn(4)
	}
	uint32() {
		return this._incrementAndReturn(4)
	}
	float32() {
		return this._incrementAndReturn(4)
	}
	float64() {
		return this._incrementAndReturn(8)
	}
	int64() {
		return this._incrementAndReturn(8)
	}
	uint64() {
		return this._incrementAndReturn(8)
	}
	time() {
		return this._incrementAndReturn(8)
	}
	duration() {
		return this._incrementAndReturn(8)
	}
}
class StandardTypeWriter {
	constructor(s) {
		this.data = s, this.view = new DataView(s.buffer, s.byteOffset, s.byteLength), this.offsetCalculator =
			new StandardTypeOffsetCalculator
	}
	json(s) {
		this.string(JSON.stringify(s))
	}
	string(s) {
		this.textEncoder == null && (this.textEncoder = new TextEncoder);
		const a = this.offsetCalculator.string(s),
			l = this.offsetCalculator.offset - a - 4;
		this.view.setUint32(a, l, !0);
		const {
			read: c,
			written: d
		} = this.textEncoder.encodeInto(s, this.data.subarray(a + 4));
		if (c !== s.length) throw new Error(
			`Not enough space to encode string into subarray (wrote ${c} of ${s.length} code units into ${d} of ${this.data.subarray(a+4).length} bytes)`
			)
	}
	bool(s) {
		this.uint8(s ? 1 : 0)
	}
	int8(s) {
		this.view.setInt8(this.offsetCalculator.int8(), s)
	}
	uint8(s) {
		this.view.setUint8(this.offsetCalculator.uint8(), s)
	}
	int16(s) {
		this.view.setInt16(this.offsetCalculator.int16(), s, !0)
	}
	uint16(s) {
		this.view.setUint16(this.offsetCalculator.uint16(), s, !0)
	}
	int32(s) {
		this.view.setInt32(this.offsetCalculator.int32(), s, !0)
	}
	uint32(s) {
		this.view.setUint32(this.offsetCalculator.uint32(), s, !0)
	}
	float32(s) {
		this.view.setFloat32(this.offsetCalculator.float32(), s, !0)
	}
	float64(s) {
		this.view.setFloat64(this.offsetCalculator.float64(), s, !0)
	}
	int64(s) {
		this.view.setBigInt64(this.offsetCalculator.int64(), BigInt(s), !0)
	}
	uint64(s) {
		this.view.setBigUint64(this.offsetCalculator.uint64(), BigInt(s), !0)
	}
	time(s) {
		writeTime(s, this.view, this.offsetCalculator.time())
	}
	duration(s) {
		writeTime(s, this.view, this.offsetCalculator.time())
	}
}
const findTypeByName = (o, s = "") => {
		let a = "";
		const l = o.filter(c => {
			const d = c.name ?? "";
			if (s.length === 0) return d.length === 0;
			const f = s.includes("/") ? s : `/${s}`;
			return d.endsWith(f) ? (a = d, !0) : !1
		});
		if (l.length !== 1) throw new Error(`Expected 1 top level type definition for '${s}' but found ${l.length}.`);
		return {
			...l[0],
			name: a
		}
	},
	friendlyName = o => o.replace(/\//g, "_");

function createWriterAndSizeCalculator(types) {
	if (types.length === 0) throw new Error("no types given");
	const unnamedTypes = types.filter(o => o.name == null);
	if (unnamedTypes.length > 1) throw new Error("multiple unnamed types");
	const unnamedType = unnamedTypes.length > 0 ? unnamedTypes[0] : types[0],
		namedTypes = types.filter(o => o.name != null),
		constructorBody = (o, s) => {
			const a = [];
			return o.definitions.forEach(l => {
				if (l.isConstant ?? !1) return;
				const c = `message["${l.name}"]`;
				if (l.isArray ?? !1) {
					const d = `length_${l.name}`;
					if (l.arrayLength != null ? a.push(`var ${d} = ${l.arrayLength};`) : (a.push(
							`var ${d} = ${c}.length;`), a.push(`${s}.uint32(${d});`)), a.push(
							`for (var i = 0; i < ${d}; i++) {`), l.isComplex ?? !1) {
						const f = findTypeByName(types, l.type);
						a.push(`  ${friendlyName(f.name)}(${s}, ${c}[i]);`)
					} else a.push(`  ${s}.${l.type}(${c}[i]);`);
					a.push("}")
				} else if (l.isComplex ?? !1) {
					const d = findTypeByName(types, l.type);
					a.push(`${friendlyName(d.name)}(${s}, ${c});`)
				} else a.push(`${s}.${l.type}(${c});`)
			}), a.join(`
    `)
		};
	let writerJs = "",
		calculateSizeJs = "";
	namedTypes.forEach(o => {
		writerJs += `
  function ${friendlyName(o.name)}(writer, message) {
    ${constructorBody(o,"writer")}
  };
`, calculateSizeJs += `
  function ${friendlyName(o.name)}(offsetCalculator, message) {
    ${constructorBody(o,"offsetCalculator")}
  };
`
	}), writerJs += `
  return function write(writer, message) {
    ${constructorBody(unnamedType,"writer")}
    return writer.data;
  };`, calculateSizeJs += `
  return function calculateSize(offsetCalculator, message) {
    ${constructorBody(unnamedType,"offsetCalculator")}
    return offsetCalculator.offset;
  };`;
	let write, calculateSize;
	try {
		write = eval(`(function buildWriter() { ${writerJs} })()`)
	} catch (o) {
		throw console.error("error building writer:", writerJs), o
	}
	try {
		calculateSize = eval(`(function buildSizeCalculator() { ${calculateSizeJs} })()`)
	} catch (o) {
		throw console.error("error building size calculator:", calculateSizeJs), o
	}
	return {
		writer(o, s) {
			const a = new StandardTypeWriter(s);
			return write(a, o)
		},
		byteSizeCalculator(o) {
			const s = new StandardTypeOffsetCalculator;
			return calculateSize(s, o)
		}
	}
}
let MessageWriter$1 = class {
	constructor(s) {
		const {
			writer: a,
			byteSizeCalculator: l
		} = createWriterAndSizeCalculator(s);
		this.writer = a, this.byteSizeCalculator = l
	}
	calculateByteSize(s) {
		return this.byteSizeCalculator(s)
	}
	writeMessage(s, a) {
		return this.writer(s, a ?? new Uint8Array(this.calculateByteSize(s)))
	}
};
var dist$2 = {},
	MessageReader = {},
	dist$1 = {},
	CdrReader = {},
	getEncapsulationKindInfo = {},
	EncapsulationKind = {},
	hasRequiredEncapsulationKind;

function requireEncapsulationKind() {
	return hasRequiredEncapsulationKind || (hasRequiredEncapsulationKind = 1, function(o) {
		Object.defineProperty(o, "__esModule", {
				value: !0
			}), o.EncapsulationKind = void 0,
			function(s) {
				s[s.CDR_BE = 0] = "CDR_BE", s[s.CDR_LE = 1] = "CDR_LE", s[s.PL_CDR_BE = 2] = "PL_CDR_BE", s[s
						.PL_CDR_LE = 3] = "PL_CDR_LE", s[s.CDR2_BE = 16] = "CDR2_BE", s[s.CDR2_LE = 17] =
					"CDR2_LE", s[s.PL_CDR2_BE = 18] = "PL_CDR2_BE", s[s.PL_CDR2_LE = 19] = "PL_CDR2_LE", s[s
						.DELIMITED_CDR2_BE = 20] = "DELIMITED_CDR2_BE", s[s.DELIMITED_CDR2_LE = 21] =
					"DELIMITED_CDR2_LE", s[s.RTPS_CDR2_BE = 6] = "RTPS_CDR2_BE", s[s.RTPS_CDR2_LE = 7] =
					"RTPS_CDR2_LE", s[s.RTPS_DELIMITED_CDR2_BE = 8] = "RTPS_DELIMITED_CDR2_BE", s[s
						.RTPS_DELIMITED_CDR2_LE = 9] = "RTPS_DELIMITED_CDR2_LE", s[s.RTPS_PL_CDR2_BE = 10] =
					"RTPS_PL_CDR2_BE", s[s.RTPS_PL_CDR2_LE = 11] = "RTPS_PL_CDR2_LE"
			}(o.EncapsulationKind || (o.EncapsulationKind = {}))
	}(EncapsulationKind)), EncapsulationKind
}
var hasRequiredGetEncapsulationKindInfo;

function requireGetEncapsulationKindInfo() {
	if (hasRequiredGetEncapsulationKindInfo) return getEncapsulationKindInfo;
	hasRequiredGetEncapsulationKindInfo = 1, Object.defineProperty(getEncapsulationKindInfo, "__esModule", {
		value: !0
	}), getEncapsulationKindInfo.getEncapsulationKindInfo = void 0;
	const o = requireEncapsulationKind(),
		s = a => {
			const l = a > o.EncapsulationKind.PL_CDR_LE,
				c = a === o.EncapsulationKind.CDR_LE || a === o.EncapsulationKind.PL_CDR_LE || a === o.EncapsulationKind
				.CDR2_LE || a === o.EncapsulationKind.PL_CDR2_LE || a === o.EncapsulationKind.DELIMITED_CDR2_LE || a ===
				o.EncapsulationKind.RTPS_CDR2_LE || a === o.EncapsulationKind.RTPS_PL_CDR2_LE || a === o
				.EncapsulationKind.RTPS_DELIMITED_CDR2_LE,
				d = a === o.EncapsulationKind.DELIMITED_CDR2_BE || a === o.EncapsulationKind.DELIMITED_CDR2_LE || a ===
				o.EncapsulationKind.RTPS_DELIMITED_CDR2_BE || a === o.EncapsulationKind.RTPS_DELIMITED_CDR2_LE,
				f = a === o.EncapsulationKind.PL_CDR2_BE || a === o.EncapsulationKind.PL_CDR2_LE || a === o
				.EncapsulationKind.RTPS_PL_CDR2_BE || a === o.EncapsulationKind.RTPS_PL_CDR2_LE,
				m = a === o.EncapsulationKind.PL_CDR_BE || a === o.EncapsulationKind.PL_CDR_LE;
			return {
				isCDR2: l,
				littleEndian: c,
				usesDelimiterHeader: d || f,
				usesMemberHeader: f || m
			}
		};
	return getEncapsulationKindInfo.getEncapsulationKindInfo = s, getEncapsulationKindInfo
}
var isBigEndian = {},
	hasRequiredIsBigEndian;

function requireIsBigEndian() {
	if (hasRequiredIsBigEndian) return isBigEndian;
	hasRequiredIsBigEndian = 1, Object.defineProperty(isBigEndian, "__esModule", {
		value: !0
	}), isBigEndian.isBigEndian = void 0;
	const o = new Uint8Array(4),
		s = new Uint32Array(o.buffer);
	s[0] = 1;

	function a() {
		return o[3] === 1
	}
	return isBigEndian.isBigEndian = a, isBigEndian
}
var lengthCodes = {},
	hasRequiredLengthCodes;

function requireLengthCodes() {
	if (hasRequiredLengthCodes) return lengthCodes;
	hasRequiredLengthCodes = 1, Object.defineProperty(lengthCodes, "__esModule", {
		value: !0
	}), lengthCodes.lengthCodeToObjectSizes = lengthCodes.getLengthCodeForObjectSize = void 0;

	function o(s) {
		let a;
		switch (s) {
			case 1:
				a = 0;
				break;
			case 2:
				a = 1;
				break;
			case 4:
				a = 2;
				break;
			case 8:
				a = 3;
				break
		}
		if (a == null) {
			if (s > 4294967295) throw Error(
				`Object size ${s} for EMHEADER too large without specifying length code. Max size is ${4294967295}`
				);
			a = 4
		}
		return a
	}
	return lengthCodes.getLengthCodeForObjectSize = o, lengthCodes.lengthCodeToObjectSizes = {
		0: 1,
		1: 2,
		2: 4,
		3: 8
	}, lengthCodes
}
var reservedPIDs = {},
	hasRequiredReservedPIDs;

function requireReservedPIDs() {
	return hasRequiredReservedPIDs || (hasRequiredReservedPIDs = 1, Object.defineProperty(reservedPIDs, "__esModule", {
			value: !0
		}), reservedPIDs.SENTINEL_PID = reservedPIDs.EXTENDED_PID = void 0, reservedPIDs.EXTENDED_PID = 16129,
		reservedPIDs.SENTINEL_PID = 16130), reservedPIDs
}
var hasRequiredCdrReader;

function requireCdrReader() {
	if (hasRequiredCdrReader) return CdrReader;
	hasRequiredCdrReader = 1, Object.defineProperty(CdrReader, "__esModule", {
		value: !0
	}), CdrReader.CdrReader = void 0;
	const o = requireGetEncapsulationKindInfo(),
		s = requireIsBigEndian(),
		a = requireLengthCodes(),
		l = requireReservedPIDs(),
		c = new TextDecoder("utf8");
	let d = class {
		constructor(m) {
			if (this.origin = 0, m.byteLength < 4) throw new Error(
				`Invalid CDR data size ${m.byteLength}, must contain at least a 4-byte header`);
			this.view = new DataView(m.buffer, m.byteOffset, m.byteLength);
			const g = this.kind,
				{
					isCDR2: v,
					littleEndian: y,
					usesDelimiterHeader: b,
					usesMemberHeader: C
				} = (0, o.getEncapsulationKindInfo)(g);
			this.usesDelimiterHeader = b, this.usesMemberHeader = C, this.littleEndian = y, this
				.hostLittleEndian = !(0, s.isBigEndian)(), this.isCDR2 = v, this.eightByteAlignment = v ? 4 : 8,
				this.origin = 4, this.offset = 4
		}
		get kind() {
			return this.view.getUint8(1)
		}
		get decodedBytes() {
			return this.offset
		}
		get byteLength() {
			return this.view.byteLength
		}
		int8() {
			const m = this.view.getInt8(this.offset);
			return this.offset += 1, m
		}
		uint8() {
			const m = this.view.getUint8(this.offset);
			return this.offset += 1, m
		}
		int16() {
			this.align(2);
			const m = this.view.getInt16(this.offset, this.littleEndian);
			return this.offset += 2, m
		}
		uint16() {
			this.align(2);
			const m = this.view.getUint16(this.offset, this.littleEndian);
			return this.offset += 2, m
		}
		int32() {
			this.align(4);
			const m = this.view.getInt32(this.offset, this.littleEndian);
			return this.offset += 4, m
		}
		uint32() {
			this.align(4);
			const m = this.view.getUint32(this.offset, this.littleEndian);
			return this.offset += 4, m
		}
		int64() {
			this.align(this.eightByteAlignment);
			const m = this.view.getBigInt64(this.offset, this.littleEndian);
			return this.offset += 8, m
		}
		uint64() {
			this.align(this.eightByteAlignment);
			const m = this.view.getBigUint64(this.offset, this.littleEndian);
			return this.offset += 8, m
		}
		uint16BE() {
			this.align(2);
			const m = this.view.getUint16(this.offset, !1);
			return this.offset += 2, m
		}
		uint32BE() {
			this.align(4);
			const m = this.view.getUint32(this.offset, !1);
			return this.offset += 4, m
		}
		uint64BE() {
			this.align(this.eightByteAlignment);
			const m = this.view.getBigUint64(this.offset, !1);
			return this.offset += 8, m
		}
		float32() {
			this.align(4);
			const m = this.view.getFloat32(this.offset, this.littleEndian);
			return this.offset += 4, m
		}
		float64() {
			this.align(this.eightByteAlignment);
			const m = this.view.getFloat64(this.offset, this.littleEndian);
			return this.offset += 8, m
		}
		string(m) {
			const g = m ?? this.uint32();
			if (g <= 1) return this.offset += g, "";
			const v = new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, g - 1),
				y = c.decode(v);
			return this.offset += g, y
		}
		dHeader() {
			return this.uint32()
		}
		emHeader() {
			return this.isCDR2 ? this.memberHeaderV2() : this.memberHeaderV1()
		}
		memberHeaderV1() {
			this.align(4);
			const m = this.uint16(),
				g = (m & 16384) >> 14 === 1,
				v = (m & 32768) >> 15 === 1,
				y = (m & 16383) === l.EXTENDED_PID;
			if ((m & 16383) === l.SENTINEL_PID) return {
				id: l.SENTINEL_PID,
				objectSize: 0,
				mustUnderstand: !1,
				readSentinelHeader: !0
			};
			if ((m & 16383) > l.SENTINEL_PID || v) throw new Error(
				`Unsupported parameter ID header ${m.toString(16)}`);
			y && this.uint16();
			const _ = y ? this.uint32() : m & 16383,
				S = y ? this.uint32() : this.uint16();
			return this.resetOrigin(), {
				id: _,
				objectSize: S,
				mustUnderstand: g
			}
		}
		resetOrigin() {
			this.origin = this.offset
		}
		sentinelHeader() {
			if (!this.isCDR2) {
				this.align(4);
				const m = this.uint16();
				if (!((m & 16383) === l.SENTINEL_PID)) throw Error(
					`Expected SENTINEL_PID (${l.SENTINEL_PID.toString(16)}) flag, but got ${m.toString(16)}`
					);
				this.uint16()
			}
		}
		memberHeaderV2() {
			const m = this.uint32(),
				g = Math.abs((m & 2147483648) >> 31) === 1,
				v = (m & 1879048192) >> 28,
				y = m & 268435455,
				b = this.emHeaderObjectSize(v);
			return {
				mustUnderstand: g,
				id: y,
				objectSize: b,
				lengthCode: v
			}
		}
		emHeaderObjectSize(m) {
			switch (m) {
				case 0:
				case 1:
				case 2:
				case 3:
					return a.lengthCodeToObjectSizes[m];
				case 4:
				case 5:
					return this.uint32();
				case 6:
					return 4 * this.uint32();
				case 7:
					return 8 * this.uint32();
				default:
					throw new Error(`Invalid length code ${m} in EMHEADER at offset ${this.offset-4}`)
			}
		}
		sequenceLength() {
			return this.uint32()
		}
		int8Array(m = this.sequenceLength()) {
			const g = new Int8Array(this.view.buffer, this.view.byteOffset + this.offset, m);
			return this.offset += m, g
		}
		uint8Array(m = this.sequenceLength()) {
			const g = new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, m);
			return this.offset += m, g
		}
		int16Array(m = this.sequenceLength()) {
			return this.typedArray(Int16Array, "getInt16", m)
		}
		uint16Array(m = this.sequenceLength()) {
			return this.typedArray(Uint16Array, "getUint16", m)
		}
		int32Array(m = this.sequenceLength()) {
			return this.typedArray(Int32Array, "getInt32", m)
		}
		uint32Array(m = this.sequenceLength()) {
			return this.typedArray(Uint32Array, "getUint32", m)
		}
		int64Array(m = this.sequenceLength()) {
			return this.typedArray(BigInt64Array, "getBigInt64", m, this.eightByteAlignment)
		}
		uint64Array(m = this.sequenceLength()) {
			return this.typedArray(BigUint64Array, "getBigUint64", m, this.eightByteAlignment)
		}
		float32Array(m = this.sequenceLength()) {
			return this.typedArray(Float32Array, "getFloat32", m)
		}
		float64Array(m = this.sequenceLength()) {
			return this.typedArray(Float64Array, "getFloat64", m, this.eightByteAlignment)
		}
		stringArray(m = this.sequenceLength()) {
			const g = [];
			for (let v = 0; v < m; v++) g.push(this.string());
			return g
		}
		seek(m) {
			const g = this.offset + m;
			if (g < 4 || g >= this.view.byteLength) throw new Error(
				`seek(${m}) failed, ${g} is outside the data range`);
			this.offset = g
		}
		seekTo(m) {
			if (m < 4 || m >= this.view.byteLength) throw new Error(
				`seekTo(${m}) failed, value is outside the data range`);
			this.offset = m
		}
		align(m) {
			const g = (this.offset - this.origin) % m;
			g > 0 && (this.offset += m - g)
		}
		typedArray(m, g, v, y = m.BYTES_PER_ELEMENT) {
			if (v === 0) return new m;
			this.align(y);
			const b = this.view.byteOffset + this.offset;
			if (this.littleEndian !== this.hostLittleEndian) return this.typedArraySlow(m, g, v);
			if (b % m.BYTES_PER_ELEMENT === 0) {
				const C = new m(this.view.buffer, b, v);
				return this.offset += m.BYTES_PER_ELEMENT * v, C
			} else return this.typedArrayUnaligned(m, g, v)
		}
		typedArrayUnaligned(m, g, v) {
			if (v < 10) return this.typedArraySlow(m, g, v);
			const y = m.BYTES_PER_ELEMENT * v,
				b = new Uint8Array(y);
			return b.set(new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, y)), this
				.offset += y, new m(b.buffer, b.byteOffset, v)
		}
		typedArraySlow(m, g, v) {
			const y = new m(v);
			let b = this.offset;
			for (let C = 0; C < v; C++) y[C] = this.view[g](b, this.littleEndian), b += m.BYTES_PER_ELEMENT;
			return this.offset = b, y
		}
	};
	return CdrReader.CdrReader = d, CdrReader
}
var CdrSizeCalculator = {},
	hasRequiredCdrSizeCalculator;

function requireCdrSizeCalculator() {
	if (hasRequiredCdrSizeCalculator) return CdrSizeCalculator;
	hasRequiredCdrSizeCalculator = 1, Object.defineProperty(CdrSizeCalculator, "__esModule", {
		value: !0
	}), CdrSizeCalculator.CdrSizeCalculator = void 0;
	let o = class {
		constructor() {
			this.offset = 4
		}
		get size() {
			return this.offset
		}
		int8() {
			return this.incrementAndReturn(1)
		}
		uint8() {
			return this.incrementAndReturn(1)
		}
		int16() {
			return this.incrementAndReturn(2)
		}
		uint16() {
			return this.incrementAndReturn(2)
		}
		int32() {
			return this.incrementAndReturn(4)
		}
		uint32() {
			return this.incrementAndReturn(4)
		}
		int64() {
			return this.incrementAndReturn(8)
		}
		uint64() {
			return this.incrementAndReturn(8)
		}
		float32() {
			return this.incrementAndReturn(4)
		}
		float64() {
			return this.incrementAndReturn(8)
		}
		string(a) {
			return this.uint32(), this.offset += a + 1, this.offset
		}
		sequenceLength() {
			return this.uint32()
		}
		incrementAndReturn(a) {
			const l = (this.offset - 4) % a;
			return l > 0 && (this.offset += a - l), this.offset += a, this.offset
		}
	};
	return CdrSizeCalculator.CdrSizeCalculator = o, CdrSizeCalculator
}
var CdrWriter = {},
	hasRequiredCdrWriter;

function requireCdrWriter() {
	if (hasRequiredCdrWriter) return CdrWriter;
	hasRequiredCdrWriter = 1, Object.defineProperty(CdrWriter, "__esModule", {
		value: !0
	}), CdrWriter.CdrWriter = void 0;
	const o = requireEncapsulationKind(),
		s = requireGetEncapsulationKindInfo(),
		a = requireIsBigEndian(),
		l = requireLengthCodes(),
		c = requireReservedPIDs(),
		d = new TextEncoder;
	let f = class Zn {
		constructor(g = {}) {
			g.buffer != null ? this.buffer = g.buffer : g.size != null ? this.buffer = new ArrayBuffer(g.size) :
				this.buffer = new ArrayBuffer(Zn.DEFAULT_CAPACITY);
			const v = g.kind ?? o.EncapsulationKind.CDR_LE,
				{
					isCDR2: y,
					littleEndian: b
				} = (0, s.getEncapsulationKindInfo)(v);
			this.isCDR2 = y, this.littleEndian = b, this.hostLittleEndian = !(0, a.isBigEndian)(), this
				.eightByteAlignment = y ? 4 : 8, this.array = new Uint8Array(this.buffer), this.view =
				new DataView(this.buffer), this.resizeIfNeeded(4), this.view.setUint8(0, 0), this.view.setUint8(
					1, v), this.view.setUint16(2, 0, !1), this.offset = 4, this.origin = 4
		}
		get data() {
			return new Uint8Array(this.buffer, 0, this.offset)
		}
		get size() {
			return this.offset
		}
		get kind() {
			return this.view.getUint8(1)
		}
		int8(g) {
			return this.resizeIfNeeded(1), this.view.setInt8(this.offset, g), this.offset += 1, this
		}
		uint8(g) {
			return this.resizeIfNeeded(1), this.view.setUint8(this.offset, g), this.offset += 1, this
		}
		int16(g) {
			return this.align(2), this.view.setInt16(this.offset, g, this.littleEndian), this.offset += 2, this
		}
		uint16(g) {
			return this.align(2), this.view.setUint16(this.offset, g, this.littleEndian), this.offset += 2, this
		}
		int32(g) {
			return this.align(4), this.view.setInt32(this.offset, g, this.littleEndian), this.offset += 4, this
		}
		uint32(g) {
			return this.align(4), this.view.setUint32(this.offset, g, this.littleEndian), this.offset += 4, this
		}
		int64(g) {
			return this.align(this.eightByteAlignment, 8), this.view.setBigInt64(this.offset, g, this
				.littleEndian), this.offset += 8, this
		}
		uint64(g) {
			return this.align(this.eightByteAlignment, 8), this.view.setBigUint64(this.offset, g, this
				.littleEndian), this.offset += 8, this
		}
		uint16BE(g) {
			return this.align(2), this.view.setUint16(this.offset, g, !1), this.offset += 2, this
		}
		uint32BE(g) {
			return this.align(4), this.view.setUint32(this.offset, g, !1), this.offset += 4, this
		}
		uint64BE(g) {
			return this.align(this.eightByteAlignment, 8), this.view.setBigUint64(this.offset, g, !1), this
				.offset += 8, this
		}
		float32(g) {
			return this.align(4), this.view.setFloat32(this.offset, g, this.littleEndian), this.offset += 4,
				this
		}
		float64(g) {
			return this.align(this.eightByteAlignment, 8), this.view.setFloat64(this.offset, g, this
				.littleEndian), this.offset += 8, this
		}
		string(g, v = !0) {
			const y = g.length;
			return v && this.uint32(y + 1), this.resizeIfNeeded(y + 1), d.encodeInto(g, new Uint8Array(this
					.buffer, this.offset, y)), this.view.setUint8(this.offset + y, 0), this.offset += y + 1,
				this
		}
		dHeader(g) {
			const v = g;
			return this.uint32(v), this
		}
		emHeader(g, v, y, b) {
			return this.isCDR2 ? this.memberHeaderV2(g, v, y, b) : this.memberHeaderV1(g, v, y)
		}
		memberHeaderV1(g, v, y) {
			this.align(4);
			const b = g ? 16384 : 0;
			if (v > 16128 || y > 65535) {
				const _ = b | c.EXTENDED_PID;
				this.uint16(_), this.uint16(8), this.uint32(v), this.uint32(y)
			} else {
				const _ = b | v;
				this.uint16(_);
				const S = y & 65535;
				this.uint16(S)
			}
			return this.resetOrigin(), this
		}
		resetOrigin() {
			this.origin = this.offset
		}
		sentinelHeader() {
			return this.isCDR2 || (this.align(4), this.uint16(c.SENTINEL_PID), this.uint16(0)), this
		}
		memberHeaderV2(g, v, y, b) {
			if (v > 268435455) throw Error(`Member ID ${v} is too large. Max value is 268435455`);
			const C = g ? 1 << 31 : 0,
				_ = b ?? (0, l.getLengthCodeForObjectSize)(y),
				S = C | _ << 28 | v;
			switch (this.uint32(S), _) {
				case 0:
				case 1:
				case 2:
				case 3: {
					const w = l.lengthCodeToObjectSizes[_];
					if (y !== w) throw new Error(
						`Cannot write a length code ${_} header with an object size not equal to ${w}`);
					break
				}
				case 4:
				case 5:
					this.uint32(y);
					break;
				case 6:
					if (y % 4 !== 0) throw new Error(
						"Cannot write a length code 6 header with an object size that is not a multiple of 4"
						);
					this.uint32(y >> 2);
					break;
				case 7:
					if (y % 8 !== 0) throw new Error(
						"Cannot write a length code 7 header with an object size that is not a multiple of 8"
						);
					this.uint32(y >> 3);
					break;
				default:
					throw new Error(`Unexpected length code ${_}`)
			}
			return this
		}
		sequenceLength(g) {
			return this.uint32(g)
		}
		int8Array(g, v) {
			return v === !0 && this.sequenceLength(g.length), this.resizeIfNeeded(g.length), this.array.set(g,
				this.offset), this.offset += g.length, this
		}
		uint8Array(g, v) {
			return v === !0 && this.sequenceLength(g.length), this.resizeIfNeeded(g.length), this.array.set(g,
				this.offset), this.offset += g.length, this
		}
		int16Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof Int16Array && this.littleEndian === this
				.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.int16(y);
			return this
		}
		uint16Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof Uint16Array && this.littleEndian ===
				this.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.uint16(y);
			return this
		}
		int32Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof Int32Array && this.littleEndian === this
				.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.int32(y);
			return this
		}
		uint32Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof Uint32Array && this.littleEndian ===
				this.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.uint32(y);
			return this
		}
		int64Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof BigInt64Array && this.littleEndian ===
				this.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.int64(BigInt(y));
			return this
		}
		uint64Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof BigUint64Array && this.littleEndian ===
				this.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.uint64(BigInt(y));
			return this
		}
		float32Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof Float32Array && this.littleEndian ===
				this.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.float32(y);
			return this
		}
		float64Array(g, v) {
			if (v === !0 && this.sequenceLength(g.length), g instanceof Float64Array && this.littleEndian ===
				this.hostLittleEndian && g.length >= Zn.BUFFER_COPY_THRESHOLD) this.align(g.BYTES_PER_ELEMENT, g
				.byteLength), this.array.set(new Uint8Array(g.buffer, g.byteOffset, g.byteLength), this
				.offset), this.offset += g.byteLength;
			else
				for (const y of g) this.float64(y);
			return this
		}
		align(g, v = g) {
			const y = (this.offset - this.origin) % g,
				b = y > 0 ? g - y : 0;
			this.resizeIfNeeded(b + v), this.array.fill(0, this.offset, this.offset + b), this.offset += b
		}
		resizeIfNeeded(g) {
			const v = this.offset + g;
			if (this.buffer.byteLength < v) {
				const y = this.buffer.byteLength * 2,
					b = y > v ? y : v;
				this.resize(b)
			}
		}
		resize(g) {
			if (this.buffer.byteLength >= g) return;
			const v = new ArrayBuffer(g),
				y = new Uint8Array(v);
			y.set(this.array), this.buffer = v, this.array = y, this.view = new DataView(v)
		}
	};
	return CdrWriter.CdrWriter = f, f.DEFAULT_CAPACITY = 16, f.BUFFER_COPY_THRESHOLD = 10, CdrWriter
}
var hasRequiredDist$2;

function requireDist$2() {
	return hasRequiredDist$2 || (hasRequiredDist$2 = 1, function(o) {
		var s = dist$1 && dist$1.__createBinding || (Object.create ? function(l, c, d, f) {
				f === void 0 && (f = d), Object.defineProperty(l, f, {
					enumerable: !0,
					get: function() {
						return c[d]
					}
				})
			} : function(l, c, d, f) {
				f === void 0 && (f = d), l[f] = c[d]
			}),
			a = dist$1 && dist$1.__exportStar || function(l, c) {
				for (var d in l) d !== "default" && !Object.prototype.hasOwnProperty.call(c, d) && s(c, l, d)
			};
		Object.defineProperty(o, "__esModule", {
			value: !0
		}), a(requireCdrReader(), o), a(requireCdrSizeCalculator(), o), a(requireCdrWriter(), o), a(
			requireEncapsulationKind(), o)
	}(dist$1)), dist$1
}
var messageDefinitionHasDataFields = {},
	hasRequiredMessageDefinitionHasDataFields;

function requireMessageDefinitionHasDataFields() {
	if (hasRequiredMessageDefinitionHasDataFields) return messageDefinitionHasDataFields;
	hasRequiredMessageDefinitionHasDataFields = 1, Object.defineProperty(messageDefinitionHasDataFields, "__esModule", {
		value: !0
	}), messageDefinitionHasDataFields.messageDefinitionHasDataFields = o;

	function o(s) {
		return s.some(a => a.isConstant !== !0)
	}
	return messageDefinitionHasDataFields
}
var hasRequiredMessageReader;

function requireMessageReader() {
	if (hasRequiredMessageReader) return MessageReader;
	hasRequiredMessageReader = 1;
	var o = MessageReader && MessageReader.__classPrivateFieldSet || function(D, F, R, O, U) {
			if (O === "m") throw new TypeError("Private method is not writable");
			if (O === "a" && !U) throw new TypeError("Private accessor was defined without a setter");
			if (typeof F == "function" ? D !== F || !U : !F.has(D)) throw new TypeError(
				"Cannot write private member to an object whose class did not declare it");
			return O === "a" ? U.call(D, R) : U ? U.value = R : F.set(D, R), R
		},
		s = MessageReader && MessageReader.__classPrivateFieldGet || function(D, F, R, O) {
			if (R === "a" && !O) throw new TypeError("Private accessor was defined without a getter");
			if (typeof F == "function" ? D !== F || !O : !F.has(D)) throw new TypeError(
				"Cannot read private member from an object whose class did not declare it");
			return R === "m" ? O : R === "a" ? O.call(D) : O ? O.value : F.get(D)
		},
		a, l, c, d, f;
	Object.defineProperty(MessageReader, "__esModule", {
		value: !0
	}), MessageReader.MessageReader = void 0;
	const m = requireDist$2(),
		g = requireMessageDefinitionHasDataFields();
	let v = class {
		constructor(F, R = {}) {
			a.add(this), l.set(this, void 0), c.set(this, void 0), d.set(this, void 0);
			const {
				timeType: O = "sec,nanosec"
			} = R, U = F.find(V => !y(V));
			if (U == null) throw new Error("MessageReader initialized with no root MessageDefinition");
			o(this, l, U.definitions, "f"), o(this, c, new Map(F.map(V => [V.name ?? "", V.definitions])), "f"),
				o(this, d, O === "sec,nsec", "f")
		}
		readMessage(F) {
			const R = new m.CdrReader(F);
			return s(this, a, "m", f).call(this, s(this, l, "f"), R)
		}
	};
	MessageReader.MessageReader = v, l = new WeakMap, c = new WeakMap, d = new WeakMap, a = new WeakSet, f = function D(
		F, R) {
		const O = {};
		if (!(0, g.messageDefinitionHasDataFields)(F)) return R.uint8(), O;
		for (const U of F)
			if (U.isConstant !== !0)
				if (U.isComplex === !0) {
					const V = s(this, c, "f").get(U.type);
					if (V == null) throw new Error(`Unrecognized complex type ${U.type}`);
					if (U.isArray === !0) {
						const z = U.arrayLength ?? R.sequenceLength(),
							j = [];
						for (let ge = 0; ge < z; ge++) j.push(s(this, a, "m", D).call(this, V, R));
						O[U.name] = j
					} else O[U.name] = s(this, a, "m", D).call(this, V, R)
				} else if (U.isArray === !0) {
			const V = (s(this, d, "f") ? S : _).get(U.type);
			if (V == null) throw new Error(`Unrecognized primitive array type ${U.type}[]`);
			const z = U.arrayLength ?? R.sequenceLength();
			O[U.name] = V(R, z)
		} else {
			const V = (s(this, d, "f") ? C : b).get(U.type);
			if (V == null) throw new Error(`Unrecognized primitive type ${U.type}`);
			O[U.name] = V(R)
		}
		return O
	};

	function y(D) {
		return D.definitions.length > 0 && D.definitions.every(F => F.isConstant)
	}
	const b = new Map([
			["bool", D => !!D.int8()],
			["int8", D => D.int8()],
			["uint8", D => D.uint8()],
			["int16", D => D.int16()],
			["uint16", D => D.uint16()],
			["int32", D => D.int32()],
			["uint32", D => D.uint32()],
			["int64", D => D.int64()],
			["uint64", D => D.uint64()],
			["float32", D => D.float32()],
			["float64", D => D.float64()],
			["string", D => D.string()],
			["wstring", M],
			["time", D => ({
				sec: D.int32(),
				nanosec: D.uint32()
			})],
			["duration", D => ({
				sec: D.int32(),
				nanosec: D.uint32()
			})]
		]),
		C = new Map([...b, ["time", D => ({
				sec: D.int32(),
				nsec: D.uint32()
			})],
			["duration", D => ({
				sec: D.int32(),
				nsec: D.uint32()
			})]
		]),
		_ = new Map([
			["bool", w],
			["int8", (D, F) => D.int8Array(F)],
			["uint8", (D, F) => D.uint8Array(F)],
			["int16", (D, F) => D.int16Array(F)],
			["uint16", (D, F) => D.uint16Array(F)],
			["int32", (D, F) => D.int32Array(F)],
			["uint32", (D, F) => D.uint32Array(F)],
			["int64", (D, F) => D.int64Array(F)],
			["uint64", (D, F) => D.uint64Array(F)],
			["float32", (D, F) => D.float32Array(F)],
			["float64", (D, F) => D.float64Array(F)],
			["string", T],
			["wstring", M],
			["time", k],
			["duration", k]
		]),
		S = new Map([..._, ["time", A],
			["duration", A]
		]);

	function w(D, F) {
		const R = new Array(F);
		for (let O = 0; O < F; O++) R[O] = !!D.int8();
		return R
	}

	function T(D, F) {
		const R = new Array(F);
		for (let O = 0; O < F; O++) R[O] = D.string();
		return R
	}

	function A(D, F) {
		const R = new Array(F);
		for (let O = 0; O < F; O++) {
			const U = D.int32(),
				V = D.uint32();
			R[O] = {
				sec: U,
				nsec: V
			}
		}
		return R
	}

	function k(D, F) {
		const R = new Array(F);
		for (let O = 0; O < F; O++) {
			const U = D.int32(),
				V = D.uint32();
			R[O] = {
				sec: U,
				nanosec: V
			}
		}
		return R
	}

	function M() {
		throw new Error("wstring is implementation-defined and therefore not supported")
	}
	return MessageReader
}
var MessageWriter = {},
	hasRequiredMessageWriter;

function requireMessageWriter() {
	if (hasRequiredMessageWriter) return MessageWriter;
	hasRequiredMessageWriter = 1;
	var o = MessageWriter && MessageWriter.__classPrivateFieldSet || function(He, Ae, xe, ye, Le) {
			if (ye === "m") throw new TypeError("Private method is not writable");
			if (ye === "a" && !Le) throw new TypeError("Private accessor was defined without a setter");
			if (typeof Ae == "function" ? He !== Ae || !Le : !Ae.has(He)) throw new TypeError(
				"Cannot write private member to an object whose class did not declare it");
			return ye === "a" ? Le.call(He, xe) : Le ? Le.value = xe : Ae.set(He, xe), xe
		},
		s = MessageWriter && MessageWriter.__classPrivateFieldGet || function(He, Ae, xe, ye) {
			if (xe === "a" && !ye) throw new TypeError("Private accessor was defined without a getter");
			if (typeof Ae == "function" ? He !== Ae || !ye : !Ae.has(He)) throw new TypeError(
				"Cannot read private member from an object whose class did not declare it");
			return xe === "m" ? ye : xe === "a" ? ye.call(He) : ye ? ye.value : Ae.get(He)
		},
		a, l, c, d, f, m, g, v, y;
	Object.defineProperty(MessageWriter, "__esModule", {
		value: !0
	}), MessageWriter.MessageWriter = void 0;
	const b = requireDist$2(),
		C = requireMessageDefinitionHasDataFields(),
		_ = new Map([
			["bool", 1],
			["int8", 1],
			["uint8", 1],
			["int16", 2],
			["uint16", 2],
			["int32", 4],
			["uint32", 4],
			["int64", 8],
			["uint64", 8],
			["float32", 4],
			["float64", 8],
			["time", 8],
			["duration", 8]
		]),
		S = new Map([
			["bool", D],
			["int8", F],
			["uint8", R],
			["int16", O],
			["uint16", U],
			["int32", V],
			["uint32", z],
			["int64", j],
			["uint64", ge],
			["float32", me],
			["float64", he],
			["string", ce],
			["time", ae],
			["duration", ae],
			["wstring", T]
		]),
		w = new Map([
			["bool", fe],
			["int8", q],
			["uint8", le],
			["int16", de],
			["uint16", _e],
			["int32", ke],
			["uint32", De],
			["int64", Se],
			["uint64", be],
			["float32", Me],
			["float64", Ve],
			["string", it],
			["time", pt],
			["duration", pt],
			["wstring", T]
		]);

	function T() {
		throw new Error("wstring is implementation-defined and therefore not supported")
	}
	let A = class {
		constructor(Ae) {
			a.add(this), l.set(this, void 0), c.set(this, void 0);
			const xe = Ae.find(ye => !k(ye));
			if (xe == null) throw new Error("MessageReader initialized with no root MessageDefinition");
			o(this, l, xe.definitions, "f"), o(this, c, new Map(Ae.map(ye => [ye.name ?? "", ye.definitions])),
				"f")
		}
		calculateByteSize(Ae) {
			return s(this, a, "m", d).call(this, s(this, l, "f"), Ae, 4)
		}
		writeMessage(Ae, xe) {
			const ye = new b.CdrWriter({
				buffer: xe,
				size: xe ? void 0 : this.calculateByteSize(Ae)
			});
			return s(this, a, "m", f).call(this, s(this, l, "f"), Ae, ye), ye.data
		}
	};
	MessageWriter.MessageWriter = A, l = new WeakMap, c = new WeakMap, a = new WeakSet, d = function He(Ae, xe, ye) {
		const Le = xe;
		let Ue = ye;
		if (!(0, C.messageDefinitionHasDataFields)(Ae)) return ye + s(this, a, "m", g).call(this, "uint8");
		for (const nt of Ae) {
			if (nt.isConstant === !0) continue;
			const ot = Le == null ? void 0 : Le[nt.name];
			if (nt.isArray === !0) {
				const at = nt.arrayLength ?? M(ot),
					Ne = Array.isArray(ot) || ArrayBuffer.isView(ot) ? ot : [];
				if (nt.arrayLength == null && (Ue += dt(Ue, 4), Ue += 4), nt.isComplex === !0) {
					const we = s(this, a, "m", m).call(this, nt.type);
					for (let Ce = 0; Ce < at; Ce++) {
						const $e = Ne[Ce] ?? {};
						Ue = s(this, a, "m", He).call(this, we, $e, Ue)
					}
				} else if (nt.type === "string")
					for (let we = 0; we < at; we++) {
						const Ce = Ne[we] ?? "";
						Ue += dt(Ue, 4), Ue += 4 + Ce.length + 1
					} else {
						const we = s(this, a, "m", g).call(this, nt.type),
							Ce = nt.type === "time" || nt.type === "duration" ? 4 : we;
						Ue += dt(Ue, Ce), Ue += we * at
					}
			} else if (nt.isComplex === !0) {
				const at = s(this, a, "m", m).call(this, nt.type),
					Je = ot ?? {};
				Ue = s(this, a, "m", He).call(this, at, Je, Ue)
			} else if (nt.type === "string") {
				const at = typeof ot == "string" ? ot : "";
				Ue += dt(Ue, 4), Ue += 4 + at.length + 1
			} else {
				const at = s(this, a, "m", g).call(this, nt.type),
					Je = nt.type === "time" || nt.type === "duration" ? 4 : at;
				Ue += dt(Ue, Je), Ue += at
			}
		}
		return Ue
	}, f = function He(Ae, xe, ye) {
		const Le = xe;
		if (!(0, C.messageDefinitionHasDataFields)(Ae)) {
			R(0, 0, ye);
			return
		}
		for (const Ue of Ae) {
			if (Ue.isConstant === !0) continue;
			const nt = Le == null ? void 0 : Le[Ue.name];
			if (Ue.isArray === !0) {
				const ot = Ue.arrayLength ?? M(nt),
					Je = Array.isArray(nt) || ArrayBuffer.isView(nt) ? nt : [];
				if (Ue.arrayLength == null && ye.sequenceLength(ot), Ue.arrayLength != null && nt != null) {
					const Ne = M(nt);
					if (Ne !== Ue.arrayLength) throw new Error(
						`Expected ${Ue.arrayLength} items for fixed-length array field ${Ue.name} but received ${Ne}`
						)
				}
				if (Ue.isComplex === !0) {
					const Ne = s(this, a, "m", m).call(this, Ue.type);
					for (let we = 0; we < ot; we++) {
						const Ce = Je[we] ?? {};
						s(this, a, "m", He).call(this, Ne, Ce, ye)
					}
				} else s(this, a, "m", y).call(this, Ue.type)(nt, Ue.defaultValue, ye, Ue.arrayLength)
			} else if (Ue.isComplex === !0) {
				const ot = s(this, a, "m", m).call(this, Ue.type),
					at = nt ?? {};
				s(this, a, "m", He).call(this, ot, at, ye)
			} else s(this, a, "m", v).call(this, Ue.type)(nt, Ue.defaultValue, ye)
		}
	}, m = function(Ae) {
		const xe = s(this, c, "f").get(Ae);
		if (xe == null) throw new Error(`Unrecognized complex type ${Ae}`);
		return xe
	}, g = function(Ae) {
		const xe = _.get(Ae);
		if (xe == null) throw Ae === "wstring" && T(), new Error(`Unrecognized primitive type ${Ae}`);
		return xe
	}, v = function(Ae) {
		const xe = S.get(Ae);
		if (xe == null) throw new Error(`Unrecognized primitive type ${Ae}`);
		return xe
	}, y = function(Ae) {
		const xe = w.get(Ae);
		if (xe == null) throw new Error(`Unrecognized primitive type ${Ae}[]`);
		return xe
	};

	function k(He) {
		return He.definitions.length > 0 && He.definitions.every(Ae => Ae.isConstant)
	}

	function M(He) {
		const Ae = He == null ? void 0 : He.length;
		return typeof Ae == "number" ? Ae : 0
	}

	function D(He, Ae, xe) {
		const ye = typeof He == "boolean" ? He : Ae ?? !1;
		xe.int8(ye ? 1 : 0)
	}

	function F(He, Ae, xe) {
		xe.int8(typeof He == "number" ? He : Ae ?? 0)
	}

	function R(He, Ae, xe) {
		xe.uint8(typeof He == "number" ? He : Ae ?? 0)
	}

	function O(He, Ae, xe) {
		xe.int16(typeof He == "number" ? He : Ae ?? 0)
	}

	function U(He, Ae, xe) {
		xe.uint16(typeof He == "number" ? He : Ae ?? 0)
	}

	function V(He, Ae, xe) {
		xe.int32(typeof He == "number" ? He : Ae ?? 0)
	}

	function z(He, Ae, xe) {
		xe.uint32(typeof He == "number" ? He : Ae ?? 0)
	}

	function j(He, Ae, xe) {
		typeof He == "bigint" ? xe.int64(He) : typeof He == "number" ? xe.int64(BigInt(He)) : xe.int64(Ae ?? 0n)
	}

	function ge(He, Ae, xe) {
		typeof He == "bigint" ? xe.uint64(He) : typeof He == "number" ? xe.uint64(BigInt(He)) : xe.uint64(Ae ?? 0n)
	}

	function me(He, Ae, xe) {
		xe.float32(typeof He == "number" ? He : Ae ?? 0)
	}

	function he(He, Ae, xe) {
		xe.float64(typeof He == "number" ? He : Ae ?? 0)
	}

	function ce(He, Ae, xe) {
		xe.string(typeof He == "string" ? He : Ae ?? "")
	}

	function ae(He, Ae, xe) {
		if (He == null) {
			xe.int32(0), xe.uint32(0);
			return
		}
		const ye = He;
		xe.int32(ye.sec ?? 0), xe.uint32(ye.nsec ?? ye.nanosec ?? 0)
	}

	function fe(He, Ae, xe, ye) {
		if (Array.isArray(He)) {
			const Le = new Int8Array(He);
			xe.int8Array(Le)
		} else xe.int8Array(Ae ?? new Int8Array(ye ?? 0).fill(0))
	}

	function q(He, Ae, xe, ye) {
		if (He instanceof Int8Array) xe.int8Array(He);
		else if (Array.isArray(He)) {
			const Le = new Int8Array(He);
			xe.int8Array(Le)
		} else xe.int8Array(Ae ?? new Int8Array(ye ?? 0).fill(0))
	}

	function le(He, Ae, xe, ye) {
		if (He instanceof Uint8Array) xe.uint8Array(He);
		else if (He instanceof Uint8ClampedArray) xe.uint8Array(new Uint8Array(He));
		else if (Array.isArray(He)) {
			const Le = new Uint8Array(He);
			xe.uint8Array(Le)
		} else xe.uint8Array(Ae ?? new Uint8Array(ye ?? 0).fill(0))
	}

	function de(He, Ae, xe, ye) {
		if (He instanceof Int16Array) xe.int16Array(He);
		else if (Array.isArray(He)) {
			const Le = new Int16Array(He);
			xe.int16Array(Le)
		} else xe.int16Array(Ae ?? new Int16Array(ye ?? 0).fill(0))
	}

	function _e(He, Ae, xe, ye) {
		if (He instanceof Uint16Array) xe.uint16Array(He);
		else if (Array.isArray(He)) {
			const Le = new Uint16Array(He);
			xe.uint16Array(Le)
		} else xe.uint16Array(Ae ?? new Uint16Array(ye ?? 0).fill(0))
	}

	function ke(He, Ae, xe, ye) {
		if (He instanceof Int32Array) xe.int32Array(He);
		else if (Array.isArray(He)) {
			const Le = new Int32Array(He);
			xe.int32Array(Le)
		} else xe.int32Array(Ae ?? new Int32Array(ye ?? 0).fill(0))
	}

	function De(He, Ae, xe, ye) {
		if (He instanceof Uint32Array) xe.uint32Array(He);
		else if (Array.isArray(He)) {
			const Le = new Uint32Array(He);
			xe.uint32Array(Le)
		} else xe.uint32Array(Ae ?? new Uint32Array(ye ?? 0).fill(0))
	}

	function Se(He, Ae, xe, ye) {
		if (He instanceof BigInt64Array) xe.int64Array(He);
		else if (Array.isArray(He)) {
			const Le = new BigInt64Array(He);
			xe.int64Array(Le)
		} else xe.int64Array(Ae ?? new BigInt64Array(ye ?? 0).fill(0n))
	}

	function be(He, Ae, xe, ye) {
		if (He instanceof BigUint64Array) xe.uint64Array(He);
		else if (Array.isArray(He)) {
			const Le = new BigUint64Array(He);
			xe.uint64Array(Le)
		} else xe.uint64Array(Ae ?? new BigUint64Array(ye ?? 0).fill(0n))
	}

	function Me(He, Ae, xe, ye) {
		if (He instanceof Float32Array) xe.float32Array(He);
		else if (Array.isArray(He)) {
			const Le = new Float32Array(He);
			xe.float32Array(Le)
		} else xe.float32Array(Ae ?? new Float32Array(ye ?? 0).fill(0))
	}

	function Ve(He, Ae, xe, ye) {
		if (He instanceof Float64Array) xe.float64Array(He);
		else if (Array.isArray(He)) {
			const Le = new Float64Array(He);
			xe.float64Array(Le)
		} else xe.float64Array(Ae ?? new Float64Array(ye ?? 0).fill(0))
	}

	function it(He, Ae, xe, ye) {
		if (Array.isArray(He))
			for (const Le of He) xe.string(typeof Le == "string" ? Le : "");
		else {
			const Le = Ae ?? new Array(ye ?? 0).fill("");
			for (const Ue of Le) xe.string(Ue)
		}
	}

	function pt(He, Ae, xe, ye) {
		if (Array.isArray(He))
			for (const Le of He) ae(Le, void 0, xe);
		else {
			const Le = new Array(ye).fill(void 0);
			for (const Ue of Le) ae(Ue, void 0, xe)
		}
	}

	function dt(He, Ae) {
		const xe = (He - 4) % Ae;
		return xe > 0 ? Ae - xe : 0
	}
	return MessageWriter
}
var hasRequiredDist$1;

function requireDist$1() {
	return hasRequiredDist$1 || (hasRequiredDist$1 = 1, function(o) {
		var s = dist$2 && dist$2.__createBinding || (Object.create ? function(l, c, d, f) {
				f === void 0 && (f = d);
				var m = Object.getOwnPropertyDescriptor(c, d);
				(!m || ("get" in m ? !c.__esModule : m.writable || m.configurable)) && (m = {
					enumerable: !0,
					get: function() {
						return c[d]
					}
				}), Object.defineProperty(l, f, m)
			} : function(l, c, d, f) {
				f === void 0 && (f = d), l[f] = c[d]
			}),
			a = dist$2 && dist$2.__exportStar || function(l, c) {
				for (var d in l) d !== "default" && !Object.prototype.hasOwnProperty.call(c, d) && s(c, l, d)
			};
		Object.defineProperty(o, "__esModule", {
			value: !0
		}), a(requireMessageReader(), o), a(requireMessageWriter(), o)
	}(dist$2)), dist$2
}
var distExports$1 = requireDist$1(),
	src$1 = {
		exports: {}
	},
	indexLight$1 = {
		exports: {}
	},
	indexMinimal$1 = {},
	minimal$1 = {},
	aspromise$1, hasRequiredAspromise$1;

function requireAspromise$1() {
	if (hasRequiredAspromise$1) return aspromise$1;
	hasRequiredAspromise$1 = 1, aspromise$1 = o;

	function o(s, a) {
		for (var l = new Array(arguments.length - 1), c = 0, d = 2, f = !0; d < arguments.length;) l[c++] = arguments[
			d++];
		return new Promise(function(g, v) {
			l[c] = function(b) {
				if (f)
					if (f = !1, b) v(b);
					else {
						for (var C = new Array(arguments.length - 1), _ = 0; _ < C.length;) C[_++] =
							arguments[_];
						g.apply(null, C)
					}
			};
			try {
				s.apply(a || null, l)
			} catch (y) {
				f && (f = !1, v(y))
			}
		})
	}
	return aspromise$1
}
var base64$1 = {},
	hasRequiredBase64$1;

function requireBase64$1() {
	return hasRequiredBase64$1 || (hasRequiredBase64$1 = 1, function(o) {
		var s = o;
		s.length = function(m) {
			var g = m.length;
			if (!g) return 0;
			for (var v = 0; --g % 4 > 1 && m.charAt(g) === "=";) ++v;
			return Math.ceil(m.length * 3) / 4 - v
		};
		for (var a = new Array(64), l = new Array(123), c = 0; c < 64;) l[a[c] = c < 26 ? c + 65 : c < 52 ? c +
			71 : c < 62 ? c - 4 : c - 59 | 43] = c++;
		s.encode = function(m, g, v) {
			for (var y = null, b = [], C = 0, _ = 0, S; g < v;) {
				var w = m[g++];
				switch (_) {
					case 0:
						b[C++] = a[w >> 2], S = (w & 3) << 4, _ = 1;
						break;
					case 1:
						b[C++] = a[S | w >> 4], S = (w & 15) << 2, _ = 2;
						break;
					case 2:
						b[C++] = a[S | w >> 6], b[C++] = a[w & 63], _ = 0;
						break
				}
				C > 8191 && ((y || (y = [])).push(String.fromCharCode.apply(String, b)), C = 0)
			}
			return _ && (b[C++] = a[S], b[C++] = 61, _ === 1 && (b[C++] = 61)), y ? (C && y.push(String
				.fromCharCode.apply(String, b.slice(0, C))), y.join("")) : String.fromCharCode.apply(
				String, b.slice(0, C))
		};
		var d = "invalid encoding";
		s.decode = function(m, g, v) {
			for (var y = v, b = 0, C, _ = 0; _ < m.length;) {
				var S = m.charCodeAt(_++);
				if (S === 61 && b > 1) break;
				if ((S = l[S]) === void 0) throw Error(d);
				switch (b) {
					case 0:
						C = S, b = 1;
						break;
					case 1:
						g[v++] = C << 2 | (S & 48) >> 4, C = S, b = 2;
						break;
					case 2:
						g[v++] = (C & 15) << 4 | (S & 60) >> 2, C = S, b = 3;
						break;
					case 3:
						g[v++] = (C & 3) << 6 | S, b = 0;
						break
				}
			}
			if (b === 1) throw Error(d);
			return v - y
		}, s.test = function(m) {
			return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(m)
		}
	}(base64$1)), base64$1
}
var eventemitter$1, hasRequiredEventemitter$1;

function requireEventemitter$1() {
	if (hasRequiredEventemitter$1) return eventemitter$1;
	hasRequiredEventemitter$1 = 1, eventemitter$1 = o;

	function o() {
		this._listeners = {}
	}
	return o.prototype.on = function(a, l, c) {
		return (this._listeners[a] || (this._listeners[a] = [])).push({
			fn: l,
			ctx: c || this
		}), this
	}, o.prototype.off = function(a, l) {
		if (a === void 0) this._listeners = {};
		else if (l === void 0) this._listeners[a] = [];
		else
			for (var c = this._listeners[a], d = 0; d < c.length;) c[d].fn === l ? c.splice(d, 1) : ++d;
		return this
	}, o.prototype.emit = function(a) {
		var l = this._listeners[a];
		if (l) {
			for (var c = [], d = 1; d < arguments.length;) c.push(arguments[d++]);
			for (d = 0; d < l.length;) l[d].fn.apply(l[d++].ctx, c)
		}
		return this
	}, eventemitter$1
}
var float$1, hasRequiredFloat$1;

function requireFloat$1() {
	if (hasRequiredFloat$1) return float$1;
	hasRequiredFloat$1 = 1, float$1 = o(o);

	function o(d) {
		return typeof Float32Array < "u" ? function() {
			var f = new Float32Array([-0]),
				m = new Uint8Array(f.buffer),
				g = m[3] === 128;

			function v(_, S, w) {
				f[0] = _, S[w] = m[0], S[w + 1] = m[1], S[w + 2] = m[2], S[w + 3] = m[3]
			}

			function y(_, S, w) {
				f[0] = _, S[w] = m[3], S[w + 1] = m[2], S[w + 2] = m[1], S[w + 3] = m[0]
			}
			d.writeFloatLE = g ? v : y, d.writeFloatBE = g ? y : v;

			function b(_, S) {
				return m[0] = _[S], m[1] = _[S + 1], m[2] = _[S + 2], m[3] = _[S + 3], f[0]
			}

			function C(_, S) {
				return m[3] = _[S], m[2] = _[S + 1], m[1] = _[S + 2], m[0] = _[S + 3], f[0]
			}
			d.readFloatLE = g ? b : C, d.readFloatBE = g ? C : b
		}() : function() {
			function f(g, v, y, b) {
				var C = v < 0 ? 1 : 0;
				if (C && (v = -v), v === 0) g(1 / v > 0 ? 0 : 2147483648, y, b);
				else if (isNaN(v)) g(2143289344, y, b);
				else if (v > 34028234663852886e22) g((C << 31 | 2139095040) >>> 0, y, b);
				else if (v < 11754943508222875e-54) g((C << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, y, b);
				else {
					var _ = Math.floor(Math.log(v) / Math.LN2),
						S = Math.round(v * Math.pow(2, -_) * 8388608) & 8388607;
					g((C << 31 | _ + 127 << 23 | S) >>> 0, y, b)
				}
			}
			d.writeFloatLE = f.bind(null, s), d.writeFloatBE = f.bind(null, a);

			function m(g, v, y) {
				var b = g(v, y),
					C = (b >> 31) * 2 + 1,
					_ = b >>> 23 & 255,
					S = b & 8388607;
				return _ === 255 ? S ? NaN : C * (1 / 0) : _ === 0 ? C * 1401298464324817e-60 * S : C * Math.pow(2,
					_ - 150) * (S + 8388608)
			}
			d.readFloatLE = m.bind(null, l), d.readFloatBE = m.bind(null, c)
		}(), typeof Float64Array < "u" ? function() {
			var f = new Float64Array([-0]),
				m = new Uint8Array(f.buffer),
				g = m[7] === 128;

			function v(_, S, w) {
				f[0] = _, S[w] = m[0], S[w + 1] = m[1], S[w + 2] = m[2], S[w + 3] = m[3], S[w + 4] = m[4], S[w +
					5] = m[5], S[w + 6] = m[6], S[w + 7] = m[7]
			}

			function y(_, S, w) {
				f[0] = _, S[w] = m[7], S[w + 1] = m[6], S[w + 2] = m[5], S[w + 3] = m[4], S[w + 4] = m[3], S[w +
					5] = m[2], S[w + 6] = m[1], S[w + 7] = m[0]
			}
			d.writeDoubleLE = g ? v : y, d.writeDoubleBE = g ? y : v;

			function b(_, S) {
				return m[0] = _[S], m[1] = _[S + 1], m[2] = _[S + 2], m[3] = _[S + 3], m[4] = _[S + 4], m[5] = _[S +
					5], m[6] = _[S + 6], m[7] = _[S + 7], f[0]
			}

			function C(_, S) {
				return m[7] = _[S], m[6] = _[S + 1], m[5] = _[S + 2], m[4] = _[S + 3], m[3] = _[S + 4], m[2] = _[S +
					5], m[1] = _[S + 6], m[0] = _[S + 7], f[0]
			}
			d.readDoubleLE = g ? b : C, d.readDoubleBE = g ? C : b
		}() : function() {
			function f(g, v, y, b, C, _) {
				var S = b < 0 ? 1 : 0;
				if (S && (b = -b), b === 0) g(0, C, _ + v), g(1 / b > 0 ? 0 : 2147483648, C, _ + y);
				else if (isNaN(b)) g(0, C, _ + v), g(2146959360, C, _ + y);
				else if (b > 17976931348623157e292) g(0, C, _ + v), g((S << 31 | 2146435072) >>> 0, C, _ + y);
				else {
					var w;
					if (b < 22250738585072014e-324) w = b / 5e-324, g(w >>> 0, C, _ + v), g((S << 31 | w /
						4294967296) >>> 0, C, _ + y);
					else {
						var T = Math.floor(Math.log(b) / Math.LN2);
						T === 1024 && (T = 1023), w = b * Math.pow(2, -T), g(w * 4503599627370496 >>> 0, C, _ + v),
							g((S << 31 | T + 1023 << 20 | w * 1048576 & 1048575) >>> 0, C, _ + y)
					}
				}
			}
			d.writeDoubleLE = f.bind(null, s, 0, 4), d.writeDoubleBE = f.bind(null, a, 4, 0);

			function m(g, v, y, b, C) {
				var _ = g(b, C + v),
					S = g(b, C + y),
					w = (S >> 31) * 2 + 1,
					T = S >>> 20 & 2047,
					A = 4294967296 * (S & 1048575) + _;
				return T === 2047 ? A ? NaN : w * (1 / 0) : T === 0 ? w * 5e-324 * A : w * Math.pow(2, T - 1075) * (
					A + 4503599627370496)
			}
			d.readDoubleLE = m.bind(null, l, 0, 4), d.readDoubleBE = m.bind(null, c, 4, 0)
		}(), d
	}

	function s(d, f, m) {
		f[m] = d & 255, f[m + 1] = d >>> 8 & 255, f[m + 2] = d >>> 16 & 255, f[m + 3] = d >>> 24
	}

	function a(d, f, m) {
		f[m] = d >>> 24, f[m + 1] = d >>> 16 & 255, f[m + 2] = d >>> 8 & 255, f[m + 3] = d & 255
	}

	function l(d, f) {
		return (d[f] | d[f + 1] << 8 | d[f + 2] << 16 | d[f + 3] << 24) >>> 0
	}

	function c(d, f) {
		return (d[f] << 24 | d[f + 1] << 16 | d[f + 2] << 8 | d[f + 3]) >>> 0
	}
	return float$1
}
var inquire_1$1, hasRequiredInquire$1;

function requireInquire$1() {
	if (hasRequiredInquire$1) return inquire_1$1;
	hasRequiredInquire$1 = 1, inquire_1$1 = inquire;

	function inquire(moduleName) {
		try {
			var mod = eval("quire".replace(/^/, "re"))(moduleName);
			if (mod && (mod.length || Object.keys(mod).length)) return mod
		} catch (o) {}
		return null
	}
	return inquire_1$1
}
var utf8$1 = {},
	hasRequiredUtf8$1;

function requireUtf8$1() {
	return hasRequiredUtf8$1 || (hasRequiredUtf8$1 = 1, function(o) {
		var s = o;
		s.length = function(l) {
			for (var c = 0, d = 0, f = 0; f < l.length; ++f) d = l.charCodeAt(f), d < 128 ? c += 1 : d <
				2048 ? c += 2 : (d & 64512) === 55296 && (l.charCodeAt(f + 1) & 64512) === 56320 ? (++f,
					c += 4) : c += 3;
			return c
		}, s.read = function(l, c, d) {
			var f = d - c;
			if (f < 1) return "";
			for (var m = null, g = [], v = 0, y; c < d;) y = l[c++], y < 128 ? g[v++] = y : y > 191 && y <
				224 ? g[v++] = (y & 31) << 6 | l[c++] & 63 : y > 239 && y < 365 ? (y = ((y & 7) << 18 | (l[
					c++] & 63) << 12 | (l[c++] & 63) << 6 | l[c++] & 63) - 65536, g[v++] = 55296 + (y >>
					10), g[v++] = 56320 + (y & 1023)) : g[v++] = (y & 15) << 12 | (l[c++] & 63) << 6 | l[
					c++] & 63, v > 8191 && ((m || (m = [])).push(String.fromCharCode.apply(String, g)), v =
					0);
			return m ? (v && m.push(String.fromCharCode.apply(String, g.slice(0, v))), m.join("")) : String
				.fromCharCode.apply(String, g.slice(0, v))
		}, s.write = function(l, c, d) {
			for (var f = d, m, g, v = 0; v < l.length; ++v) m = l.charCodeAt(v), m < 128 ? c[d++] = m : m <
				2048 ? (c[d++] = m >> 6 | 192, c[d++] = m & 63 | 128) : (m & 64512) === 55296 && ((g = l
					.charCodeAt(v + 1)) & 64512) === 56320 ? (m = 65536 + ((m & 1023) << 10) + (g & 1023),
					++v, c[d++] = m >> 18 | 240, c[d++] = m >> 12 & 63 | 128, c[d++] = m >> 6 & 63 | 128, c[
						d++] = m & 63 | 128) : (c[d++] = m >> 12 | 224, c[d++] = m >> 6 & 63 | 128, c[d++] =
					m & 63 | 128);
			return d - f
		}
	}(utf8$1)), utf8$1
}
var pool_1$1, hasRequiredPool$1;

function requirePool$1() {
	if (hasRequiredPool$1) return pool_1$1;
	hasRequiredPool$1 = 1, pool_1$1 = o;

	function o(s, a, l) {
		var c = l || 8192,
			d = c >>> 1,
			f = null,
			m = c;
		return function(v) {
			if (v < 1 || v > d) return s(v);
			m + v > c && (f = s(c), m = 0);
			var y = a.call(f, m, m += v);
			return m & 7 && (m = (m | 7) + 1), y
		}
	}
	return pool_1$1
}
var longbits$1, hasRequiredLongbits$1;

function requireLongbits$1() {
	if (hasRequiredLongbits$1) return longbits$1;
	hasRequiredLongbits$1 = 1, longbits$1 = s;
	var o = requireMinimal$1();

	function s(d, f) {
		this.lo = d >>> 0, this.hi = f >>> 0
	}
	var a = s.zero = new s(0, 0);
	a.toNumber = function() {
		return 0
	}, a.zzEncode = a.zzDecode = function() {
		return this
	}, a.length = function() {
		return 1
	};
	var l = s.zeroHash = "\0\0\0\0\0\0\0\0";
	s.fromNumber = function(f) {
		if (f === 0) return a;
		var m = f < 0;
		m && (f = -f);
		var g = f >>> 0,
			v = (f - g) / 4294967296 >>> 0;
		return m && (v = ~v >>> 0, g = ~g >>> 0, ++g > 4294967295 && (g = 0, ++v > 4294967295 && (v = 0))), new s(g,
			v)
	}, s.from = function(f) {
		if (typeof f == "number") return s.fromNumber(f);
		if (o.isString(f))
			if (o.Long) f = o.Long.fromString(f);
			else return s.fromNumber(parseInt(f, 10));
		return f.low || f.high ? new s(f.low >>> 0, f.high >>> 0) : a
	}, s.prototype.toNumber = function(f) {
		if (!f && this.hi >>> 31) {
			var m = ~this.lo + 1 >>> 0,
				g = ~this.hi >>> 0;
			return m || (g = g + 1 >>> 0), -(m + g * 4294967296)
		}
		return this.lo + this.hi * 4294967296
	}, s.prototype.toLong = function(f) {
		return o.Long ? new o.Long(this.lo | 0, this.hi | 0, !!f) : {
			low: this.lo | 0,
			high: this.hi | 0,
			unsigned: !!f
		}
	};
	var c = String.prototype.charCodeAt;
	return s.fromHash = function(f) {
		return f === l ? a : new s((c.call(f, 0) | c.call(f, 1) << 8 | c.call(f, 2) << 16 | c.call(f, 3) << 24) >>>
			0, (c.call(f, 4) | c.call(f, 5) << 8 | c.call(f, 6) << 16 | c.call(f, 7) << 24) >>> 0)
	}, s.prototype.toHash = function() {
		return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this
			.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
	}, s.prototype.zzEncode = function() {
		var f = this.hi >> 31;
		return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ f) >>> 0, this.lo = (this.lo << 1 ^ f) >>> 0, this
	}, s.prototype.zzDecode = function() {
		var f = -(this.lo & 1);
		return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ f) >>> 0, this.hi = (this.hi >>> 1 ^ f) >>> 0, this
	}, s.prototype.length = function() {
		var f = this.lo,
			m = (this.lo >>> 28 | this.hi << 4) >>> 0,
			g = this.hi >>> 24;
		return g === 0 ? m === 0 ? f < 16384 ? f < 128 ? 1 : 2 : f < 2097152 ? 3 : 4 : m < 16384 ? m < 128 ? 5 : 6 :
			m < 2097152 ? 7 : 8 : g < 128 ? 9 : 10
	}, longbits$1
}
var hasRequiredMinimal$1;

function requireMinimal$1() {
	return hasRequiredMinimal$1 || (hasRequiredMinimal$1 = 1, function(o) {
		var s = o;
		s.asPromise = requireAspromise$1(), s.base64 = requireBase64$1(), s.EventEmitter =
			requireEventemitter$1(), s.float = requireFloat$1(), s.inquire = requireInquire$1(), s.utf8 =
			requireUtf8$1(), s.pool = requirePool$1(), s.LongBits = requireLongbits$1(), s.isNode = !!(
				typeof commonjsGlobal$1 < "u" && commonjsGlobal$1 && commonjsGlobal$1.process &&
				commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node), s.global = s
			.isNode && commonjsGlobal$1 || typeof window < "u" && window || typeof self < "u" && self ||
			minimal$1, s.emptyArray = Object.freeze ? Object.freeze([]) : [], s.emptyObject = Object.freeze ?
			Object.freeze({}) : {}, s.isInteger = Number.isInteger || function(d) {
				return typeof d == "number" && isFinite(d) && Math.floor(d) === d
			}, s.isString = function(d) {
				return typeof d == "string" || d instanceof String
			}, s.isObject = function(d) {
				return d && typeof d == "object"
			}, s.isset = s.isSet = function(d, f) {
				var m = d[f];
				return m != null && d.hasOwnProperty(f) ? typeof m != "object" || (Array.isArray(m) ? m.length :
					Object.keys(m).length) > 0 : !1
			}, s.Buffer = function() {
				try {
					var c = s.inquire("buffer").Buffer;
					return c.prototype.utf8Write ? c : null
				} catch {
					return null
				}
			}(), s._Buffer_from = null, s._Buffer_allocUnsafe = null, s.newBuffer = function(d) {
				return typeof d == "number" ? s.Buffer ? s._Buffer_allocUnsafe(d) : new s.Array(d) : s.Buffer ?
					s._Buffer_from(d) : typeof Uint8Array > "u" ? d : new Uint8Array(d)
			}, s.Array = typeof Uint8Array < "u" ? Uint8Array : Array, s.Long = s.global.dcodeIO && s.global
			.dcodeIO.Long || s.global.Long || s.inquire("long"), s.key2Re = /^true|false|0|1$/, s.key32Re =
			/^-?(?:0|[1-9][0-9]*)$/, s.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, s.longToHash =
			function(d) {
				return d ? s.LongBits.from(d).toHash() : s.LongBits.zeroHash
			}, s.longFromHash = function(d, f) {
				var m = s.LongBits.fromHash(d);
				return s.Long ? s.Long.fromBits(m.lo, m.hi, f) : m.toNumber(!!f)
			};

		function a(c, d, f) {
			for (var m = Object.keys(d), g = 0; g < m.length; ++g)(c[m[g]] === void 0 || !f) && (c[m[g]] = d[m[
				g]]);
			return c
		}
		s.merge = a, s.lcFirst = function(d) {
			return d.charAt(0).toLowerCase() + d.substring(1)
		};

		function l(c) {
			function d(f, m) {
				if (!(this instanceof d)) return new d(f, m);
				Object.defineProperty(this, "message", {
					get: function() {
						return f
					}
				}), Error.captureStackTrace ? Error.captureStackTrace(this, d) : Object.defineProperty(this,
					"stack", {
						value: new Error().stack || ""
					}), m && a(this, m)
			}
			return d.prototype = Object.create(Error.prototype, {
				constructor: {
					value: d,
					writable: !0,
					enumerable: !1,
					configurable: !0
				},
				name: {
					get: function() {
						return c
					},
					set: void 0,
					enumerable: !1,
					configurable: !0
				},
				toString: {
					value: function() {
						return this.name + ": " + this.message
					},
					writable: !0,
					enumerable: !1,
					configurable: !0
				}
			}), d
		}
		s.newError = l, s.ProtocolError = l("ProtocolError"), s.oneOfGetter = function(d) {
			for (var f = {}, m = 0; m < d.length; ++m) f[d[m]] = 1;
			return function() {
				for (var g = Object.keys(this), v = g.length - 1; v > -1; --v)
					if (f[g[v]] === 1 && this[g[v]] !== void 0 && this[g[v]] !== null) return g[v]
			}
		}, s.oneOfSetter = function(d) {
			return function(f) {
				for (var m = 0; m < d.length; ++m) d[m] !== f && delete this[d[m]]
			}
		}, s.toJSONOptions = {
			longs: String,
			enums: String,
			bytes: String,
			json: !0
		}, s._configure = function() {
			var c = s.Buffer;
			if (!c) {
				s._Buffer_from = s._Buffer_allocUnsafe = null;
				return
			}
			s._Buffer_from = c.from !== Uint8Array.from && c.from || function(f, m) {
				return new c(f, m)
			}, s._Buffer_allocUnsafe = c.allocUnsafe || function(f) {
				return new c(f)
			}
		}
	}(minimal$1)), minimal$1
}
var writer$1, hasRequiredWriter$1;

function requireWriter$1() {
	if (hasRequiredWriter$1) return writer$1;
	hasRequiredWriter$1 = 1, writer$1 = g;
	var o = requireMinimal$1(),
		s, a = o.LongBits,
		l = o.base64,
		c = o.utf8;

	function d(T, A, k) {
		this.fn = T, this.len = A, this.next = void 0, this.val = k
	}

	function f() {}

	function m(T) {
		this.head = T.head, this.tail = T.tail, this.len = T.len, this.next = T.states
	}

	function g() {
		this.len = 0, this.head = new d(f, 0, 0), this.tail = this.head, this.states = null
	}
	var v = function() {
		return o.Buffer ? function() {
			return (g.create = function() {
				return new s
			})()
		} : function() {
			return new g
		}
	};
	g.create = v(), g.alloc = function(A) {
		return new o.Array(A)
	}, o.Array !== Array && (g.alloc = o.pool(g.alloc, o.Array.prototype.subarray)), g.prototype._push = function(A,
		k, M) {
		return this.tail = this.tail.next = new d(A, k, M), this.len += k, this
	};

	function y(T, A, k) {
		A[k] = T & 255
	}

	function b(T, A, k) {
		for (; T > 127;) A[k++] = T & 127 | 128, T >>>= 7;
		A[k] = T
	}

	function C(T, A) {
		this.len = T, this.next = void 0, this.val = A
	}
	C.prototype = Object.create(d.prototype), C.prototype.fn = b, g.prototype.uint32 = function(A) {
		return this.len += (this.tail = this.tail.next = new C((A = A >>> 0) < 128 ? 1 : A < 16384 ? 2 : A <
			2097152 ? 3 : A < 268435456 ? 4 : 5, A)).len, this
	}, g.prototype.int32 = function(A) {
		return A < 0 ? this._push(_, 10, a.fromNumber(A)) : this.uint32(A)
	}, g.prototype.sint32 = function(A) {
		return this.uint32((A << 1 ^ A >> 31) >>> 0)
	};

	function _(T, A, k) {
		for (; T.hi;) A[k++] = T.lo & 127 | 128, T.lo = (T.lo >>> 7 | T.hi << 25) >>> 0, T.hi >>>= 7;
		for (; T.lo > 127;) A[k++] = T.lo & 127 | 128, T.lo = T.lo >>> 7;
		A[k++] = T.lo
	}
	g.prototype.uint64 = function(A) {
		var k = a.from(A);
		return this._push(_, k.length(), k)
	}, g.prototype.int64 = g.prototype.uint64, g.prototype.sint64 = function(A) {
		var k = a.from(A).zzEncode();
		return this._push(_, k.length(), k)
	}, g.prototype.bool = function(A) {
		return this._push(y, 1, A ? 1 : 0)
	};

	function S(T, A, k) {
		A[k] = T & 255, A[k + 1] = T >>> 8 & 255, A[k + 2] = T >>> 16 & 255, A[k + 3] = T >>> 24
	}
	g.prototype.fixed32 = function(A) {
		return this._push(S, 4, A >>> 0)
	}, g.prototype.sfixed32 = g.prototype.fixed32, g.prototype.fixed64 = function(A) {
		var k = a.from(A);
		return this._push(S, 4, k.lo)._push(S, 4, k.hi)
	}, g.prototype.sfixed64 = g.prototype.fixed64, g.prototype.float = function(A) {
		return this._push(o.float.writeFloatLE, 4, A)
	}, g.prototype.double = function(A) {
		return this._push(o.float.writeDoubleLE, 8, A)
	};
	var w = o.Array.prototype.set ? function(A, k, M) {
		k.set(A, M)
	} : function(A, k, M) {
		for (var D = 0; D < A.length; ++D) k[M + D] = A[D]
	};
	return g.prototype.bytes = function(A) {
		var k = A.length >>> 0;
		if (!k) return this._push(y, 1, 0);
		if (o.isString(A)) {
			var M = g.alloc(k = l.length(A));
			l.decode(A, M, 0), A = M
		}
		return this.uint32(k)._push(w, k, A)
	}, g.prototype.string = function(A) {
		var k = c.length(A);
		return k ? this.uint32(k)._push(c.write, k, A) : this._push(y, 1, 0)
	}, g.prototype.fork = function() {
		return this.states = new m(this), this.head = this.tail = new d(f, 0, 0), this.len = 0, this
	}, g.prototype.reset = function() {
		return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states
			.len, this.states = this.states.next) : (this.head = this.tail = new d(f, 0, 0), this.len = 0), this
	}, g.prototype.ldelim = function() {
		var A = this.head,
			k = this.tail,
			M = this.len;
		return this.reset().uint32(M), M && (this.tail.next = A.next, this.tail = k, this.len += M), this
	}, g.prototype.finish = function() {
		for (var A = this.head.next, k = this.constructor.alloc(this.len), M = 0; A;) A.fn(A.val, k, M), M += A.len,
			A = A.next;
		return k
	}, g._configure = function(T) {
		s = T, g.create = v(), s._configure()
	}, writer$1
}
var writer_buffer$1, hasRequiredWriter_buffer$1;

function requireWriter_buffer$1() {
	if (hasRequiredWriter_buffer$1) return writer_buffer$1;
	hasRequiredWriter_buffer$1 = 1, writer_buffer$1 = a;
	var o = requireWriter$1();
	(a.prototype = Object.create(o.prototype)).constructor = a;
	var s = requireMinimal$1();

	function a() {
		o.call(this)
	}
	a._configure = function() {
		a.alloc = s._Buffer_allocUnsafe, a.writeBytesBuffer = s.Buffer && s.Buffer
			.prototype instanceof Uint8Array && s.Buffer.prototype.set.name === "set" ? function(d, f, m) {
				f.set(d, m)
			} : function(d, f, m) {
				if (d.copy) d.copy(f, m, 0, d.length);
				else
					for (var g = 0; g < d.length;) f[m++] = d[g++]
			}
	}, a.prototype.bytes = function(d) {
		s.isString(d) && (d = s._Buffer_from(d, "base64"));
		var f = d.length >>> 0;
		return this.uint32(f), f && this._push(a.writeBytesBuffer, f, d), this
	};

	function l(c, d, f) {
		c.length < 40 ? s.utf8.write(c, d, f) : d.utf8Write ? d.utf8Write(c, f) : d.write(c, f)
	}
	return a.prototype.string = function(d) {
		var f = s.Buffer.byteLength(d);
		return this.uint32(f), f && this._push(l, f, d), this
	}, a._configure(), writer_buffer$1
}
var reader$1, hasRequiredReader$1;

function requireReader$1() {
	if (hasRequiredReader$1) return reader$1;
	hasRequiredReader$1 = 1, reader$1 = d;
	var o = requireMinimal$1(),
		s, a = o.LongBits,
		l = o.utf8;

	function c(b, C) {
		return RangeError("index out of range: " + b.pos + " + " + (C || 1) + " > " + b.len)
	}

	function d(b) {
		this.buf = b, this.pos = 0, this.len = b.length
	}
	var f = typeof Uint8Array < "u" ? function(C) {
			if (C instanceof Uint8Array || Array.isArray(C)) return new d(C);
			throw Error("illegal buffer")
		} : function(C) {
			if (Array.isArray(C)) return new d(C);
			throw Error("illegal buffer")
		},
		m = function() {
			return o.Buffer ? function(_) {
				return (d.create = function(w) {
					return o.Buffer.isBuffer(w) ? new s(w) : f(w)
				})(_)
			} : f
		};
	d.create = m(), d.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, d.prototype.uint32 =
		function() {
			var C = 4294967295;
			return function() {
				if (C = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (C = (C | (this.buf[this
						.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (C = (C | (this.buf[this.pos] &
						127) << 14) >>> 0, this.buf[this.pos++] < 128) || (C = (C | (this.buf[this.pos] & 127) <<
						21) >>> 0, this.buf[this.pos++] < 128) || (C = (C | (this.buf[this.pos] & 15) << 28) >>> 0,
						this.buf[this.pos++] < 128)) return C;
				if ((this.pos += 5) > this.len) throw this.pos = this.len, c(this, 10);
				return C
			}
		}(), d.prototype.int32 = function() {
			return this.uint32() | 0
		}, d.prototype.sint32 = function() {
			var C = this.uint32();
			return C >>> 1 ^ -(C & 1) | 0
		};

	function g() {
		var b = new a(0, 0),
			C = 0;
		if (this.len - this.pos > 4) {
			for (; C < 4; ++C)
				if (b.lo = (b.lo | (this.buf[this.pos] & 127) << C * 7) >>> 0, this.buf[this.pos++] < 128) return b;
			if (b.lo = (b.lo | (this.buf[this.pos] & 127) << 28) >>> 0, b.hi = (b.hi | (this.buf[this.pos] & 127) >>
				4) >>> 0, this.buf[this.pos++] < 128) return b;
			C = 0
		} else {
			for (; C < 3; ++C) {
				if (this.pos >= this.len) throw c(this);
				if (b.lo = (b.lo | (this.buf[this.pos] & 127) << C * 7) >>> 0, this.buf[this.pos++] < 128) return b
			}
			return b.lo = (b.lo | (this.buf[this.pos++] & 127) << C * 7) >>> 0, b
		}
		if (this.len - this.pos > 4) {
			for (; C < 5; ++C)
				if (b.hi = (b.hi | (this.buf[this.pos] & 127) << C * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return b
		} else
			for (; C < 5; ++C) {
				if (this.pos >= this.len) throw c(this);
				if (b.hi = (b.hi | (this.buf[this.pos] & 127) << C * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return b
			}
		throw Error("invalid varint encoding")
	}
	d.prototype.bool = function() {
		return this.uint32() !== 0
	};

	function v(b, C) {
		return (b[C - 4] | b[C - 3] << 8 | b[C - 2] << 16 | b[C - 1] << 24) >>> 0
	}
	d.prototype.fixed32 = function() {
		if (this.pos + 4 > this.len) throw c(this, 4);
		return v(this.buf, this.pos += 4)
	}, d.prototype.sfixed32 = function() {
		if (this.pos + 4 > this.len) throw c(this, 4);
		return v(this.buf, this.pos += 4) | 0
	};

	function y() {
		if (this.pos + 8 > this.len) throw c(this, 8);
		return new a(v(this.buf, this.pos += 4), v(this.buf, this.pos += 4))
	}
	return d.prototype.float = function() {
		if (this.pos + 4 > this.len) throw c(this, 4);
		var C = o.float.readFloatLE(this.buf, this.pos);
		return this.pos += 4, C
	}, d.prototype.double = function() {
		if (this.pos + 8 > this.len) throw c(this, 4);
		var C = o.float.readDoubleLE(this.buf, this.pos);
		return this.pos += 8, C
	}, d.prototype.bytes = function() {
		var C = this.uint32(),
			_ = this.pos,
			S = this.pos + C;
		if (S > this.len) throw c(this, C);
		if (this.pos += C, Array.isArray(this.buf)) return this.buf.slice(_, S);
		if (_ === S) {
			var w = o.Buffer;
			return w ? w.alloc(0) : new this.buf.constructor(0)
		}
		return this._slice.call(this.buf, _, S)
	}, d.prototype.string = function() {
		var C = this.bytes();
		return l.read(C, 0, C.length)
	}, d.prototype.skip = function(C) {
		if (typeof C == "number") {
			if (this.pos + C > this.len) throw c(this, C);
			this.pos += C
		} else
			do
				if (this.pos >= this.len) throw c(this); while (this.buf[this.pos++] & 128);
		return this
	}, d.prototype.skipType = function(b) {
		switch (b) {
			case 0:
				this.skip();
				break;
			case 1:
				this.skip(8);
				break;
			case 2:
				this.skip(this.uint32());
				break;
			case 3:
				for (;
					(b = this.uint32() & 7) !== 4;) this.skipType(b);
				break;
			case 5:
				this.skip(4);
				break;
			default:
				throw Error("invalid wire type " + b + " at offset " + this.pos)
		}
		return this
	}, d._configure = function(b) {
		s = b, d.create = m(), s._configure();
		var C = o.Long ? "toLong" : "toNumber";
		o.merge(d.prototype, {
			int64: function() {
				return g.call(this)[C](!1)
			},
			uint64: function() {
				return g.call(this)[C](!0)
			},
			sint64: function() {
				return g.call(this).zzDecode()[C](!1)
			},
			fixed64: function() {
				return y.call(this)[C](!0)
			},
			sfixed64: function() {
				return y.call(this)[C](!1)
			}
		})
	}, reader$1
}
var reader_buffer$1, hasRequiredReader_buffer$1;

function requireReader_buffer$1() {
	if (hasRequiredReader_buffer$1) return reader_buffer$1;
	hasRequiredReader_buffer$1 = 1, reader_buffer$1 = a;
	var o = requireReader$1();
	(a.prototype = Object.create(o.prototype)).constructor = a;
	var s = requireMinimal$1();

	function a(l) {
		o.call(this, l)
	}
	return a._configure = function() {
		s.Buffer && (a.prototype._slice = s.Buffer.prototype.slice)
	}, a.prototype.string = function() {
		var c = this.uint32();
		return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + c, this.len)) : this
			.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + c, this.len))
	}, a._configure(), reader_buffer$1
}
var rpc$1 = {},
	service$3, hasRequiredService$3;

function requireService$3() {
	if (hasRequiredService$3) return service$3;
	hasRequiredService$3 = 1, service$3 = s;
	var o = requireMinimal$1();
	(s.prototype = Object.create(o.EventEmitter.prototype)).constructor = s;

	function s(a, l, c) {
		if (typeof a != "function") throw TypeError("rpcImpl must be a function");
		o.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!l, this.responseDelimited = !!c
	}
	return s.prototype.rpcCall = function a(l, c, d, f, m) {
		if (!f) throw TypeError("request must be specified");
		var g = this;
		if (!m) return o.asPromise(a, g, l, c, d, f);
		if (!g.rpcImpl) {
			setTimeout(function() {
				m(Error("already ended"))
			}, 0);
			return
		}
		try {
			return g.rpcImpl(l, c[g.requestDelimited ? "encodeDelimited" : "encode"](f).finish(), function(y, b) {
				if (y) return g.emit("error", y, l), m(y);
				if (b === null) {
					g.end(!0);
					return
				}
				if (!(b instanceof d)) try {
					b = d[g.responseDelimited ? "decodeDelimited" : "decode"](b)
				} catch (C) {
					return g.emit("error", C, l), m(C)
				}
				return g.emit("data", b, l), m(null, b)
			})
		} catch (v) {
			g.emit("error", v, l), setTimeout(function() {
				m(v)
			}, 0);
			return
		}
	}, s.prototype.end = function(l) {
		return this.rpcImpl && (l || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()),
			this
	}, service$3
}
var hasRequiredRpc$1;

function requireRpc$1() {
	return hasRequiredRpc$1 || (hasRequiredRpc$1 = 1, function(o) {
		var s = o;
		s.Service = requireService$3()
	}(rpc$1)), rpc$1
}
var roots$1, hasRequiredRoots$1;

function requireRoots$1() {
	return hasRequiredRoots$1 || (hasRequiredRoots$1 = 1, roots$1 = {}), roots$1
}
var hasRequiredIndexMinimal$1;

function requireIndexMinimal$1() {
	return hasRequiredIndexMinimal$1 || (hasRequiredIndexMinimal$1 = 1, function(o) {
		var s = o;
		s.build = "minimal", s.Writer = requireWriter$1(), s.BufferWriter = requireWriter_buffer$1(), s.Reader =
			requireReader$1(), s.BufferReader = requireReader_buffer$1(), s.util = requireMinimal$1(), s.rpc =
			requireRpc$1(), s.roots = requireRoots$1(), s.configure = a;

		function a() {
			s.util._configure(), s.Writer._configure(s.BufferWriter), s.Reader._configure(s.BufferReader)
		}
		a()
	}(indexMinimal$1)), indexMinimal$1
}
var types$1 = {},
	util$1 = {
		exports: {}
	},
	codegen_1$1, hasRequiredCodegen$1;

function requireCodegen$1() {
	if (hasRequiredCodegen$1) return codegen_1$1;
	hasRequiredCodegen$1 = 1, codegen_1$1 = o;

	function o(s, a) {
		typeof s == "string" && (a = s, s = void 0);
		var l = [];

		function c(f) {
			if (typeof f != "string") {
				var m = d();
				if (o.verbose && console.log("codegen: " + m), m = "return " + m, f) {
					for (var g = Object.keys(f), v = new Array(g.length + 1), y = new Array(g.length), b = 0; b < g
						.length;) v[b] = g[b], y[b] = f[g[b++]];
					return v[b] = m, Function.apply(null, v).apply(null, y)
				}
				return Function(m)()
			}
			for (var C = new Array(arguments.length - 1), _ = 0; _ < C.length;) C[_] = arguments[++_];
			if (_ = 0, f = f.replace(/%([%dfijs])/g, function(w, T) {
					var A = C[_++];
					switch (T) {
						case "d":
						case "f":
							return String(Number(A));
						case "i":
							return String(Math.floor(A));
						case "j":
							return JSON.stringify(A);
						case "s":
							return String(A)
					}
					return "%"
				}), _ !== C.length) throw Error("parameter count mismatch");
			return l.push(f), c
		}

		function d(f) {
			return "function " + (f || a || "") + "(" + (s && s.join(",") || "") + `){
  ` + l.join(`
  `) + `
}`
		}
		return c.toString = d, c
	}
	return o.verbose = !1, codegen_1$1
}
var fetch_1$1, hasRequiredFetch$1;

function requireFetch$1() {
	if (hasRequiredFetch$1) return fetch_1$1;
	hasRequiredFetch$1 = 1, fetch_1$1 = l;
	var o = requireAspromise$1(),
		s = requireInquire$1(),
		a = s("fs");

	function l(c, d, f) {
		return typeof d == "function" ? (f = d, d = {}) : d || (d = {}), f ? !d.xhr && a && a.readFile ? a.readFile(c,
			function(g, v) {
				return g && typeof XMLHttpRequest < "u" ? l.xhr(c, d, f) : g ? f(g) : f(null, d.binary ? v : v
					.toString("utf8"))
			}) : l.xhr(c, d, f) : o(l, this, c, d)
	}
	return l.xhr = function(d, f, m) {
		var g = new XMLHttpRequest;
		g.onreadystatechange = function() {
			if (g.readyState === 4) {
				if (g.status !== 0 && g.status !== 200) return m(Error("status " + g.status));
				if (f.binary) {
					var y = g.response;
					if (!y) {
						y = [];
						for (var b = 0; b < g.responseText.length; ++b) y.push(g.responseText.charCodeAt(b) &
							255)
					}
					return m(null, typeof Uint8Array < "u" ? new Uint8Array(y) : y)
				}
				return m(null, g.responseText)
			}
		}, f.binary && ("overrideMimeType" in g && g.overrideMimeType("text/plain; charset=x-user-defined"), g
			.responseType = "arraybuffer"), g.open("GET", d), g.send()
	}, fetch_1$1
}
var path$1 = {},
	hasRequiredPath$1;

function requirePath$1() {
	return hasRequiredPath$1 || (hasRequiredPath$1 = 1, function(o) {
		var s = o,
			a = s.isAbsolute = function(d) {
				return /^(?:\/|\w+:)/.test(d)
			},
			l = s.normalize = function(d) {
				d = d.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
				var f = d.split("/"),
					m = a(d),
					g = "";
				m && (g = f.shift() + "/");
				for (var v = 0; v < f.length;) f[v] === ".." ? v > 0 && f[v - 1] !== ".." ? f.splice(--v, 2) :
					m ? f.splice(v, 1) : ++v : f[v] === "." ? f.splice(v, 1) : ++v;
				return g + f.join("/")
			};
		s.resolve = function(d, f, m) {
			return m || (f = l(f)), a(f) ? f : (m || (d = l(d)), (d = d.replace(/(?:\/|^)[^/]+$/, ""))
				.length ? l(d + "/" + f) : f)
		}
	}(path$1)), path$1
}
var namespace$1, hasRequiredNamespace$1;

function requireNamespace$1() {
	if (hasRequiredNamespace$1) return namespace$1;
	hasRequiredNamespace$1 = 1, namespace$1 = g;
	var o = requireObject$1();
	((g.prototype = Object.create(o.prototype)).constructor = g).className = "Namespace";
	var s = requireField$1(),
		a = requireUtil$1(),
		l = requireOneof$1(),
		c, d, f;
	g.fromJSON = function(b, C) {
		return new g(b, C.options).addJSON(C.nested)
	};

	function m(y, b) {
		if (y && y.length) {
			for (var C = {}, _ = 0; _ < y.length; ++_) C[y[_].name] = y[_].toJSON(b);
			return C
		}
	}
	g.arrayToJSON = m, g.isReservedId = function(b, C) {
		if (b) {
			for (var _ = 0; _ < b.length; ++_)
				if (typeof b[_] != "string" && b[_][0] <= C && b[_][1] > C) return !0
		}
		return !1
	}, g.isReservedName = function(b, C) {
		if (b) {
			for (var _ = 0; _ < b.length; ++_)
				if (b[_] === C) return !0
		}
		return !1
	};

	function g(y, b) {
		o.call(this, y, b), this.nested = void 0, this._nestedArray = null, this._lookupCache = {}, this
			._needsRecursiveFeatureResolution = !0
	}

	function v(y) {
		y._nestedArray = null, y._lookupCache = {};
		for (var b = y; b = b.parent;) b._lookupCache = {};
		return y
	}
	return Object.defineProperty(g.prototype, "nestedArray", {
		get: function() {
			return this._nestedArray || (this._nestedArray = a.toArray(this.nested))
		}
	}), g.prototype.toJSON = function(b) {
		return a.toObject(["options", this.options, "nested", m(this.nestedArray, b)])
	}, g.prototype.addJSON = function(b) {
		var C = this;
		if (b)
			for (var _ = Object.keys(b), S = 0, w; S < _.length; ++S) w = b[_[S]], C.add((w.fields !== void 0 ? c
				.fromJSON : w.values !== void 0 ? f.fromJSON : w.methods !== void 0 ? d.fromJSON : w.id !==
				void 0 ? s.fromJSON : g.fromJSON)(_[S], w));
		return this
	}, g.prototype.get = function(b) {
		return this.nested && this.nested[b] || null
	}, g.prototype.getEnum = function(b) {
		if (this.nested && this.nested[b] instanceof f) return this.nested[b].values;
		throw Error("no such enum: " + b)
	}, g.prototype.add = function(b) {
		if (!(b instanceof s && b.extend !== void 0 || b instanceof c || b instanceof l || b instanceof f ||
				b instanceof d || b instanceof g)) throw TypeError("object must be a valid nested object");
		if (!this.nested) this.nested = {};
		else {
			var C = this.get(b.name);
			if (C)
				if (C instanceof g && b instanceof g && !(C instanceof c || C instanceof d)) {
					for (var _ = C.nestedArray, S = 0; S < _.length; ++S) b.add(_[S]);
					this.remove(C), this.nested || (this.nested = {}), b.setOptions(C.options, !0)
				} else throw Error("duplicate name '" + b.name + "' in " + this)
		}
		this.nested[b.name] = b, this instanceof c || this instanceof d || this instanceof f || this instanceof s ||
			b._edition || (b._edition = b._defaultEdition), this._needsRecursiveFeatureResolution = !0;
		for (var w = this; w = w.parent;) w._needsRecursiveFeatureResolution = !0;
		return b.onAdd(this), v(this)
	}, g.prototype.remove = function(b) {
		if (!(b instanceof o)) throw TypeError("object must be a ReflectionObject");
		if (b.parent !== this) throw Error(b + " is not a member of " + this);
		return delete this.nested[b.name], Object.keys(this.nested).length || (this.nested = void 0), b.onRemove(
			this), v(this)
	}, g.prototype.define = function(b, C) {
		if (a.isString(b)) b = b.split(".");
		else if (!Array.isArray(b)) throw TypeError("illegal path");
		if (b && b.length && b[0] === "") throw Error("path must be relative");
		for (var _ = this; b.length > 0;) {
			var S = b.shift();
			if (_.nested && _.nested[S]) {
				if (_ = _.nested[S], !(_ instanceof g)) throw Error("path conflicts with non-namespace objects")
			} else _.add(_ = new g(S))
		}
		return C && _.addJSON(C), _
	}, g.prototype.resolveAll = function() {
		var b = this.nestedArray,
			C = 0;
		for (this.resolve(); C < b.length;) b[C] instanceof g ? b[C++].resolveAll() : b[C++].resolve();
		return this
	}, g.prototype._resolveFeaturesRecursive = function(b) {
		return this._needsRecursiveFeatureResolution ? (this._needsRecursiveFeatureResolution = !1, b = this
			._edition || b, o.prototype._resolveFeaturesRecursive.call(this, b), this.nestedArray.forEach(C => {
				C._resolveFeaturesRecursive(b)
			}), this) : this
	}, g.prototype.lookup = function(b, C, _) {
		if (typeof C == "boolean" ? (_ = C, C = void 0) : C && !Array.isArray(C) && (C = [C]), a.isString(b) && b
			.length) {
			if (b === ".") return this.root;
			b = b.split(".")
		} else if (!b.length) return this;
		if (b[0] === "") return this.root.lookup(b.slice(1), C);
		var S = this._lookupImpl(b);
		return S && (!C || C.indexOf(S.constructor) > -1) ? S : this.parent === null || _ ? null : this.parent
			.lookup(b, C)
	}, g.prototype._lookupImpl = function(b) {
		var C = b.join(".");
		if (Object.prototype.hasOwnProperty.call(this._lookupCache, C)) return this._lookupCache[C];
		var _ = this.get(b[0]),
			S = null;
		if (_)(b.length === 1 || _ instanceof g && (_ = _._lookupImpl(b.slice(1)))) && (S = _);
		else
			for (var w = 0; w < this.nestedArray.length; ++w) this._nestedArray[w] instanceof g && (_ = this
				._nestedArray[w]._lookupImpl(b)) && (S = _);
		return this._lookupCache[C] = S, S
	}, g.prototype.lookupType = function(b) {
		var C = this.lookup(b, [c]);
		if (!C) throw Error("no such type: " + b);
		return C
	}, g.prototype.lookupEnum = function(b) {
		var C = this.lookup(b, [f]);
		if (!C) throw Error("no such Enum '" + b + "' in " + this);
		return C
	}, g.prototype.lookupTypeOrEnum = function(b) {
		var C = this.lookup(b, [c, f]);
		if (!C) throw Error("no such Type or Enum '" + b + "' in " + this);
		return C
	}, g.prototype.lookupService = function(b) {
		var C = this.lookup(b, [d]);
		if (!C) throw Error("no such Service '" + b + "' in " + this);
		return C
	}, g._configure = function(y, b, C) {
		c = y, d = b, f = C
	}, namespace$1
}
var mapfield$1, hasRequiredMapfield$1;

function requireMapfield$1() {
	if (hasRequiredMapfield$1) return mapfield$1;
	hasRequiredMapfield$1 = 1, mapfield$1 = l;
	var o = requireField$1();
	((l.prototype = Object.create(o.prototype)).constructor = l).className = "MapField";
	var s = requireTypes$1(),
		a = requireUtil$1();

	function l(c, d, f, m, g, v) {
		if (o.call(this, c, d, m, void 0, void 0, g, v), !a.isString(f)) throw TypeError("keyType must be a string");
		this.keyType = f, this.resolvedKeyType = null, this.map = !0
	}
	return l.fromJSON = function(d, f) {
		return new l(d, f.id, f.keyType, f.type, f.options, f.comment)
	}, l.prototype.toJSON = function(d) {
		var f = d ? !!d.keepComments : !1;
		return a.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend,
			"options", this.options, "comment", f ? this.comment : void 0
		])
	}, l.prototype.resolve = function() {
		if (this.resolved) return this;
		if (s.mapKey[this.keyType] === void 0) throw Error("invalid key type: " + this.keyType);
		return o.prototype.resolve.call(this)
	}, l.d = function(d, f, m) {
		return typeof m == "function" ? m = a.decorateType(m).name : m && typeof m == "object" && (m = a
				.decorateEnum(m).name),
			function(v, y) {
				a.decorateType(v.constructor).add(new l(y, d, f, m))
			}
	}, mapfield$1
}
var method$1, hasRequiredMethod$1;

function requireMethod$1() {
	if (hasRequiredMethod$1) return method$1;
	hasRequiredMethod$1 = 1, method$1 = a;
	var o = requireObject$1();
	((a.prototype = Object.create(o.prototype)).constructor = a).className = "Method";
	var s = requireUtil$1();

	function a(l, c, d, f, m, g, v, y, b) {
		if (s.isObject(m) ? (v = m, m = g = void 0) : s.isObject(g) && (v = g, g = void 0), !(c === void 0 || s
				.isString(c))) throw TypeError("type must be a string");
		if (!s.isString(d)) throw TypeError("requestType must be a string");
		if (!s.isString(f)) throw TypeError("responseType must be a string");
		o.call(this, l, v), this.type = c || "rpc", this.requestType = d, this.requestStream = m ? !0 : void 0, this
			.responseType = f, this.responseStream = g ? !0 : void 0, this.resolvedRequestType = null, this
			.resolvedResponseType = null, this.comment = y, this.parsedOptions = b
	}
	return a.fromJSON = function(c, d) {
		return new a(c, d.type, d.requestType, d.responseType, d.requestStream, d.responseStream, d.options, d
			.comment, d.parsedOptions)
	}, a.prototype.toJSON = function(c) {
		var d = c ? !!c.keepComments : !1;
		return s.toObject(["type", this.type !== "rpc" && this.type || void 0, "requestType", this.requestType,
			"requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this
			.responseStream, "options", this.options, "comment", d ? this.comment : void 0, "parsedOptions",
			this.parsedOptions
		])
	}, a.prototype.resolve = function() {
		return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this
			.resolvedResponseType = this.parent.lookupType(this.responseType), o.prototype.resolve.call(this))
	}, method$1
}
var service$2, hasRequiredService$2;

function requireService$2() {
	if (hasRequiredService$2) return service$2;
	hasRequiredService$2 = 1, service$2 = c;
	var o = requireNamespace$1();
	((c.prototype = Object.create(o.prototype)).constructor = c).className = "Service";
	var s = requireMethod$1(),
		a = requireUtil$1(),
		l = requireRpc$1();

	function c(f, m) {
		o.call(this, f, m), this.methods = {}, this._methodsArray = null
	}
	c.fromJSON = function(m, g) {
		var v = new c(m, g.options);
		if (g.methods)
			for (var y = Object.keys(g.methods), b = 0; b < y.length; ++b) v.add(s.fromJSON(y[b], g.methods[y[b]]));
		return g.nested && v.addJSON(g.nested), g.edition && (v._edition = g.edition), v.comment = g.comment, v
			._defaultEdition = "proto3", v
	}, c.prototype.toJSON = function(m) {
		var g = o.prototype.toJSON.call(this, m),
			v = m ? !!m.keepComments : !1;
		return a.toObject(["edition", this._editionToJSON(), "options", g && g.options || void 0, "methods", o
			.arrayToJSON(this.methodsArray, m) || {}, "nested", g && g.nested || void 0, "comment", v ? this
			.comment : void 0
		])
	}, Object.defineProperty(c.prototype, "methodsArray", {
		get: function() {
			return this._methodsArray || (this._methodsArray = a.toArray(this.methods))
		}
	});

	function d(f) {
		return f._methodsArray = null, f
	}
	return c.prototype.get = function(m) {
		return this.methods[m] || o.prototype.get.call(this, m)
	}, c.prototype.resolveAll = function() {
		o.prototype.resolve.call(this);
		for (var m = this.methodsArray, g = 0; g < m.length; ++g) m[g].resolve();
		return this
	}, c.prototype._resolveFeaturesRecursive = function(m) {
		return this._needsRecursiveFeatureResolution ? (m = this._edition || m, o.prototype
			._resolveFeaturesRecursive.call(this, m), this.methodsArray.forEach(g => {
				g._resolveFeaturesRecursive(m)
			}), this) : this
	}, c.prototype.add = function(m) {
		if (this.get(m.name)) throw Error("duplicate name '" + m.name + "' in " + this);
		return m instanceof s ? (this.methods[m.name] = m, m.parent = this, d(this)) : o.prototype.add.call(this, m)
	}, c.prototype.remove = function(m) {
		if (m instanceof s) {
			if (this.methods[m.name] !== m) throw Error(m + " is not a member of " + this);
			return delete this.methods[m.name], m.parent = null, d(this)
		}
		return o.prototype.remove.call(this, m)
	}, c.prototype.create = function(m, g, v) {
		for (var y = new l.Service(m, g, v), b = 0, C; b < this.methodsArray.length; ++b) {
			var _ = a.lcFirst((C = this._methodsArray[b]).resolve().name).replace(/[^$\w_]/g, "");
			y[_] = a.codegen(["r", "c"], a.isReserved(_) ? _ + "_" : _)("return this.rpcCall(m,q,s,r,c)")({
				m: C,
				q: C.resolvedRequestType.ctor,
				s: C.resolvedResponseType.ctor
			})
		}
		return y
	}, service$2
}
var message$1, hasRequiredMessage$1;

function requireMessage$1() {
	if (hasRequiredMessage$1) return message$1;
	hasRequiredMessage$1 = 1, message$1 = s;
	var o = requireMinimal$1();

	function s(a) {
		if (a)
			for (var l = Object.keys(a), c = 0; c < l.length; ++c) this[l[c]] = a[l[c]]
	}
	return s.create = function(l) {
		return this.$type.create(l)
	}, s.encode = function(l, c) {
		return this.$type.encode(l, c)
	}, s.encodeDelimited = function(l, c) {
		return this.$type.encodeDelimited(l, c)
	}, s.decode = function(l) {
		return this.$type.decode(l)
	}, s.decodeDelimited = function(l) {
		return this.$type.decodeDelimited(l)
	}, s.verify = function(l) {
		return this.$type.verify(l)
	}, s.fromObject = function(l) {
		return this.$type.fromObject(l)
	}, s.toObject = function(l, c) {
		return this.$type.toObject(l, c)
	}, s.prototype.toJSON = function() {
		return this.$type.toObject(this, o.toJSONOptions)
	}, message$1
}
var decoder_1$1, hasRequiredDecoder$1;

function requireDecoder$1() {
	if (hasRequiredDecoder$1) return decoder_1$1;
	hasRequiredDecoder$1 = 1, decoder_1$1 = c;
	var o = require_enum$1(),
		s = requireTypes$1(),
		a = requireUtil$1();

	function l(d) {
		return "missing required '" + d.name + "'"
	}

	function c(d) {
		for (var f = a.codegen(["r", "l", "e"], d.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")(
				"var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (d.fieldsArray.filter(function(C) {
					return C.map
				}).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")(
				"switch(t>>>3){"), m = 0; m < d.fieldsArray.length; ++m) {
			var g = d._fieldsArray[m].resolve(),
				v = g.resolvedType instanceof o ? "int32" : g.type,
				y = "m" + a.safeProp(g.name);
			f("case %i: {", g.id), g.map ? (f("if(%s===util.emptyObject)", y)("%s={}", y)("var c2 = r.uint32()+r.pos"),
					s.defaults[g.keyType] !== void 0 ? f("k=%j", s.defaults[g.keyType]) : f("k=null"), s.defaults[v] !==
					void 0 ? f("value=%j", s.defaults[v]) : f("value=null"), f("while(r.pos<c2){")(
						"var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", g.keyType)("case 2:"), s
					.basic[v] === void 0 ? f("value=types[%i].decode(r,r.uint32())", m) : f("value=r.%s()", v), f(
						"break")("default:")("r.skipType(tag2&7)")("break")("}")("}"), s.long[g.keyType] !== void 0 ? f(
						'%s[typeof k==="object"?util.longToHash(k):k]=value', y) : f("%s[k]=value", y)) : g.repeated ? (
					f("if(!(%s&&%s.length))", y, y)("%s=[]", y), s.packed[v] !== void 0 && f("if((t&7)===2){")(
						"var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", y, v)("}else"), s.basic[v] ===
					void 0 ? f(g.delimited ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))" :
						"%s.push(types[%i].decode(r,r.uint32()))", y, m) : f("%s.push(r.%s())", y, v)) : s.basic[v] ===
				void 0 ? f(g.delimited ? "%s=types[%i].decode(r,undefined,((t&~7)|4))" :
					"%s=types[%i].decode(r,r.uint32())", y, m) : f("%s=r.%s()", y, v), f("break")("}")
		}
		for (f("default:")("r.skipType(t&7)")("break")("}")("}"), m = 0; m < d._fieldsArray.length; ++m) {
			var b = d._fieldsArray[m];
			b.required && f("if(!m.hasOwnProperty(%j))", b.name)("throw util.ProtocolError(%j,{instance:m})", l(b))
		}
		return f("return m")
	}
	return decoder_1$1
}
var verifier_1$1, hasRequiredVerifier$1;

function requireVerifier$1() {
	if (hasRequiredVerifier$1) return verifier_1$1;
	hasRequiredVerifier$1 = 1, verifier_1$1 = d;
	var o = require_enum$1(),
		s = requireUtil$1();

	function a(f, m) {
		return f.name + ": " + m + (f.repeated && m !== "array" ? "[]" : f.map && m !== "object" ? "{k:" + f.keyType +
			"}" : "") + " expected"
	}

	function l(f, m, g, v) {
		if (m.resolvedType)
			if (m.resolvedType instanceof o) {
				f("switch(%s){", v)("default:")("return%j", a(m, "enum value"));
				for (var y = Object.keys(m.resolvedType.values), b = 0; b < y.length; ++b) f("case %i:", m.resolvedType
					.values[y[b]]);
				f("break")("}")
			} else f("{")("var e=types[%i].verify(%s);", g, v)("if(e)")("return%j+e", m.name + ".")("}");
		else switch (m.type) {
			case "int32":
			case "uint32":
			case "sint32":
			case "fixed32":
			case "sfixed32":
				f("if(!util.isInteger(%s))", v)("return%j", a(m, "integer"));
				break;
			case "int64":
			case "uint64":
			case "sint64":
			case "fixed64":
			case "sfixed64":
				f("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", v, v, v, v)(
					"return%j", a(m, "integer|Long"));
				break;
			case "float":
			case "double":
				f('if(typeof %s!=="number")', v)("return%j", a(m, "number"));
				break;
			case "bool":
				f('if(typeof %s!=="boolean")', v)("return%j", a(m, "boolean"));
				break;
			case "string":
				f("if(!util.isString(%s))", v)("return%j", a(m, "string"));
				break;
			case "bytes":
				f('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', v, v, v)("return%j", a(m, "buffer"));
				break
		}
		return f
	}

	function c(f, m, g) {
		switch (m.keyType) {
			case "int32":
			case "uint32":
			case "sint32":
			case "fixed32":
			case "sfixed32":
				f("if(!util.key32Re.test(%s))", g)("return%j", a(m, "integer key"));
				break;
			case "int64":
			case "uint64":
			case "sint64":
			case "fixed64":
			case "sfixed64":
				f("if(!util.key64Re.test(%s))", g)("return%j", a(m, "integer|Long key"));
				break;
			case "bool":
				f("if(!util.key2Re.test(%s))", g)("return%j", a(m, "boolean key"));
				break
		}
		return f
	}

	function d(f) {
		var m = s.codegen(["m"], f.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j",
			"object expected"),
			g = f.oneofsArray,
			v = {};
		g.length && m("var p={}");
		for (var y = 0; y < f.fieldsArray.length; ++y) {
			var b = f._fieldsArray[y].resolve(),
				C = "m" + s.safeProp(b.name);
			if (b.optional && m("if(%s!=null&&m.hasOwnProperty(%j)){", C, b.name), b.map) m("if(!util.isObject(%s))", C)
				("return%j", a(b, "object"))("var k=Object.keys(%s)", C)("for(var i=0;i<k.length;++i){"), c(m, b,
					"k[i]"), l(m, b, y, C + "[k[i]]")("}");
			else if (b.repeated) m("if(!Array.isArray(%s))", C)("return%j", a(b, "array"))(
				"for(var i=0;i<%s.length;++i){", C), l(m, b, y, C + "[i]")("}");
			else {
				if (b.partOf) {
					var _ = s.safeProp(b.partOf.name);
					v[b.partOf.name] === 1 && m("if(p%s===1)", _)("return%j", b.partOf.name + ": multiple values"), v[b
						.partOf.name] = 1, m("p%s=1", _)
				}
				l(m, b, y, C)
			}
			b.optional && m("}")
		}
		return m("return null")
	}
	return verifier_1$1
}
var converter$1 = {},
	hasRequiredConverter$1;

function requireConverter$1() {
	return hasRequiredConverter$1 || (hasRequiredConverter$1 = 1, function(o) {
		var s = o,
			a = require_enum$1(),
			l = requireUtil$1();

		function c(f, m, g, v) {
			var y = !1;
			if (m.resolvedType)
				if (m.resolvedType instanceof a) {
					f("switch(d%s){", v);
					for (var b = m.resolvedType.values, C = Object.keys(b), _ = 0; _ < C.length; ++_) b[C[
						_]] === m.typeDefault && !y && (f("default:")(
								'if(typeof(d%s)==="number"){m%s=d%s;break}', v, v, v), m.repeated || f("break"),
							y = !0), f("case%j:", C[_])("case %i:", b[C[_]])("m%s=%j", v, b[C[_]])("break");
					f("}")
				} else f('if(typeof d%s!=="object")', v)("throw TypeError(%j)", m.fullName +
					": object expected")("m%s=types[%i].fromObject(d%s)", v, g, v);
			else {
				var S = !1;
				switch (m.type) {
					case "double":
					case "float":
						f("m%s=Number(d%s)", v, v);
						break;
					case "uint32":
					case "fixed32":
						f("m%s=d%s>>>0", v, v);
						break;
					case "int32":
					case "sint32":
					case "sfixed32":
						f("m%s=d%s|0", v, v);
						break;
					case "uint64":
						S = !0;
					case "int64":
					case "sint64":
					case "fixed64":
					case "sfixed64":
						f("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", v, v, S)(
							'else if(typeof d%s==="string")', v)("m%s=parseInt(d%s,10)", v, v)(
							'else if(typeof d%s==="number")', v)("m%s=d%s", v, v)(
							'else if(typeof d%s==="object")', v)(
							"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", v, v, v, S ?
							"true" : "");
						break;
					case "bytes":
						f('if(typeof d%s==="string")', v)(
							"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", v, v, v
							)("else if(d%s.length >= 0)", v)("m%s=d%s", v, v);
						break;
					case "string":
						f("m%s=String(d%s)", v, v);
						break;
					case "bool":
						f("m%s=Boolean(d%s)", v, v);
						break
				}
			}
			return f
		}
		s.fromObject = function(m) {
			var g = m.fieldsArray,
				v = l.codegen(["d"], m.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
			if (!g.length) return v("return new this.ctor");
			v("var m=new this.ctor");
			for (var y = 0; y < g.length; ++y) {
				var b = g[y].resolve(),
					C = l.safeProp(b.name);
				b.map ? (v("if(d%s){", C)('if(typeof d%s!=="object")', C)("throw TypeError(%j)", b
					.fullName + ": object expected")("m%s={}", C)(
					"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", C), c(v, b, y, C +
					"[ks[i]]")("}")("}")) : b.repeated ? (v("if(d%s){", C)("if(!Array.isArray(d%s))", C)
					("throw TypeError(%j)", b.fullName + ": array expected")("m%s=[]", C)(
						"for(var i=0;i<d%s.length;++i){", C), c(v, b, y, C + "[i]")("}")("}")) : (b
					.resolvedType instanceof a || v("if(d%s!=null){", C), c(v, b, y, C), b
					.resolvedType instanceof a || v("}"))
			}
			return v("return m")
		};

		function d(f, m, g, v) {
			if (m.resolvedType) m.resolvedType instanceof a ? f(
				"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", v,
				g, v, v, g, v, v) : f("d%s=types[%i].toObject(m%s,o)", v, g, v);
			else {
				var y = !1;
				switch (m.type) {
					case "double":
					case "float":
						f("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", v, v, v, v);
						break;
					case "uint64":
						y = !0;
					case "int64":
					case "sint64":
					case "fixed64":
					case "sfixed64":
						f('if(typeof m%s==="number")', v)("d%s=o.longs===String?String(m%s):m%s", v, v, v)(
							"else")(
							"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",
							v, v, v, v, y ? "true" : "", v);
						break;
					case "bytes":
						f("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",
							v, v, v, v, v);
						break;
					default:
						f("d%s=m%s", v, v);
						break
				}
			}
			return f
		}
		s.toObject = function(m) {
			var g = m.fieldsArray.slice().sort(l.compareFieldsById);
			if (!g.length) return l.codegen()("return {}");
			for (var v = l.codegen(["m", "o"], m.name + "$toObject")("if(!o)")("o={}")("var d={}"), y = [],
					b = [], C = [], _ = 0; _ < g.length; ++_) g[_].partOf || (g[_].resolve().repeated ? y :
				g[_].map ? b : C).push(g[_]);
			if (y.length) {
				for (v("if(o.arrays||o.defaults){"), _ = 0; _ < y.length; ++_) v("d%s=[]", l.safeProp(y[_]
					.name));
				v("}")
			}
			if (b.length) {
				for (v("if(o.objects||o.defaults){"), _ = 0; _ < b.length; ++_) v("d%s={}", l.safeProp(b[_]
					.name));
				v("}")
			}
			if (C.length) {
				for (v("if(o.defaults){"), _ = 0; _ < C.length; ++_) {
					var S = C[_],
						w = l.safeProp(S.name);
					if (S.resolvedType instanceof a) v("d%s=o.enums===String?%j:%j", w, S.resolvedType
						.valuesById[S.typeDefault], S.typeDefault);
					else if (S.long) v("if(util.Long){")("var n=new util.Long(%i,%i,%j)", S.typeDefault.low,
							S.typeDefault.high, S.typeDefault.unsigned)(
							"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", w)("}else")
						("d%s=o.longs===String?%j:%i", w, S.typeDefault.toString(), S.typeDefault
						.toNumber());
					else if (S.bytes) {
						var T = "[" + Array.prototype.slice.call(S.typeDefault).join(",") + "]";
						v("if(o.bytes===String)d%s=%j", w, String.fromCharCode.apply(String, S.typeDefault))
							("else{")("d%s=%s", w, T)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", w, w)(
								"}")
					} else v("d%s=%j", w, S.typeDefault)
				}
				v("}")
			}
			var A = !1;
			for (_ = 0; _ < g.length; ++_) {
				var S = g[_],
					k = m._fieldsArray.indexOf(S),
					w = l.safeProp(S.name);
				S.map ? (A || (A = !0, v("var ks2")), v("if(m%s&&(ks2=Object.keys(m%s)).length){", w, w)(
						"d%s={}", w)("for(var j=0;j<ks2.length;++j){"), d(v, S, k, w + "[ks2[j]]")("}")) : S
					.repeated ? (v("if(m%s&&m%s.length){", w, w)("d%s=[]", w)(
						"for(var j=0;j<m%s.length;++j){", w), d(v, S, k, w + "[j]")("}")) : (v(
							"if(m%s!=null&&m.hasOwnProperty(%j)){", w, S.name), d(v, S, k, w), S.partOf &&
						v("if(o.oneofs)")("d%s=%j", l.safeProp(S.partOf.name), S.name)), v("}")
			}
			return v("return d")
		}
	}(converter$1)), converter$1
}
var wrappers$1 = {},
	hasRequiredWrappers$1;

function requireWrappers$1() {
	return hasRequiredWrappers$1 || (hasRequiredWrappers$1 = 1, function(o) {
		var s = o,
			a = requireMessage$1();
		s[".google.protobuf.Any"] = {
			fromObject: function(l) {
				if (l && l["@type"]) {
					var c = l["@type"].substring(l["@type"].lastIndexOf("/") + 1),
						d = this.lookup(c);
					if (d) {
						var f = l["@type"].charAt(0) === "." ? l["@type"].slice(1) : l["@type"];
						return f.indexOf("/") === -1 && (f = "/" + f), this.create({
							type_url: f,
							value: d.encode(d.fromObject(l)).finish()
						})
					}
				}
				return this.fromObject(l)
			},
			toObject: function(l, c) {
				var d = "type.googleapis.com/",
					f = "",
					m = "";
				if (c && c.json && l.type_url && l.value) {
					m = l.type_url.substring(l.type_url.lastIndexOf("/") + 1), f = l.type_url.substring(
						0, l.type_url.lastIndexOf("/") + 1);
					var g = this.lookup(m);
					g && (l = g.decode(l.value))
				}
				if (!(l instanceof this.ctor) && l instanceof a) {
					var v = l.$type.toObject(l, c),
						y = l.$type.fullName[0] === "." ? l.$type.fullName.slice(1) : l.$type.fullName;
					return f === "" && (f = d), m = f + y, v["@type"] = m, v
				}
				return this.toObject(l, c)
			}
		}
	}(wrappers$1)), wrappers$1
}
var type$1, hasRequiredType$1;

function requireType$1() {
	if (hasRequiredType$1) return type$1;
	hasRequiredType$1 = 1, type$1 = w;
	var o = requireNamespace$1();
	((w.prototype = Object.create(o.prototype)).constructor = w).className = "Type";
	var s = require_enum$1(),
		a = requireOneof$1(),
		l = requireField$1(),
		c = requireMapfield$1(),
		d = requireService$2(),
		f = requireMessage$1(),
		m = requireReader$1(),
		g = requireWriter$1(),
		v = requireUtil$1(),
		y = requireEncoder$1(),
		b = requireDecoder$1(),
		C = requireVerifier$1(),
		_ = requireConverter$1(),
		S = requireWrappers$1();

	function w(A, k) {
		o.call(this, A, k), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0,
			this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this
			._ctor = null
	}
	Object.defineProperties(w.prototype, {
		fieldsById: {
			get: function() {
				if (this._fieldsById) return this._fieldsById;
				this._fieldsById = {};
				for (var A = Object.keys(this.fields), k = 0; k < A.length; ++k) {
					var M = this.fields[A[k]],
						D = M.id;
					if (this._fieldsById[D]) throw Error("duplicate id " + D + " in " + this);
					this._fieldsById[D] = M
				}
				return this._fieldsById
			}
		},
		fieldsArray: {
			get: function() {
				return this._fieldsArray || (this._fieldsArray = v.toArray(this.fields))
			}
		},
		oneofsArray: {
			get: function() {
				return this._oneofsArray || (this._oneofsArray = v.toArray(this.oneofs))
			}
		},
		ctor: {
			get: function() {
				return this._ctor || (this.ctor = w.generateConstructor(this)())
			},
			set: function(A) {
				var k = A.prototype;
				k instanceof f || ((A.prototype = new f).constructor = A, v.merge(A.prototype, k)), A
					.$type = A.prototype.$type = this, v.merge(A, f, !0), this._ctor = A;
				for (var M = 0; M < this.fieldsArray.length; ++M) this._fieldsArray[M].resolve();
				var D = {};
				for (M = 0; M < this.oneofsArray.length; ++M) D[this._oneofsArray[M].resolve().name] = {
					get: v.oneOfGetter(this._oneofsArray[M].oneof),
					set: v.oneOfSetter(this._oneofsArray[M].oneof)
				};
				M && Object.defineProperties(A.prototype, D)
			}
		}
	}), w.generateConstructor = function(k) {
		for (var M = v.codegen(["p"], k.name), D = 0, F; D < k.fieldsArray.length; ++D)(F = k._fieldsArray[D]).map ?
			M("this%s={}", v.safeProp(F.name)) : F.repeated && M("this%s=[]", v.safeProp(F.name));
		return M("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]")
	};

	function T(A) {
		return A._fieldsById = A._fieldsArray = A._oneofsArray = null, delete A.encode, delete A.decode, delete A
			.verify, A
	}
	return w.fromJSON = function(k, M) {
		var D = new w(k, M.options);
		D.extensions = M.extensions, D.reserved = M.reserved;
		for (var F = Object.keys(M.fields), R = 0; R < F.length; ++R) D.add((typeof M.fields[F[R]].keyType < "u" ? c
			.fromJSON : l.fromJSON)(F[R], M.fields[F[R]]));
		if (M.oneofs)
			for (F = Object.keys(M.oneofs), R = 0; R < F.length; ++R) D.add(a.fromJSON(F[R], M.oneofs[F[R]]));
		if (M.nested)
			for (F = Object.keys(M.nested), R = 0; R < F.length; ++R) {
				var O = M.nested[F[R]];
				D.add((O.id !== void 0 ? l.fromJSON : O.fields !== void 0 ? w.fromJSON : O.values !== void 0 ? s
					.fromJSON : O.methods !== void 0 ? d.fromJSON : o.fromJSON)(F[R], O))
			}
		return M.extensions && M.extensions.length && (D.extensions = M.extensions), M.reserved && M.reserved
			.length && (D.reserved = M.reserved), M.group && (D.group = !0), M.comment && (D.comment = M.comment), M
			.edition && (D._edition = M.edition), D._defaultEdition = "proto3", D
	}, w.prototype.toJSON = function(k) {
		var M = o.prototype.toJSON.call(this, k),
			D = k ? !!k.keepComments : !1;
		return v.toObject(["edition", this._editionToJSON(), "options", M && M.options || void 0, "oneofs", o
			.arrayToJSON(this.oneofsArray, k), "fields", o.arrayToJSON(this.fieldsArray.filter(function(F) {
				return !F.declaringField
			}), k) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions :
			void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group",
			this.group || void 0, "nested", M && M.nested || void 0, "comment", D ? this.comment : void 0
		])
	}, w.prototype.resolveAll = function() {
		o.prototype.resolveAll.call(this);
		var k = this.oneofsArray;
		for (D = 0; D < k.length;) k[D++].resolve();
		for (var M = this.fieldsArray, D = 0; D < M.length;) M[D++].resolve();
		return this
	}, w.prototype._resolveFeaturesRecursive = function(k) {
		return this._needsRecursiveFeatureResolution ? (k = this._edition || k, o.prototype
			._resolveFeaturesRecursive.call(this, k), this.oneofsArray.forEach(M => {
				M._resolveFeatures(k)
			}), this.fieldsArray.forEach(M => {
				M._resolveFeatures(k)
			}), this) : this
	}, w.prototype.get = function(k) {
		return this.fields[k] || this.oneofs && this.oneofs[k] || this.nested && this.nested[k] || null
	}, w.prototype.add = function(k) {
		if (this.get(k.name)) throw Error("duplicate name '" + k.name + "' in " + this);
		if (k instanceof l && k.extend === void 0) {
			if (this._fieldsById ? this._fieldsById[k.id] : this.fieldsById[k.id]) throw Error("duplicate id " + k
				.id + " in " + this);
			if (this.isReservedId(k.id)) throw Error("id " + k.id + " is reserved in " + this);
			if (this.isReservedName(k.name)) throw Error("name '" + k.name + "' is reserved in " + this);
			return k.parent && k.parent.remove(k), this.fields[k.name] = k, k.message = this, k.onAdd(this), T(this)
		}
		return k instanceof a ? (this.oneofs || (this.oneofs = {}), this.oneofs[k.name] = k, k.onAdd(this), T(
			this)) : o.prototype.add.call(this, k)
	}, w.prototype.remove = function(k) {
		if (k instanceof l && k.extend === void 0) {
			if (!this.fields || this.fields[k.name] !== k) throw Error(k + " is not a member of " + this);
			return delete this.fields[k.name], k.parent = null, k.onRemove(this), T(this)
		}
		if (k instanceof a) {
			if (!this.oneofs || this.oneofs[k.name] !== k) throw Error(k + " is not a member of " + this);
			return delete this.oneofs[k.name], k.parent = null, k.onRemove(this), T(this)
		}
		return o.prototype.remove.call(this, k)
	}, w.prototype.isReservedId = function(k) {
		return o.isReservedId(this.reserved, k)
	}, w.prototype.isReservedName = function(k) {
		return o.isReservedName(this.reserved, k)
	}, w.prototype.create = function(k) {
		return new this.ctor(k)
	}, w.prototype.setup = function() {
		for (var k = this.fullName, M = [], D = 0; D < this.fieldsArray.length; ++D) M.push(this._fieldsArray[D]
			.resolve().resolvedType);
		this.encode = y(this)({
			Writer: g,
			types: M,
			util: v
		}), this.decode = b(this)({
			Reader: m,
			types: M,
			util: v
		}), this.verify = C(this)({
			types: M,
			util: v
		}), this.fromObject = _.fromObject(this)({
			types: M,
			util: v
		}), this.toObject = _.toObject(this)({
			types: M,
			util: v
		});
		var F = S[k];
		if (F) {
			var R = Object.create(this);
			R.fromObject = this.fromObject, this.fromObject = F.fromObject.bind(R), R.toObject = this.toObject, this
				.toObject = F.toObject.bind(R)
		}
		return this
	}, w.prototype.encode = function(k, M) {
		return this.setup().encode(k, M)
	}, w.prototype.encodeDelimited = function(k, M) {
		return this.encode(k, M && M.len ? M.fork() : M).ldelim()
	}, w.prototype.decode = function(k, M) {
		return this.setup().decode(k, M)
	}, w.prototype.decodeDelimited = function(k) {
		return k instanceof m || (k = m.create(k)), this.decode(k, k.uint32())
	}, w.prototype.verify = function(k) {
		return this.setup().verify(k)
	}, w.prototype.fromObject = function(k) {
		return this.setup().fromObject(k)
	}, w.prototype.toObject = function(k, M) {
		return this.setup().toObject(k, M)
	}, w.d = function(k) {
		return function(D) {
			v.decorateType(D, k)
		}
	}, type$1
}
var root$1, hasRequiredRoot$1;

function requireRoot$1() {
	if (hasRequiredRoot$1) return root$1;
	hasRequiredRoot$1 = 1, root$1 = g;
	var o = requireNamespace$1();
	((g.prototype = Object.create(o.prototype)).constructor = g).className = "Root";
	var s = requireField$1(),
		a = require_enum$1(),
		l = requireOneof$1(),
		c = requireUtil$1(),
		d, f, m;

	function g(C) {
		o.call(this, "", C), this.deferred = [], this.files = [], this._edition = "proto2"
	}
	g.fromJSON = function(_, S) {
		return S || (S = new g), _.options && S.setOptions(_.options), S.addJSON(_.nested)
			._resolveFeaturesRecursive()
	}, g.prototype.resolvePath = c.path.resolve, g.prototype.fetch = c.fetch;

	function v() {}
	g.prototype.load = function C(_, S, w) {
		typeof S == "function" && (w = S, S = void 0);
		var T = this;
		if (!w) return c.asPromise(C, T, _, S);
		var A = w === v;

		function k(V, z) {
			if (z && z._resolveFeaturesRecursive(), !!w) {
				if (A) throw V;
				var j = w;
				w = null, j(V, z)
			}
		}

		function M(V) {
			var z = V.lastIndexOf("google/protobuf/");
			if (z > -1) {
				var j = V.substring(z);
				if (j in m) return j
			}
			return null
		}

		function D(V, z) {
			try {
				if (c.isString(z) && z.charAt(0) === "{" && (z = JSON.parse(z)), !c.isString(z)) T.setOptions(z
					.options).addJSON(z.nested);
				else {
					f.filename = V;
					var j = f(z, T, S),
						ge, me = 0;
					if (j.imports)
						for (; me < j.imports.length; ++me)(ge = M(j.imports[me]) || T.resolvePath(V, j.imports[
							me])) && F(ge);
					if (j.weakImports)
						for (me = 0; me < j.weakImports.length; ++me)(ge = M(j.weakImports[me]) || T.resolvePath(V,
							j.weakImports[me])) && F(ge, !0)
				}
			} catch (he) {
				k(he)
			}!A && !R && k(null, T)
		}

		function F(V, z) {
			if (V = M(V) || V, !(T.files.indexOf(V) > -1)) {
				if (T.files.push(V), V in m) {
					A ? D(V, m[V]) : (++R, setTimeout(function() {
						--R, D(V, m[V])
					}));
					return
				}
				if (A) {
					var j;
					try {
						j = c.fs.readFileSync(V).toString("utf8")
					} catch (ge) {
						z || k(ge);
						return
					}
					D(V, j)
				} else ++R, T.fetch(V, function(ge, me) {
					if (--R, !!w) {
						if (ge) {
							z ? R || k(null, T) : k(ge);
							return
						}
						D(V, me)
					}
				})
			}
		}
		var R = 0;
		c.isString(_) && (_ = [_]);
		for (var O = 0, U; O < _.length; ++O)(U = T.resolvePath("", _[O])) && F(U);
		return A ? (T._resolveFeaturesRecursive(), T) : (R || k(null, T), T)
	}, g.prototype.loadSync = function(_, S) {
		if (!c.isNode) throw Error("not supported");
		return this.load(_, S, v)
	}, g.prototype.resolveAll = function() {
		if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function(_) {
			return "'extend " + _.extend + "' in " + _.parent.fullName
		}).join(", "));
		return this._resolveFeaturesRecursive(this._edition), o.prototype.resolveAll.call(this)
	};
	var y = /^[A-Z]/;

	function b(C, _) {
		var S = _.parent.lookup(_.extend);
		if (S) {
			var w = new s(_.fullName, _.id, _.type, _.rule, void 0, _.options);
			return S.get(w.name) || (w.declaringField = _, _.extensionField = w, S.add(w)), !0
		}
		return !1
	}
	return g.prototype._handleAdd = function(_) {
		if (_ instanceof s) _.extend !== void 0 && !_.extensionField && (b(this, _) || this.deferred.push(_));
		else if (_ instanceof a) y.test(_.name) && (_.parent[_.name] = _.values);
		else if (!(_ instanceof l)) {
			if (_ instanceof d)
				for (var S = 0; S < this.deferred.length;) b(this, this.deferred[S]) ? this.deferred.splice(S, 1) :
					++S;
			for (var w = 0; w < _.nestedArray.length; ++w) this._handleAdd(_._nestedArray[w]);
			y.test(_.name) && (_.parent[_.name] = _)
		}
	}, g.prototype._handleRemove = function(_) {
		if (_ instanceof s) {
			if (_.extend !== void 0)
				if (_.extensionField) _.extensionField.parent.remove(_.extensionField), _.extensionField = null;
				else {
					var S = this.deferred.indexOf(_);
					S > -1 && this.deferred.splice(S, 1)
				}
		} else if (_ instanceof a) y.test(_.name) && delete _.parent[_.name];
		else if (_ instanceof o) {
			for (var w = 0; w < _.nestedArray.length; ++w) this._handleRemove(_._nestedArray[w]);
			y.test(_.name) && delete _.parent[_.name]
		}
	}, g._configure = function(C, _, S) {
		d = C, f = _, m = S
	}, root$1
}
var hasRequiredUtil$1;

function requireUtil$1() {
	if (hasRequiredUtil$1) return util$1.exports;
	hasRequiredUtil$1 = 1;
	var o = util$1.exports = requireMinimal$1(),
		s = requireRoots$1(),
		a, l;
	o.codegen = requireCodegen$1(), o.fetch = requireFetch$1(), o.path = requirePath$1(), o.fs = o.inquire("fs"), o
		.toArray = function(v) {
			if (v) {
				for (var y = Object.keys(v), b = new Array(y.length), C = 0; C < y.length;) b[C] = v[y[C++]];
				return b
			}
			return []
		}, o.toObject = function(v) {
			for (var y = {}, b = 0; b < v.length;) {
				var C = v[b++],
					_ = v[b++];
				_ !== void 0 && (y[C] = _)
			}
			return y
		};
	var c = /\\/g,
		d = /"/g;
	o.isReserved = function(v) {
		return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/
			.test(v)
	}, o.safeProp = function(v) {
		return !/^[$\w_]+$/.test(v) || o.isReserved(v) ? '["' + v.replace(c, "\\\\").replace(d, '\\"') + '"]' :
			"." + v
	}, o.ucFirst = function(v) {
		return v.charAt(0).toUpperCase() + v.substring(1)
	};
	var f = /_([a-z])/g;
	o.camelCase = function(v) {
		return v.substring(0, 1) + v.substring(1).replace(f, function(y, b) {
			return b.toUpperCase()
		})
	}, o.compareFieldsById = function(v, y) {
		return v.id - y.id
	}, o.decorateType = function(v, y) {
		if (v.$type) return y && v.$type.name !== y && (o.decorateRoot.remove(v.$type), v.$type.name = y, o
			.decorateRoot.add(v.$type)), v.$type;
		a || (a = requireType$1());
		var b = new a(y || v.name);
		return o.decorateRoot.add(b), b.ctor = v, Object.defineProperty(v, "$type", {
			value: b,
			enumerable: !1
		}), Object.defineProperty(v.prototype, "$type", {
			value: b,
			enumerable: !1
		}), b
	};
	var m = 0;
	return o.decorateEnum = function(v) {
		if (v.$type) return v.$type;
		l || (l = require_enum$1());
		var y = new l("Enum" + m++, v);
		return o.decorateRoot.add(y), Object.defineProperty(v, "$type", {
			value: y,
			enumerable: !1
		}), y
	}, o.setProperty = function(v, y, b, C) {
		function _(S, w, T) {
			var A = w.shift();
			if (A === "__proto__" || A === "prototype") return S;
			if (w.length > 0) S[A] = _(S[A] || {}, w, T);
			else {
				var k = S[A];
				if (k && C) return S;
				k && (T = [].concat(k).concat(T)), S[A] = T
			}
			return S
		}
		if (typeof v != "object") throw TypeError("dst must be an object");
		if (!y) throw TypeError("path must be specified");
		return y = y.split("."), _(v, y, b)
	}, Object.defineProperty(o, "decorateRoot", {
		get: function() {
			return s.decorated || (s.decorated = new(requireRoot$1()))
		}
	}), util$1.exports
}
var hasRequiredTypes$1;

function requireTypes$1() {
	return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1, function(o) {
		var s = o,
			a = requireUtil$1(),
			l = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64",
				"sint64", "fixed64", "sfixed64", "bool", "string", "bytes"
			];

		function c(d, f) {
			var m = 0,
				g = {};
			for (f |= 0; m < d.length;) g[l[m + f]] = d[m++];
			return g
		}
		s.basic = c([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), s.defaults = c([0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, !1, "", a.emptyArray, null
			]), s.long = c([0, 0, 0, 1, 1], 7), s.mapKey = c([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), s
			.packed = c([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0])
	}(types$1)), types$1
}
var field$1, hasRequiredField$1;

function requireField$1() {
	if (hasRequiredField$1) return field$1;
	hasRequiredField$1 = 1, field$1 = f;
	var o = requireObject$1();
	((f.prototype = Object.create(o.prototype)).constructor = f).className = "Field";
	var s = require_enum$1(),
		a = requireTypes$1(),
		l = requireUtil$1(),
		c, d = /^required|optional|repeated$/;
	f.fromJSON = function(g, v) {
		var y = new f(g, v.id, v.type, v.rule, v.extend, v.options, v.comment);
		return v.edition && (y._edition = v.edition), y._defaultEdition = "proto3", y
	};

	function f(m, g, v, y, b, C, _) {
		if (l.isObject(y) ? (_ = b, C = y, y = b = void 0) : l.isObject(b) && (_ = C, C = b, b = void 0), o.call(this,
				m, C), !l.isInteger(g) || g < 0) throw TypeError("id must be a non-negative integer");
		if (!l.isString(v)) throw TypeError("type must be a string");
		if (y !== void 0 && !d.test(y = y.toString().toLowerCase())) throw TypeError("rule must be a string rule");
		if (b !== void 0 && !l.isString(b)) throw TypeError("extend must be a string");
		y === "proto3_optional" && (y = "optional"), this.rule = y && y !== "optional" ? y : void 0, this.type = v, this
			.id = g, this.extend = b || void 0, this.repeated = y === "repeated", this.map = !1, this.message = null,
			this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = l.Long ? a.long[v] !==
			void 0 : !1, this.bytes = v === "bytes", this.resolvedType = null, this.extensionField = null, this
			.declaringField = null, this.comment = _
	}
	return Object.defineProperty(f.prototype, "required", {
		get: function() {
			return this._features.field_presence === "LEGACY_REQUIRED"
		}
	}), Object.defineProperty(f.prototype, "optional", {
		get: function() {
			return !this.required
		}
	}), Object.defineProperty(f.prototype, "delimited", {
		get: function() {
			return this.resolvedType instanceof c && this._features.message_encoding === "DELIMITED"
		}
	}), Object.defineProperty(f.prototype, "packed", {
		get: function() {
			return this._features.repeated_field_encoding === "PACKED"
		}
	}), Object.defineProperty(f.prototype, "hasPresence", {
		get: function() {
			return this.repeated || this.map ? !1 : this.partOf || this.declaringField || this
				.extensionField || this._features.field_presence !== "IMPLICIT"
		}
	}), f.prototype.setOption = function(g, v, y) {
		return o.prototype.setOption.call(this, g, v, y)
	}, f.prototype.toJSON = function(g) {
		var v = g ? !!g.keepComments : !1;
		return l.toObject(["edition", this._editionToJSON(), "rule", this.rule !== "optional" && this.rule ||
			void 0, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options,
			"comment", v ? this.comment : void 0
		])
	}, f.prototype.resolve = function() {
		if (this.resolved) return this;
		if ((this.typeDefault = a.defaults[this.type]) === void 0 ? (this.resolvedType = (this.declaringField ? this
					.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this
				.resolvedType instanceof c ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[
					Object.keys(this.resolvedType.values)[0]]) : this.options && this.options.proto3_optional && (
				this.typeDefault = null), this.options && this.options.default != null && (this.typeDefault = this
				.options.default, this.resolvedType instanceof s && typeof this.typeDefault == "string" && (this
					.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (this.options
				.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof s) && delete this.options
				.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault =
			l.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u"), Object.freeze && Object.freeze(this
				.typeDefault);
		else if (this.bytes && typeof this.typeDefault == "string") {
			var g;
			l.base64.test(this.typeDefault) ? l.base64.decode(this.typeDefault, g = l.newBuffer(l.base64.length(this
				.typeDefault)), 0) : l.utf8.write(this.typeDefault, g = l.newBuffer(l.utf8.length(this
				.typeDefault)), 0), this.typeDefault = g
		}
		return this.map ? this.defaultValue = l.emptyObject : this.repeated ? this.defaultValue = l.emptyArray :
			this.defaultValue = this.typeDefault, this.parent instanceof c && (this.parent.ctor.prototype[this
				.name] = this.defaultValue), o.prototype.resolve.call(this)
	}, f.prototype._inferLegacyProtoFeatures = function(g) {
		if (g !== "proto2" && g !== "proto3") return {};
		var v = {};
		if (this.rule === "required" && (v.field_presence = "LEGACY_REQUIRED"), this.parent && a.defaults[this
			.type] === void 0) {
			var y = this.parent.get(this.type.split(".").pop());
			y && y instanceof c && y.group && (v.message_encoding = "DELIMITED")
		}
		return this.getOption("packed") === !0 ? v.repeated_field_encoding = "PACKED" : this.getOption("packed") ===
			!1 && (v.repeated_field_encoding = "EXPANDED"), v
	}, f.prototype._resolveFeatures = function(g) {
		return o.prototype._resolveFeatures.call(this, this._edition || g)
	}, f.d = function(g, v, y, b) {
		return typeof v == "function" ? v = l.decorateType(v).name : v && typeof v == "object" && (v = l
				.decorateEnum(v).name),
			function(_, S) {
				l.decorateType(_.constructor).add(new f(S, g, v, y, {
					default: b
				}))
			}
	}, f._configure = function(g) {
		c = g
	}, field$1
}
var oneof$1, hasRequiredOneof$1;

function requireOneof$1() {
	if (hasRequiredOneof$1) return oneof$1;
	hasRequiredOneof$1 = 1, oneof$1 = l;
	var o = requireObject$1();
	((l.prototype = Object.create(o.prototype)).constructor = l).className = "OneOf";
	var s = requireField$1(),
		a = requireUtil$1();

	function l(d, f, m, g) {
		if (Array.isArray(f) || (m = f, f = void 0), o.call(this, d, m), !(f === void 0 || Array.isArray(f)))
		throw TypeError("fieldNames must be an Array");
		this.oneof = f || [], this.fieldsArray = [], this.comment = g
	}
	l.fromJSON = function(f, m) {
		return new l(f, m.oneof, m.options, m.comment)
	}, l.prototype.toJSON = function(f) {
		var m = f ? !!f.keepComments : !1;
		return a.toObject(["options", this.options, "oneof", this.oneof, "comment", m ? this.comment : void 0])
	};

	function c(d) {
		if (d.parent)
			for (var f = 0; f < d.fieldsArray.length; ++f) d.fieldsArray[f].parent || d.parent.add(d.fieldsArray[f])
	}
	return l.prototype.add = function(f) {
		if (!(f instanceof s)) throw TypeError("field must be a Field");
		return f.parent && f.parent !== this.parent && f.parent.remove(f), this.oneof.push(f.name), this.fieldsArray
			.push(f), f.partOf = this, c(this), this
	}, l.prototype.remove = function(f) {
		if (!(f instanceof s)) throw TypeError("field must be a Field");
		var m = this.fieldsArray.indexOf(f);
		if (m < 0) throw Error(f + " is not a member of " + this);
		return this.fieldsArray.splice(m, 1), m = this.oneof.indexOf(f.name), m > -1 && this.oneof.splice(m, 1), f
			.partOf = null, this
	}, l.prototype.onAdd = function(f) {
		o.prototype.onAdd.call(this, f);
		for (var m = this, g = 0; g < this.oneof.length; ++g) {
			var v = f.get(this.oneof[g]);
			v && !v.partOf && (v.partOf = m, m.fieldsArray.push(v))
		}
		c(this)
	}, l.prototype.onRemove = function(f) {
		for (var m = 0, g; m < this.fieldsArray.length; ++m)(g = this.fieldsArray[m]).parent && g.parent.remove(g);
		o.prototype.onRemove.call(this, f)
	}, Object.defineProperty(l.prototype, "isProto3Optional", {
		get: function() {
			if (this.fieldsArray == null || this.fieldsArray.length !== 1) return !1;
			var d = this.fieldsArray[0];
			return d.options != null && d.options.proto3_optional === !0
		}
	}), l.d = function() {
		for (var f = new Array(arguments.length), m = 0; m < arguments.length;) f[m] = arguments[m++];
		return function(v, y) {
			a.decorateType(v.constructor).add(new l(y, f)), Object.defineProperty(v, y, {
				get: a.oneOfGetter(f),
				set: a.oneOfSetter(f)
			})
		}
	}, oneof$1
}
var object$1, hasRequiredObject$1;

function requireObject$1() {
	if (hasRequiredObject$1) return object$1;
	hasRequiredObject$1 = 1, object$1 = f, f.className = "ReflectionObject";
	const o = requireOneof$1();
	var s = requireUtil$1(),
		a, l = {
			enum_type: "OPEN",
			field_presence: "EXPLICIT",
			json_format: "ALLOW",
			message_encoding: "LENGTH_PREFIXED",
			repeated_field_encoding: "PACKED",
			utf8_validation: "VERIFY"
		},
		c = {
			enum_type: "CLOSED",
			field_presence: "EXPLICIT",
			json_format: "LEGACY_BEST_EFFORT",
			message_encoding: "LENGTH_PREFIXED",
			repeated_field_encoding: "EXPANDED",
			utf8_validation: "NONE"
		},
		d = {
			enum_type: "OPEN",
			field_presence: "IMPLICIT",
			json_format: "ALLOW",
			message_encoding: "LENGTH_PREFIXED",
			repeated_field_encoding: "PACKED",
			utf8_validation: "VERIFY"
		};

	function f(m, g) {
		if (!s.isString(m)) throw TypeError("name must be a string");
		if (g && !s.isObject(g)) throw TypeError("options must be an object");
		this.options = g, this.parsedOptions = null, this.name = m, this._edition = null, this._defaultEdition =
			"proto2", this._features = {}, this._featuresResolved = !1, this.parent = null, this.resolved = !1, this
			.comment = null, this.filename = null
	}
	return Object.defineProperties(f.prototype, {
		root: {
			get: function() {
				for (var m = this; m.parent !== null;) m = m.parent;
				return m
			}
		},
		fullName: {
			get: function() {
				for (var m = [this.name], g = this.parent; g;) m.unshift(g.name), g = g.parent;
				return m.join(".")
			}
		}
	}), f.prototype.toJSON = function() {
		throw Error()
	}, f.prototype.onAdd = function(g) {
		this.parent && this.parent !== g && this.parent.remove(this), this.parent = g, this.resolved = !1;
		var v = g.root;
		v instanceof a && v._handleAdd(this)
	}, f.prototype.onRemove = function(g) {
		var v = g.root;
		v instanceof a && v._handleRemove(this), this.parent = null, this.resolved = !1
	}, f.prototype.resolve = function() {
		return this.resolved ? this : (this.root instanceof a && (this.resolved = !0), this)
	}, f.prototype._resolveFeaturesRecursive = function(g) {
		return this._resolveFeatures(this._edition || g)
	}, f.prototype._resolveFeatures = function(g) {
		if (!this._featuresResolved) {
			var v = {};
			if (!g) throw new Error("Unknown edition for " + this.fullName);
			var y = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this
				._inferLegacyProtoFeatures(g));
			if (this._edition) {
				if (g === "proto2") v = Object.assign({}, c);
				else if (g === "proto3") v = Object.assign({}, d);
				else if (g === "2023") v = Object.assign({}, l);
				else throw new Error("Unknown edition: " + g);
				this._features = Object.assign(v, y || {}), this._featuresResolved = !0;
				return
			}
			if (this.partOf instanceof o) {
				var b = Object.assign({}, this.partOf._features);
				this._features = Object.assign(b, y || {})
			} else if (!this.declaringField)
				if (this.parent) {
					var C = Object.assign({}, this.parent._features);
					this._features = Object.assign(C, y || {})
				} else throw new Error("Unable to find a parent for " + this.fullName);
			this.extensionField && (this.extensionField._features = this._features), this._featuresResolved = !0
		}
	}, f.prototype._inferLegacyProtoFeatures = function() {
		return {}
	}, f.prototype.getOption = function(g) {
		if (this.options) return this.options[g]
	}, f.prototype.setOption = function(g, v, y) {
		return this.options || (this.options = {}), /^features\./.test(g) ? s.setProperty(this.options, g, v, y) : (
			!y || this.options[g] === void 0) && (this.getOption(g) !== v && (this.resolved = !1), this.options[
			g] = v), this
	}, f.prototype.setParsedOption = function(g, v, y) {
		this.parsedOptions || (this.parsedOptions = []);
		var b = this.parsedOptions;
		if (y) {
			var C = b.find(function(w) {
				return Object.prototype.hasOwnProperty.call(w, g)
			});
			if (C) {
				var _ = C[g];
				s.setProperty(_, y, v)
			} else C = {}, C[g] = s.setProperty({}, y, v), b.push(C)
		} else {
			var S = {};
			S[g] = v, b.push(S)
		}
		return this
	}, f.prototype.setOptions = function(g, v) {
		if (g)
			for (var y = Object.keys(g), b = 0; b < y.length; ++b) this.setOption(y[b], g[y[b]], v);
		return this
	}, f.prototype.toString = function() {
		var g = this.constructor.className,
			v = this.fullName;
		return v.length ? g + " " + v : g
	}, f.prototype._editionToJSON = function() {
		if (!(!this._edition || this._edition === "proto3")) return this._edition
	}, f._configure = function(m) {
		a = m
	}, object$1
}
var _enum$1, hasRequired_enum$1;

function require_enum$1() {
	if (hasRequired_enum$1) return _enum$1;
	hasRequired_enum$1 = 1, _enum$1 = l;
	var o = requireObject$1();
	((l.prototype = Object.create(o.prototype)).constructor = l).className = "Enum";
	var s = requireNamespace$1(),
		a = requireUtil$1();

	function l(c, d, f, m, g, v) {
		if (o.call(this, c, f), d && typeof d != "object") throw TypeError("values must be an object");
		if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = m, this.comments = g ||
			{}, this.valuesOptions = v, this._valuesFeatures = {}, this.reserved = void 0, d)
			for (var y = Object.keys(d), b = 0; b < y.length; ++b) typeof d[y[b]] == "number" && (this.valuesById[this
				.values[y[b]] = d[y[b]]] = y[b])
	}
	return l.prototype._resolveFeatures = function(d) {
		return d = this._edition || d, o.prototype._resolveFeatures.call(this, d), Object.keys(this.values).forEach(
			f => {
				var m = Object.assign({}, this._features);
				this._valuesFeatures[f] = Object.assign(m, this.valuesOptions && this.valuesOptions[f] && this
					.valuesOptions[f].features)
			}), this
	}, l.fromJSON = function(d, f) {
		var m = new l(d, f.values, f.options, f.comment, f.comments);
		return m.reserved = f.reserved, f.edition && (m._edition = f.edition), m._defaultEdition = "proto3", m
	}, l.prototype.toJSON = function(d) {
		var f = d ? !!d.keepComments : !1;
		return a.toObject(["edition", this._editionToJSON(), "options", this.options, "valuesOptions", this
			.valuesOptions, "values", this.values, "reserved", this.reserved && this.reserved.length ? this
			.reserved : void 0, "comment", f ? this.comment : void 0, "comments", f ? this.comments : void 0
		])
	}, l.prototype.add = function(d, f, m, g) {
		if (!a.isString(d)) throw TypeError("name must be a string");
		if (!a.isInteger(f)) throw TypeError("id must be an integer");
		if (this.values[d] !== void 0) throw Error("duplicate name '" + d + "' in " + this);
		if (this.isReservedId(f)) throw Error("id " + f + " is reserved in " + this);
		if (this.isReservedName(d)) throw Error("name '" + d + "' is reserved in " + this);
		if (this.valuesById[f] !== void 0) {
			if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + f + " in " + this);
			this.values[d] = f
		} else this.valuesById[this.values[d] = f] = d;
		return g && (this.valuesOptions === void 0 && (this.valuesOptions = {}), this.valuesOptions[d] = g || null),
			this.comments[d] = m || null, this
	}, l.prototype.remove = function(d) {
		if (!a.isString(d)) throw TypeError("name must be a string");
		var f = this.values[d];
		if (f == null) throw Error("name '" + d + "' does not exist in " + this);
		return delete this.valuesById[f], delete this.values[d], delete this.comments[d], this.valuesOptions &&
			delete this.valuesOptions[d], this
	}, l.prototype.isReservedId = function(d) {
		return s.isReservedId(this.reserved, d)
	}, l.prototype.isReservedName = function(d) {
		return s.isReservedName(this.reserved, d)
	}, _enum$1
}
var encoder_1$1, hasRequiredEncoder$1;

function requireEncoder$1() {
	if (hasRequiredEncoder$1) return encoder_1$1;
	hasRequiredEncoder$1 = 1, encoder_1$1 = c;
	var o = require_enum$1(),
		s = requireTypes$1(),
		a = requireUtil$1();

	function l(d, f, m, g) {
		return f.delimited ? d("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", m, g, (f.id << 3 | 3) >>> 0, (f.id << 3 |
			4) >>> 0) : d("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", m, g, (f.id << 3 | 2) >>> 0)
	}

	function c(d) {
		for (var f = a.codegen(["m", "w"], d.name + "$encode")("if(!w)")("w=Writer.create()"), m, g, v = d.fieldsArray
				.slice().sort(a.compareFieldsById), m = 0; m < v.length; ++m) {
			var y = v[m].resolve(),
				b = d._fieldsArray.indexOf(y),
				C = y.resolvedType instanceof o ? "int32" : y.type,
				_ = s.basic[C];
			g = "m" + a.safeProp(y.name), y.map ? (f("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", g, y.name)(
				"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", g)(
				"w.uint32(%i).fork().uint32(%i).%s(ks[i])", (y.id << 3 | 2) >>> 0, 8 | s.mapKey[y.keyType], y
				.keyType), _ === void 0 ? f("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",
				b, g) : f(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | _, C, g), f("}")("}")) : y.repeated ? (f(
				"if(%s!=null&&%s.length){", g, g), y.packed && s.packed[C] !== void 0 ? f("w.uint32(%i).fork()",
				(y.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", g)("w.%s(%s[i])", C, g)("w.ldelim()") : (
				f("for(var i=0;i<%s.length;++i)", g), _ === void 0 ? l(f, y, b, g + "[i]") : f(
					"w.uint32(%i).%s(%s[i])", (y.id << 3 | _) >>> 0, C, g)), f("}")) : (y.optional && f(
				"if(%s!=null&&Object.hasOwnProperty.call(m,%j))", g, y.name), _ === void 0 ? l(f, y, b, g) : f(
				"w.uint32(%i).%s(%s)", (y.id << 3 | _) >>> 0, C, g))
		}
		return f("return w")
	}
	return encoder_1$1
}
var hasRequiredIndexLight$1;

function requireIndexLight$1() {
	if (hasRequiredIndexLight$1) return indexLight$1.exports;
	hasRequiredIndexLight$1 = 1;
	var o = indexLight$1.exports = requireIndexMinimal$1();
	o.build = "light";

	function s(l, c, d) {
		return typeof c == "function" ? (d = c, c = new o.Root) : c || (c = new o.Root), c.load(l, d)
	}
	o.load = s;

	function a(l, c) {
		return c || (c = new o.Root), c.loadSync(l)
	}
	return o.loadSync = a, o.encoder = requireEncoder$1(), o.decoder = requireDecoder$1(), o.verifier =
		requireVerifier$1(), o.converter = requireConverter$1(), o.ReflectionObject = requireObject$1(), o.Namespace =
		requireNamespace$1(), o.Root = requireRoot$1(), o.Enum = require_enum$1(), o.Type = requireType$1(), o.Field =
		requireField$1(), o.OneOf = requireOneof$1(), o.MapField = requireMapfield$1(), o.Service = requireService$2(),
		o.Method = requireMethod$1(), o.Message = requireMessage$1(), o.wrappers = requireWrappers$1(), o.types =
		requireTypes$1(), o.util = requireUtil$1(), o.ReflectionObject._configure(o.Root), o.Namespace._configure(o
			.Type, o.Service, o.Enum), o.Root._configure(o.Type), o.Field._configure(o.Type), indexLight$1.exports
}
var tokenize_1$1, hasRequiredTokenize$1;

function requireTokenize$1() {
	if (hasRequiredTokenize$1) return tokenize_1$1;
	hasRequiredTokenize$1 = 1, tokenize_1$1 = y;
	var o = /[\s{}=;:[\],'"()<>]/g,
		s = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
		a = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
		l = /^ *[*/]+ */,
		c = /^\s*\*?\/*/,
		d = /\n/g,
		f = /\s/,
		m = /\\(.?)/g,
		g = {
			0: "\0",
			r: "\r",
			n: `
`,
			t: "	"
		};

	function v(b) {
		return b.replace(m, function(C, _) {
			switch (_) {
				case "\\":
				case "":
					return _;
				default:
					return g[_] || ""
			}
		})
	}
	y.unescape = v;

	function y(b, C) {
		b = b.toString();
		var _ = 0,
			S = b.length,
			w = 1,
			T = 0,
			A = {},
			k = [],
			M = null;

		function D(ce) {
			return Error("illegal " + ce + " (line " + w + ")")
		}

		function F() {
			var ce = M === "'" ? a : s;
			ce.lastIndex = _ - 1;
			var ae = ce.exec(b);
			if (!ae) throw D("string");
			return _ = ce.lastIndex, j(M), M = null, v(ae[1])
		}

		function R(ce) {
			return b.charAt(ce)
		}

		function O(ce, ae, fe) {
			var q = {
					type: b.charAt(ce++),
					lineEmpty: !1,
					leading: fe
				},
				le;
			C ? le = 2 : le = 3;
			var de = ce - le,
				_e;
			do
				if (--de < 0 || (_e = b.charAt(de)) === `
`) {
					q.lineEmpty = !0;
					break
				} while (_e === " " || _e === "	");
			for (var ke = b.substring(ce, ae).split(d), De = 0; De < ke.length; ++De) ke[De] = ke[De].replace(C ? c : l,
				"").trim();
			q.text = ke.join(`
`).trim(), A[w] = q, T = w
		}

		function U(ce) {
			var ae = V(ce),
				fe = b.substring(ce, ae),
				q = /^\s*\/\//.test(fe);
			return q
		}

		function V(ce) {
			for (var ae = ce; ae < S && R(ae) !== `
`;) ae++;
			return ae
		}

		function z() {
			if (k.length > 0) return k.shift();
			if (M) return F();
			var ce, ae, fe, q, le, de = _ === 0;
			do {
				if (_ === S) return null;
				for (ce = !1; f.test(fe = R(_));)
					if (fe === `
` && (de = !0, ++w), ++_ === S) return null;
				if (R(_) === "/") {
					if (++_ === S) throw D("comment");
					if (R(_) === "/")
						if (C) {
							if (q = _, le = !1, U(_ - 1)) {
								le = !0;
								do
									if (_ = V(_), _ === S || (_++, !de)) break; while (U(_))
							} else _ = Math.min(S, V(_) + 1);
							le && (O(q, _, de), de = !0), w++, ce = !0
						} else {
							for (le = R(q = _ + 1) === "/"; R(++_) !== `
`;)
								if (_ === S) return null;
							++_, le && (O(q, _ - 1, de), de = !0), ++w, ce = !0
						}
					else if ((fe = R(_)) === "*") {
						q = _ + 1, le = C || R(q) === "*";
						do {
							if (fe === `
` && ++w, ++_ === S) throw D("comment");
							ae = fe, fe = R(_)
						} while (ae !== "*" || fe !== "/");
						++_, le && (O(q, _ - 2, de), de = !0), ce = !0
					} else return "/"
				}
			} while (ce);
			var _e = _;
			o.lastIndex = 0;
			var ke = o.test(R(_e++));
			if (!ke)
				for (; _e < S && !o.test(R(_e));) ++_e;
			var De = b.substring(_, _ = _e);
			return (De === '"' || De === "'") && (M = De), De
		}

		function j(ce) {
			k.push(ce)
		}

		function ge() {
			if (!k.length) {
				var ce = z();
				if (ce === null) return null;
				j(ce)
			}
			return k[0]
		}

		function me(ce, ae) {
			var fe = ge(),
				q = fe === ce;
			if (q) return z(), !0;
			if (!ae) throw D("token '" + fe + "', '" + ce + "' expected");
			return !1
		}

		function he(ce) {
			var ae = null,
				fe;
			return ce === void 0 ? (fe = A[w - 1], delete A[w - 1], fe && (C || fe.type === "*" || fe.lineEmpty) && (
				ae = fe.leading ? fe.text : null)) : (T < ce && ge(), fe = A[ce], delete A[ce], fe && !fe
				.lineEmpty && (C || fe.type === "/") && (ae = fe.leading ? null : fe.text)), ae
		}
		return Object.defineProperty({
			next: z,
			peek: ge,
			push: j,
			skip: me,
			cmnt: he
		}, "line", {
			get: function() {
				return w
			}
		})
	}
	return tokenize_1$1
}
var parse_1$1, hasRequiredParse$1;

function requireParse$1() {
	if (hasRequiredParse$1) return parse_1$1;
	hasRequiredParse$1 = 1, parse_1$1 = F, F.filename = null, F.defaults = {
		keepCase: !1
	};
	var o = requireTokenize$1(),
		s = requireRoot$1(),
		a = requireType$1(),
		l = requireField$1(),
		c = requireMapfield$1(),
		d = requireOneof$1(),
		f = require_enum$1(),
		m = requireService$2(),
		g = requireMethod$1(),
		v = requireObject$1(),
		y = requireTypes$1(),
		b = requireUtil$1(),
		C = /^[1-9][0-9]*$/,
		_ = /^-?[1-9][0-9]*$/,
		S = /^0[x][0-9a-fA-F]+$/,
		w = /^-?0[x][0-9a-fA-F]+$/,
		T = /^0[0-7]+$/,
		A = /^-?0[0-7]+$/,
		k = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
		M = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
		D = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;

	function F(R, O, U) {
		O instanceof s || (U = O, O = new s), U || (U = F.defaults);
		var V = U.preferTrailingComment || !1,
			z = o(R, U.alternateCommentMode || !1),
			j = z.next,
			ge = z.push,
			me = z.peek,
			he = z.skip,
			ce = z.cmnt,
			ae = !0,
			fe, q, le, de = "proto2",
			_e = O,
			ke = [],
			De = {},
			Se = U.keepCase ? function(Ze) {
				return Ze
			} : b.camelCase;

		function be() {
			ke.forEach(Ze => {
				Ze._edition = de, Object.keys(De).forEach(Ye => {
					Ze.getOption(Ye) === void 0 && Ze.setOption(Ye, De[Ye], !0)
				})
			})
		}

		function Me(Ze, Ye, ct) {
			var yt = F.filename;
			return ct || (F.filename = null), Error("illegal " + (Ye || "token") + " '" + Ze + "' (" + (yt ? yt + ", " :
				"") + "line " + z.line + ")")
		}

		function Ve() {
			var Ze = [],
				Ye;
			do {
				if ((Ye = j()) !== '"' && Ye !== "'") throw Me(Ye);
				Ze.push(j()), he(Ye), Ye = me()
			} while (Ye === '"' || Ye === "'");
			return Ze.join("")
		}

		function it(Ze) {
			var Ye = j();
			switch (Ye) {
				case "'":
				case '"':
					return ge(Ye), Ve();
				case "true":
				case "TRUE":
					return !0;
				case "false":
				case "FALSE":
					return !1
			}
			try {
				return dt(Ye, !0)
			} catch {
				if (D.test(Ye)) return Ye;
				throw Me(Ye, "value")
			}
		}

		function pt(Ze, Ye) {
			var ct, yt;
			do
				if (Ye && ((ct = me()) === '"' || ct === "'")) {
					var wt = Ve();
					if (Ze.push(wt), de >= 2023) throw Me(wt, "id")
				} else try {
					Ze.push([yt = He(j()), he("to", !0) ? He(j()) : yt])
				} catch (At) {
					if (Ye && D.test(ct) && de >= 2023) Ze.push(ct);
					else throw At
				}
			while (he(",", !0));
			var Qe = {
				options: void 0
			};
			Qe.setOption = function(At, Ct) {
				this.options === void 0 && (this.options = {}), this.options[At] = Ct
			}, nt(Qe, function(Ct) {
				if (Ct === "option") Fe(Qe, Ct), he(";");
				else throw Me(Ct)
			}, function() {
				Xe(Qe)
			})
		}

		function dt(Ze, Ye) {
			var ct = 1;
			switch (Ze.charAt(0) === "-" && (ct = -1, Ze = Ze.substring(1)), Ze) {
				case "inf":
				case "INF":
				case "Inf":
					return ct * (1 / 0);
				case "nan":
				case "NAN":
				case "Nan":
				case "NaN":
					return NaN;
				case "0":
					return 0
			}
			if (C.test(Ze)) return ct * parseInt(Ze, 10);
			if (S.test(Ze)) return ct * parseInt(Ze, 16);
			if (T.test(Ze)) return ct * parseInt(Ze, 8);
			if (k.test(Ze)) return ct * parseFloat(Ze);
			throw Me(Ze, "number", Ye)
		}

		function He(Ze, Ye) {
			switch (Ze) {
				case "max":
				case "MAX":
				case "Max":
					return 536870911;
				case "0":
					return 0
			}
			if (!Ye && Ze.charAt(0) === "-") throw Me(Ze, "id");
			if (_.test(Ze)) return parseInt(Ze, 10);
			if (w.test(Ze)) return parseInt(Ze, 16);
			if (A.test(Ze)) return parseInt(Ze, 8);
			throw Me(Ze, "id")
		}

		function Ae() {
			if (fe !== void 0) throw Me("package");
			if (fe = j(), !D.test(fe)) throw Me(fe, "name");
			_e = _e.define(fe), he(";")
		}

		function xe() {
			var Ze = me(),
				Ye;
			switch (Ze) {
				case "weak":
					Ye = le || (le = []), j();
					break;
				case "public":
					j();
				default:
					Ye = q || (q = []);
					break
			}
			Ze = Ve(), he(";"), Ye.push(Ze)
		}

		function ye() {
			if (he("="), de = Ve(), de < 2023) throw Me(de, "syntax");
			he(";")
		}

		function Le() {
			if (he("="), de = Ve(), !["2023"].includes(de)) throw Me(de, "edition");
			he(";")
		}

		function Ue(Ze, Ye) {
			switch (Ye) {
				case "option":
					return Fe(Ze, Ye), he(";"), !0;
				case "message":
					return ot(Ze, Ye), !0;
				case "enum":
					return Ce(Ze, Ye), !0;
				case "service":
					return rt(Ze, Ye), !0;
				case "extend":
					return gt(Ze, Ye), !0
			}
			return !1
		}

		function nt(Ze, Ye, ct) {
			var yt = z.line;
			if (Ze && (typeof Ze.comment != "string" && (Ze.comment = ce()), Ze.filename = F.filename), he("{", !0)) {
				for (var wt;
					(wt = j()) !== "}";) Ye(wt);
				he(";", !0)
			} else ct && ct(), he(";"), Ze && (typeof Ze.comment != "string" || V) && (Ze.comment = ce(yt) || Ze
				.comment)
		}

		function ot(Ze, Ye) {
			if (!M.test(Ye = j())) throw Me(Ye, "type name");
			var ct = new a(Ye);
			nt(ct, function(wt) {
				if (!Ue(ct, wt)) switch (wt) {
					case "map":
						Ne(ct);
						break;
					case "required":
						if (de !== "proto2") throw Me(wt);
					case "repeated":
						at(ct, wt);
						break;
					case "optional":
						if (de === "proto3") at(ct, "proto3_optional");
						else {
							if (de !== "proto2") throw Me(wt);
							at(ct, "optional")
						}
						break;
					case "oneof":
						we(ct, wt);
						break;
					case "extensions":
						pt(ct.extensions || (ct.extensions = []));
						break;
					case "reserved":
						pt(ct.reserved || (ct.reserved = []), !0);
						break;
					default:
						if (de === "proto2" || !D.test(wt)) throw Me(wt);
						ge(wt), at(ct, "optional");
						break
				}
			}), Ze.add(ct), Ze === _e && ke.push(ct)
		}

		function at(Ze, Ye, ct) {
			var yt = j();
			if (yt === "group") {
				Je(Ze, Ye);
				return
			}
			for (; yt.endsWith(".") || me().startsWith(".");) yt += j();
			if (!D.test(yt)) throw Me(yt, "type");
			var wt = j();
			if (!M.test(wt)) throw Me(wt, "name");
			wt = Se(wt), he("=");
			var Qe = new l(wt, He(j()), yt, Ye, ct);
			if (nt(Qe, function(xt) {
					if (xt === "option") Fe(Qe, xt), he(";");
					else throw Me(xt)
				}, function() {
					Xe(Qe)
				}), Ye === "proto3_optional") {
				var At = new d("_" + wt);
				Qe.setOption("proto3_optional", !0), At.add(Qe), Ze.add(At)
			} else Ze.add(Qe);
			Ze === _e && ke.push(Qe)
		}

		function Je(Ze, Ye) {
			if (de >= 2023) throw Me("group");
			var ct = j();
			if (!M.test(ct)) throw Me(ct, "name");
			var yt = b.lcFirst(ct);
			ct === yt && (ct = b.ucFirst(ct)), he("=");
			var wt = He(j()),
				Qe = new a(ct);
			Qe.group = !0;
			var At = new l(yt, wt, ct, Ye);
			At.filename = F.filename, nt(Qe, function(xt) {
				switch (xt) {
					case "option":
						Fe(Qe, xt), he(";");
						break;
					case "required":
					case "repeated":
						at(Qe, xt);
						break;
					case "optional":
						de === "proto3" ? at(Qe, "proto3_optional") : at(Qe, "optional");
						break;
					case "message":
						ot(Qe, xt);
						break;
					case "enum":
						Ce(Qe, xt);
						break;
					case "reserved":
						pt(Qe.reserved || (Qe.reserved = []), !0);
						break;
					default:
						throw Me(xt)
				}
			}), Ze.add(Qe).add(At)
		}

		function Ne(Ze) {
			he("<");
			var Ye = j();
			if (y.mapKey[Ye] === void 0) throw Me(Ye, "type");
			he(",");
			var ct = j();
			if (!D.test(ct)) throw Me(ct, "type");
			he(">");
			var yt = j();
			if (!M.test(yt)) throw Me(yt, "name");
			he("=");
			var wt = new c(Se(yt), He(j()), Ye, ct);
			nt(wt, function(At) {
				if (At === "option") Fe(wt, At), he(";");
				else throw Me(At)
			}, function() {
				Xe(wt)
			}), Ze.add(wt)
		}

		function we(Ze, Ye) {
			if (!M.test(Ye = j())) throw Me(Ye, "name");
			var ct = new d(Se(Ye));
			nt(ct, function(wt) {
				wt === "option" ? (Fe(ct, wt), he(";")) : (ge(wt), at(ct, "optional"))
			}), Ze.add(ct)
		}

		function Ce(Ze, Ye) {
			if (!M.test(Ye = j())) throw Me(Ye, "name");
			var ct = new f(Ye);
			nt(ct, function(wt) {
				switch (wt) {
					case "option":
						Fe(ct, wt), he(";");
						break;
					case "reserved":
						pt(ct.reserved || (ct.reserved = []), !0), ct.reserved === void 0 && (ct.reserved = []);
						break;
					default:
						$e(ct, wt)
				}
			}), Ze.add(ct), Ze === _e && ke.push(ct)
		}

		function $e(Ze, Ye) {
			if (!M.test(Ye)) throw Me(Ye, "name");
			he("=");
			var ct = He(j(), !0),
				yt = {
					options: void 0
				};
			yt.getOption = function(wt) {
				return this.options[wt]
			}, yt.setOption = function(wt, Qe) {
				v.prototype.setOption.call(yt, wt, Qe)
			}, yt.setParsedOption = function() {}, nt(yt, function(Qe) {
				if (Qe === "option") Fe(yt, Qe), he(";");
				else throw Me(Qe)
			}, function() {
				Xe(yt)
			}), Ze.add(Ye, ct, yt.comment, yt.parsedOptions || yt.options)
		}

		function Fe(Ze, Ye) {
			var ct, yt, wt = !0;
			for (Ye === "option" && (Ye = j()); Ye !== "=";) {
				if (Ye === "(") {
					var Qe = j();
					he(")"), Ye = "(" + Qe + ")"
				}
				if (wt) {
					if (wt = !1, Ye.includes(".") && !Ye.includes("(")) {
						var At = Ye.split(".");
						ct = At[0] + ".", Ye = At[1];
						continue
					}
					ct = Ye
				} else yt = yt ? yt += Ye : Ye;
				Ye = j()
			}
			var Ct = yt ? ct.concat(yt) : ct,
				xt = Ge(Ze, Ct);
			yt = yt && yt[0] === "." ? yt.slice(1) : yt, ct = ct && ct[ct.length - 1] === "." ? ct.slice(0, -1) : ct,
				Oe(Ze, ct, xt, yt)
		}

		function Ge(Ze, Ye) {
			if (he("{", !0)) {
				for (var ct = {}; !he("}", !0);) {
					if (!M.test(Et = j())) throw Me(Et, "name");
					if (Et === null) throw Me(Et, "end of input");
					var yt, wt = Et;
					if (he(":", !0), me() === "{") yt = Ge(Ze, Ye + "." + Et);
					else if (me() === "[") {
						yt = [];
						var Qe;
						if (he("[", !0)) {
							do Qe = it(), yt.push(Qe); while (he(",", !0));
							he("]"), typeof Qe < "u" && ze(Ze, Ye + "." + Et, Qe)
						}
					} else yt = it(), ze(Ze, Ye + "." + Et, yt);
					var At = ct[wt];
					At && (yt = [].concat(At).concat(yt)), ct[wt] = yt, he(",", !0), he(";", !0)
				}
				return ct
			}
			var Ct = it();
			return ze(Ze, Ye, Ct), Ct
		}

		function ze(Ze, Ye, ct) {
			if (_e === Ze && /^features\./.test(Ye)) {
				De[Ye] = ct;
				return
			}
			Ze.setOption && Ze.setOption(Ye, ct)
		}

		function Oe(Ze, Ye, ct, yt) {
			Ze.setParsedOption && Ze.setParsedOption(Ye, ct, yt)
		}

		function Xe(Ze) {
			if (he("[", !0)) {
				do Fe(Ze, "option"); while (he(",", !0));
				he("]")
			}
			return Ze
		}

		function rt(Ze, Ye) {
			if (!M.test(Ye = j())) throw Me(Ye, "service name");
			var ct = new m(Ye);
			nt(ct, function(wt) {
				if (!Ue(ct, wt))
					if (wt === "rpc") ut(ct, wt);
					else throw Me(wt)
			}), Ze.add(ct), Ze === _e && ke.push(ct)
		}

		function ut(Ze, Ye) {
			var ct = ce(),
				yt = Ye;
			if (!M.test(Ye = j())) throw Me(Ye, "name");
			var wt = Ye,
				Qe, At, Ct, xt;
			if (he("("), he("stream", !0) && (At = !0), !D.test(Ye = j()) || (Qe = Ye, he(")"), he("returns"), he("("),
					he("stream", !0) && (xt = !0), !D.test(Ye = j()))) throw Me(Ye);
			Ct = Ye, he(")");
			var Rt = new g(wt, yt, Qe, Ct, At, xt);
			Rt.comment = ct, nt(Rt, function(zt) {
				if (zt === "option") Fe(Rt, zt), he(";");
				else throw Me(zt)
			}), Ze.add(Rt)
		}

		function gt(Ze, Ye) {
			if (!D.test(Ye = j())) throw Me(Ye, "reference");
			var ct = Ye;
			nt(null, function(wt) {
				switch (wt) {
					case "required":
					case "repeated":
						at(Ze, wt, ct);
						break;
					case "optional":
						de === "proto3" ? at(Ze, "proto3_optional", ct) : at(Ze, "optional", ct);
						break;
					default:
						if (de === "proto2" || !D.test(wt)) throw Me(wt);
						ge(wt), at(Ze, "optional", ct);
						break
				}
			})
		}
		for (var Et;
			(Et = j()) !== null;) switch (Et) {
			case "package":
				if (!ae) throw Me(Et);
				Ae();
				break;
			case "import":
				if (!ae) throw Me(Et);
				xe();
				break;
			case "syntax":
				if (!ae) throw Me(Et);
				ye();
				break;
			case "edition":
				if (!ae) throw Me(Et);
				Le();
				break;
			case "option":
				Fe(_e, Et), he(";", !0);
				break;
			default:
				if (Ue(_e, Et)) {
					ae = !1;
					continue
				}
				throw Me(Et)
		}
		return be(), F.filename = null, {
			package: fe,
			imports: q,
			weakImports: le,
			root: O
		}
	}
	return parse_1$1
}
var common_1$1, hasRequiredCommon$1;

function requireCommon$1() {
	if (hasRequiredCommon$1) return common_1$1;
	hasRequiredCommon$1 = 1, common_1$1 = s;
	var o = /\/|\./;

	function s(l, c) {
		o.test(l) || (l = "google/protobuf/" + l + ".proto", c = {
			nested: {
				google: {
					nested: {
						protobuf: {
							nested: c
						}
					}
				}
			}
		}), s[l] = c
	}
	s("any", {
		Any: {
			fields: {
				type_url: {
					type: "string",
					id: 1
				},
				value: {
					type: "bytes",
					id: 2
				}
			}
		}
	});
	var a;
	return s("duration", {
		Duration: a = {
			fields: {
				seconds: {
					type: "int64",
					id: 1
				},
				nanos: {
					type: "int32",
					id: 2
				}
			}
		}
	}), s("timestamp", {
		Timestamp: a
	}), s("empty", {
		Empty: {
			fields: {}
		}
	}), s("struct", {
		Struct: {
			fields: {
				fields: {
					keyType: "string",
					type: "Value",
					id: 1
				}
			}
		},
		Value: {
			oneofs: {
				kind: {
					oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]
				}
			},
			fields: {
				nullValue: {
					type: "NullValue",
					id: 1
				},
				numberValue: {
					type: "double",
					id: 2
				},
				stringValue: {
					type: "string",
					id: 3
				},
				boolValue: {
					type: "bool",
					id: 4
				},
				structValue: {
					type: "Struct",
					id: 5
				},
				listValue: {
					type: "ListValue",
					id: 6
				}
			}
		},
		NullValue: {
			values: {
				NULL_VALUE: 0
			}
		},
		ListValue: {
			fields: {
				values: {
					rule: "repeated",
					type: "Value",
					id: 1
				}
			}
		}
	}), s("wrappers", {
		DoubleValue: {
			fields: {
				value: {
					type: "double",
					id: 1
				}
			}
		},
		FloatValue: {
			fields: {
				value: {
					type: "float",
					id: 1
				}
			}
		},
		Int64Value: {
			fields: {
				value: {
					type: "int64",
					id: 1
				}
			}
		},
		UInt64Value: {
			fields: {
				value: {
					type: "uint64",
					id: 1
				}
			}
		},
		Int32Value: {
			fields: {
				value: {
					type: "int32",
					id: 1
				}
			}
		},
		UInt32Value: {
			fields: {
				value: {
					type: "uint32",
					id: 1
				}
			}
		},
		BoolValue: {
			fields: {
				value: {
					type: "bool",
					id: 1
				}
			}
		},
		StringValue: {
			fields: {
				value: {
					type: "string",
					id: 1
				}
			}
		},
		BytesValue: {
			fields: {
				value: {
					type: "bytes",
					id: 1
				}
			}
		}
	}), s("field_mask", {
		FieldMask: {
			fields: {
				paths: {
					rule: "repeated",
					type: "string",
					id: 1
				}
			}
		}
	}), s.get = function(c) {
		return s[c] || null
	}, common_1$1
}
var hasRequiredSrc$1;

function requireSrc$1() {
	if (hasRequiredSrc$1) return src$1.exports;
	hasRequiredSrc$1 = 1;
	var o = src$1.exports = requireIndexLight$1();
	return o.build = "full", o.tokenize = requireTokenize$1(), o.parse = requireParse$1(), o.common = requireCommon$1(),
		o.Root._configure(o.Type, o.parse, o.common), src$1.exports
}
var protobufjs$1, hasRequiredProtobufjs$1;

function requireProtobufjs$1() {
	return hasRequiredProtobufjs$1 || (hasRequiredProtobufjs$1 = 1, protobufjs$1 = requireSrc$1()), protobufjs$1
}
var protobufjsExports = requireProtobufjs$1(),
	dist = {
		exports: {}
	},
	hasRequiredDist;

function requireDist() {
	return hasRequiredDist || (hasRequiredDist = 1, function(o) {
		(() => {
			var s = {
					570: (d, f) => {
						Object.defineProperty(f, "__esModule", {
							value: !0
						}), f.isMsgDefEqual = f.isMsgDefFieldEqual = void 0;

						function m(y, b) {
							if (Array.isArray(y) && Array.isArray(b)) {
								if (y.length !== b.length) return !1;
								for (let C = 0; C < y.length; C++)
									if (y[C] !== b[C]) return !1;
								return !0
							}
							return y === b
						}

						function g(y, b) {
							return y.type === b.type && y.name === b.name && (y.isComplex ?? !1) === (b
									.isComplex ?? !1) && (y.isArray ?? !1) === (b.isArray ?? !1) && y
								.arrayLength === b.arrayLength && (y.isConstant ?? !1) === (b
									.isConstant ?? !1) && y.value === b.value && y.valueText === b
								.valueText && y.upperBound === b.upperBound && y.arrayUpperBound === b
								.arrayUpperBound && m(y.defaultValue, b.defaultValue)
						}
						f.isMsgDefFieldEqual = g;

						function v(y, b) {
							return (y.name == null || b.name == null || y.name === b.name) && y
								.definitions.length === b.definitions.length && y.definitions.every((C,
									_) => g(C, b.definitions[_]))
						}
						f.isMsgDefEqual = v
					},
					767: function(d, f, m) {
						var g = this && this.__createBinding || (Object.create ? function(y, b, C, _) {
								_ === void 0 && (_ = C);
								var S = Object.getOwnPropertyDescriptor(b, C);
								(!S || ("get" in S ? !b.__esModule : S.writable || S
								.configurable)) && (S = {
									enumerable: !0,
									get: function() {
										return b[C]
									}
								}), Object.defineProperty(y, _, S)
							} : function(y, b, C, _) {
								_ === void 0 && (_ = C), y[_] = b[C]
							}),
							v = this && this.__exportStar || function(y, b) {
								for (var C in y) C !== "default" && !Object.prototype.hasOwnProperty
									.call(b, C) && g(b, y, C)
							};
						Object.defineProperty(f, "__esModule", {
							value: !0
						}), v(m(726), f), v(m(570), f)
					},
					726: (d, f) => {
						Object.defineProperty(f, "__esModule", {
							value: !0
						})
					},
					417: (d, f, m) => {
						m.r(f), m.d(f, {
							Md5: () => g
						});
						var g = function() {
							function v() {}
							return v.AddUnsigned = function(y, b) {
									var C, _, S, w, T;
									return S = y & 2147483648, w = b & 2147483648, C = y &
										1073741824, _ = b & 1073741824, T = (y & 1073741823) + (b &
											1073741823), C & _ ? T ^ 2147483648 ^ S ^ w : C | _ ?
										T & 1073741824 ? T ^ 3221225472 ^ S ^ w : T ^ 1073741824 ^
										S ^ w : T ^ S ^ w
								}, v.FF = function(y, b, C, _, S, w, T) {
									return y = this.AddUnsigned(y, this.AddUnsigned(this
										.AddUnsigned(this.F(b, C, _), S), T)), this.AddUnsigned(
										this.RotateLeft(y, w), b)
								}, v.GG = function(y, b, C, _, S, w, T) {
									return y = this.AddUnsigned(y, this.AddUnsigned(this
										.AddUnsigned(this.G(b, C, _), S), T)), this.AddUnsigned(
										this.RotateLeft(y, w), b)
								}, v.HH = function(y, b, C, _, S, w, T) {
									return y = this.AddUnsigned(y, this.AddUnsigned(this
										.AddUnsigned(this.H(b, C, _), S), T)), this.AddUnsigned(
										this.RotateLeft(y, w), b)
								}, v.II = function(y, b, C, _, S, w, T) {
									return y = this.AddUnsigned(y, this.AddUnsigned(this
										.AddUnsigned(this.I(b, C, _), S), T)), this.AddUnsigned(
										this.RotateLeft(y, w), b)
								}, v.ConvertToWordArray = function(y) {
									for (var b, C = y.length, _ = C + 8, S = (_ - _ % 64) / 64, w =
											(S + 1) * 16, T = Array(w - 1), A = 0, k = 0; k < C;)
										b = (k - k % 4) / 4, A = k % 4 * 8, T[b] = T[b] | y
										.charCodeAt(k) << A, k++;
									return b = (k - k % 4) / 4, A = k % 4 * 8, T[b] = T[b] | 128 <<
										A, T[w - 2] = C << 3, T[w - 1] = C >>> 29, T
								}, v.WordToHex = function(y) {
									var b = "",
										C = "",
										_, S;
									for (S = 0; S <= 3; S++) _ = y >>> S * 8 & 255, C = "0" + _
										.toString(16), b = b + C.substr(C.length - 2, 2);
									return b
								}, v.Utf8Encode = function(y) {
									var b = "",
										C;
									y = y.replace(/\r\n/g, `
`);
									for (var _ = 0; _ < y.length; _++) C = y.charCodeAt(_), C <
										128 ? b += String.fromCharCode(C) : C > 127 && C < 2048 ? (
											b += String.fromCharCode(C >> 6 | 192), b += String
											.fromCharCode(C & 63 | 128)) : (b += String
											.fromCharCode(C >> 12 | 224), b += String.fromCharCode(
												C >> 6 & 63 | 128), b += String.fromCharCode(C &
												63 | 128));
									return b
								}, v.init = function(y) {
									var b;
									for (typeof y != "string" && (y = JSON.stringify(y)), this
										._string = this.Utf8Encode(y), this.x = this
										.ConvertToWordArray(this._string), this.a = 1732584193, this
										.b = 4023233417, this.c = 2562383102, this.d = 271733878,
										this.k = 0; this.k < this.x.length; this.k += 16) this.AA =
										this.a, this.BB = this.b, this.CC = this.c, this.DD = this
										.d, this.a = this.FF(this.a, this.b, this.c, this.d, this.x[
											this.k], this.S11, 3614090360), this.d = this.FF(this.d,
											this.a, this.b, this.c, this.x[this.k + 1], this.S12,
											3905402710), this.c = this.FF(this.c, this.d, this.a,
											this.b, this.x[this.k + 2], this.S13, 606105819), this
										.b = this.FF(this.b, this.c, this.d, this.a, this.x[this.k +
											3], this.S14, 3250441966), this.a = this.FF(this.a, this
											.b, this.c, this.d, this.x[this.k + 4], this.S11,
											4118548399), this.d = this.FF(this.d, this.a, this.b,
											this.c, this.x[this.k + 5], this.S12, 1200080426), this
										.c = this.FF(this.c, this.d, this.a, this.b, this.x[this.k +
											6], this.S13, 2821735955), this.b = this.FF(this.b, this
											.c, this.d, this.a, this.x[this.k + 7], this.S14,
											4249261313), this.a = this.FF(this.a, this.b, this.c,
											this.d, this.x[this.k + 8], this.S11, 1770035416), this
										.d = this.FF(this.d, this.a, this.b, this.c, this.x[this.k +
											9], this.S12, 2336552879), this.c = this.FF(this.c, this
											.d, this.a, this.b, this.x[this.k + 10], this.S13,
											4294925233), this.b = this.FF(this.b, this.c, this.d,
											this.a, this.x[this.k + 11], this.S14, 2304563134), this
										.a = this.FF(this.a, this.b, this.c, this.d, this.x[this.k +
											12], this.S11, 1804603682), this.d = this.FF(this.d,
											this.a, this.b, this.c, this.x[this.k + 13], this.S12,
											4254626195), this.c = this.FF(this.c, this.d, this.a,
											this.b, this.x[this.k + 14], this.S13, 2792965006), this
										.b = this.FF(this.b, this.c, this.d, this.a, this.x[this.k +
											15], this.S14, 1236535329), this.a = this.GG(this.a,
											this.b, this.c, this.d, this.x[this.k + 1], this.S21,
											4129170786), this.d = this.GG(this.d, this.a, this.b,
											this.c, this.x[this.k + 6], this.S22, 3225465664), this
										.c = this.GG(this.c, this.d, this.a, this.b, this.x[this.k +
											11], this.S23, 643717713), this.b = this.GG(this.b, this
											.c, this.d, this.a, this.x[this.k], this.S24, 3921069994
											), this.a = this.GG(this.a, this.b, this.c, this.d, this
											.x[this.k + 5], this.S21, 3593408605), this.d = this.GG(
											this.d, this.a, this.b, this.c, this.x[this.k + 10],
											this.S22, 38016083), this.c = this.GG(this.c, this.d,
											this.a, this.b, this.x[this.k + 15], this.S23,
											3634488961), this.b = this.GG(this.b, this.c, this.d,
											this.a, this.x[this.k + 4], this.S24, 3889429448), this
										.a = this.GG(this.a, this.b, this.c, this.d, this.x[this.k +
											9], this.S21, 568446438), this.d = this.GG(this.d, this
											.a, this.b, this.c, this.x[this.k + 14], this.S22,
											3275163606), this.c = this.GG(this.c, this.d, this.a,
											this.b, this.x[this.k + 3], this.S23, 4107603335), this
										.b = this.GG(this.b, this.c, this.d, this.a, this.x[this.k +
											8], this.S24, 1163531501), this.a = this.GG(this.a, this
											.b, this.c, this.d, this.x[this.k + 13], this.S21,
											2850285829), this.d = this.GG(this.d, this.a, this.b,
											this.c, this.x[this.k + 2], this.S22, 4243563512), this
										.c = this.GG(this.c, this.d, this.a, this.b, this.x[this.k +
											7], this.S23, 1735328473), this.b = this.GG(this.b, this
											.c, this.d, this.a, this.x[this.k + 12], this.S24,
											2368359562), this.a = this.HH(this.a, this.b, this.c,
											this.d, this.x[this.k + 5], this.S31, 4294588738), this
										.d = this.HH(this.d, this.a, this.b, this.c, this.x[this.k +
											8], this.S32, 2272392833), this.c = this.HH(this.c, this
											.d, this.a, this.b, this.x[this.k + 11], this.S33,
											1839030562), this.b = this.HH(this.b, this.c, this.d,
											this.a, this.x[this.k + 14], this.S34, 4259657740), this
										.a = this.HH(this.a, this.b, this.c, this.d, this.x[this.k +
											1], this.S31, 2763975236), this.d = this.HH(this.d, this
											.a, this.b, this.c, this.x[this.k + 4], this.S32,
											1272893353), this.c = this.HH(this.c, this.d, this.a,
											this.b, this.x[this.k + 7], this.S33, 4139469664), this
										.b = this.HH(this.b, this.c, this.d, this.a, this.x[this.k +
											10], this.S34, 3200236656), this.a = this.HH(this.a,
											this.b, this.c, this.d, this.x[this.k + 13], this.S31,
											681279174), this.d = this.HH(this.d, this.a, this.b,
											this.c, this.x[this.k], this.S32, 3936430074), this.c =
										this.HH(this.c, this.d, this.a, this.b, this.x[this.k + 3],
											this.S33, 3572445317), this.b = this.HH(this.b, this.c,
											this.d, this.a, this.x[this.k + 6], this.S34, 76029189),
										this.a = this.HH(this.a, this.b, this.c, this.d, this.x[this
											.k + 9], this.S31, 3654602809), this.d = this.HH(this.d,
											this.a, this.b, this.c, this.x[this.k + 12], this.S32,
											3873151461), this.c = this.HH(this.c, this.d, this.a,
											this.b, this.x[this.k + 15], this.S33, 530742520), this
										.b = this.HH(this.b, this.c, this.d, this.a, this.x[this.k +
											2], this.S34, 3299628645), this.a = this.II(this.a, this
											.b, this.c, this.d, this.x[this.k], this.S41, 4096336452
											), this.d = this.II(this.d, this.a, this.b, this.c, this
											.x[this.k + 7], this.S42, 1126891415), this.c = this.II(
											this.c, this.d, this.a, this.b, this.x[this.k + 14],
											this.S43, 2878612391), this.b = this.II(this.b, this.c,
											this.d, this.a, this.x[this.k + 5], this.S44, 4237533241
											), this.a = this.II(this.a, this.b, this.c, this.d, this
											.x[this.k + 12], this.S41, 1700485571), this.d = this
										.II(this.d, this.a, this.b, this.c, this.x[this.k + 3], this
											.S42, 2399980690), this.c = this.II(this.c, this.d, this
											.a, this.b, this.x[this.k + 10], this.S43, 4293915773),
										this.b = this.II(this.b, this.c, this.d, this.a, this.x[this
											.k + 1], this.S44, 2240044497), this.a = this.II(this.a,
											this.b, this.c, this.d, this.x[this.k + 8], this.S41,
											1873313359), this.d = this.II(this.d, this.a, this.b,
											this.c, this.x[this.k + 15], this.S42, 4264355552), this
										.c = this.II(this.c, this.d, this.a, this.b, this.x[this.k +
											6], this.S43, 2734768916), this.b = this.II(this.b, this
											.c, this.d, this.a, this.x[this.k + 13], this.S44,
											1309151649), this.a = this.II(this.a, this.b, this.c,
											this.d, this.x[this.k + 4], this.S41, 4149444226), this
										.d = this.II(this.d, this.a, this.b, this.c, this.x[this.k +
											11], this.S42, 3174756917), this.c = this.II(this.c,
											this.d, this.a, this.b, this.x[this.k + 2], this.S43,
											718787259), this.b = this.II(this.b, this.c, this.d,
											this.a, this.x[this.k + 9], this.S44, 3951481745), this
										.a = this.AddUnsigned(this.a, this.AA), this.b = this
										.AddUnsigned(this.b, this.BB), this.c = this.AddUnsigned(
											this.c, this.CC), this.d = this.AddUnsigned(this.d, this
											.DD);
									return b = this.WordToHex(this.a) + this.WordToHex(this.b) +
										this.WordToHex(this.c) + this.WordToHex(this.d), b
										.toLowerCase()
								}, v.x = Array(), v.S11 = 7, v.S12 = 12, v.S13 = 17, v.S14 = 22, v
								.S21 = 5, v.S22 = 9, v.S23 = 14, v.S24 = 20, v.S31 = 4, v.S32 = 11,
								v.S33 = 16, v.S34 = 23, v.S41 = 6, v.S42 = 10, v.S43 = 15, v.S44 =
								21, v.RotateLeft = function(y, b) {
									return y << b | y >>> 32 - b
								}, v.F = function(y, b, C) {
									return y & b | ~y & C
								}, v.G = function(y, b, C) {
									return y & C | b & ~C
								}, v.H = function(y, b, C) {
									return y ^ b ^ C
								}, v.I = function(y, b, C) {
									return b ^ (y | ~C)
								}, v
						}()
					},
					271: function(d, f) {
						var m, g, v;
						(function(y, b) {
							g = [], m = b, v = typeof m == "function" ? m.apply(f, g) : m, v !==
								void 0 && (d.exports = v)
						})(this, function() {
							var y = Object.prototype.hasOwnProperty,
								b = Object.prototype.toString,
								C = typeof new RegExp().sticky == "boolean";

							function _(q) {
								return q && b.call(q) === "[object RegExp]"
							}

							function S(q) {
								return q && typeof q == "object" && !_(q) && !Array.isArray(q)
							}

							function w(q) {
								return q.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
							}

							function T(q) {
								var le = new RegExp("|" + q);
								return le.exec("").length - 1
							}

							function A(q) {
								return "(" + q + ")"
							}

							function k(q) {
								if (!q.length) return "(?!)";
								var le = q.map(function(de) {
									return "(?:" + de + ")"
								}).join("|");
								return "(?:" + le + ")"
							}

							function M(q) {
								if (typeof q == "string") return "(?:" + w(q) + ")";
								if (_(q)) {
									if (q.ignoreCase) throw new Error("RegExp /i flag not allowed");
									if (q.global) throw new Error("RegExp /g flag is implied");
									if (q.sticky) throw new Error("RegExp /y flag is implied");
									if (q.multiline) throw new Error("RegExp /m flag is implied");
									return q.source
								} else throw new Error("Not a pattern: " + q)
							}

							function D(q) {
								for (var le = Object.getOwnPropertyNames(q), de = [], _e = 0; _e <
									le.length; _e++) {
									var ke = le[_e],
										De = q[ke],
										Se = [].concat(De);
									if (ke === "include") {
										for (var be = 0; be < Se.length; be++) de.push({
											include: Se[be]
										});
										continue
									}
									var Me = [];
									Se.forEach(function(Ve) {
										S(Ve) ? (Me.length && de.push(R(ke, Me)), de.push(R(
											ke, Ve)), Me = []) : Me.push(Ve)
									}), Me.length && de.push(R(ke, Me))
								}
								return de
							}

							function F(q) {
								for (var le = [], de = 0; de < q.length; de++) {
									var _e = q[de];
									if (_e.include) {
										for (var ke = [].concat(_e.include), De = 0; De < ke
											.length; De++) le.push({
											include: ke[De]
										});
										continue
									}
									if (!_e.type) throw new Error("Rule has no type: " + JSON
										.stringify(_e));
									le.push(R(_e.type, _e))
								}
								return le
							}

							function R(q, le) {
								if (S(le) || (le = {
										match: le
									}), le.include) throw new Error(
									"Matching rules cannot also include states");
								var de = {
									defaultType: q,
									lineBreaks: !!le.error || !!le.fallback,
									pop: !1,
									next: null,
									push: null,
									error: !1,
									fallback: !1,
									value: null,
									type: null,
									shouldThrow: !1
								};
								for (var _e in le) y.call(le, _e) && (de[_e] = le[_e]);
								if (typeof de.type == "string" && q !== de.type) throw new Error(
									"Type transform cannot be a string (type '" + de.type +
									"' for token '" + q + "')");
								var ke = de.match;
								return de.match = Array.isArray(ke) ? ke : ke ? [ke] : [], de.match
									.sort(function(De, Se) {
										return _(De) && _(Se) ? 0 : _(Se) ? -1 : _(De) ? 1 : Se
											.length - De.length
									}), de
							}

							function O(q) {
								return Array.isArray(q) ? F(q) : D(q)
							}
							var U = R("error", {
								lineBreaks: !0,
								shouldThrow: !0
							});

							function V(q, le) {
								for (var de = null, _e = Object.create(null), ke = !0, De = null,
										Se = [], be = [], Me = 0; Me < q.length; Me++) q[Me]
									.fallback && (ke = !1);
								for (var Me = 0; Me < q.length; Me++) {
									var Ve = q[Me];
									if (Ve.include) throw new Error(
										"Inheritance is not allowed in stateless lexers");
									if (Ve.error || Ve.fallback) {
										if (de) throw !Ve.fallback == !de.fallback ? new Error(
											"Multiple " + (Ve.fallback ? "fallback" :
												"error") +
											" rules not allowed (for token '" + Ve
											.defaultType + "')") : new Error(
											"fallback and error are mutually exclusive (for token '" +
											Ve.defaultType + "')");
										de = Ve
									}
									var it = Ve.match.slice();
									if (ke)
										for (; it.length && typeof it[0] == "string" && it[0]
											.length === 1;) {
											var pt = it.shift();
											_e[pt.charCodeAt(0)] = Ve
										}
									if (Ve.pop || Ve.push || Ve.next) {
										if (!le) throw new Error(
											"State-switching options are not allowed in stateless lexers (for token '" +
											Ve.defaultType + "')");
										if (Ve.fallback) throw new Error(
											"State-switching options are not allowed on fallback tokens (for token '" +
											Ve.defaultType + "')")
									}
									if (it.length !== 0) {
										ke = !1, Se.push(Ve);
										for (var dt = 0; dt < it.length; dt++) {
											var He = it[dt];
											if (_(He)) {
												if (De === null) De = He.unicode;
												else if (De !== He.unicode && Ve.fallback === !1)
													throw new Error(
														"If one rule is /u then all must be")
											}
										}
										var Ae = k(it.map(M)),
											xe = new RegExp(Ae);
										if (xe.test("")) throw new Error(
											"RegExp matches empty string: " + xe);
										var ye = T(Ae);
										if (ye > 0) throw new Error("RegExp has capture groups: " +
											xe + `
Use (?: … ) instead`);
										if (!Ve.lineBreaks && xe.test(`
`)) throw new Error("Rule should declare lineBreaks: " + xe);
										be.push(A(Ae))
									}
								}
								var Le = de && de.fallback,
									Ue = C && !Le ? "ym" : "gm",
									nt = C || Le ? "" : "|";
								De === !0 && (Ue += "u");
								var ot = new RegExp(k(be) + nt, Ue);
								return {
									regexp: ot,
									groups: Se,
									fast: _e,
									error: de || U
								}
							}

							function z(q) {
								var le = V(O(q));
								return new he({
									start: le
								}, "start")
							}

							function j(q, le, de) {
								var _e = q && (q.push || q.next);
								if (_e && !de[_e]) throw new Error("Missing state '" + _e +
									"' (in token '" + q.defaultType + "' of state '" + le +
									"')");
								if (q && q.pop && +q.pop != 1) throw new Error(
									"pop must be 1 (in token '" + q.defaultType +
									"' of state '" + le + "')")
							}

							function ge(q, le) {
								var de = q.$all ? O(q.$all) : [];
								delete q.$all;
								var _e = Object.getOwnPropertyNames(q);
								le || (le = _e[0]);
								for (var ke = Object.create(null), De = 0; De < _e.length; De++) {
									var Se = _e[De];
									ke[Se] = O(q[Se]).concat(de)
								}
								for (var De = 0; De < _e.length; De++)
									for (var Se = _e[De], be = ke[Se], Me = Object.create(null),
											Ve = 0; Ve < be.length; Ve++) {
										var it = be[Ve];
										if (it.include) {
											var pt = [Ve, 1];
											if (it.include !== Se && !Me[it.include]) {
												Me[it.include] = !0;
												var dt = ke[it.include];
												if (!dt) throw new Error(
													"Cannot include nonexistent state '" +
													it.include + "' (in state '" + Se + "')"
													);
												for (var He = 0; He < dt.length; He++) {
													var Ae = dt[He];
													be.indexOf(Ae) === -1 && pt.push(Ae)
												}
											}
											be.splice.apply(be, pt), Ve--
										}
									}
								for (var xe = Object.create(null), De = 0; De < _e.length; De++) {
									var Se = _e[De];
									xe[Se] = V(ke[Se], !0)
								}
								for (var De = 0; De < _e.length; De++) {
									for (var ye = _e[De], Le = xe[ye], Ue = Le.groups, Ve = 0; Ve <
										Ue.length; Ve++) j(Ue[Ve], ye, xe);
									for (var nt = Object.getOwnPropertyNames(Le.fast), Ve = 0; Ve <
										nt.length; Ve++) j(Le.fast[nt[Ve]], ye, xe)
								}
								return new he(xe, le)
							}

							function me(q) {
								for (var le = Object.create(null), de = Object.create(null), _e =
										Object.getOwnPropertyNames(q), ke = 0; ke < _e
									.length; ke++) {
									var De = _e[ke],
										Se = q[De],
										be = Array.isArray(Se) ? Se : [Se];
									be.forEach(function(dt) {
										if ((de[dt.length] = de[dt.length] || []).push(dt),
											typeof dt != "string") throw new Error(
											"keyword must be string (in keyword '" +
											De + "')");
										le[dt] = De
									})
								}

								function Me(dt) {
									return JSON.stringify(dt)
								}
								var Ve = "";
								Ve += `switch (value.length) {
`;
								for (var it in de) {
									var pt = de[it];
									Ve += "case " + it + `:
`, Ve += `switch (value) {
`, pt.forEach(function(dt) {
										var He = le[dt];
										Ve += "case " + Me(dt) + ": return " + Me(He) + `
`
									}), Ve += `}
`
								}
								return Ve += `}
`, Function("value", Ve)
							}
							var he = function(q, le) {
								this.startState = le, this.states = q, this.buffer = "", this
									.stack = [], this.reset()
							};
							he.prototype.reset = function(q, le) {
								return this.buffer = q || "", this.index = 0, this.line = le ?
									le.line : 1, this.col = le ? le.col : 1, this.queuedToken =
									le ? le.queuedToken : null, this.queuedThrow = le ? le
									.queuedThrow : null, this.setState(le ? le.state : this
										.startState), this.stack = le && le.stack ? le.stack
									.slice() : [], this
							}, he.prototype.save = function() {
								return {
									line: this.line,
									col: this.col,
									state: this.state,
									stack: this.stack.slice(),
									queuedToken: this.queuedToken,
									queuedThrow: this.queuedThrow
								}
							}, he.prototype.setState = function(q) {
								if (!(!q || this.state === q)) {
									this.state = q;
									var le = this.states[q];
									this.groups = le.groups, this.error = le.error, this.re = le
										.regexp, this.fast = le.fast
								}
							}, he.prototype.popState = function() {
								this.setState(this.stack.pop())
							}, he.prototype.pushState = function(q) {
								this.stack.push(this.state), this.setState(q)
							};
							var ce = C ? function(q, le) {
								return q.exec(le)
							} : function(q, le) {
								var de = q.exec(le);
								return de[0].length === 0 ? null : de
							};
							he.prototype._getGroup = function(q) {
								for (var le = this.groups.length, de = 0; de < le; de++)
									if (q[de + 1] !== void 0) return this.groups[de];
								throw new Error("Cannot find token type for matched text")
							};

							function ae() {
								return this.value
							}
							if (he.prototype.next = function() {
									var q = this.index;
									if (this.queuedGroup) {
										var le = this._token(this.queuedGroup, this.queuedText, q);
										return this.queuedGroup = null, this.queuedText = "", le
									}
									var de = this.buffer;
									if (q !== de.length) {
										var Se = this.fast[de.charCodeAt(q)];
										if (Se) return this._token(Se, de.charAt(q), q);
										var _e = this.re;
										_e.lastIndex = q;
										var ke = ce(_e, de),
											De = this.error;
										if (ke == null) return this._token(De, de.slice(q, de
											.length), q);
										var Se = this._getGroup(ke),
											be = ke[0];
										return De.fallback && ke.index !== q ? (this.queuedGroup =
											Se, this.queuedText = be, this._token(De, de.slice(
												q, ke.index), q)) : this._token(Se, be, q)
									}
								}, he.prototype._token = function(q, le, de) {
									var _e = 0;
									if (q.lineBreaks) {
										var ke = /\n/g,
											De = 1;
										if (le === `
`) _e = 1;
										else
											for (; ke.exec(le);) _e++, De = ke.lastIndex
									}
									var Se = {
											type: typeof q.type == "function" && q.type(le) || q
												.defaultType,
											value: typeof q.value == "function" ? q.value(le) : le,
											text: le,
											toString: ae,
											offset: de,
											lineBreaks: _e,
											line: this.line,
											col: this.col
										},
										be = le.length;
									if (this.index += be, this.line += _e, _e !== 0 ? this.col =
										be - De + 1 : this.col += be, q.shouldThrow)
									throw new Error(this.formatError(Se, "invalid syntax"));
									return q.pop ? this.popState() : q.push ? this.pushState(q
										.push) : q.next && this.setState(q.next), Se
								}, typeof Symbol < "u" && Symbol.iterator) {
								var fe = function(q) {
									this.lexer = q
								};
								fe.prototype.next = function() {
									var q = this.lexer.next();
									return {
										value: q,
										done: !q
									}
								}, fe.prototype[Symbol.iterator] = function() {
									return this
								}, he.prototype[Symbol.iterator] = function() {
									return new fe(this)
								}
							}
							return he.prototype.formatError = function(q, le) {
								if (q == null) var de = this.buffer.slice(this.index),
									q = {
										text: de,
										offset: this.index,
										lineBreaks: de.indexOf(`
`) === -1 ? 0 : 1,
										line: this.line,
										col: this.col
									};
								var _e = Math.max(0, q.offset - q.col + 1),
									ke = q.lineBreaks ? q.text.indexOf(`
`) : q.text.length,
									De = this.buffer.substring(_e, q.offset + ke);
								return le += " at line " + q.line + " col " + q.col + `:

`, le += "  " + De + `
`, le += "  " + Array(q.col).join(" ") + "^", le
							}, he.prototype.clone = function() {
								return new he(this.states, this.state)
							}, he.prototype.has = function(q) {
								return !0
							}, {
								compile: z,
								states: ge,
								error: Object.freeze({
									error: !0
								}),
								fallback: Object.freeze({
									fallback: !0
								}),
								keywords: me
							}
						})
					},
					558: (d, f, m) => {
						(function() {
							function g(_) {
								return _[0]
							}
							const y = m(271).compile({
								space: {
									match: /\s+/,
									lineBreaks: !0
								},
								number: /-?(?:[0-9]|[1-9][0-9]+)(?:\.[0-9]+)?(?:[eE][-+]?[0-9]+)?\b/,
								comment: /#[^\n]*/,
								"[": "[",
								"]": "]",
								assignment: /=[^\n]*/,
								fieldOrType: /[a-zA-Z_][a-zA-Z0-9_]*(?:\/[a-zA-Z][a-zA-Z0-9_]*)?/
							});

							function b(_) {
								return _.reduce((S, w) => ({
									...S,
									...w
								}), {})
							}
							var C = {
								Lexer: y,
								ParserRules: [{
									name: "main$ebnf$1",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$1",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "boolType", "arrayType", "__",
										"field", "_", "main$ebnf$1", "simple"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$2",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$2",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "bigintType", "arrayType", "__",
										"field", "_", "main$ebnf$2", "simple"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$3",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$3",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "numericType", "arrayType", "__",
										"field", "_", "main$ebnf$3", "simple"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$4",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$4",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "stringType", "arrayType", "__",
										"field", "_", "main$ebnf$4", "simple"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$5",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$5",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "timeType", "arrayType", "__",
										"field", "_", "main$ebnf$5", "simple"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$6",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$6",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "customType", "arrayType", "__",
										"field", "_", "main$ebnf$6", "complex"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$7",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$7",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "boolType", "__", "constantField",
										"_", "boolConstantValue", "_", "main$ebnf$7"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$8",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$8",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "bigintType", "__", "constantField",
										"_", "bigintConstantValue", "_",
										"main$ebnf$8"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$9",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$9",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "numericType", "__", "constantField",
										"_", "numericConstantValue", "_",
										"main$ebnf$9"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main$ebnf$10",
									symbols: ["comment"],
									postprocess: g
								}, {
									name: "main$ebnf$10",
									symbols: [],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["_", "stringType", "__", "constantField",
										"_", "stringConstantValue", "_",
										"main$ebnf$10"
									],
									postprocess: function(_) {
										return b(_)
									}
								}, {
									name: "main",
									symbols: ["comment"],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "main",
									symbols: ["blankLine"],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "boolType",
									symbols: [{
										literal: "bool"
									}],
									postprocess: function(_) {
										return {
											type: _[0].value
										}
									}
								}, {
									name: "bigintType$subexpression$1",
									symbols: [{
										literal: "int64"
									}]
								}, {
									name: "bigintType$subexpression$1",
									symbols: [{
										literal: "uint64"
									}]
								}, {
									name: "bigintType",
									symbols: ["bigintType$subexpression$1"],
									postprocess: function(_) {
										return {
											type: _[0][0].value
										}
									}
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "byte"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "char"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "float32"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "float64"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "int8"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "uint8"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "int16"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "uint16"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "int32"
									}]
								}, {
									name: "numericType$subexpression$1",
									symbols: [{
										literal: "uint32"
									}]
								}, {
									name: "numericType",
									symbols: ["numericType$subexpression$1"],
									postprocess: function(_) {
										return {
											type: _[0][0].value
										}
									}
								}, {
									name: "stringType",
									symbols: [{
										literal: "string"
									}],
									postprocess: function(_) {
										return {
											type: _[0].value
										}
									}
								}, {
									name: "timeType$subexpression$1",
									symbols: [{
										literal: "time"
									}]
								}, {
									name: "timeType$subexpression$1",
									symbols: [{
										literal: "duration"
									}]
								}, {
									name: "timeType",
									symbols: ["timeType$subexpression$1"],
									postprocess: function(_) {
										return {
											type: _[0][0].value
										}
									}
								}, {
									name: "customType",
									symbols: [y.has("fieldOrType") ? {
										type: "fieldOrType"
									} : fieldOrType],
									postprocess: function(_, S, w) {
										const T = ["bool", "byte", "char",
												"float32", "float64", "int8",
												"uint8", "int16", "uint16", "int32",
												"uint32", "int64", "uint64",
												"string", "time", "duration"
											],
											A = _[0].value;
										return T.includes(A) ? w : {
											type: A
										}
									}
								}, {
									name: "arrayType",
									symbols: [{
										literal: "["
									}, "_", {
										literal: "]"
									}],
									postprocess: function(_) {
										return {
											isArray: !0
										}
									}
								}, {
									name: "arrayType",
									symbols: [{
										literal: "["
									}, "_", "number", "_", {
										literal: "]"
									}],
									postprocess: function(_) {
										return {
											isArray: !0,
											arrayLength: _[2]
										}
									}
								}, {
									name: "arrayType",
									symbols: ["_"],
									postprocess: function(_) {
										return {
											isArray: !1
										}
									}
								}, {
									name: "field",
									symbols: [y.has("fieldOrType") ? {
										type: "fieldOrType"
									} : fieldOrType],
									postprocess: function(_, S, w) {
										const T = _[0].value;
										return T.match(/^[a-zA-Z][a-zA-Z0-9_]*$/) ==
											null ? w : {
												name: T
											}
									}
								}, {
									name: "constantField",
									symbols: [y.has("fieldOrType") ? {
										type: "fieldOrType"
									} : fieldOrType],
									postprocess: function(_, S, w) {
										const T = _[0].value;
										return T.match(
											/^[a-zA-Z_][a-zA-Z0-9_]*$/) == null ?
											w : {
												name: T,
												isConstant: !0
											}
									}
								}, {
									name: "boolConstantValue",
									symbols: ["assignment"],
									postprocess: function(_, S, w) {
										const T = _[0].split("#")[0].trim();
										return T === "True" || T === "1" ? {
											value: !0,
											valueText: T
										} : T === "False" || T === "0" ? {
											value: !1,
											valueText: T
										} : w
									}
								}, {
									name: "numericConstantValue",
									symbols: ["assignment"],
									postprocess: function(_, S, w) {
										const T = _[0].split("#")[0].trim(),
											A = parseFloat(T);
										return isNaN(A) ? w : {
											value: A,
											valueText: T
										}
									}
								}, {
									name: "bigintConstantValue",
									symbols: ["assignment"],
									postprocess: function(_, S, w) {
										const T = _[0].split("#")[0].trim();
										try {
											return {
												value: BigInt(T),
												valueText: T
											}
										} catch {
											return w
										}
									}
								}, {
									name: "stringConstantValue",
									symbols: ["assignment"],
									postprocess: function(_) {
										return {
											value: _[0],
											valueText: _[0]
										}
									}
								}, {
									name: "bool$subexpression$1",
									symbols: [{
										literal: "True"
									}]
								}, {
									name: "bool$subexpression$1",
									symbols: [{
										literal: "1"
									}]
								}, {
									name: "bool",
									symbols: ["bool$subexpression$1"],
									postprocess: function(_) {
										return !0
									}
								}, {
									name: "bool$subexpression$2",
									symbols: [{
										literal: "False"
									}]
								}, {
									name: "bool$subexpression$2",
									symbols: [{
										literal: "0"
									}]
								}, {
									name: "bool",
									symbols: ["bool$subexpression$2"],
									postprocess: function(_) {
										return !1
									}
								}, {
									name: "number",
									symbols: [y.has("number") ? {
										type: "number"
									} : number],
									postprocess: function(_) {
										return parseFloat(_[0].value)
									}
								}, {
									name: "assignment",
									symbols: [y.has("assignment") ? {
										type: "assignment"
									} : assignment],
									postprocess: function(_) {
										return _[0].value.substr(1).trim()
									}
								}, {
									name: "comment",
									symbols: [y.has("comment") ? {
										type: "comment"
									} : comment],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "blankLine",
									symbols: ["_"],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "_$subexpression$1",
									symbols: []
								}, {
									name: "_$subexpression$1",
									symbols: [y.has("space") ? {
										type: "space"
									} : space]
								}, {
									name: "_",
									symbols: ["_$subexpression$1"],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "__",
									symbols: [y.has("space") ? {
										type: "space"
									} : space],
									postprocess: function(_) {
										return null
									}
								}, {
									name: "simple",
									symbols: [],
									postprocess: function() {
										return {
											isComplex: !1
										}
									}
								}, {
									name: "complex",
									symbols: [],
									postprocess: function() {
										return {
											isComplex: !0
										}
									}
								}],
								ParserStart: "main"
							};
							typeof d.exports < "u" ? d.exports = C : window.grammar = C
						})()
					},
					654: function(d) {
						(function(f, m) {
							d.exports ? d.exports = m() : f.nearley = m()
						})(this, function() {
							function f(S, w, T) {
								return this.id = ++f.highestId, this.name = S, this.symbols = w,
									this.postprocess = T, this
							}
							f.highestId = 0, f.prototype.toString = function(S) {
								var w = typeof S > "u" ? this.symbols.map(_).join(" ") : this
									.symbols.slice(0, S).map(_).join(" ") + " ● " + this.symbols
									.slice(S).map(_).join(" ");
								return this.name + " → " + w
							};

							function m(S, w, T, A) {
								this.rule = S, this.dot = w, this.reference = T, this.data = [],
									this.wantedBy = A, this.isComplete = this.dot === S.symbols
									.length
							}
							m.prototype.toString = function() {
								return "{" + this.rule.toString(this.dot) + "}, from: " + (this
									.reference || 0)
							}, m.prototype.nextState = function(S) {
								var w = new m(this.rule, this.dot + 1, this.reference, this
									.wantedBy);
								return w.left = this, w.right = S, w.isComplete && (w.data = w
									.build(), w.right = void 0), w
							}, m.prototype.build = function() {
								var S = [],
									w = this;
								do S.push(w.right.data), w = w.left; while (w.left);
								return S.reverse(), S
							}, m.prototype.finish = function() {
								this.rule.postprocess && (this.data = this.rule.postprocess(this
									.data, this.reference, b.fail))
							};

							function g(S, w) {
								this.grammar = S, this.index = w, this.states = [], this.wants = {},
									this.scannable = [], this.completed = {}
							}
							g.prototype.process = function(S) {
								for (var w = this.states, T = this.wants, A = this.completed,
										k = 0; k < w.length; k++) {
									var M = w[k];
									if (M.isComplete) {
										if (M.finish(), M.data !== b.fail) {
											for (var D = M.wantedBy, F = D.length; F--;) {
												var R = D[F];
												this.complete(R, M)
											}
											if (M.reference === this.index) {
												var O = M.rule.name;
												(this.completed[O] = this.completed[O] || [])
												.push(M)
											}
										}
									} else {
										var O = M.rule.symbols[M.dot];
										if (typeof O != "string") {
											this.scannable.push(M);
											continue
										}
										if (T[O]) {
											if (T[O].push(M), A.hasOwnProperty(O))
												for (var U = A[O], F = 0; F < U.length; F++) {
													var V = U[F];
													this.complete(M, V)
												}
										} else T[O] = [M], this.predict(O)
									}
								}
							}, g.prototype.predict = function(S) {
								for (var w = this.grammar.byName[S] || [], T = 0; T < w
									.length; T++) {
									var A = w[T],
										k = this.wants[S],
										M = new m(A, 0, this.index, k);
									this.states.push(M)
								}
							}, g.prototype.complete = function(S, w) {
								var T = S.nextState(w);
								this.states.push(T)
							};

							function v(S, w) {
								this.rules = S, this.start = w || this.rules[0].name;
								var T = this.byName = {};
								this.rules.forEach(function(A) {
									T.hasOwnProperty(A.name) || (T[A.name] = []), T[A.name]
										.push(A)
								})
							}
							v.fromCompiled = function(A, w) {
								var T = A.Lexer;
								A.ParserStart && (w = A.ParserStart, A = A.ParserRules);
								var A = A.map(function(M) {
										return new f(M.name, M.symbols, M.postprocess)
									}),
									k = new v(A, w);
								return k.lexer = T, k
							};

							function y() {
								this.reset("")
							}
							y.prototype.reset = function(S, w) {
								this.buffer = S, this.index = 0, this.line = w ? w.line : 1,
									this.lastLineBreak = w ? -w.col : 0
							}, y.prototype.next = function() {
								if (this.index < this.buffer.length) {
									var S = this.buffer[this.index++];
									return S === `
` && (this.line += 1, this.lastLineBreak = this.index), {
										value: S
									}
								}
							}, y.prototype.save = function() {
								return {
									line: this.line,
									col: this.index - this.lastLineBreak
								}
							}, y.prototype.formatError = function(S, w) {
								var T = this.buffer;
								if (typeof T == "string") {
									var A = T.split(`
`).slice(Math.max(0, this.line - 5), this.line),
										k = T.indexOf(`
`, this.index);
									k === -1 && (k = T.length);
									var M = this.index - this.lastLineBreak,
										D = String(this.line).length;
									return w += " at line " + this.line + " col " + M + `:

`, w += A.map(function(R, O) {
										return F(this.line - A.length + O + 1, D) +
											" " + R
									}, this).join(`
`), w += `
` + F("", D + M) + `^
`, w
								} else return w + " at index " + (this.index - 1);

								function F(R, O) {
									var U = String(R);
									return Array(O - U.length + 1).join(" ") + U
								}
							};

							function b(S, w, T) {
								if (S instanceof v) var A = S,
									T = w;
								else var A = v.fromCompiled(S, w);
								this.grammar = A, this.options = {
									keepHistory: !1,
									lexer: A.lexer || new y
								};
								for (var k in T || {}) this.options[k] = T[k];
								this.lexer = this.options.lexer, this.lexerState = void 0;
								var M = new g(A, 0);
								this.table = [M], M.wants[A.start] = [], M.predict(A.start), M
									.process(), this.current = 0
							}
							b.fail = {}, b.prototype.feed = function(S) {
								var w = this.lexer;
								w.reset(S, this.lexerState);
								for (var T;;) {
									try {
										if (T = w.next(), !T) break
									} catch (ge) {
										var D = new g(this.grammar, this.current + 1);
										this.table.push(D);
										var A = new Error(this.reportLexerError(ge));
										throw A.offset = this.current, A.token = ge.token, A
									}
									var k = this.table[this.current];
									this.options.keepHistory || delete this.table[this.current -
										1];
									var M = this.current + 1,
										D = new g(this.grammar, M);
									this.table.push(D);
									for (var F = T.text !== void 0 ? T.text : T.value, R = w
											.constructor === y ? T.value : T, O = k.scannable,
											U = O.length; U--;) {
										var V = O[U],
											z = V.rule.symbols[V.dot];
										if (z.test ? z.test(R) : z.type ? z.type === T.type : z
											.literal === F) {
											var j = V.nextState({
												data: R,
												token: T,
												isToken: !0,
												reference: M - 1
											});
											D.states.push(j)
										}
									}
									if (D.process(), D.states.length === 0) {
										var A = new Error(this.reportError(T));
										throw A.offset = this.current, A.token = T, A
									}
									this.options.keepHistory && (k.lexerState = w.save()), this
										.current++
								}
								return k && (this.lexerState = w.save()), this.results = this
									.finish(), this
							}, b.prototype.reportLexerError = function(S) {
								var w, T, A = S.token;
								return A ? (w = "input " + JSON.stringify(A.text[0]) +
									" (lexer error)", T = this.lexer.formatError(A,
										"Syntax error")) : (w = "input (lexer error)", T = S
									.message), this.reportErrorCommon(T, w)
							}, b.prototype.reportError = function(S) {
								var w = (S.type ? S.type + " token: " : "") + JSON.stringify(S
										.value !== void 0 ? S.value : S),
									T = this.lexer.formatError(S, "Syntax error");
								return this.reportErrorCommon(T, w)
							}, b.prototype.reportErrorCommon = function(S, w) {
								var T = [];
								T.push(S);
								var A = this.table.length - 2,
									k = this.table[A],
									M = k.states.filter(function(F) {
										var R = F.rule.symbols[F.dot];
										return R && typeof R != "string"
									});
								if (M.length === 0) T.push("Unexpected " + w + `. I did not expect any more input. Here is the state of my parse table:
`), this.displayStateStack(k.states, T);
								else {
									T.push("Unexpected " + w + `. Instead, I was expecting to see one of the following:
`);
									var D = M.map(function(F) {
										return this.buildFirstStateStack(F, []) || [F]
									}, this);
									D.forEach(function(F) {
										var R = F[0],
											O = R.rule.symbols[R.dot],
											U = this.getSymbolDisplay(O);
										T.push("A " + U + " based on:"), this
											.displayStateStack(F, T)
									}, this)
								}
								return T.push(""), T.join(`
`)
							}, b.prototype.displayStateStack = function(S, w) {
								for (var T, A = 0, k = 0; k < S.length; k++) {
									var M = S[k],
										D = M.rule.toString(M.dot);
									D === T ? A++ : (A > 0 && w.push("    ^ " + A +
										" more lines identical to this"), A = 0, w.push(
										"    " + D)), T = D
								}
							}, b.prototype.getSymbolDisplay = function(S) {
								return C(S)
							}, b.prototype.buildFirstStateStack = function(S, w) {
								if (w.indexOf(S) !== -1) return null;
								if (S.wantedBy.length === 0) return [S];
								var T = S.wantedBy[0],
									A = [S].concat(w),
									k = this.buildFirstStateStack(T, A);
								return k === null ? null : [S].concat(k)
							}, b.prototype.save = function() {
								var S = this.table[this.current];
								return S.lexerState = this.lexerState, S
							}, b.prototype.restore = function(S) {
								var w = S.index;
								this.current = w, this.table[w] = S, this.table.splice(w + 1),
									this.lexerState = S.lexerState, this.results = this.finish()
							}, b.prototype.rewind = function(S) {
								if (!this.options.keepHistory) throw new Error(
									"set option `keepHistory` to enable rewinding");
								this.restore(this.table[S])
							}, b.prototype.finish = function() {
								var S = [],
									w = this.grammar.start,
									T = this.table[this.table.length - 1];
								return T.states.forEach(function(A) {
									A.rule.name === w && A.dot === A.rule.symbols
										.length && A.reference === 0 && A.data !== b
										.fail && S.push(A)
								}), S.map(function(A) {
									return A.data
								})
							};

							function C(S) {
								var w = typeof S;
								if (w === "string") return S;
								if (w === "object") {
									if (S.literal) return JSON.stringify(S.literal);
									if (S instanceof RegExp) return "character matching " + S;
									if (S.type) return S.type + " token";
									if (S.test) return "token matching " + String(S.test);
									throw new Error("Unknown symbol type: " + S)
								}
							}

							function _(S) {
								var w = typeof S;
								if (w === "string") return S;
								if (w === "object") {
									if (S.literal) return JSON.stringify(S.literal);
									if (S instanceof RegExp) return S.toString();
									if (S.type) return "%" + S.type;
									if (S.test) return "<" + String(S.test) + ">";
									throw new Error("Unknown symbol type: " + S)
								}
							}
							return {
								Parser: b,
								Grammar: v,
								Rule: f
							}
						})
					},
					515: (d, f) => {
						Object.defineProperty(f, "__esModule", {
							value: !0
						}), f.buildRos2Type = void 0;
						const m = String.raw`(?<type>[a-zA-Z0-9_/]+)`,
							g = String.raw`(?:<=(?<stringBound>\d+))`,
							v = String
							.raw`(?:(?<unboundedArray>\[\])|\[(?<arrayLength>\d+)\]|\[<=(?<arrayBound>\d+)\])`,
							y = String.raw`(?<name>[a-zA-Z0-9_]+)`,
							b = String.raw`'(?:\\.|[^'\\])*'|"(?:\\.|[^"\\])*"`,
							C = String.raw`(?:${b}|(?:\\.|[^\s'"#\\])(?:\\.|[^#\\])*)`,
							_ = String.raw`(?:${b}|(?:\\.|[^\s'"\],#\\])(?:\\.|[^\],#\\])*)`,
							S = String.raw`\s*=\s*(?<constantValue>${C}?)`,
							w = String.raw`\[(?:${_},)*${_}?\]`,
							T = String.raw`(?<defaultValue>${w}|${C})`,
							A = String.raw`(?:#.*)`,
							k = new RegExp(String
							.raw`^${m}${g}?${v}?\s+${y}(?:${S}|\s+${T})?\s*${A}?$`),
							M = String
							.raw`\\(?<char>['"abfnrtv\\])|\\(?<oct>[0-7]{1,3})|\\x(?<hex2>[a-fA-F0-9]{2})|\\u(?<hex4>[a-fA-F0-9]{4})|\\U(?<hex8>[a-fA-F0-9]{8})`,
							D = ["bool", "byte", "char", "float32", "float64", "int8", "uint8", "int16",
								"uint16", "int32", "uint32", "int64", "uint64", "string", "wstring",
								"time", "duration", "builtin_interfaces/Time",
								"builtin_interfaces/Duration", "builtin_interfaces/msg/Time",
								"builtin_interfaces/msg/Duration"
							];

						function F(he, ce, ae) {
							const fe = BigInt(he);
							if (fe < ce || fe > ae) throw new Error(
								`Number ${he} out of range [${ce}, ${ae}]`);
							return fe
						}

						function R(he, ce, ae) {
							const fe = parseInt(he);
							if (Number.isNaN(fe)) throw new Error(`Invalid numeric literal: ${he}`);
							if (fe < ce || fe > ae) throw new Error(
								`Number ${he} out of range [${ce}, ${ae}]`);
							return fe
						}
						const O = new RegExp(_, "y"),
							U = /\s*(,)\s*|\s*$/y;

						function V(he, ce) {
							if (!ce.startsWith("[") || !ce.endsWith("]")) throw new Error(
								"Array must start with [ and end with ]");
							const ae = ce.substring(1, ce.length - 1);
							if (he === "string" || he === "wstring") {
								const fe = [];
								let q = 0;
								for (; q < ae.length;) {
									if (ae[q] === ",") throw new Error(
										"Expected array element before comma");
									O.lastIndex = q;
									let le = O.exec(ae);
									if (le && (fe.push(z(le[0])), q = O.lastIndex), U.lastIndex = q,
										le = U.exec(ae), !le) throw new Error(
										"Expected comma or end of array");
									if (!le[1]) break;
									q = U.lastIndex
								}
								return fe
							}
							return ae.split(",").map(fe => j(he, fe.trim()))
						}

						function z(he) {
							let ce = "",
								ae = he;
							for (const fe of ["'", '"'])
								if (he.startsWith(fe)) {
									if (!he.endsWith(fe)) throw new Error(
										`Expected terminating ${fe} in string literal: ${he}`);
									ce = fe, ae = he.substring(fe.length, he.length - fe.length);
									break
								} if (!new RegExp(String.raw`^(?:[^\\${ce}]|${M})*$`).test(ae) == null)
								throw new Error(`Invalid string literal: ${ae}`);
							return ae.replace(new RegExp(M, "g"), (...fe) => {
								const {
									char: q,
									oct: le,
									hex2: de,
									hex4: _e,
									hex8: ke
								} = fe[fe.length - 1], De = de ?? _e ?? ke;
								if (q != null) return {
									"'": "'",
									'"': '"',
									a: "\x07",
									b: "\b",
									f: "\f",
									n: `
`,
									r: "\r",
									t: "	",
									v: "\v",
									"\\": "\\"
								} [q];
								if (le != null) return String.fromCodePoint(parseInt(le, 8));
								if (De != null) return String.fromCodePoint(parseInt(De, 16));
								throw new Error("Expected exactly one matched group")
							})
						}

						function j(he, ce) {
							switch (he) {
								case "bool":
									if (["true", "True", "1"].includes(ce)) return !0;
									if (["false", "False", "0"].includes(ce)) return !1;
									break;
								case "float32":
								case "float64": {
									const ae = parseFloat(ce);
									if (!Number.isNaN(ae)) return ae;
									break
								}
								case "int8":
									return R(ce, -128, 127);
								case "uint8":
									return R(ce, 0, 255);
								case "int16":
									return R(ce, -32768, 32767);
								case "uint16":
									return R(ce, 0, 65535);
								case "int32":
									return R(ce, -2147483648, 2147483647);
								case "uint32":
									return R(ce, 0, 4294967295);
								case "int64":
									return F(ce, ~0x7fffffffffffffffn, 0x7fffffffffffffffn);
								case "uint64":
									return F(ce, 0n, 0xffffffffffffffffn);
								case "string":
								case "wstring":
									return z(ce)
							}
							throw new Error(`Invalid literal of type ${he}: ${ce}`)
						}

						function ge(he) {
							switch (he) {
								case "char":
									return "uint8";
								case "byte":
									return "uint8";
								case "builtin_interfaces/Time":
								case "builtin_interfaces/msg/Time":
									return "time";
								case "builtin_interfaces/Duration":
								case "builtin_interfaces/msg/Duration":
									return "duration"
							}
							return he
						}

						function me(he) {
							const ce = [];
							let ae;
							for (const {
									line: fe
								}
								of he) {
								let q;
								if (!fe.startsWith("#"))
									if (q = /^MSG: ([^ ]+)\s*(?:#.+)?$/.exec(fe)) {
										ae = q[1];
										continue
									} else if (q = k.exec(fe)) {
									const {
										type: le,
										stringBound: de,
										unboundedArray: _e,
										arrayLength: ke,
										arrayBound: De,
										name: Se,
										constantValue: be,
										defaultValue: Me
									} = q.groups, Ve = ge(le);
									if (de != null && Ve !== "string" && Ve !== "wstring")
									throw new Error(`Invalid string bound for type ${Ve}`);
									if (be != null) {
										if (!/^[A-Z](?:_?[A-Z0-9]+)*$/.test(Se)) throw new Error(
											`Invalid constant name: ${Se}`)
									} else if (!/^[a-z](?:_?[a-z0-9]+)*$/.test(Se)) throw new Error(
										`Invalid field name: ${Se}`);
									const it = !D.includes(Ve),
										pt = _e != null || ke != null || De != null;
									ce.push({
										name: Se,
										type: Ve,
										isComplex: be != null ? it || void 0 : it,
										isConstant: be != null || void 0,
										isArray: be != null ? pt || void 0 : pt,
										arrayLength: ke != null ? parseInt(ke) : void 0,
										arrayUpperBound: De != null ? parseInt(De) : void 0,
										upperBound: de != null ? parseInt(de) : void 0,
										defaultValue: Me != null ? pt ? V(Ve, Me.trim()) : j(Ve,
											Me.trim()) : void 0,
										value: be != null ? j(Ve, be.trim()) : void 0,
										valueText: be == null ? void 0 : be.trim()
									})
								} else throw new Error(`Could not parse line: '${fe}'`)
							}
							return {
								name: ae,
								definitions: ce
							}
						}
						f.buildRos2Type = me
					},
					715: function(d, f, m) {
						var g = this && this.__createBinding || (Object.create ? function(y, b, C, _) {
								_ === void 0 && (_ = C);
								var S = Object.getOwnPropertyDescriptor(b, C);
								(!S || ("get" in S ? !b.__esModule : S.writable || S
								.configurable)) && (S = {
									enumerable: !0,
									get: function() {
										return b[C]
									}
								}), Object.defineProperty(y, _, S)
							} : function(y, b, C, _) {
								_ === void 0 && (_ = C), y[_] = b[C]
							}),
							v = this && this.__exportStar || function(y, b) {
								for (var C in y) C !== "default" && !Object.prototype.hasOwnProperty
									.call(b, C) && g(b, y, C)
							};
						Object.defineProperty(f, "__esModule", {
							value: !0
						}), v(m(322), f), v(m(867), f), v(m(210), f)
					},
					322: (d, f, m) => {
						Object.defineProperty(f, "__esModule", {
							value: !0
						}), f.md5 = void 0;
						const g = m(417),
							v = new Set(["int8", "uint8", "int16", "uint16", "int32", "uint32", "int64",
								"uint64", "float32", "float64", "string", "bool", "char", "byte",
								"time", "duration"
							]);

						function y(_) {
							if (_.length === 0) throw new Error(
								"Cannot produce md5sum for empty msgDefs");
							const S = new Map;
							for (const T of _) T.name != null && S.set(T.name, T);
							const w = _[0];
							return b(w, S)
						}
						f.md5 = y;

						function b(_, S) {
							let w = "";
							const T = _.definitions.filter(({
									isConstant: k
								}) => k),
								A = _.definitions.filter(({
									isConstant: k
								}) => k == null || !k);
							for (const k of T) w += `${k.type} ${k.name}=${k.valueText??String(k.value)}
`;
							for (const k of A)
								if (C(k.type)) {
									const M = k.arrayLength != null ? String(k.arrayLength) : "",
										D = k.isArray === !0 ? `[${M}]` : "";
									w += `${k.type}${D} ${k.name}
`
								} else {
									const M = S.get(k.type);
									if (M == null) throw new Error(
										`Missing definition for submessage type "${k.type}"`);
									const D = b(M, S);
									w += `${D} ${k.name}
`
								} return w = w.trimEnd(), g.Md5.init(w)
						}

						function C(_) {
							return v.has(_)
						}
					},
					867: function(d, f, m) {
						var g = this && this.__importDefault || function(D) {
							return D && D.__esModule ? D : {
								default: D
							}
						};
						Object.defineProperty(f, "__esModule", {
							value: !0
						}), f.normalizeType = f.fixupTypes = f.parse = void 0;
						const v = m(767),
							y = m(654),
							b = m(515),
							C = g(m(558)),
							_ = y.Grammar.fromCompiled(C.default);

						function S(D, F = {}) {
							const R = D.split(`
`).map(j => j.trim()).filter(j => j);
							let O = [];
							const U = [];
							R.forEach(j => {
								j.startsWith("#") || (j.startsWith("==") ? (U.push(F.ros2 === !
										0 ? (0, b.buildRos2Type)(O) : T(O, _)), O = []) : O
									.push({
										line: j
									}))
							}), U.push(F.ros2 === !0 ? (0, b.buildRos2Type)(O) : T(O, _));
							const V = [],
								z = U.filter(j => V.find(ge => (0, v.isMsgDefEqual)(j, ge)) ? !1 : V
									.push(j));
							return F.skipTypeFixup !== !0 && w(z), z
						}
						f.parse = S;

						function w(D) {
							D.forEach(({
								definitions: F,
								name: R
							}) => {
								F.forEach(O => {
									if (O.isComplex === !0) {
										const U = R == null ? void 0 : R.split("/")
											.slice(0, -1).join("/"),
											V = k(D, O.type, U).name;
										if (V == null) throw new Error(
											`Missing type definition for ${O.type}`
											);
										O.type = V
									}
								})
							})
						}
						f.fixupTypes = w;

						function T(D, F) {
							const R = [];
							let O;
							return D.forEach(({
								line: U
							}) => {
								if (U.startsWith("MSG:")) {
									const [ge, me] = A(U);
									O = me == null ? void 0 : me.trim();
									return
								}
								const V = new y.Parser(F);
								V.feed(U);
								const z = V.finish();
								if (z.length === 0) throw new Error(
									`Could not parse line: '${U}'`);
								if (z.length > 1) throw new Error(`Ambiguous line: '${U}'`);
								const j = z[0];
								j != null && (j.type = M(j.type), R.push(j))
							}), {
								name: O,
								definitions: R
							}
						}

						function A(D) {
							return D.replace(/#.*/gi, "").split(" ").filter(F => F)
						}

						function k(D, F, R) {
							const O = D.filter(U => {
								const V = U.name ?? "";
								return F.length === 0 ? V.length === 0 : F.includes("/") ? V ===
									F : F === "Header" ? V === "std_msgs/Header" : R ? V ===
									`${R}/${F}` : V.endsWith(`/${F}`)
							});
							if (O[0] == null) throw new Error(
								`Expected 1 top level type definition for '${F}' but found ${O.length}`
								);
							if (O.length > 1) throw new Error(
								`Cannot unambiguously determine fully-qualified type name for '${F}'`
								);
							return O[0]
						}

						function M(D) {
							return D === "char" ? "uint8" : D === "byte" ? "int8" : D
						}
						f.normalizeType = M
					},
					210: (d, f) => {
						Object.defineProperty(f, "__esModule", {
							value: !0
						}), f.stringify = void 0;

						function m(v) {
							let y = "";
							for (let b = 0; b < v.length; b++) {
								const C = v[b],
									_ = C.definitions.filter(({
										isConstant: w
									}) => w),
									S = C.definitions.filter(({
										isConstant: w
									}) => w == null || !w);
								b > 0 && (y += `
================================================================================
`, y += `MSG: ${C.name??""}
`);
								for (const w of _) y += `${w.type} ${w.name} = ${w.valueText??String(w.value)}
`;
								if (S.length > 0) {
									y.length > 0 && (y += `
`);
									for (const w of S) {
										const T = w.upperBound != null ? `<=${w.upperBound}` : "",
											A = w.arrayLength != null ? String(w.arrayLength) : w
											.arrayUpperBound != null ? `<=${w.arrayUpperBound}` : "",
											k = w.isArray === !0 ? `[${A}]` : "",
											M = w.defaultValue != null ? ` ${g(w.defaultValue)}` : "";
										y += `${w.type}${T}${k} ${w.name}${M}
`
									}
								}
							}
							return y.trimEnd()
						}
						f.stringify = m;

						function g(v) {
							return Array.isArray(v) ?
								`[${v.map(y=>typeof y=="bigint"?y.toString():JSON.stringify(y)).join(", ")}]` :
								typeof v == "bigint" ? v.toString() : JSON.stringify(v)
						}
					}
				},
				a = {};

			function l(d) {
				var f = a[d];
				if (f !== void 0) return f.exports;
				var m = a[d] = {
					exports: {}
				};
				return s[d].call(m.exports, m, m.exports, l), m.exports
			}
			l.d = (d, f) => {
				for (var m in f) l.o(f, m) && !l.o(d, m) && Object.defineProperty(d, m, {
					enumerable: !0,
					get: f[m]
				})
			}, l.o = (d, f) => Object.prototype.hasOwnProperty.call(d, f), l.r = d => {
				typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(d, Symbol
					.toStringTag, {
						value: "Module"
					}), Object.defineProperty(d, "__esModule", {
					value: !0
				})
			};
			var c = l(715);
			o.exports = c
		})()
	}(dist)), dist.exports
}
var distExports = requireDist(),
	lib = {},
	conventions = {},
	hasRequiredConventions;

function requireConventions() {
	if (hasRequiredConventions) return conventions;
	hasRequiredConventions = 1;

	function o(A, k, M) {
		if (M === void 0 && (M = Array.prototype), A && typeof M.find == "function") return M.find.call(A, k);
		for (var D = 0; D < A.length; D++)
			if (a(A, D)) {
				var F = A[D];
				if (k.call(void 0, F, D, A)) return F
			}
	}

	function s(A, k) {
		return k === void 0 && (k = Object), k && typeof k.getOwnPropertyDescriptors == "function" && (A = k.create(
			null, k.getOwnPropertyDescriptors(A))), k && typeof k.freeze == "function" ? k.freeze(A) : A
	}

	function a(A, k) {
		return Object.prototype.hasOwnProperty.call(A, k)
	}

	function l(A, k) {
		if (A === null || typeof A != "object") throw new TypeError("target is not an object");
		for (var M in k) a(k, M) && (A[M] = k[M]);
		return A
	}
	var c = s({
		allowfullscreen: !0,
		async: !0,
		autofocus: !0,
		autoplay: !0,
		checked: !0,
		controls: !0,
		default: !0,
		defer: !0,
		disabled: !0,
		formnovalidate: !0,
		hidden: !0,
		ismap: !0,
		itemscope: !0,
		loop: !0,
		multiple: !0,
		muted: !0,
		nomodule: !0,
		novalidate: !0,
		open: !0,
		playsinline: !0,
		readonly: !0,
		required: !0,
		reversed: !0,
		selected: !0
	});

	function d(A) {
		return a(c, A.toLowerCase())
	}
	var f = s({
		area: !0,
		base: !0,
		br: !0,
		col: !0,
		embed: !0,
		hr: !0,
		img: !0,
		input: !0,
		link: !0,
		meta: !0,
		param: !0,
		source: !0,
		track: !0,
		wbr: !0
	});

	function m(A) {
		return a(f, A.toLowerCase())
	}
	var g = s({
		script: !1,
		style: !1,
		textarea: !0,
		title: !0
	});

	function v(A) {
		var k = A.toLowerCase();
		return a(g, k) && !g[k]
	}

	function y(A) {
		var k = A.toLowerCase();
		return a(g, k) && g[k]
	}

	function b(A) {
		return A === _.HTML
	}

	function C(A) {
		return b(A) || A === _.XML_XHTML_APPLICATION
	}
	var _ = s({
			HTML: "text/html",
			XML_APPLICATION: "application/xml",
			XML_TEXT: "text/xml",
			XML_XHTML_APPLICATION: "application/xhtml+xml",
			XML_SVG_IMAGE: "image/svg+xml"
		}),
		S = Object.keys(_).map(function(A) {
			return _[A]
		});

	function w(A) {
		return S.indexOf(A) > -1
	}
	var T = s({
		HTML: "http://www.w3.org/1999/xhtml",
		SVG: "http://www.w3.org/2000/svg",
		XML: "http://www.w3.org/XML/1998/namespace",
		XMLNS: "http://www.w3.org/2000/xmlns/"
	});
	return conventions.assign = l, conventions.find = o, conventions.freeze = s, conventions.HTML_BOOLEAN_ATTRIBUTES =
		c, conventions.HTML_RAW_TEXT_ELEMENTS = g, conventions.HTML_VOID_ELEMENTS = f, conventions
		.hasDefaultHTMLNamespace = C, conventions.hasOwn = a, conventions.isHTMLBooleanAttribute = d, conventions
		.isHTMLRawTextElement = v, conventions.isHTMLEscapableRawTextElement = y, conventions.isHTMLMimeType = b,
		conventions.isHTMLVoidElement = m, conventions.isValidMimeType = w, conventions.MIME_TYPE = _, conventions
		.NAMESPACE = T, conventions
}
var errors = {},
	hasRequiredErrors;

function requireErrors() {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	var o = requireConventions();

	function s(C, _) {
		C.prototype = Object.create(Error.prototype, {
			constructor: {
				value: C
			},
			name: {
				value: C.name,
				enumerable: !0,
				writable: _
			}
		})
	}
	var a = o.freeze({
			Error: "Error",
			IndexSizeError: "IndexSizeError",
			DomstringSizeError: "DomstringSizeError",
			HierarchyRequestError: "HierarchyRequestError",
			WrongDocumentError: "WrongDocumentError",
			InvalidCharacterError: "InvalidCharacterError",
			NoDataAllowedError: "NoDataAllowedError",
			NoModificationAllowedError: "NoModificationAllowedError",
			NotFoundError: "NotFoundError",
			NotSupportedError: "NotSupportedError",
			InUseAttributeError: "InUseAttributeError",
			InvalidStateError: "InvalidStateError",
			SyntaxError: "SyntaxError",
			InvalidModificationError: "InvalidModificationError",
			NamespaceError: "NamespaceError",
			InvalidAccessError: "InvalidAccessError",
			ValidationError: "ValidationError",
			TypeMismatchError: "TypeMismatchError",
			SecurityError: "SecurityError",
			NetworkError: "NetworkError",
			AbortError: "AbortError",
			URLMismatchError: "URLMismatchError",
			QuotaExceededError: "QuotaExceededError",
			TimeoutError: "TimeoutError",
			InvalidNodeTypeError: "InvalidNodeTypeError",
			DataCloneError: "DataCloneError",
			EncodingError: "EncodingError",
			NotReadableError: "NotReadableError",
			UnknownError: "UnknownError",
			ConstraintError: "ConstraintError",
			DataError: "DataError",
			TransactionInactiveError: "TransactionInactiveError",
			ReadOnlyError: "ReadOnlyError",
			VersionError: "VersionError",
			OperationError: "OperationError",
			NotAllowedError: "NotAllowedError",
			OptOutError: "OptOutError"
		}),
		l = Object.keys(a);

	function c(C) {
		return typeof C == "number" && C >= 1 && C <= 25
	}

	function d(C) {
		return typeof C == "string" && C.substring(C.length - a.Error.length) === a.Error
	}

	function f(C, _) {
		c(C) ? (this.name = l[C], this.message = _ || "") : (this.message = C, this.name = d(_) ? _ : a.Error), Error
			.captureStackTrace && Error.captureStackTrace(this, f)
	}
	s(f, !0), Object.defineProperties(f.prototype, {
		code: {
			enumerable: !0,
			get: function() {
				var C = l.indexOf(this.name);
				return c(C) ? C : 0
			}
		}
	});
	for (var m = {
			INDEX_SIZE_ERR: 1,
			DOMSTRING_SIZE_ERR: 2,
			HIERARCHY_REQUEST_ERR: 3,
			WRONG_DOCUMENT_ERR: 4,
			INVALID_CHARACTER_ERR: 5,
			NO_DATA_ALLOWED_ERR: 6,
			NO_MODIFICATION_ALLOWED_ERR: 7,
			NOT_FOUND_ERR: 8,
			NOT_SUPPORTED_ERR: 9,
			INUSE_ATTRIBUTE_ERR: 10,
			INVALID_STATE_ERR: 11,
			SYNTAX_ERR: 12,
			INVALID_MODIFICATION_ERR: 13,
			NAMESPACE_ERR: 14,
			INVALID_ACCESS_ERR: 15,
			VALIDATION_ERR: 16,
			TYPE_MISMATCH_ERR: 17,
			SECURITY_ERR: 18,
			NETWORK_ERR: 19,
			ABORT_ERR: 20,
			URL_MISMATCH_ERR: 21,
			QUOTA_EXCEEDED_ERR: 22,
			TIMEOUT_ERR: 23,
			INVALID_NODE_TYPE_ERR: 24,
			DATA_CLONE_ERR: 25
		}, g = Object.entries(m), v = 0; v < g.length; v++) {
		var y = g[v][0];
		f[y] = g[v][1]
	}

	function b(C, _) {
		this.message = C, this.locator = _, Error.captureStackTrace && Error.captureStackTrace(this, b)
	}
	return s(b), errors.DOMException = f, errors.DOMExceptionName = a, errors.ExceptionCode = m, errors.ParseError = b,
		errors
}
var dom = {},
	grammar = {},
	hasRequiredGrammar;

function requireGrammar() {
	if (hasRequiredGrammar) return grammar;
	hasRequiredGrammar = 1;

	function o($t) {
		try {
			typeof $t != "function" && ($t = RegExp);
			var zt = new $t("𝌆", "u").exec("𝌆");
			return !!zt && zt[0].length === 2
		} catch {}
		return !1
	}
	var s = o();

	function a($t) {
		if ($t.source[0] !== "[") throw new Error($t + " can not be used with chars");
		return $t.source.slice(1, $t.source.lastIndexOf("]"))
	}

	function l($t, zt) {
		if ($t.source[0] !== "[") throw new Error("/" + $t.source + "/ can not be used with chars_without");
		if (!zt || typeof zt != "string") throw new Error(JSON.stringify(zt) + " is not a valid search");
		if ($t.source.indexOf(zt) === -1) throw new Error('"' + zt + '" is not is /' + $t.source + "/");
		if (zt === "-" && $t.source.indexOf(zt) !== 1) throw new Error('"' + zt + '" is not at the first postion of /' +
			$t.source + "/");
		return new RegExp($t.source.replace(zt, ""), s ? "u" : "")
	}

	function c($t) {
		var zt = this;
		return new RegExp(Array.prototype.slice.call(arguments).map(function(sn) {
			var dn = typeof sn == "string";
			if (dn && zt === void 0 && sn === "|") throw new Error(
				"use regg instead of reg to wrap expressions with `|`!");
			return dn ? sn : sn.source
		}).join(""), s ? "mu" : "m")
	}

	function d($t) {
		if (arguments.length === 0) throw new Error("no parameters provided");
		return c.apply(d, ["(?:"].concat(Array.prototype.slice.call(arguments), [")"]))
	}
	var f = "�",
		m = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/;
	s && (m = c("[", a(m), "\\u{10000}-\\u{10FFFF}", "]"));
	var g = /[\x20\x09\x0D\x0A]/,
		v = a(g),
		y = c(g, "+"),
		b = c(g, "*"),
		C =
		/[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
	s && (C = c("[", a(C), "\\u{10000}-\\u{10FFFF}", "]"));
	var _ = a(C),
		S = c("[", _, a(/[-.0-9\xB7]/), a(/[\u0300-\u036F\u203F-\u2040]/), "]"),
		w = c(C, S, "*"),
		T = c(S, "+"),
		A = c("&", w, ";"),
		k = d(/&#[0-9]+;|&#x[0-9a-fA-F]+;/),
		M = d(A, "|", k),
		D = c("%", w, ";"),
		F = d(c('"', d(/[^%&"]/, "|", D, "|", M), "*", '"'), "|", c("'", d(/[^%&']/, "|", D, "|", M), "*", "'")),
		R = d('"', d(/[^<&"]/, "|", M), "*", '"', "|", "'", d(/[^<&']/, "|", M), "*", "'"),
		O = l(C, ":"),
		U = l(S, ":"),
		V = c(O, U, "*"),
		z = c(V, d(":", V), "?"),
		j = c("^", z, "$"),
		ge = c("(", z, ")"),
		me = d(/"[^"]*"|'[^']*'/),
		he = c(/^<\?/, "(", w, ")", d(y, "(", m, "*?)"), "?", /\?>/),
		ce = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/,
		ae = d('"', ce, '*"', "|", "'", l(ce, "'"), "*'"),
		fe = "<!--",
		q = "-->",
		le = c(fe, d(l(m, "-"), "|", c("-", l(m, "-"))), "*", q),
		de = "#PCDATA",
		_e = d(c(/\(/, b, de, d(b, /\|/, b, z), "*", b, /\)\*/), "|", c(/\(/, b, de, b, /\)/)),
		ke = /[?*+]?/,
		De = c(/\([^>]+\)/, ke),
		Se = d("EMPTY", "|", "ANY", "|", _e, "|", De),
		be = "<!ELEMENT",
		Me = c(be, y, d(z, "|", D), y, d(Se, "|", D), b, ">"),
		Ve = c("NOTATION", y, /\(/, b, w, d(b, /\|/, b, w), "*", b, /\)/),
		it = c(/\(/, b, T, d(b, /\|/, b, T), "*", b, /\)/),
		pt = d(Ve, "|", it),
		dt = d(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, "|", pt),
		He = d(/#REQUIRED|#IMPLIED/, "|", d(d("#FIXED", y), "?", R)),
		Ae = d(y, w, y, dt, y, He),
		xe = "<!ATTLIST",
		ye = c(xe, y, w, Ae, "*", b, ">"),
		Le = "about:legacy-compat",
		Ue = d('"' + Le + '"', "|", "'" + Le + "'"),
		nt = "SYSTEM",
		ot = "PUBLIC",
		at = d(d(nt, y, me), "|", d(ot, y, ae, y, me)),
		Je = c("^", d(d(nt, y, "(?<SystemLiteralOnly>", me, ")"), "|", d(ot, y, "(?<PubidLiteral>", ae, ")", y,
			"(?<SystemLiteral>", me, ")"))),
		Ne = d(y, "NDATA", y, w),
		we = d(F, "|", d(at, Ne, "?")),
		Ce = "<!ENTITY",
		$e = c(Ce, y, w, y, we, b, ">"),
		Fe = d(F, "|", at),
		Ge = c(Ce, y, "%", y, w, y, Fe, b, ">"),
		ze = d($e, "|", Ge),
		Oe = c(ot, y, ae),
		Xe = c("<!NOTATION", y, w, y, d(at, "|", Oe), b, ">"),
		rt = c(b, "=", b),
		ut = /1[.]\d+/,
		gt = c(y, "version", rt, d("'", ut, "'", "|", '"', ut, '"')),
		Et = /[A-Za-z][-A-Za-z0-9._]*/,
		Ze = d(y, "encoding", rt, d('"', Et, '"', "|", "'", Et, "'")),
		Ye = d(y, "standalone", rt, d("'", d("yes", "|", "no"), "'", "|", '"', d("yes", "|", "no"), '"')),
		ct = c(/^<\?xml/, gt, Ze, "?", Ye, "?", b, /\?>/),
		yt = "<!DOCTYPE",
		wt = "<![CDATA[",
		Qe = "]]>",
		At = /<!\[CDATA\[/,
		Ct = /\]\]>/,
		xt = c(m, "*?", Ct),
		Rt = c(At, xt);
	return grammar.chars = a, grammar.chars_without = l, grammar.detectUnicodeSupport = o, grammar.reg = c, grammar
		.regg = d, grammar.ABOUT_LEGACY_COMPAT = Le, grammar.ABOUT_LEGACY_COMPAT_SystemLiteral = Ue, grammar
		.AttlistDecl = ye, grammar.CDATA_START = wt, grammar.CDATA_END = Qe, grammar.CDSect = Rt, grammar.Char = m,
		grammar.Comment = le, grammar.COMMENT_START = fe, grammar.COMMENT_END = q, grammar.DOCTYPE_DECL_START = yt,
		grammar.elementdecl = Me, grammar.EntityDecl = ze, grammar.EntityValue = F, grammar.ExternalID = at, grammar
		.ExternalID_match = Je, grammar.Name = w, grammar.NotationDecl = Xe, grammar.Reference = M, grammar
		.PEReference = D, grammar.PI = he, grammar.PUBLIC = ot, grammar.PubidLiteral = ae, grammar.QName = z, grammar
		.QName_exact = j, grammar.QName_group = ge, grammar.S = y, grammar.SChar_s = v, grammar.S_OPT = b, grammar
		.SYSTEM = nt, grammar.SystemLiteral = me, grammar.UNICODE_REPLACEMENT_CHARACTER = f, grammar.UNICODE_SUPPORT =
		s, grammar.XMLDecl = ct, grammar
}
var hasRequiredDom;

function requireDom() {
	if (hasRequiredDom) return dom;
	hasRequiredDom = 1;
	var o = requireConventions(),
		s = o.find,
		a = o.hasDefaultHTMLNamespace,
		l = o.hasOwn,
		c = o.isHTMLMimeType,
		d = o.isHTMLRawTextElement,
		f = o.isHTMLVoidElement,
		m = o.MIME_TYPE,
		g = o.NAMESPACE,
		v = Symbol(),
		y = requireErrors(),
		b = y.DOMException,
		C = y.DOMExceptionName,
		_ = requireGrammar();

	function S(Te) {
		if (Te !== v) throw new TypeError("Illegal constructor")
	}

	function w(Te) {
		return Te !== ""
	}

	function T(Te) {
		return Te ? Te.split(/[\t\n\f\r ]+/).filter(w) : []
	}

	function A(Te, Pe) {
		return l(Te, Pe) || (Te[Pe] = !0), Te
	}

	function k(Te) {
		if (!Te) return [];
		var Pe = T(Te);
		return Object.keys(Pe.reduce(A, {}))
	}

	function M(Te) {
		return function(Pe) {
			return Te && Te.indexOf(Pe) !== -1
		}
	}

	function D(Te) {
		if (!_.QName_exact.test(Te)) throw new b(b.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + Te +
			'"')
	}

	function F(Te, Pe) {
		D(Pe), Te = Te || null;
		var lt = null,
			bt = Pe;
		if (Pe.indexOf(":") >= 0) {
			var Nt = Pe.split(":");
			lt = Nt[0], bt = Nt[1]
		}
		if (lt !== null && Te === null) throw new b(b.NAMESPACE_ERR, "prefix is non-null and namespace is null");
		if (lt === "xml" && Te !== o.NAMESPACE.XML) throw new b(b.NAMESPACE_ERR,
			'prefix is "xml" and namespace is not the XML namespace');
		if ((lt === "xmlns" || Pe === "xmlns") && Te !== o.NAMESPACE.XMLNS) throw new b(b.NAMESPACE_ERR,
			'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace');
		if (Te === o.NAMESPACE.XMLNS && lt !== "xmlns" && Pe !== "xmlns") throw new b(b.NAMESPACE_ERR,
			'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"');
		return [Te, lt, bt]
	}

	function R(Te, Pe) {
		for (var lt in Te) l(Te, lt) && (Pe[lt] = Te[lt])
	}

	function O(Te, Pe) {
		var lt = Te.prototype;
		if (!(lt instanceof Pe)) {
			let bt = function() {};
			bt.prototype = Pe.prototype, bt = new bt, R(lt, bt), Te.prototype = lt = bt
		}
		lt.constructor != Te && (typeof Te != "function" && console.error("unknown Class:" + Te), lt.constructor = Te)
	}
	var U = {},
		V = U.ELEMENT_NODE = 1,
		z = U.ATTRIBUTE_NODE = 2,
		j = U.TEXT_NODE = 3,
		ge = U.CDATA_SECTION_NODE = 4,
		me = U.ENTITY_REFERENCE_NODE = 5,
		he = U.ENTITY_NODE = 6,
		ce = U.PROCESSING_INSTRUCTION_NODE = 7,
		ae = U.COMMENT_NODE = 8,
		fe = U.DOCUMENT_NODE = 9,
		q = U.DOCUMENT_TYPE_NODE = 10,
		le = U.DOCUMENT_FRAGMENT_NODE = 11,
		de = U.NOTATION_NODE = 12,
		_e = o.freeze({
			DOCUMENT_POSITION_DISCONNECTED: 1,
			DOCUMENT_POSITION_PRECEDING: 2,
			DOCUMENT_POSITION_FOLLOWING: 4,
			DOCUMENT_POSITION_CONTAINS: 8,
			DOCUMENT_POSITION_CONTAINED_BY: 16,
			DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32
		});

	function ke(Te, Pe) {
		if (Pe.length < Te.length) return ke(Pe, Te);
		var lt = null;
		for (var bt in Te) {
			if (Te[bt] !== Pe[bt]) return lt;
			lt = Te[bt]
		}
		return lt
	}

	function De(Te) {
		return Te.guid || (Te.guid = Math.random()), Te.guid
	}

	function Se() {}
	Se.prototype = {
		length: 0,
		item: function(Te) {
			return Te >= 0 && Te < this.length ? this[Te] : null
		},
		toString: function(Te) {
			for (var Pe = [], lt = 0; lt < this.length; lt++) dn(this[lt], Pe, Te);
			return Pe.join("")
		},
		filter: function(Te) {
			return Array.prototype.filter.call(this, Te)
		},
		indexOf: function(Te) {
			return Array.prototype.indexOf.call(this, Te)
		}
	}, Se.prototype[Symbol.iterator] = function() {
		var Te = this,
			Pe = 0;
		return {
			next: function() {
				return Pe < Te.length ? {
					value: Te[Pe++],
					done: !1
				} : {
					done: !0
				}
			},
			return: function() {
				return {
					done: !0
				}
			}
		}
	};

	function be(Te, Pe) {
		this._node = Te, this._refresh = Pe, Me(this)
	}

	function Me(Te) {
		var Pe = Te._node._inc || Te._node.ownerDocument._inc;
		if (Te._inc !== Pe) {
			var lt = Te._refresh(Te._node);
			if (pn(Te, "length", lt.length), !Te.$$length || lt.length < Te.$$length)
				for (var bt = lt.length; bt in Te; bt++) l(Te, bt) && delete Te[bt];
			R(lt, Te), Te._inc = Pe
		}
	}
	be.prototype.item = function(Te) {
		return Me(this), this[Te] || null
	}, O(be, Se);

	function Ve() {}

	function it(Te, Pe) {
		for (var lt = 0; lt < Te.length;) {
			if (Te[lt] === Pe) return lt;
			lt++
		}
	}

	function pt(Te, Pe, lt, bt) {
		if (bt ? Pe[it(Pe, bt)] = lt : (Pe[Pe.length] = lt, Pe.length++), Te) {
			lt.ownerElement = Te;
			var Nt = Te.ownerDocument;
			Nt && (bt && nt(Nt, Te, bt), Ue(Nt, Te, lt))
		}
	}

	function dt(Te, Pe, lt) {
		var bt = it(Pe, lt);
		if (bt >= 0) {
			for (var Nt = Pe.length - 1; bt <= Nt;) Pe[bt] = Pe[++bt];
			if (Pe.length = Nt, Te) {
				var Ot = Te.ownerDocument;
				Ot && nt(Ot, Te, lt), lt.ownerElement = null
			}
		}
	}
	Ve.prototype = {
		length: 0,
		item: Se.prototype.item,
		getNamedItem: function(Te) {
			this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace() && (Te = Te.toLowerCase());
			for (var Pe = 0; Pe < this.length;) {
				var lt = this[Pe];
				if (lt.nodeName === Te) return lt;
				Pe++
			}
			return null
		},
		setNamedItem: function(Te) {
			var Pe = Te.ownerElement;
			if (Pe && Pe !== this._ownerElement) throw new b(b.INUSE_ATTRIBUTE_ERR);
			var lt = this.getNamedItemNS(Te.namespaceURI, Te.localName);
			return lt === Te ? Te : (pt(this._ownerElement, this, Te, lt), lt)
		},
		setNamedItemNS: function(Te) {
			return this.setNamedItem(Te)
		},
		removeNamedItem: function(Te) {
			var Pe = this.getNamedItem(Te);
			if (!Pe) throw new b(b.NOT_FOUND_ERR, Te);
			return dt(this._ownerElement, this, Pe), Pe
		},
		removeNamedItemNS: function(Te, Pe) {
			var lt = this.getNamedItemNS(Te, Pe);
			if (!lt) throw new b(b.NOT_FOUND_ERR, Te ? Te + " : " + Pe : Pe);
			return dt(this._ownerElement, this, lt), lt
		},
		getNamedItemNS: function(Te, Pe) {
			Te || (Te = null);
			for (var lt = 0; lt < this.length;) {
				var bt = this[lt];
				if (bt.localName === Pe && bt.namespaceURI === Te) return bt;
				lt++
			}
			return null
		}
	}, Ve.prototype[Symbol.iterator] = function() {
		var Te = this,
			Pe = 0;
		return {
			next: function() {
				return Pe < Te.length ? {
					value: Te[Pe++],
					done: !1
				} : {
					done: !0
				}
			},
			return: function() {
				return {
					done: !0
				}
			}
		}
	};

	function He() {}
	He.prototype = {
		hasFeature: function(Te, Pe) {
			return !0
		},
		createDocument: function(Te, Pe, lt) {
			var bt = m.XML_APPLICATION;
			Te === g.HTML ? bt = m.XML_XHTML_APPLICATION : Te === g.SVG && (bt = m.XML_SVG_IMAGE);
			var Nt = new Le(v, {
				contentType: bt
			});
			if (Nt.implementation = this, Nt.childNodes = new Se, Nt.doctype = lt || null, lt && Nt.appendChild(
					lt), Pe) {
				var Ot = Nt.createElementNS(Te, Pe);
				Nt.appendChild(Ot)
			}
			return Nt
		},
		createDocumentType: function(Te, Pe, lt, bt) {
			D(Te);
			var Nt = new yt(v);
			return Nt.name = Te, Nt.nodeName = Te, Nt.publicId = Pe || "", Nt.systemId = lt || "", Nt
				.internalSubset = bt || "", Nt.childNodes = new Se, Nt
		},
		createHTMLDocument: function(Te) {
			var Pe = new Le(v, {
				contentType: m.HTML
			});
			if (Pe.implementation = this, Pe.childNodes = new Se, Te !== !1) {
				Pe.doctype = this.createDocumentType("html"), Pe.doctype.ownerDocument = Pe, Pe.appendChild(Pe
					.doctype);
				var lt = Pe.createElement("html");
				Pe.appendChild(lt);
				var bt = Pe.createElement("head");
				if (lt.appendChild(bt), typeof Te == "string") {
					var Nt = Pe.createElement("title");
					Nt.appendChild(Pe.createTextNode(Te)), bt.appendChild(Nt)
				}
				lt.appendChild(Pe.createElement("body"))
			}
			return Pe
		}
	};

	function Ae(Te) {
		S(Te)
	}
	Ae.prototype = {
		firstChild: null,
		lastChild: null,
		previousSibling: null,
		nextSibling: null,
		parentNode: null,
		get parentElement() {
			return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null
		},
		childNodes: null,
		ownerDocument: null,
		nodeValue: null,
		namespaceURI: null,
		prefix: null,
		localName: null,
		baseURI: "about:blank",
		get isConnected() {
			var Te = this.getRootNode();
			return Te && Te.nodeType === Te.DOCUMENT_NODE
		},
		contains: function(Te) {
			if (!Te) return !1;
			var Pe = Te;
			do {
				if (this === Pe) return !0;
				Pe = Te.parentNode
			} while (Pe);
			return !1
		},
		getRootNode: function(Te) {
			var Pe = this;
			do {
				if (!Pe.parentNode) return Pe;
				Pe = Pe.parentNode
			} while (Pe)
		},
		isEqualNode: function(Te) {
			if (!Te || this.nodeType !== Te.nodeType) return !1;
			switch (this.nodeType) {
				case this.DOCUMENT_TYPE_NODE:
					if (this.name !== Te.name || this.publicId !== Te.publicId || this.systemId !== Te.systemId)
						return !1;
					break;
				case this.ELEMENT_NODE:
					if (this.namespaceURI !== Te.namespaceURI || this.prefix !== Te.prefix || this.localName !==
						Te.localName || this.attributes.length !== Te.attributes.length) return !1;
					for (var Pe = 0; Pe < this.attributes.length; Pe++) {
						var lt = this.attributes.item(Pe);
						if (!lt.isEqualNode(Te.getAttributeNodeNS(lt.namespaceURI, lt.localName))) return !1
					}
					break;
				case this.ATTRIBUTE_NODE:
					if (this.namespaceURI !== Te.namespaceURI || this.localName !== Te.localName || this
						.value !== Te.value) return !1;
					break;
				case this.PROCESSING_INSTRUCTION_NODE:
					if (this.target !== Te.target || this.data !== Te.data) return !1;
					break;
				case this.TEXT_NODE:
				case this.COMMENT_NODE:
					if (this.data !== Te.data) return !1;
					break
			}
			if (this.childNodes.length !== Te.childNodes.length) return !1;
			for (var Pe = 0; Pe < this.childNodes.length; Pe++)
				if (!this.childNodes[Pe].isEqualNode(Te.childNodes[Pe])) return !1;
			return !0
		},
		isSameNode: function(Te) {
			return this === Te
		},
		insertBefore: function(Te, Pe) {
			return rt(this, Te, Pe)
		},
		replaceChild: function(Te, Pe) {
			rt(this, Te, Pe, Xe), Pe && this.removeChild(Pe)
		},
		removeChild: function(Te) {
			return at(this, Te)
		},
		appendChild: function(Te) {
			return this.insertBefore(Te, null)
		},
		hasChildNodes: function() {
			return this.firstChild != null
		},
		cloneNode: function(Te) {
			return qt(this.ownerDocument || this, this, Te)
		},
		normalize: function() {
			for (var Te = this.firstChild; Te;) {
				var Pe = Te.nextSibling;
				Pe && Pe.nodeType == j && Te.nodeType == j ? (this.removeChild(Pe), Te.appendData(Pe.data)) : (
					Te.normalize(), Te = Pe)
			}
		},
		isSupported: function(Te, Pe) {
			return this.ownerDocument.implementation.hasFeature(Te, Pe)
		},
		lookupPrefix: function(Te) {
			for (var Pe = this; Pe;) {
				var lt = Pe._nsMap;
				if (lt) {
					for (var bt in lt)
						if (l(lt, bt) && lt[bt] === Te) return bt
				}
				Pe = Pe.nodeType == z ? Pe.ownerDocument : Pe.parentNode
			}
			return null
		},
		lookupNamespaceURI: function(Te) {
			for (var Pe = this; Pe;) {
				var lt = Pe._nsMap;
				if (lt && l(lt, Te)) return lt[Te];
				Pe = Pe.nodeType == z ? Pe.ownerDocument : Pe.parentNode
			}
			return null
		},
		isDefaultNamespace: function(Te) {
			var Pe = this.lookupPrefix(Te);
			return Pe == null
		},
		compareDocumentPosition: function(Te) {
			if (this === Te) return 0;
			var Pe = Te,
				lt = this,
				bt = null,
				Nt = null;
			if (Pe instanceof gt && (bt = Pe, Pe = bt.ownerElement), lt instanceof gt && (Nt = lt, lt = Nt
					.ownerElement, bt && Pe && lt === Pe))
				for (var Ot = 0, nn; nn = lt.attributes[Ot]; Ot++) {
					if (nn === bt) return _e.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + _e
						.DOCUMENT_POSITION_PRECEDING;
					if (nn === Nt) return _e.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + _e
						.DOCUMENT_POSITION_FOLLOWING
				}
			if (!Pe || !lt || lt.ownerDocument !== Pe.ownerDocument) return _e.DOCUMENT_POSITION_DISCONNECTED +
				_e.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (De(lt.ownerDocument) > De(Pe
					.ownerDocument) ? _e.DOCUMENT_POSITION_FOLLOWING : _e.DOCUMENT_POSITION_PRECEDING);
			if (Nt && Pe === lt) return _e.DOCUMENT_POSITION_CONTAINS + _e.DOCUMENT_POSITION_PRECEDING;
			if (bt && Pe === lt) return _e.DOCUMENT_POSITION_CONTAINED_BY + _e.DOCUMENT_POSITION_FOLLOWING;
			for (var Cn = [], wn = Pe.parentNode; wn;) {
				if (!Nt && wn === lt) return _e.DOCUMENT_POSITION_CONTAINED_BY + _e.DOCUMENT_POSITION_FOLLOWING;
				Cn.push(wn), wn = wn.parentNode
			}
			Cn.reverse();
			for (var Mn = [], fn = lt.parentNode; fn;) {
				if (!bt && fn === Pe) return _e.DOCUMENT_POSITION_CONTAINS + _e.DOCUMENT_POSITION_PRECEDING;
				Mn.push(fn), fn = fn.parentNode
			}
			Mn.reverse();
			var zn = ke(Cn, Mn);
			for (var On in zn.childNodes) {
				var Nn = zn.childNodes[On];
				if (Nn === lt) return _e.DOCUMENT_POSITION_FOLLOWING;
				if (Nn === Pe) return _e.DOCUMENT_POSITION_PRECEDING;
				if (Mn.indexOf(Nn) >= 0) return _e.DOCUMENT_POSITION_FOLLOWING;
				if (Cn.indexOf(Nn) >= 0) return _e.DOCUMENT_POSITION_PRECEDING
			}
			return 0
		}
	};

	function xe(Te) {
		return Te == "<" && "&lt;" || Te == ">" && "&gt;" || Te == "&" && "&amp;" || Te == '"' && "&quot;" || "&#" + Te
			.charCodeAt() + ";"
	}
	R(U, Ae), R(U, Ae.prototype), R(_e, Ae), R(_e, Ae.prototype);

	function ye(Te, Pe) {
		if (Pe(Te)) return !0;
		if (Te = Te.firstChild)
			do
				if (ye(Te, Pe)) return !0; while (Te = Te.nextSibling)
	}

	function Le(Te, Pe) {
		S(Te);
		var lt = Pe || {};
		this.ownerDocument = this, this.contentType = lt.contentType || m.XML_APPLICATION, this.type = c(this
			.contentType) ? "html" : "xml"
	}

	function Ue(Te, Pe, lt) {
		Te && Te._inc++;
		var bt = lt.namespaceURI;
		bt === g.XMLNS && (Pe._nsMap[lt.prefix ? lt.localName : ""] = lt.value)
	}

	function nt(Te, Pe, lt, bt) {
		Te && Te._inc++;
		var Nt = lt.namespaceURI;
		Nt === g.XMLNS && delete Pe._nsMap[lt.prefix ? lt.localName : ""]
	}

	function ot(Te, Pe, lt) {
		if (Te && Te._inc) {
			Te._inc++;
			var bt = Pe.childNodes;
			if (lt && !lt.nextSibling) bt[bt.length++] = lt;
			else {
				for (var Nt = Pe.firstChild, Ot = 0; Nt;) bt[Ot++] = Nt, Nt = Nt.nextSibling;
				bt.length = Ot, delete bt[bt.length]
			}
		}
	}

	function at(Te, Pe) {
		if (Te !== Pe.parentNode) throw new b(b.NOT_FOUND_ERR, "child's parent is not parent");
		var lt = Pe.previousSibling,
			bt = Pe.nextSibling;
		return lt ? lt.nextSibling = bt : Te.firstChild = bt, bt ? bt.previousSibling = lt : Te.lastChild = lt, ot(Te
			.ownerDocument, Te), Pe.parentNode = null, Pe.previousSibling = null, Pe.nextSibling = null, Pe
	}

	function Je(Te) {
		return Te && (Te.nodeType === Ae.DOCUMENT_NODE || Te.nodeType === Ae.DOCUMENT_FRAGMENT_NODE || Te.nodeType ===
			Ae.ELEMENT_NODE)
	}

	function Ne(Te) {
		return Te && (Te.nodeType === Ae.CDATA_SECTION_NODE || Te.nodeType === Ae.COMMENT_NODE || Te.nodeType === Ae
			.DOCUMENT_FRAGMENT_NODE || Te.nodeType === Ae.DOCUMENT_TYPE_NODE || Te.nodeType === Ae.ELEMENT_NODE ||
			Te.nodeType === Ae.PROCESSING_INSTRUCTION_NODE || Te.nodeType === Ae.TEXT_NODE)
	}

	function we(Te) {
		return Te && Te.nodeType === Ae.DOCUMENT_TYPE_NODE
	}

	function Ce(Te) {
		return Te && Te.nodeType === Ae.ELEMENT_NODE
	}

	function $e(Te) {
		return Te && Te.nodeType === Ae.TEXT_NODE
	}

	function Fe(Te, Pe) {
		var lt = Te.childNodes || [];
		if (s(lt, Ce) || we(Pe)) return !1;
		var bt = s(lt, we);
		return !(Pe && bt && lt.indexOf(bt) > lt.indexOf(Pe))
	}

	function Ge(Te, Pe) {
		var lt = Te.childNodes || [];

		function bt(Ot) {
			return Ce(Ot) && Ot !== Pe
		}
		if (s(lt, bt)) return !1;
		var Nt = s(lt, we);
		return !(Pe && Nt && lt.indexOf(Nt) > lt.indexOf(Pe))
	}

	function ze(Te, Pe, lt) {
		if (!Je(Te)) throw new b(b.HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + Te.nodeType);
		if (lt && lt.parentNode !== Te) throw new b(b.NOT_FOUND_ERR, "child not in parent");
		if (!Ne(Pe) || we(Pe) && Te.nodeType !== Ae.DOCUMENT_NODE) throw new b(b.HIERARCHY_REQUEST_ERR,
			"Unexpected node type " + Pe.nodeType + " for parent node type " + Te.nodeType)
	}

	function Oe(Te, Pe, lt) {
		var bt = Te.childNodes || [],
			Nt = Pe.childNodes || [];
		if (Pe.nodeType === Ae.DOCUMENT_FRAGMENT_NODE) {
			var Ot = Nt.filter(Ce);
			if (Ot.length > 1 || s(Nt, $e)) throw new b(b.HIERARCHY_REQUEST_ERR,
				"More than one element or text in fragment");
			if (Ot.length === 1 && !Fe(Te, lt)) throw new b(b.HIERARCHY_REQUEST_ERR,
				"Element in fragment can not be inserted before doctype")
		}
		if (Ce(Pe) && !Fe(Te, lt)) throw new b(b.HIERARCHY_REQUEST_ERR,
			"Only one element can be added and only after doctype");
		if (we(Pe)) {
			if (s(bt, we)) throw new b(b.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
			var nn = s(bt, Ce);
			if (lt && bt.indexOf(nn) < bt.indexOf(lt)) throw new b(b.HIERARCHY_REQUEST_ERR,
				"Doctype can only be inserted before an element");
			if (!lt && nn) throw new b(b.HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present")
		}
	}

	function Xe(Te, Pe, lt) {
		var bt = Te.childNodes || [],
			Nt = Pe.childNodes || [];
		if (Pe.nodeType === Ae.DOCUMENT_FRAGMENT_NODE) {
			var Ot = Nt.filter(Ce);
			if (Ot.length > 1 || s(Nt, $e)) throw new b(b.HIERARCHY_REQUEST_ERR,
				"More than one element or text in fragment");
			if (Ot.length === 1 && !Ge(Te, lt)) throw new b(b.HIERARCHY_REQUEST_ERR,
				"Element in fragment can not be inserted before doctype")
		}
		if (Ce(Pe) && !Ge(Te, lt)) throw new b(b.HIERARCHY_REQUEST_ERR,
			"Only one element can be added and only after doctype");
		if (we(Pe)) {
			if (s(bt, function(wn) {
					return we(wn) && wn !== lt
				})) throw new b(b.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
			var nn = s(bt, Ce);
			if (lt && bt.indexOf(nn) < bt.indexOf(lt)) throw new b(b.HIERARCHY_REQUEST_ERR,
				"Doctype can only be inserted before an element")
		}
	}

	function rt(Te, Pe, lt, bt) {
		ze(Te, Pe, lt), Te.nodeType === Ae.DOCUMENT_NODE && (bt || Oe)(Te, Pe, lt);
		var Nt = Pe.parentNode;
		if (Nt && Nt.removeChild(Pe), Pe.nodeType === le) {
			var Ot = Pe.firstChild;
			if (Ot == null) return Pe;
			var nn = Pe.lastChild
		} else Ot = nn = Pe;
		var Cn = lt ? lt.previousSibling : Te.lastChild;
		Ot.previousSibling = Cn, nn.nextSibling = lt, Cn ? Cn.nextSibling = Ot : Te.firstChild = Ot, lt == null ? Te
			.lastChild = nn : lt.previousSibling = nn;
		do Ot.parentNode = Te; while (Ot !== nn && (Ot = Ot.nextSibling));
		return ot(Te.ownerDocument || Te, Te, Pe), Pe.nodeType == le && (Pe.firstChild = Pe.lastChild = null), Pe
	}
	Le.prototype = {
		implementation: null,
		nodeName: "#document",
		nodeType: fe,
		doctype: null,
		documentElement: null,
		_inc: 1,
		insertBefore: function(Te, Pe) {
			if (Te.nodeType === le) {
				for (var lt = Te.firstChild; lt;) {
					var bt = lt.nextSibling;
					this.insertBefore(lt, Pe), lt = bt
				}
				return Te
			}
			return rt(this, Te, Pe), Te.ownerDocument = this, this.documentElement === null && Te.nodeType ===
				V && (this.documentElement = Te), Te
		},
		removeChild: function(Te) {
			var Pe = at(this, Te);
			return Pe === this.documentElement && (this.documentElement = null), Pe
		},
		replaceChild: function(Te, Pe) {
			rt(this, Te, Pe, Xe), Te.ownerDocument = this, Pe && this.removeChild(Pe), Ce(Te) && (this
				.documentElement = Te)
		},
		importNode: function(Te, Pe) {
			return Mt(this, Te, Pe)
		},
		getElementById: function(Te) {
			var Pe = null;
			return ye(this.documentElement, function(lt) {
				if (lt.nodeType == V && lt.getAttribute("id") == Te) return Pe = lt, !0
			}), Pe
		},
		createElement: function(Te) {
			var Pe = new ut(v);
			Pe.ownerDocument = this, this.type === "html" && (Te = Te.toLowerCase()), a(this.contentType) && (Pe
					.namespaceURI = g.HTML), Pe.nodeName = Te, Pe.tagName = Te, Pe.localName = Te, Pe
				.childNodes = new Se;
			var lt = Pe.attributes = new Ve;
			return lt._ownerElement = Pe, Pe
		},
		createDocumentFragment: function() {
			var Te = new Ct(v);
			return Te.ownerDocument = this, Te.childNodes = new Se, Te
		},
		createTextNode: function(Te) {
			var Pe = new Ze(v);
			return Pe.ownerDocument = this, Pe.childNodes = new Se, Pe.appendData(Te), Pe
		},
		createComment: function(Te) {
			var Pe = new Ye(v);
			return Pe.ownerDocument = this, Pe.childNodes = new Se, Pe.appendData(Te), Pe
		},
		createCDATASection: function(Te) {
			var Pe = new ct(v);
			return Pe.ownerDocument = this, Pe.childNodes = new Se, Pe.appendData(Te), Pe
		},
		createProcessingInstruction: function(Te, Pe) {
			var lt = new xt(v);
			return lt.ownerDocument = this, lt.childNodes = new Se, lt.nodeName = lt.target = Te, lt.nodeValue =
				lt.data = Pe, lt
		},
		createAttribute: function(Te) {
			if (!_.QName_exact.test(Te)) throw new b(b.INVALID_CHARACTER_ERR, 'invalid character in name "' +
				Te + '"');
			return this.type === "html" && (Te = Te.toLowerCase()), this._createAttribute(Te)
		},
		_createAttribute: function(Te) {
			var Pe = new gt(v);
			return Pe.ownerDocument = this, Pe.childNodes = new Se, Pe.name = Te, Pe.nodeName = Te, Pe
				.localName = Te, Pe.specified = !0, Pe
		},
		createEntityReference: function(Te) {
			if (!_.Name.test(Te)) throw new b(b.INVALID_CHARACTER_ERR, 'not a valid xml name "' + Te + '"');
			if (this.type === "html") throw new b("document is an html document", C.NotSupportedError);
			var Pe = new At(v);
			return Pe.ownerDocument = this, Pe.childNodes = new Se, Pe.nodeName = Te, Pe
		},
		createElementNS: function(Te, Pe) {
			var lt = F(Te, Pe),
				bt = new ut(v),
				Nt = bt.attributes = new Ve;
			return bt.childNodes = new Se, bt.ownerDocument = this, bt.nodeName = Pe, bt.tagName = Pe, bt
				.namespaceURI = lt[0], bt.prefix = lt[1], bt.localName = lt[2], Nt._ownerElement = bt, bt
		},
		createAttributeNS: function(Te, Pe) {
			var lt = F(Te, Pe),
				bt = new gt(v);
			return bt.ownerDocument = this, bt.childNodes = new Se, bt.nodeName = Pe, bt.name = Pe, bt
				.specified = !0, bt.namespaceURI = lt[0], bt.prefix = lt[1], bt.localName = lt[2], bt
		}
	}, O(Le, Ae);

	function ut(Te) {
		S(Te), this._nsMap = Object.create(null)
	}
	ut.prototype = {
			nodeType: V,
			attributes: null,
			getQualifiedName: function() {
				return this.prefix ? this.prefix + ":" + this.localName : this.localName
			},
			_isInHTMLDocumentAndNamespace: function() {
				return this.ownerDocument.type === "html" && this.namespaceURI === g.HTML
			},
			hasAttributes: function() {
				return !!(this.attributes && this.attributes.length)
			},
			hasAttribute: function(Te) {
				return !!this.getAttributeNode(Te)
			},
			getAttribute: function(Te) {
				var Pe = this.getAttributeNode(Te);
				return Pe ? Pe.value : null
			},
			getAttributeNode: function(Te) {
				return this._isInHTMLDocumentAndNamespace() && (Te = Te.toLowerCase()), this.attributes
					.getNamedItem(Te)
			},
			setAttribute: function(Te, Pe) {
				this._isInHTMLDocumentAndNamespace() && (Te = Te.toLowerCase());
				var lt = this.getAttributeNode(Te);
				lt ? lt.value = lt.nodeValue = "" + Pe : (lt = this.ownerDocument._createAttribute(Te), lt.value =
					lt.nodeValue = "" + Pe, this.setAttributeNode(lt))
			},
			removeAttribute: function(Te) {
				var Pe = this.getAttributeNode(Te);
				Pe && this.removeAttributeNode(Pe)
			},
			setAttributeNode: function(Te) {
				return this.attributes.setNamedItem(Te)
			},
			setAttributeNodeNS: function(Te) {
				return this.attributes.setNamedItemNS(Te)
			},
			removeAttributeNode: function(Te) {
				return this.attributes.removeNamedItem(Te.nodeName)
			},
			removeAttributeNS: function(Te, Pe) {
				var lt = this.getAttributeNodeNS(Te, Pe);
				lt && this.removeAttributeNode(lt)
			},
			hasAttributeNS: function(Te, Pe) {
				return this.getAttributeNodeNS(Te, Pe) != null
			},
			getAttributeNS: function(Te, Pe) {
				var lt = this.getAttributeNodeNS(Te, Pe);
				return lt ? lt.value : null
			},
			setAttributeNS: function(Te, Pe, lt) {
				var bt = F(Te, Pe),
					Nt = bt[2],
					Ot = this.getAttributeNodeNS(Te, Nt);
				Ot ? Ot.value = Ot.nodeValue = "" + lt : (Ot = this.ownerDocument.createAttributeNS(Te, Pe), Ot
					.value = Ot.nodeValue = "" + lt, this.setAttributeNode(Ot))
			},
			getAttributeNodeNS: function(Te, Pe) {
				return this.attributes.getNamedItemNS(Te, Pe)
			},
			getElementsByClassName: function(Te) {
				var Pe = k(Te);
				return new be(this, function(lt) {
					var bt = [];
					return Pe.length > 0 && ye(lt, function(Nt) {
						if (Nt !== lt && Nt.nodeType === V) {
							var Ot = Nt.getAttribute("class");
							if (Ot) {
								var nn = Te === Ot;
								if (!nn) {
									var Cn = k(Ot);
									nn = Pe.every(M(Cn))
								}
								nn && bt.push(Nt)
							}
						}
					}), bt
				})
			},
			getElementsByTagName: function(Te) {
				var Pe = (this.nodeType === fe ? this : this.ownerDocument).type === "html",
					lt = Te.toLowerCase();
				return new be(this, function(bt) {
					var Nt = [];
					return ye(bt, function(Ot) {
						if (!(Ot === bt || Ot.nodeType !== V))
							if (Te === "*") Nt.push(Ot);
							else {
								var nn = Ot.getQualifiedName(),
									Cn = Pe && Ot.namespaceURI === g.HTML ? lt : Te;
								nn === Cn && Nt.push(Ot)
							}
					}), Nt
				})
			},
			getElementsByTagNameNS: function(Te, Pe) {
				return new be(this, function(lt) {
					var bt = [];
					return ye(lt, function(Nt) {
						Nt !== lt && Nt.nodeType === V && (Te === "*" || Nt.namespaceURI === Te) &&
							(Pe === "*" || Nt.localName == Pe) && bt.push(Nt)
					}), bt
				})
			}
		}, Le.prototype.getElementsByClassName = ut.prototype.getElementsByClassName, Le.prototype
		.getElementsByTagName = ut.prototype.getElementsByTagName, Le.prototype.getElementsByTagNameNS = ut.prototype
		.getElementsByTagNameNS, O(ut, Ae);

	function gt(Te) {
		S(Te), this.namespaceURI = null, this.prefix = null, this.ownerElement = null
	}
	gt.prototype.nodeType = z, O(gt, Ae);

	function Et(Te) {
		S(Te)
	}
	Et.prototype = {
		data: "",
		substringData: function(Te, Pe) {
			return this.data.substring(Te, Te + Pe)
		},
		appendData: function(Te) {
			Te = this.data + Te, this.nodeValue = this.data = Te, this.length = Te.length
		},
		insertData: function(Te, Pe) {
			this.replaceData(Te, 0, Pe)
		},
		deleteData: function(Te, Pe) {
			this.replaceData(Te, Pe, "")
		},
		replaceData: function(Te, Pe, lt) {
			var bt = this.data.substring(0, Te),
				Nt = this.data.substring(Te + Pe);
			lt = bt + lt + Nt, this.nodeValue = this.data = lt, this.length = lt.length
		}
	}, O(Et, Ae);

	function Ze(Te) {
		S(Te)
	}
	Ze.prototype = {
		nodeName: "#text",
		nodeType: j,
		splitText: function(Te) {
			var Pe = this.data,
				lt = Pe.substring(Te);
			Pe = Pe.substring(0, Te), this.data = this.nodeValue = Pe, this.length = Pe.length;
			var bt = this.ownerDocument.createTextNode(lt);
			return this.parentNode && this.parentNode.insertBefore(bt, this.nextSibling), bt
		}
	}, O(Ze, Et);

	function Ye(Te) {
		S(Te)
	}
	Ye.prototype = {
		nodeName: "#comment",
		nodeType: ae
	}, O(Ye, Et);

	function ct(Te) {
		S(Te)
	}
	ct.prototype = {
		nodeName: "#cdata-section",
		nodeType: ge
	}, O(ct, Ze);

	function yt(Te) {
		S(Te)
	}
	yt.prototype.nodeType = q, O(yt, Ae);

	function wt(Te) {
		S(Te)
	}
	wt.prototype.nodeType = de, O(wt, Ae);

	function Qe(Te) {
		S(Te)
	}
	Qe.prototype.nodeType = he, O(Qe, Ae);

	function At(Te) {
		S(Te)
	}
	At.prototype.nodeType = me, O(At, Ae);

	function Ct(Te) {
		S(Te)
	}
	Ct.prototype.nodeName = "#document-fragment", Ct.prototype.nodeType = le, O(Ct, Ae);

	function xt(Te) {
		S(Te)
	}
	xt.prototype.nodeType = ce, O(xt, Et);

	function Rt() {}
	Rt.prototype.serializeToString = function(Te, Pe) {
		return $t.call(Te, Pe)
	}, Ae.prototype.toString = $t;

	function $t(Te) {
		var Pe = [],
			lt = this.nodeType === fe && this.documentElement || this,
			bt = lt.prefix,
			Nt = lt.namespaceURI;
		if (Nt && bt == null) {
			var bt = lt.lookupPrefix(Nt);
			if (bt == null) var Ot = [{
				namespace: Nt,
				prefix: null
			}]
		}
		return dn(this, Pe, Te, Ot), Pe.join("")
	}

	function zt(Te, Pe, lt) {
		var bt = Te.prefix || "",
			Nt = Te.namespaceURI;
		if (!Nt || bt === "xml" && Nt === g.XML || Nt === g.XMLNS) return !1;
		for (var Ot = lt.length; Ot--;) {
			var nn = lt[Ot];
			if (nn.prefix === bt) return nn.namespace !== Nt
		}
		return !0
	}

	function sn(Te, Pe, lt) {
		Te.push(" ", Pe, '="', lt.replace(/[<>&"\t\n\r]/g, xe), '"')
	}

	function dn(Te, Pe, lt, bt) {
		bt || (bt = []);
		var Nt = Te.nodeType === fe ? Te : Te.ownerDocument,
			Ot = Nt.type === "html";
		if (lt)
			if (Te = lt(Te), Te) {
				if (typeof Te == "string") {
					Pe.push(Te);
					return
				}
			} else return;
		switch (Te.nodeType) {
			case V:
				var nn = Te.attributes,
					Cn = nn.length,
					ft = Te.firstChild,
					wn = Te.tagName,
					Mn = wn;
				if (!Ot && !Te.prefix && Te.namespaceURI) {
					for (var fn, zn = 0; zn < nn.length; zn++)
						if (nn.item(zn).name === "xmlns") {
							fn = nn.item(zn).value;
							break
						} if (!fn)
						for (var On = bt.length - 1; On >= 0; On--) {
							var Nn = bt[On];
							if (Nn.prefix === "" && Nn.namespace === Te.namespaceURI) {
								fn = Nn.namespace;
								break
							}
						}
					if (fn !== Te.namespaceURI)
						for (var On = bt.length - 1; On >= 0; On--) {
							var Nn = bt[On];
							if (Nn.namespace === Te.namespaceURI) {
								Nn.prefix && (Mn = Nn.prefix + ":" + wn);
								break
							}
						}
				}
				Pe.push("<", Mn);
				for (var An = 0; An < Cn; An++) {
					var $n = nn.item(An);
					$n.prefix == "xmlns" ? bt.push({
						prefix: $n.localName,
						namespace: $n.value
					}) : $n.nodeName == "xmlns" && bt.push({
						prefix: "",
						namespace: $n.value
					})
				}
				for (var An = 0; An < Cn; An++) {
					var $n = nn.item(An);
					if (zt($n, Ot, bt)) {
						var Rn = $n.prefix || "",
							We = $n.namespaceURI;
						sn(Pe, Rn ? "xmlns:" + Rn : "xmlns", We), bt.push({
							prefix: Rn,
							namespace: We
						})
					}
					dn($n, Pe, lt, bt)
				}
				if (wn === Mn && zt(Te, Ot, bt)) {
					var Rn = Te.prefix || "",
						We = Te.namespaceURI;
					sn(Pe, Rn ? "xmlns:" + Rn : "xmlns", We), bt.push({
						prefix: Rn,
						namespace: We
					})
				}
				var et = !ft;
				if (et && (Ot || Te.namespaceURI === g.HTML) && (et = f(wn)), et) Pe.push("/>");
				else {
					if (Pe.push(">"), Ot && d(wn))
						for (; ft;) ft.data ? Pe.push(ft.data) : dn(ft, Pe, lt, bt.slice()), ft = ft.nextSibling;
					else
						for (; ft;) dn(ft, Pe, lt, bt.slice()), ft = ft.nextSibling;
					Pe.push("</", Mn, ">")
				}
				return;
			case fe:
			case le:
				for (var ft = Te.firstChild; ft;) dn(ft, Pe, lt, bt.slice()), ft = ft.nextSibling;
				return;
			case z:
				return sn(Pe, Te.name, Te.value);
			case j:
				return Pe.push(Te.data.replace(/[<&>]/g, xe));
			case ge:
				return Pe.push(_.CDATA_START, Te.data, _.CDATA_END);
			case ae:
				return Pe.push(_.COMMENT_START, Te.data, _.COMMENT_END);
			case q:
				var vt = Te.publicId,
					mt = Te.systemId;
				Pe.push(_.DOCTYPE_DECL_START, " ", Te.name), vt ? (Pe.push(" ", _.PUBLIC, " ", vt), mt && mt !== "." &&
						Pe.push(" ", mt)) : mt && mt !== "." && Pe.push(" ", _.SYSTEM, " ", mt), Te.internalSubset && Pe
					.push(" [", Te.internalSubset, "]"), Pe.push(">");
				return;
			case ce:
				return Pe.push("<?", Te.target, " ", Te.data, "?>");
			case me:
				return Pe.push("&", Te.nodeName, ";");
			default:
				Pe.push("??", Te.nodeName)
		}
	}

	function Mt(Te, Pe, lt) {
		var bt;
		switch (Pe.nodeType) {
			case V:
				bt = Pe.cloneNode(!1), bt.ownerDocument = Te;
			case le:
				break;
			case z:
				lt = !0;
				break
		}
		if (bt || (bt = Pe.cloneNode(!1)), bt.ownerDocument = Te, bt.parentNode = null, lt)
			for (var Nt = Pe.firstChild; Nt;) bt.appendChild(Mt(Te, Nt, lt)), Nt = Nt.nextSibling;
		return bt
	}

	function qt(Te, Pe, lt) {
		var bt = new Pe.constructor(v);
		for (var Nt in Pe)
			if (l(Pe, Nt)) {
				var Ot = Pe[Nt];
				typeof Ot != "object" && Ot != bt[Nt] && (bt[Nt] = Ot)
			} switch (Pe.childNodes && (bt.childNodes = new Se), bt.ownerDocument = Te, bt.nodeType) {
			case V:
				var nn = Pe.attributes,
					Cn = bt.attributes = new Ve,
					wn = nn.length;
				Cn._ownerElement = bt;
				for (var Mn = 0; Mn < wn; Mn++) bt.setAttributeNode(qt(Te, nn.item(Mn), !0));
				break;
			case z:
				lt = !0
		}
		if (lt)
			for (var fn = Pe.firstChild; fn;) bt.appendChild(qt(Te, fn, lt)), fn = fn.nextSibling;
		return bt
	}

	function pn(Te, Pe, lt) {
		Te[Pe] = lt
	}
	try {
		if (Object.defineProperty) {
			let Te = function(Pe) {
				switch (Pe.nodeType) {
					case V:
					case le:
						var lt = [];
						for (Pe = Pe.firstChild; Pe;) Pe.nodeType !== 7 && Pe.nodeType !== 8 && lt.push(Te(Pe)),
							Pe = Pe.nextSibling;
						return lt.join("");
					default:
						return Pe.nodeValue
				}
			};
			Object.defineProperty(be.prototype, "length", {
				get: function() {
					return Me(this), this.$$length
				}
			}), Object.defineProperty(Ae.prototype, "textContent", {
				get: function() {
					return Te(this)
				},
				set: function(Pe) {
					switch (this.nodeType) {
						case V:
						case le:
							for (; this.firstChild;) this.removeChild(this.firstChild);
							(Pe || String(Pe)) && this.appendChild(this.ownerDocument.createTextNode(Pe));
							break;
						default:
							this.data = Pe, this.value = Pe, this.nodeValue = Pe
					}
				}
			}), pn = function(Pe, lt, bt) {
				Pe["$$" + lt] = bt
			}
		}
	} catch {}
	return dom._updateLiveList = Me, dom.Attr = gt, dom.CDATASection = ct, dom.CharacterData = Et, dom.Comment = Ye, dom
		.Document = Le, dom.DocumentFragment = Ct, dom.DocumentType = yt, dom.DOMImplementation = He, dom.Element = ut,
		dom.Entity = Qe, dom.EntityReference = At, dom.LiveNodeList = be, dom.NamedNodeMap = Ve, dom.Node = Ae, dom
		.NodeList = Se, dom.Notation = wt, dom.Text = Ze, dom.ProcessingInstruction = xt, dom.XMLSerializer = Rt, dom
}
var domParser = {},
	entities = {},
	hasRequiredEntities;

function requireEntities() {
	return hasRequiredEntities || (hasRequiredEntities = 1, function(o) {
		var s = requireConventions().freeze;
		o.XML_ENTITIES = s({
			amp: "&",
			apos: "'",
			gt: ">",
			lt: "<",
			quot: '"'
		}), o.HTML_ENTITIES = s({
			Aacute: "Á",
			aacute: "á",
			Abreve: "Ă",
			abreve: "ă",
			ac: "∾",
			acd: "∿",
			acE: "∾̳",
			Acirc: "Â",
			acirc: "â",
			acute: "´",
			Acy: "А",
			acy: "а",
			AElig: "Æ",
			aelig: "æ",
			af: "⁡",
			Afr: "𝔄",
			afr: "𝔞",
			Agrave: "À",
			agrave: "à",
			alefsym: "ℵ",
			aleph: "ℵ",
			Alpha: "Α",
			alpha: "α",
			Amacr: "Ā",
			amacr: "ā",
			amalg: "⨿",
			AMP: "&",
			amp: "&",
			And: "⩓",
			and: "∧",
			andand: "⩕",
			andd: "⩜",
			andslope: "⩘",
			andv: "⩚",
			ang: "∠",
			ange: "⦤",
			angle: "∠",
			angmsd: "∡",
			angmsdaa: "⦨",
			angmsdab: "⦩",
			angmsdac: "⦪",
			angmsdad: "⦫",
			angmsdae: "⦬",
			angmsdaf: "⦭",
			angmsdag: "⦮",
			angmsdah: "⦯",
			angrt: "∟",
			angrtvb: "⊾",
			angrtvbd: "⦝",
			angsph: "∢",
			angst: "Å",
			angzarr: "⍼",
			Aogon: "Ą",
			aogon: "ą",
			Aopf: "𝔸",
			aopf: "𝕒",
			ap: "≈",
			apacir: "⩯",
			apE: "⩰",
			ape: "≊",
			apid: "≋",
			apos: "'",
			ApplyFunction: "⁡",
			approx: "≈",
			approxeq: "≊",
			Aring: "Å",
			aring: "å",
			Ascr: "𝒜",
			ascr: "𝒶",
			Assign: "≔",
			ast: "*",
			asymp: "≈",
			asympeq: "≍",
			Atilde: "Ã",
			atilde: "ã",
			Auml: "Ä",
			auml: "ä",
			awconint: "∳",
			awint: "⨑",
			backcong: "≌",
			backepsilon: "϶",
			backprime: "‵",
			backsim: "∽",
			backsimeq: "⋍",
			Backslash: "∖",
			Barv: "⫧",
			barvee: "⊽",
			Barwed: "⌆",
			barwed: "⌅",
			barwedge: "⌅",
			bbrk: "⎵",
			bbrktbrk: "⎶",
			bcong: "≌",
			Bcy: "Б",
			bcy: "б",
			bdquo: "„",
			becaus: "∵",
			Because: "∵",
			because: "∵",
			bemptyv: "⦰",
			bepsi: "϶",
			bernou: "ℬ",
			Bernoullis: "ℬ",
			Beta: "Β",
			beta: "β",
			beth: "ℶ",
			between: "≬",
			Bfr: "𝔅",
			bfr: "𝔟",
			bigcap: "⋂",
			bigcirc: "◯",
			bigcup: "⋃",
			bigodot: "⨀",
			bigoplus: "⨁",
			bigotimes: "⨂",
			bigsqcup: "⨆",
			bigstar: "★",
			bigtriangledown: "▽",
			bigtriangleup: "△",
			biguplus: "⨄",
			bigvee: "⋁",
			bigwedge: "⋀",
			bkarow: "⤍",
			blacklozenge: "⧫",
			blacksquare: "▪",
			blacktriangle: "▴",
			blacktriangledown: "▾",
			blacktriangleleft: "◂",
			blacktriangleright: "▸",
			blank: "␣",
			blk12: "▒",
			blk14: "░",
			blk34: "▓",
			block: "█",
			bne: "=⃥",
			bnequiv: "≡⃥",
			bNot: "⫭",
			bnot: "⌐",
			Bopf: "𝔹",
			bopf: "𝕓",
			bot: "⊥",
			bottom: "⊥",
			bowtie: "⋈",
			boxbox: "⧉",
			boxDL: "╗",
			boxDl: "╖",
			boxdL: "╕",
			boxdl: "┐",
			boxDR: "╔",
			boxDr: "╓",
			boxdR: "╒",
			boxdr: "┌",
			boxH: "═",
			boxh: "─",
			boxHD: "╦",
			boxHd: "╤",
			boxhD: "╥",
			boxhd: "┬",
			boxHU: "╩",
			boxHu: "╧",
			boxhU: "╨",
			boxhu: "┴",
			boxminus: "⊟",
			boxplus: "⊞",
			boxtimes: "⊠",
			boxUL: "╝",
			boxUl: "╜",
			boxuL: "╛",
			boxul: "┘",
			boxUR: "╚",
			boxUr: "╙",
			boxuR: "╘",
			boxur: "└",
			boxV: "║",
			boxv: "│",
			boxVH: "╬",
			boxVh: "╫",
			boxvH: "╪",
			boxvh: "┼",
			boxVL: "╣",
			boxVl: "╢",
			boxvL: "╡",
			boxvl: "┤",
			boxVR: "╠",
			boxVr: "╟",
			boxvR: "╞",
			boxvr: "├",
			bprime: "‵",
			Breve: "˘",
			breve: "˘",
			brvbar: "¦",
			Bscr: "ℬ",
			bscr: "𝒷",
			bsemi: "⁏",
			bsim: "∽",
			bsime: "⋍",
			bsol: "\\",
			bsolb: "⧅",
			bsolhsub: "⟈",
			bull: "•",
			bullet: "•",
			bump: "≎",
			bumpE: "⪮",
			bumpe: "≏",
			Bumpeq: "≎",
			bumpeq: "≏",
			Cacute: "Ć",
			cacute: "ć",
			Cap: "⋒",
			cap: "∩",
			capand: "⩄",
			capbrcup: "⩉",
			capcap: "⩋",
			capcup: "⩇",
			capdot: "⩀",
			CapitalDifferentialD: "ⅅ",
			caps: "∩︀",
			caret: "⁁",
			caron: "ˇ",
			Cayleys: "ℭ",
			ccaps: "⩍",
			Ccaron: "Č",
			ccaron: "č",
			Ccedil: "Ç",
			ccedil: "ç",
			Ccirc: "Ĉ",
			ccirc: "ĉ",
			Cconint: "∰",
			ccups: "⩌",
			ccupssm: "⩐",
			Cdot: "Ċ",
			cdot: "ċ",
			cedil: "¸",
			Cedilla: "¸",
			cemptyv: "⦲",
			cent: "¢",
			CenterDot: "·",
			centerdot: "·",
			Cfr: "ℭ",
			cfr: "𝔠",
			CHcy: "Ч",
			chcy: "ч",
			check: "✓",
			checkmark: "✓",
			Chi: "Χ",
			chi: "χ",
			cir: "○",
			circ: "ˆ",
			circeq: "≗",
			circlearrowleft: "↺",
			circlearrowright: "↻",
			circledast: "⊛",
			circledcirc: "⊚",
			circleddash: "⊝",
			CircleDot: "⊙",
			circledR: "®",
			circledS: "Ⓢ",
			CircleMinus: "⊖",
			CirclePlus: "⊕",
			CircleTimes: "⊗",
			cirE: "⧃",
			cire: "≗",
			cirfnint: "⨐",
			cirmid: "⫯",
			cirscir: "⧂",
			ClockwiseContourIntegral: "∲",
			CloseCurlyDoubleQuote: "”",
			CloseCurlyQuote: "’",
			clubs: "♣",
			clubsuit: "♣",
			Colon: "∷",
			colon: ":",
			Colone: "⩴",
			colone: "≔",
			coloneq: "≔",
			comma: ",",
			commat: "@",
			comp: "∁",
			compfn: "∘",
			complement: "∁",
			complexes: "ℂ",
			cong: "≅",
			congdot: "⩭",
			Congruent: "≡",
			Conint: "∯",
			conint: "∮",
			ContourIntegral: "∮",
			Copf: "ℂ",
			copf: "𝕔",
			coprod: "∐",
			Coproduct: "∐",
			COPY: "©",
			copy: "©",
			copysr: "℗",
			CounterClockwiseContourIntegral: "∳",
			crarr: "↵",
			Cross: "⨯",
			cross: "✗",
			Cscr: "𝒞",
			cscr: "𝒸",
			csub: "⫏",
			csube: "⫑",
			csup: "⫐",
			csupe: "⫒",
			ctdot: "⋯",
			cudarrl: "⤸",
			cudarrr: "⤵",
			cuepr: "⋞",
			cuesc: "⋟",
			cularr: "↶",
			cularrp: "⤽",
			Cup: "⋓",
			cup: "∪",
			cupbrcap: "⩈",
			CupCap: "≍",
			cupcap: "⩆",
			cupcup: "⩊",
			cupdot: "⊍",
			cupor: "⩅",
			cups: "∪︀",
			curarr: "↷",
			curarrm: "⤼",
			curlyeqprec: "⋞",
			curlyeqsucc: "⋟",
			curlyvee: "⋎",
			curlywedge: "⋏",
			curren: "¤",
			curvearrowleft: "↶",
			curvearrowright: "↷",
			cuvee: "⋎",
			cuwed: "⋏",
			cwconint: "∲",
			cwint: "∱",
			cylcty: "⌭",
			Dagger: "‡",
			dagger: "†",
			daleth: "ℸ",
			Darr: "↡",
			dArr: "⇓",
			darr: "↓",
			dash: "‐",
			Dashv: "⫤",
			dashv: "⊣",
			dbkarow: "⤏",
			dblac: "˝",
			Dcaron: "Ď",
			dcaron: "ď",
			Dcy: "Д",
			dcy: "д",
			DD: "ⅅ",
			dd: "ⅆ",
			ddagger: "‡",
			ddarr: "⇊",
			DDotrahd: "⤑",
			ddotseq: "⩷",
			deg: "°",
			Del: "∇",
			Delta: "Δ",
			delta: "δ",
			demptyv: "⦱",
			dfisht: "⥿",
			Dfr: "𝔇",
			dfr: "𝔡",
			dHar: "⥥",
			dharl: "⇃",
			dharr: "⇂",
			DiacriticalAcute: "´",
			DiacriticalDot: "˙",
			DiacriticalDoubleAcute: "˝",
			DiacriticalGrave: "`",
			DiacriticalTilde: "˜",
			diam: "⋄",
			Diamond: "⋄",
			diamond: "⋄",
			diamondsuit: "♦",
			diams: "♦",
			die: "¨",
			DifferentialD: "ⅆ",
			digamma: "ϝ",
			disin: "⋲",
			div: "÷",
			divide: "÷",
			divideontimes: "⋇",
			divonx: "⋇",
			DJcy: "Ђ",
			djcy: "ђ",
			dlcorn: "⌞",
			dlcrop: "⌍",
			dollar: "$",
			Dopf: "𝔻",
			dopf: "𝕕",
			Dot: "¨",
			dot: "˙",
			DotDot: "⃜",
			doteq: "≐",
			doteqdot: "≑",
			DotEqual: "≐",
			dotminus: "∸",
			dotplus: "∔",
			dotsquare: "⊡",
			doublebarwedge: "⌆",
			DoubleContourIntegral: "∯",
			DoubleDot: "¨",
			DoubleDownArrow: "⇓",
			DoubleLeftArrow: "⇐",
			DoubleLeftRightArrow: "⇔",
			DoubleLeftTee: "⫤",
			DoubleLongLeftArrow: "⟸",
			DoubleLongLeftRightArrow: "⟺",
			DoubleLongRightArrow: "⟹",
			DoubleRightArrow: "⇒",
			DoubleRightTee: "⊨",
			DoubleUpArrow: "⇑",
			DoubleUpDownArrow: "⇕",
			DoubleVerticalBar: "∥",
			DownArrow: "↓",
			Downarrow: "⇓",
			downarrow: "↓",
			DownArrowBar: "⤓",
			DownArrowUpArrow: "⇵",
			DownBreve: "̑",
			downdownarrows: "⇊",
			downharpoonleft: "⇃",
			downharpoonright: "⇂",
			DownLeftRightVector: "⥐",
			DownLeftTeeVector: "⥞",
			DownLeftVector: "↽",
			DownLeftVectorBar: "⥖",
			DownRightTeeVector: "⥟",
			DownRightVector: "⇁",
			DownRightVectorBar: "⥗",
			DownTee: "⊤",
			DownTeeArrow: "↧",
			drbkarow: "⤐",
			drcorn: "⌟",
			drcrop: "⌌",
			Dscr: "𝒟",
			dscr: "𝒹",
			DScy: "Ѕ",
			dscy: "ѕ",
			dsol: "⧶",
			Dstrok: "Đ",
			dstrok: "đ",
			dtdot: "⋱",
			dtri: "▿",
			dtrif: "▾",
			duarr: "⇵",
			duhar: "⥯",
			dwangle: "⦦",
			DZcy: "Џ",
			dzcy: "џ",
			dzigrarr: "⟿",
			Eacute: "É",
			eacute: "é",
			easter: "⩮",
			Ecaron: "Ě",
			ecaron: "ě",
			ecir: "≖",
			Ecirc: "Ê",
			ecirc: "ê",
			ecolon: "≕",
			Ecy: "Э",
			ecy: "э",
			eDDot: "⩷",
			Edot: "Ė",
			eDot: "≑",
			edot: "ė",
			ee: "ⅇ",
			efDot: "≒",
			Efr: "𝔈",
			efr: "𝔢",
			eg: "⪚",
			Egrave: "È",
			egrave: "è",
			egs: "⪖",
			egsdot: "⪘",
			el: "⪙",
			Element: "∈",
			elinters: "⏧",
			ell: "ℓ",
			els: "⪕",
			elsdot: "⪗",
			Emacr: "Ē",
			emacr: "ē",
			empty: "∅",
			emptyset: "∅",
			EmptySmallSquare: "◻",
			emptyv: "∅",
			EmptyVerySmallSquare: "▫",
			emsp: " ",
			emsp13: " ",
			emsp14: " ",
			ENG: "Ŋ",
			eng: "ŋ",
			ensp: " ",
			Eogon: "Ę",
			eogon: "ę",
			Eopf: "𝔼",
			eopf: "𝕖",
			epar: "⋕",
			eparsl: "⧣",
			eplus: "⩱",
			epsi: "ε",
			Epsilon: "Ε",
			epsilon: "ε",
			epsiv: "ϵ",
			eqcirc: "≖",
			eqcolon: "≕",
			eqsim: "≂",
			eqslantgtr: "⪖",
			eqslantless: "⪕",
			Equal: "⩵",
			equals: "=",
			EqualTilde: "≂",
			equest: "≟",
			Equilibrium: "⇌",
			equiv: "≡",
			equivDD: "⩸",
			eqvparsl: "⧥",
			erarr: "⥱",
			erDot: "≓",
			Escr: "ℰ",
			escr: "ℯ",
			esdot: "≐",
			Esim: "⩳",
			esim: "≂",
			Eta: "Η",
			eta: "η",
			ETH: "Ð",
			eth: "ð",
			Euml: "Ë",
			euml: "ë",
			euro: "€",
			excl: "!",
			exist: "∃",
			Exists: "∃",
			expectation: "ℰ",
			ExponentialE: "ⅇ",
			exponentiale: "ⅇ",
			fallingdotseq: "≒",
			Fcy: "Ф",
			fcy: "ф",
			female: "♀",
			ffilig: "ﬃ",
			fflig: "ﬀ",
			ffllig: "ﬄ",
			Ffr: "𝔉",
			ffr: "𝔣",
			filig: "ﬁ",
			FilledSmallSquare: "◼",
			FilledVerySmallSquare: "▪",
			fjlig: "fj",
			flat: "♭",
			fllig: "ﬂ",
			fltns: "▱",
			fnof: "ƒ",
			Fopf: "𝔽",
			fopf: "𝕗",
			ForAll: "∀",
			forall: "∀",
			fork: "⋔",
			forkv: "⫙",
			Fouriertrf: "ℱ",
			fpartint: "⨍",
			frac12: "½",
			frac13: "⅓",
			frac14: "¼",
			frac15: "⅕",
			frac16: "⅙",
			frac18: "⅛",
			frac23: "⅔",
			frac25: "⅖",
			frac34: "¾",
			frac35: "⅗",
			frac38: "⅜",
			frac45: "⅘",
			frac56: "⅚",
			frac58: "⅝",
			frac78: "⅞",
			frasl: "⁄",
			frown: "⌢",
			Fscr: "ℱ",
			fscr: "𝒻",
			gacute: "ǵ",
			Gamma: "Γ",
			gamma: "γ",
			Gammad: "Ϝ",
			gammad: "ϝ",
			gap: "⪆",
			Gbreve: "Ğ",
			gbreve: "ğ",
			Gcedil: "Ģ",
			Gcirc: "Ĝ",
			gcirc: "ĝ",
			Gcy: "Г",
			gcy: "г",
			Gdot: "Ġ",
			gdot: "ġ",
			gE: "≧",
			ge: "≥",
			gEl: "⪌",
			gel: "⋛",
			geq: "≥",
			geqq: "≧",
			geqslant: "⩾",
			ges: "⩾",
			gescc: "⪩",
			gesdot: "⪀",
			gesdoto: "⪂",
			gesdotol: "⪄",
			gesl: "⋛︀",
			gesles: "⪔",
			Gfr: "𝔊",
			gfr: "𝔤",
			Gg: "⋙",
			gg: "≫",
			ggg: "⋙",
			gimel: "ℷ",
			GJcy: "Ѓ",
			gjcy: "ѓ",
			gl: "≷",
			gla: "⪥",
			glE: "⪒",
			glj: "⪤",
			gnap: "⪊",
			gnapprox: "⪊",
			gnE: "≩",
			gne: "⪈",
			gneq: "⪈",
			gneqq: "≩",
			gnsim: "⋧",
			Gopf: "𝔾",
			gopf: "𝕘",
			grave: "`",
			GreaterEqual: "≥",
			GreaterEqualLess: "⋛",
			GreaterFullEqual: "≧",
			GreaterGreater: "⪢",
			GreaterLess: "≷",
			GreaterSlantEqual: "⩾",
			GreaterTilde: "≳",
			Gscr: "𝒢",
			gscr: "ℊ",
			gsim: "≳",
			gsime: "⪎",
			gsiml: "⪐",
			Gt: "≫",
			GT: ">",
			gt: ">",
			gtcc: "⪧",
			gtcir: "⩺",
			gtdot: "⋗",
			gtlPar: "⦕",
			gtquest: "⩼",
			gtrapprox: "⪆",
			gtrarr: "⥸",
			gtrdot: "⋗",
			gtreqless: "⋛",
			gtreqqless: "⪌",
			gtrless: "≷",
			gtrsim: "≳",
			gvertneqq: "≩︀",
			gvnE: "≩︀",
			Hacek: "ˇ",
			hairsp: " ",
			half: "½",
			hamilt: "ℋ",
			HARDcy: "Ъ",
			hardcy: "ъ",
			hArr: "⇔",
			harr: "↔",
			harrcir: "⥈",
			harrw: "↭",
			Hat: "^",
			hbar: "ℏ",
			Hcirc: "Ĥ",
			hcirc: "ĥ",
			hearts: "♥",
			heartsuit: "♥",
			hellip: "…",
			hercon: "⊹",
			Hfr: "ℌ",
			hfr: "𝔥",
			HilbertSpace: "ℋ",
			hksearow: "⤥",
			hkswarow: "⤦",
			hoarr: "⇿",
			homtht: "∻",
			hookleftarrow: "↩",
			hookrightarrow: "↪",
			Hopf: "ℍ",
			hopf: "𝕙",
			horbar: "―",
			HorizontalLine: "─",
			Hscr: "ℋ",
			hscr: "𝒽",
			hslash: "ℏ",
			Hstrok: "Ħ",
			hstrok: "ħ",
			HumpDownHump: "≎",
			HumpEqual: "≏",
			hybull: "⁃",
			hyphen: "‐",
			Iacute: "Í",
			iacute: "í",
			ic: "⁣",
			Icirc: "Î",
			icirc: "î",
			Icy: "И",
			icy: "и",
			Idot: "İ",
			IEcy: "Е",
			iecy: "е",
			iexcl: "¡",
			iff: "⇔",
			Ifr: "ℑ",
			ifr: "𝔦",
			Igrave: "Ì",
			igrave: "ì",
			ii: "ⅈ",
			iiiint: "⨌",
			iiint: "∭",
			iinfin: "⧜",
			iiota: "℩",
			IJlig: "Ĳ",
			ijlig: "ĳ",
			Im: "ℑ",
			Imacr: "Ī",
			imacr: "ī",
			image: "ℑ",
			ImaginaryI: "ⅈ",
			imagline: "ℐ",
			imagpart: "ℑ",
			imath: "ı",
			imof: "⊷",
			imped: "Ƶ",
			Implies: "⇒",
			in: "∈",
			incare: "℅",
			infin: "∞",
			infintie: "⧝",
			inodot: "ı",
			Int: "∬",
			int: "∫",
			intcal: "⊺",
			integers: "ℤ",
			Integral: "∫",
			intercal: "⊺",
			Intersection: "⋂",
			intlarhk: "⨗",
			intprod: "⨼",
			InvisibleComma: "⁣",
			InvisibleTimes: "⁢",
			IOcy: "Ё",
			iocy: "ё",
			Iogon: "Į",
			iogon: "į",
			Iopf: "𝕀",
			iopf: "𝕚",
			Iota: "Ι",
			iota: "ι",
			iprod: "⨼",
			iquest: "¿",
			Iscr: "ℐ",
			iscr: "𝒾",
			isin: "∈",
			isindot: "⋵",
			isinE: "⋹",
			isins: "⋴",
			isinsv: "⋳",
			isinv: "∈",
			it: "⁢",
			Itilde: "Ĩ",
			itilde: "ĩ",
			Iukcy: "І",
			iukcy: "і",
			Iuml: "Ï",
			iuml: "ï",
			Jcirc: "Ĵ",
			jcirc: "ĵ",
			Jcy: "Й",
			jcy: "й",
			Jfr: "𝔍",
			jfr: "𝔧",
			jmath: "ȷ",
			Jopf: "𝕁",
			jopf: "𝕛",
			Jscr: "𝒥",
			jscr: "𝒿",
			Jsercy: "Ј",
			jsercy: "ј",
			Jukcy: "Є",
			jukcy: "є",
			Kappa: "Κ",
			kappa: "κ",
			kappav: "ϰ",
			Kcedil: "Ķ",
			kcedil: "ķ",
			Kcy: "К",
			kcy: "к",
			Kfr: "𝔎",
			kfr: "𝔨",
			kgreen: "ĸ",
			KHcy: "Х",
			khcy: "х",
			KJcy: "Ќ",
			kjcy: "ќ",
			Kopf: "𝕂",
			kopf: "𝕜",
			Kscr: "𝒦",
			kscr: "𝓀",
			lAarr: "⇚",
			Lacute: "Ĺ",
			lacute: "ĺ",
			laemptyv: "⦴",
			lagran: "ℒ",
			Lambda: "Λ",
			lambda: "λ",
			Lang: "⟪",
			lang: "⟨",
			langd: "⦑",
			langle: "⟨",
			lap: "⪅",
			Laplacetrf: "ℒ",
			laquo: "«",
			Larr: "↞",
			lArr: "⇐",
			larr: "←",
			larrb: "⇤",
			larrbfs: "⤟",
			larrfs: "⤝",
			larrhk: "↩",
			larrlp: "↫",
			larrpl: "⤹",
			larrsim: "⥳",
			larrtl: "↢",
			lat: "⪫",
			lAtail: "⤛",
			latail: "⤙",
			late: "⪭",
			lates: "⪭︀",
			lBarr: "⤎",
			lbarr: "⤌",
			lbbrk: "❲",
			lbrace: "{",
			lbrack: "[",
			lbrke: "⦋",
			lbrksld: "⦏",
			lbrkslu: "⦍",
			Lcaron: "Ľ",
			lcaron: "ľ",
			Lcedil: "Ļ",
			lcedil: "ļ",
			lceil: "⌈",
			lcub: "{",
			Lcy: "Л",
			lcy: "л",
			ldca: "⤶",
			ldquo: "“",
			ldquor: "„",
			ldrdhar: "⥧",
			ldrushar: "⥋",
			ldsh: "↲",
			lE: "≦",
			le: "≤",
			LeftAngleBracket: "⟨",
			LeftArrow: "←",
			Leftarrow: "⇐",
			leftarrow: "←",
			LeftArrowBar: "⇤",
			LeftArrowRightArrow: "⇆",
			leftarrowtail: "↢",
			LeftCeiling: "⌈",
			LeftDoubleBracket: "⟦",
			LeftDownTeeVector: "⥡",
			LeftDownVector: "⇃",
			LeftDownVectorBar: "⥙",
			LeftFloor: "⌊",
			leftharpoondown: "↽",
			leftharpoonup: "↼",
			leftleftarrows: "⇇",
			LeftRightArrow: "↔",
			Leftrightarrow: "⇔",
			leftrightarrow: "↔",
			leftrightarrows: "⇆",
			leftrightharpoons: "⇋",
			leftrightsquigarrow: "↭",
			LeftRightVector: "⥎",
			LeftTee: "⊣",
			LeftTeeArrow: "↤",
			LeftTeeVector: "⥚",
			leftthreetimes: "⋋",
			LeftTriangle: "⊲",
			LeftTriangleBar: "⧏",
			LeftTriangleEqual: "⊴",
			LeftUpDownVector: "⥑",
			LeftUpTeeVector: "⥠",
			LeftUpVector: "↿",
			LeftUpVectorBar: "⥘",
			LeftVector: "↼",
			LeftVectorBar: "⥒",
			lEg: "⪋",
			leg: "⋚",
			leq: "≤",
			leqq: "≦",
			leqslant: "⩽",
			les: "⩽",
			lescc: "⪨",
			lesdot: "⩿",
			lesdoto: "⪁",
			lesdotor: "⪃",
			lesg: "⋚︀",
			lesges: "⪓",
			lessapprox: "⪅",
			lessdot: "⋖",
			lesseqgtr: "⋚",
			lesseqqgtr: "⪋",
			LessEqualGreater: "⋚",
			LessFullEqual: "≦",
			LessGreater: "≶",
			lessgtr: "≶",
			LessLess: "⪡",
			lesssim: "≲",
			LessSlantEqual: "⩽",
			LessTilde: "≲",
			lfisht: "⥼",
			lfloor: "⌊",
			Lfr: "𝔏",
			lfr: "𝔩",
			lg: "≶",
			lgE: "⪑",
			lHar: "⥢",
			lhard: "↽",
			lharu: "↼",
			lharul: "⥪",
			lhblk: "▄",
			LJcy: "Љ",
			ljcy: "љ",
			Ll: "⋘",
			ll: "≪",
			llarr: "⇇",
			llcorner: "⌞",
			Lleftarrow: "⇚",
			llhard: "⥫",
			lltri: "◺",
			Lmidot: "Ŀ",
			lmidot: "ŀ",
			lmoust: "⎰",
			lmoustache: "⎰",
			lnap: "⪉",
			lnapprox: "⪉",
			lnE: "≨",
			lne: "⪇",
			lneq: "⪇",
			lneqq: "≨",
			lnsim: "⋦",
			loang: "⟬",
			loarr: "⇽",
			lobrk: "⟦",
			LongLeftArrow: "⟵",
			Longleftarrow: "⟸",
			longleftarrow: "⟵",
			LongLeftRightArrow: "⟷",
			Longleftrightarrow: "⟺",
			longleftrightarrow: "⟷",
			longmapsto: "⟼",
			LongRightArrow: "⟶",
			Longrightarrow: "⟹",
			longrightarrow: "⟶",
			looparrowleft: "↫",
			looparrowright: "↬",
			lopar: "⦅",
			Lopf: "𝕃",
			lopf: "𝕝",
			loplus: "⨭",
			lotimes: "⨴",
			lowast: "∗",
			lowbar: "_",
			LowerLeftArrow: "↙",
			LowerRightArrow: "↘",
			loz: "◊",
			lozenge: "◊",
			lozf: "⧫",
			lpar: "(",
			lparlt: "⦓",
			lrarr: "⇆",
			lrcorner: "⌟",
			lrhar: "⇋",
			lrhard: "⥭",
			lrm: "‎",
			lrtri: "⊿",
			lsaquo: "‹",
			Lscr: "ℒ",
			lscr: "𝓁",
			Lsh: "↰",
			lsh: "↰",
			lsim: "≲",
			lsime: "⪍",
			lsimg: "⪏",
			lsqb: "[",
			lsquo: "‘",
			lsquor: "‚",
			Lstrok: "Ł",
			lstrok: "ł",
			Lt: "≪",
			LT: "<",
			lt: "<",
			ltcc: "⪦",
			ltcir: "⩹",
			ltdot: "⋖",
			lthree: "⋋",
			ltimes: "⋉",
			ltlarr: "⥶",
			ltquest: "⩻",
			ltri: "◃",
			ltrie: "⊴",
			ltrif: "◂",
			ltrPar: "⦖",
			lurdshar: "⥊",
			luruhar: "⥦",
			lvertneqq: "≨︀",
			lvnE: "≨︀",
			macr: "¯",
			male: "♂",
			malt: "✠",
			maltese: "✠",
			Map: "⤅",
			map: "↦",
			mapsto: "↦",
			mapstodown: "↧",
			mapstoleft: "↤",
			mapstoup: "↥",
			marker: "▮",
			mcomma: "⨩",
			Mcy: "М",
			mcy: "м",
			mdash: "—",
			mDDot: "∺",
			measuredangle: "∡",
			MediumSpace: " ",
			Mellintrf: "ℳ",
			Mfr: "𝔐",
			mfr: "𝔪",
			mho: "℧",
			micro: "µ",
			mid: "∣",
			midast: "*",
			midcir: "⫰",
			middot: "·",
			minus: "−",
			minusb: "⊟",
			minusd: "∸",
			minusdu: "⨪",
			MinusPlus: "∓",
			mlcp: "⫛",
			mldr: "…",
			mnplus: "∓",
			models: "⊧",
			Mopf: "𝕄",
			mopf: "𝕞",
			mp: "∓",
			Mscr: "ℳ",
			mscr: "𝓂",
			mstpos: "∾",
			Mu: "Μ",
			mu: "μ",
			multimap: "⊸",
			mumap: "⊸",
			nabla: "∇",
			Nacute: "Ń",
			nacute: "ń",
			nang: "∠⃒",
			nap: "≉",
			napE: "⩰̸",
			napid: "≋̸",
			napos: "ŉ",
			napprox: "≉",
			natur: "♮",
			natural: "♮",
			naturals: "ℕ",
			nbsp: " ",
			nbump: "≎̸",
			nbumpe: "≏̸",
			ncap: "⩃",
			Ncaron: "Ň",
			ncaron: "ň",
			Ncedil: "Ņ",
			ncedil: "ņ",
			ncong: "≇",
			ncongdot: "⩭̸",
			ncup: "⩂",
			Ncy: "Н",
			ncy: "н",
			ndash: "–",
			ne: "≠",
			nearhk: "⤤",
			neArr: "⇗",
			nearr: "↗",
			nearrow: "↗",
			nedot: "≐̸",
			NegativeMediumSpace: "​",
			NegativeThickSpace: "​",
			NegativeThinSpace: "​",
			NegativeVeryThinSpace: "​",
			nequiv: "≢",
			nesear: "⤨",
			nesim: "≂̸",
			NestedGreaterGreater: "≫",
			NestedLessLess: "≪",
			NewLine: `
`,
			nexist: "∄",
			nexists: "∄",
			Nfr: "𝔑",
			nfr: "𝔫",
			ngE: "≧̸",
			nge: "≱",
			ngeq: "≱",
			ngeqq: "≧̸",
			ngeqslant: "⩾̸",
			nges: "⩾̸",
			nGg: "⋙̸",
			ngsim: "≵",
			nGt: "≫⃒",
			ngt: "≯",
			ngtr: "≯",
			nGtv: "≫̸",
			nhArr: "⇎",
			nharr: "↮",
			nhpar: "⫲",
			ni: "∋",
			nis: "⋼",
			nisd: "⋺",
			niv: "∋",
			NJcy: "Њ",
			njcy: "њ",
			nlArr: "⇍",
			nlarr: "↚",
			nldr: "‥",
			nlE: "≦̸",
			nle: "≰",
			nLeftarrow: "⇍",
			nleftarrow: "↚",
			nLeftrightarrow: "⇎",
			nleftrightarrow: "↮",
			nleq: "≰",
			nleqq: "≦̸",
			nleqslant: "⩽̸",
			nles: "⩽̸",
			nless: "≮",
			nLl: "⋘̸",
			nlsim: "≴",
			nLt: "≪⃒",
			nlt: "≮",
			nltri: "⋪",
			nltrie: "⋬",
			nLtv: "≪̸",
			nmid: "∤",
			NoBreak: "⁠",
			NonBreakingSpace: " ",
			Nopf: "ℕ",
			nopf: "𝕟",
			Not: "⫬",
			not: "¬",
			NotCongruent: "≢",
			NotCupCap: "≭",
			NotDoubleVerticalBar: "∦",
			NotElement: "∉",
			NotEqual: "≠",
			NotEqualTilde: "≂̸",
			NotExists: "∄",
			NotGreater: "≯",
			NotGreaterEqual: "≱",
			NotGreaterFullEqual: "≧̸",
			NotGreaterGreater: "≫̸",
			NotGreaterLess: "≹",
			NotGreaterSlantEqual: "⩾̸",
			NotGreaterTilde: "≵",
			NotHumpDownHump: "≎̸",
			NotHumpEqual: "≏̸",
			notin: "∉",
			notindot: "⋵̸",
			notinE: "⋹̸",
			notinva: "∉",
			notinvb: "⋷",
			notinvc: "⋶",
			NotLeftTriangle: "⋪",
			NotLeftTriangleBar: "⧏̸",
			NotLeftTriangleEqual: "⋬",
			NotLess: "≮",
			NotLessEqual: "≰",
			NotLessGreater: "≸",
			NotLessLess: "≪̸",
			NotLessSlantEqual: "⩽̸",
			NotLessTilde: "≴",
			NotNestedGreaterGreater: "⪢̸",
			NotNestedLessLess: "⪡̸",
			notni: "∌",
			notniva: "∌",
			notnivb: "⋾",
			notnivc: "⋽",
			NotPrecedes: "⊀",
			NotPrecedesEqual: "⪯̸",
			NotPrecedesSlantEqual: "⋠",
			NotReverseElement: "∌",
			NotRightTriangle: "⋫",
			NotRightTriangleBar: "⧐̸",
			NotRightTriangleEqual: "⋭",
			NotSquareSubset: "⊏̸",
			NotSquareSubsetEqual: "⋢",
			NotSquareSuperset: "⊐̸",
			NotSquareSupersetEqual: "⋣",
			NotSubset: "⊂⃒",
			NotSubsetEqual: "⊈",
			NotSucceeds: "⊁",
			NotSucceedsEqual: "⪰̸",
			NotSucceedsSlantEqual: "⋡",
			NotSucceedsTilde: "≿̸",
			NotSuperset: "⊃⃒",
			NotSupersetEqual: "⊉",
			NotTilde: "≁",
			NotTildeEqual: "≄",
			NotTildeFullEqual: "≇",
			NotTildeTilde: "≉",
			NotVerticalBar: "∤",
			npar: "∦",
			nparallel: "∦",
			nparsl: "⫽⃥",
			npart: "∂̸",
			npolint: "⨔",
			npr: "⊀",
			nprcue: "⋠",
			npre: "⪯̸",
			nprec: "⊀",
			npreceq: "⪯̸",
			nrArr: "⇏",
			nrarr: "↛",
			nrarrc: "⤳̸",
			nrarrw: "↝̸",
			nRightarrow: "⇏",
			nrightarrow: "↛",
			nrtri: "⋫",
			nrtrie: "⋭",
			nsc: "⊁",
			nsccue: "⋡",
			nsce: "⪰̸",
			Nscr: "𝒩",
			nscr: "𝓃",
			nshortmid: "∤",
			nshortparallel: "∦",
			nsim: "≁",
			nsime: "≄",
			nsimeq: "≄",
			nsmid: "∤",
			nspar: "∦",
			nsqsube: "⋢",
			nsqsupe: "⋣",
			nsub: "⊄",
			nsubE: "⫅̸",
			nsube: "⊈",
			nsubset: "⊂⃒",
			nsubseteq: "⊈",
			nsubseteqq: "⫅̸",
			nsucc: "⊁",
			nsucceq: "⪰̸",
			nsup: "⊅",
			nsupE: "⫆̸",
			nsupe: "⊉",
			nsupset: "⊃⃒",
			nsupseteq: "⊉",
			nsupseteqq: "⫆̸",
			ntgl: "≹",
			Ntilde: "Ñ",
			ntilde: "ñ",
			ntlg: "≸",
			ntriangleleft: "⋪",
			ntrianglelefteq: "⋬",
			ntriangleright: "⋫",
			ntrianglerighteq: "⋭",
			Nu: "Ν",
			nu: "ν",
			num: "#",
			numero: "№",
			numsp: " ",
			nvap: "≍⃒",
			nVDash: "⊯",
			nVdash: "⊮",
			nvDash: "⊭",
			nvdash: "⊬",
			nvge: "≥⃒",
			nvgt: ">⃒",
			nvHarr: "⤄",
			nvinfin: "⧞",
			nvlArr: "⤂",
			nvle: "≤⃒",
			nvlt: "<⃒",
			nvltrie: "⊴⃒",
			nvrArr: "⤃",
			nvrtrie: "⊵⃒",
			nvsim: "∼⃒",
			nwarhk: "⤣",
			nwArr: "⇖",
			nwarr: "↖",
			nwarrow: "↖",
			nwnear: "⤧",
			Oacute: "Ó",
			oacute: "ó",
			oast: "⊛",
			ocir: "⊚",
			Ocirc: "Ô",
			ocirc: "ô",
			Ocy: "О",
			ocy: "о",
			odash: "⊝",
			Odblac: "Ő",
			odblac: "ő",
			odiv: "⨸",
			odot: "⊙",
			odsold: "⦼",
			OElig: "Œ",
			oelig: "œ",
			ofcir: "⦿",
			Ofr: "𝔒",
			ofr: "𝔬",
			ogon: "˛",
			Ograve: "Ò",
			ograve: "ò",
			ogt: "⧁",
			ohbar: "⦵",
			ohm: "Ω",
			oint: "∮",
			olarr: "↺",
			olcir: "⦾",
			olcross: "⦻",
			oline: "‾",
			olt: "⧀",
			Omacr: "Ō",
			omacr: "ō",
			Omega: "Ω",
			omega: "ω",
			Omicron: "Ο",
			omicron: "ο",
			omid: "⦶",
			ominus: "⊖",
			Oopf: "𝕆",
			oopf: "𝕠",
			opar: "⦷",
			OpenCurlyDoubleQuote: "“",
			OpenCurlyQuote: "‘",
			operp: "⦹",
			oplus: "⊕",
			Or: "⩔",
			or: "∨",
			orarr: "↻",
			ord: "⩝",
			order: "ℴ",
			orderof: "ℴ",
			ordf: "ª",
			ordm: "º",
			origof: "⊶",
			oror: "⩖",
			orslope: "⩗",
			orv: "⩛",
			oS: "Ⓢ",
			Oscr: "𝒪",
			oscr: "ℴ",
			Oslash: "Ø",
			oslash: "ø",
			osol: "⊘",
			Otilde: "Õ",
			otilde: "õ",
			Otimes: "⨷",
			otimes: "⊗",
			otimesas: "⨶",
			Ouml: "Ö",
			ouml: "ö",
			ovbar: "⌽",
			OverBar: "‾",
			OverBrace: "⏞",
			OverBracket: "⎴",
			OverParenthesis: "⏜",
			par: "∥",
			para: "¶",
			parallel: "∥",
			parsim: "⫳",
			parsl: "⫽",
			part: "∂",
			PartialD: "∂",
			Pcy: "П",
			pcy: "п",
			percnt: "%",
			period: ".",
			permil: "‰",
			perp: "⊥",
			pertenk: "‱",
			Pfr: "𝔓",
			pfr: "𝔭",
			Phi: "Φ",
			phi: "φ",
			phiv: "ϕ",
			phmmat: "ℳ",
			phone: "☎",
			Pi: "Π",
			pi: "π",
			pitchfork: "⋔",
			piv: "ϖ",
			planck: "ℏ",
			planckh: "ℎ",
			plankv: "ℏ",
			plus: "+",
			plusacir: "⨣",
			plusb: "⊞",
			pluscir: "⨢",
			plusdo: "∔",
			plusdu: "⨥",
			pluse: "⩲",
			PlusMinus: "±",
			plusmn: "±",
			plussim: "⨦",
			plustwo: "⨧",
			pm: "±",
			Poincareplane: "ℌ",
			pointint: "⨕",
			Popf: "ℙ",
			popf: "𝕡",
			pound: "£",
			Pr: "⪻",
			pr: "≺",
			prap: "⪷",
			prcue: "≼",
			prE: "⪳",
			pre: "⪯",
			prec: "≺",
			precapprox: "⪷",
			preccurlyeq: "≼",
			Precedes: "≺",
			PrecedesEqual: "⪯",
			PrecedesSlantEqual: "≼",
			PrecedesTilde: "≾",
			preceq: "⪯",
			precnapprox: "⪹",
			precneqq: "⪵",
			precnsim: "⋨",
			precsim: "≾",
			Prime: "″",
			prime: "′",
			primes: "ℙ",
			prnap: "⪹",
			prnE: "⪵",
			prnsim: "⋨",
			prod: "∏",
			Product: "∏",
			profalar: "⌮",
			profline: "⌒",
			profsurf: "⌓",
			prop: "∝",
			Proportion: "∷",
			Proportional: "∝",
			propto: "∝",
			prsim: "≾",
			prurel: "⊰",
			Pscr: "𝒫",
			pscr: "𝓅",
			Psi: "Ψ",
			psi: "ψ",
			puncsp: " ",
			Qfr: "𝔔",
			qfr: "𝔮",
			qint: "⨌",
			Qopf: "ℚ",
			qopf: "𝕢",
			qprime: "⁗",
			Qscr: "𝒬",
			qscr: "𝓆",
			quaternions: "ℍ",
			quatint: "⨖",
			quest: "?",
			questeq: "≟",
			QUOT: '"',
			quot: '"',
			rAarr: "⇛",
			race: "∽̱",
			Racute: "Ŕ",
			racute: "ŕ",
			radic: "√",
			raemptyv: "⦳",
			Rang: "⟫",
			rang: "⟩",
			rangd: "⦒",
			range: "⦥",
			rangle: "⟩",
			raquo: "»",
			Rarr: "↠",
			rArr: "⇒",
			rarr: "→",
			rarrap: "⥵",
			rarrb: "⇥",
			rarrbfs: "⤠",
			rarrc: "⤳",
			rarrfs: "⤞",
			rarrhk: "↪",
			rarrlp: "↬",
			rarrpl: "⥅",
			rarrsim: "⥴",
			Rarrtl: "⤖",
			rarrtl: "↣",
			rarrw: "↝",
			rAtail: "⤜",
			ratail: "⤚",
			ratio: "∶",
			rationals: "ℚ",
			RBarr: "⤐",
			rBarr: "⤏",
			rbarr: "⤍",
			rbbrk: "❳",
			rbrace: "}",
			rbrack: "]",
			rbrke: "⦌",
			rbrksld: "⦎",
			rbrkslu: "⦐",
			Rcaron: "Ř",
			rcaron: "ř",
			Rcedil: "Ŗ",
			rcedil: "ŗ",
			rceil: "⌉",
			rcub: "}",
			Rcy: "Р",
			rcy: "р",
			rdca: "⤷",
			rdldhar: "⥩",
			rdquo: "”",
			rdquor: "”",
			rdsh: "↳",
			Re: "ℜ",
			real: "ℜ",
			realine: "ℛ",
			realpart: "ℜ",
			reals: "ℝ",
			rect: "▭",
			REG: "®",
			reg: "®",
			ReverseElement: "∋",
			ReverseEquilibrium: "⇋",
			ReverseUpEquilibrium: "⥯",
			rfisht: "⥽",
			rfloor: "⌋",
			Rfr: "ℜ",
			rfr: "𝔯",
			rHar: "⥤",
			rhard: "⇁",
			rharu: "⇀",
			rharul: "⥬",
			Rho: "Ρ",
			rho: "ρ",
			rhov: "ϱ",
			RightAngleBracket: "⟩",
			RightArrow: "→",
			Rightarrow: "⇒",
			rightarrow: "→",
			RightArrowBar: "⇥",
			RightArrowLeftArrow: "⇄",
			rightarrowtail: "↣",
			RightCeiling: "⌉",
			RightDoubleBracket: "⟧",
			RightDownTeeVector: "⥝",
			RightDownVector: "⇂",
			RightDownVectorBar: "⥕",
			RightFloor: "⌋",
			rightharpoondown: "⇁",
			rightharpoonup: "⇀",
			rightleftarrows: "⇄",
			rightleftharpoons: "⇌",
			rightrightarrows: "⇉",
			rightsquigarrow: "↝",
			RightTee: "⊢",
			RightTeeArrow: "↦",
			RightTeeVector: "⥛",
			rightthreetimes: "⋌",
			RightTriangle: "⊳",
			RightTriangleBar: "⧐",
			RightTriangleEqual: "⊵",
			RightUpDownVector: "⥏",
			RightUpTeeVector: "⥜",
			RightUpVector: "↾",
			RightUpVectorBar: "⥔",
			RightVector: "⇀",
			RightVectorBar: "⥓",
			ring: "˚",
			risingdotseq: "≓",
			rlarr: "⇄",
			rlhar: "⇌",
			rlm: "‏",
			rmoust: "⎱",
			rmoustache: "⎱",
			rnmid: "⫮",
			roang: "⟭",
			roarr: "⇾",
			robrk: "⟧",
			ropar: "⦆",
			Ropf: "ℝ",
			ropf: "𝕣",
			roplus: "⨮",
			rotimes: "⨵",
			RoundImplies: "⥰",
			rpar: ")",
			rpargt: "⦔",
			rppolint: "⨒",
			rrarr: "⇉",
			Rrightarrow: "⇛",
			rsaquo: "›",
			Rscr: "ℛ",
			rscr: "𝓇",
			Rsh: "↱",
			rsh: "↱",
			rsqb: "]",
			rsquo: "’",
			rsquor: "’",
			rthree: "⋌",
			rtimes: "⋊",
			rtri: "▹",
			rtrie: "⊵",
			rtrif: "▸",
			rtriltri: "⧎",
			RuleDelayed: "⧴",
			ruluhar: "⥨",
			rx: "℞",
			Sacute: "Ś",
			sacute: "ś",
			sbquo: "‚",
			Sc: "⪼",
			sc: "≻",
			scap: "⪸",
			Scaron: "Š",
			scaron: "š",
			sccue: "≽",
			scE: "⪴",
			sce: "⪰",
			Scedil: "Ş",
			scedil: "ş",
			Scirc: "Ŝ",
			scirc: "ŝ",
			scnap: "⪺",
			scnE: "⪶",
			scnsim: "⋩",
			scpolint: "⨓",
			scsim: "≿",
			Scy: "С",
			scy: "с",
			sdot: "⋅",
			sdotb: "⊡",
			sdote: "⩦",
			searhk: "⤥",
			seArr: "⇘",
			searr: "↘",
			searrow: "↘",
			sect: "§",
			semi: ";",
			seswar: "⤩",
			setminus: "∖",
			setmn: "∖",
			sext: "✶",
			Sfr: "𝔖",
			sfr: "𝔰",
			sfrown: "⌢",
			sharp: "♯",
			SHCHcy: "Щ",
			shchcy: "щ",
			SHcy: "Ш",
			shcy: "ш",
			ShortDownArrow: "↓",
			ShortLeftArrow: "←",
			shortmid: "∣",
			shortparallel: "∥",
			ShortRightArrow: "→",
			ShortUpArrow: "↑",
			shy: "­",
			Sigma: "Σ",
			sigma: "σ",
			sigmaf: "ς",
			sigmav: "ς",
			sim: "∼",
			simdot: "⩪",
			sime: "≃",
			simeq: "≃",
			simg: "⪞",
			simgE: "⪠",
			siml: "⪝",
			simlE: "⪟",
			simne: "≆",
			simplus: "⨤",
			simrarr: "⥲",
			slarr: "←",
			SmallCircle: "∘",
			smallsetminus: "∖",
			smashp: "⨳",
			smeparsl: "⧤",
			smid: "∣",
			smile: "⌣",
			smt: "⪪",
			smte: "⪬",
			smtes: "⪬︀",
			SOFTcy: "Ь",
			softcy: "ь",
			sol: "/",
			solb: "⧄",
			solbar: "⌿",
			Sopf: "𝕊",
			sopf: "𝕤",
			spades: "♠",
			spadesuit: "♠",
			spar: "∥",
			sqcap: "⊓",
			sqcaps: "⊓︀",
			sqcup: "⊔",
			sqcups: "⊔︀",
			Sqrt: "√",
			sqsub: "⊏",
			sqsube: "⊑",
			sqsubset: "⊏",
			sqsubseteq: "⊑",
			sqsup: "⊐",
			sqsupe: "⊒",
			sqsupset: "⊐",
			sqsupseteq: "⊒",
			squ: "□",
			Square: "□",
			square: "□",
			SquareIntersection: "⊓",
			SquareSubset: "⊏",
			SquareSubsetEqual: "⊑",
			SquareSuperset: "⊐",
			SquareSupersetEqual: "⊒",
			SquareUnion: "⊔",
			squarf: "▪",
			squf: "▪",
			srarr: "→",
			Sscr: "𝒮",
			sscr: "𝓈",
			ssetmn: "∖",
			ssmile: "⌣",
			sstarf: "⋆",
			Star: "⋆",
			star: "☆",
			starf: "★",
			straightepsilon: "ϵ",
			straightphi: "ϕ",
			strns: "¯",
			Sub: "⋐",
			sub: "⊂",
			subdot: "⪽",
			subE: "⫅",
			sube: "⊆",
			subedot: "⫃",
			submult: "⫁",
			subnE: "⫋",
			subne: "⊊",
			subplus: "⪿",
			subrarr: "⥹",
			Subset: "⋐",
			subset: "⊂",
			subseteq: "⊆",
			subseteqq: "⫅",
			SubsetEqual: "⊆",
			subsetneq: "⊊",
			subsetneqq: "⫋",
			subsim: "⫇",
			subsub: "⫕",
			subsup: "⫓",
			succ: "≻",
			succapprox: "⪸",
			succcurlyeq: "≽",
			Succeeds: "≻",
			SucceedsEqual: "⪰",
			SucceedsSlantEqual: "≽",
			SucceedsTilde: "≿",
			succeq: "⪰",
			succnapprox: "⪺",
			succneqq: "⪶",
			succnsim: "⋩",
			succsim: "≿",
			SuchThat: "∋",
			Sum: "∑",
			sum: "∑",
			sung: "♪",
			Sup: "⋑",
			sup: "⊃",
			sup1: "¹",
			sup2: "²",
			sup3: "³",
			supdot: "⪾",
			supdsub: "⫘",
			supE: "⫆",
			supe: "⊇",
			supedot: "⫄",
			Superset: "⊃",
			SupersetEqual: "⊇",
			suphsol: "⟉",
			suphsub: "⫗",
			suplarr: "⥻",
			supmult: "⫂",
			supnE: "⫌",
			supne: "⊋",
			supplus: "⫀",
			Supset: "⋑",
			supset: "⊃",
			supseteq: "⊇",
			supseteqq: "⫆",
			supsetneq: "⊋",
			supsetneqq: "⫌",
			supsim: "⫈",
			supsub: "⫔",
			supsup: "⫖",
			swarhk: "⤦",
			swArr: "⇙",
			swarr: "↙",
			swarrow: "↙",
			swnwar: "⤪",
			szlig: "ß",
			Tab: "	",
			target: "⌖",
			Tau: "Τ",
			tau: "τ",
			tbrk: "⎴",
			Tcaron: "Ť",
			tcaron: "ť",
			Tcedil: "Ţ",
			tcedil: "ţ",
			Tcy: "Т",
			tcy: "т",
			tdot: "⃛",
			telrec: "⌕",
			Tfr: "𝔗",
			tfr: "𝔱",
			there4: "∴",
			Therefore: "∴",
			therefore: "∴",
			Theta: "Θ",
			theta: "θ",
			thetasym: "ϑ",
			thetav: "ϑ",
			thickapprox: "≈",
			thicksim: "∼",
			ThickSpace: "  ",
			thinsp: " ",
			ThinSpace: " ",
			thkap: "≈",
			thksim: "∼",
			THORN: "Þ",
			thorn: "þ",
			Tilde: "∼",
			tilde: "˜",
			TildeEqual: "≃",
			TildeFullEqual: "≅",
			TildeTilde: "≈",
			times: "×",
			timesb: "⊠",
			timesbar: "⨱",
			timesd: "⨰",
			tint: "∭",
			toea: "⤨",
			top: "⊤",
			topbot: "⌶",
			topcir: "⫱",
			Topf: "𝕋",
			topf: "𝕥",
			topfork: "⫚",
			tosa: "⤩",
			tprime: "‴",
			TRADE: "™",
			trade: "™",
			triangle: "▵",
			triangledown: "▿",
			triangleleft: "◃",
			trianglelefteq: "⊴",
			triangleq: "≜",
			triangleright: "▹",
			trianglerighteq: "⊵",
			tridot: "◬",
			trie: "≜",
			triminus: "⨺",
			TripleDot: "⃛",
			triplus: "⨹",
			trisb: "⧍",
			tritime: "⨻",
			trpezium: "⏢",
			Tscr: "𝒯",
			tscr: "𝓉",
			TScy: "Ц",
			tscy: "ц",
			TSHcy: "Ћ",
			tshcy: "ћ",
			Tstrok: "Ŧ",
			tstrok: "ŧ",
			twixt: "≬",
			twoheadleftarrow: "↞",
			twoheadrightarrow: "↠",
			Uacute: "Ú",
			uacute: "ú",
			Uarr: "↟",
			uArr: "⇑",
			uarr: "↑",
			Uarrocir: "⥉",
			Ubrcy: "Ў",
			ubrcy: "ў",
			Ubreve: "Ŭ",
			ubreve: "ŭ",
			Ucirc: "Û",
			ucirc: "û",
			Ucy: "У",
			ucy: "у",
			udarr: "⇅",
			Udblac: "Ű",
			udblac: "ű",
			udhar: "⥮",
			ufisht: "⥾",
			Ufr: "𝔘",
			ufr: "𝔲",
			Ugrave: "Ù",
			ugrave: "ù",
			uHar: "⥣",
			uharl: "↿",
			uharr: "↾",
			uhblk: "▀",
			ulcorn: "⌜",
			ulcorner: "⌜",
			ulcrop: "⌏",
			ultri: "◸",
			Umacr: "Ū",
			umacr: "ū",
			uml: "¨",
			UnderBar: "_",
			UnderBrace: "⏟",
			UnderBracket: "⎵",
			UnderParenthesis: "⏝",
			Union: "⋃",
			UnionPlus: "⊎",
			Uogon: "Ų",
			uogon: "ų",
			Uopf: "𝕌",
			uopf: "𝕦",
			UpArrow: "↑",
			Uparrow: "⇑",
			uparrow: "↑",
			UpArrowBar: "⤒",
			UpArrowDownArrow: "⇅",
			UpDownArrow: "↕",
			Updownarrow: "⇕",
			updownarrow: "↕",
			UpEquilibrium: "⥮",
			upharpoonleft: "↿",
			upharpoonright: "↾",
			uplus: "⊎",
			UpperLeftArrow: "↖",
			UpperRightArrow: "↗",
			Upsi: "ϒ",
			upsi: "υ",
			upsih: "ϒ",
			Upsilon: "Υ",
			upsilon: "υ",
			UpTee: "⊥",
			UpTeeArrow: "↥",
			upuparrows: "⇈",
			urcorn: "⌝",
			urcorner: "⌝",
			urcrop: "⌎",
			Uring: "Ů",
			uring: "ů",
			urtri: "◹",
			Uscr: "𝒰",
			uscr: "𝓊",
			utdot: "⋰",
			Utilde: "Ũ",
			utilde: "ũ",
			utri: "▵",
			utrif: "▴",
			uuarr: "⇈",
			Uuml: "Ü",
			uuml: "ü",
			uwangle: "⦧",
			vangrt: "⦜",
			varepsilon: "ϵ",
			varkappa: "ϰ",
			varnothing: "∅",
			varphi: "ϕ",
			varpi: "ϖ",
			varpropto: "∝",
			vArr: "⇕",
			varr: "↕",
			varrho: "ϱ",
			varsigma: "ς",
			varsubsetneq: "⊊︀",
			varsubsetneqq: "⫋︀",
			varsupsetneq: "⊋︀",
			varsupsetneqq: "⫌︀",
			vartheta: "ϑ",
			vartriangleleft: "⊲",
			vartriangleright: "⊳",
			Vbar: "⫫",
			vBar: "⫨",
			vBarv: "⫩",
			Vcy: "В",
			vcy: "в",
			VDash: "⊫",
			Vdash: "⊩",
			vDash: "⊨",
			vdash: "⊢",
			Vdashl: "⫦",
			Vee: "⋁",
			vee: "∨",
			veebar: "⊻",
			veeeq: "≚",
			vellip: "⋮",
			Verbar: "‖",
			verbar: "|",
			Vert: "‖",
			vert: "|",
			VerticalBar: "∣",
			VerticalLine: "|",
			VerticalSeparator: "❘",
			VerticalTilde: "≀",
			VeryThinSpace: " ",
			Vfr: "𝔙",
			vfr: "𝔳",
			vltri: "⊲",
			vnsub: "⊂⃒",
			vnsup: "⊃⃒",
			Vopf: "𝕍",
			vopf: "𝕧",
			vprop: "∝",
			vrtri: "⊳",
			Vscr: "𝒱",
			vscr: "𝓋",
			vsubnE: "⫋︀",
			vsubne: "⊊︀",
			vsupnE: "⫌︀",
			vsupne: "⊋︀",
			Vvdash: "⊪",
			vzigzag: "⦚",
			Wcirc: "Ŵ",
			wcirc: "ŵ",
			wedbar: "⩟",
			Wedge: "⋀",
			wedge: "∧",
			wedgeq: "≙",
			weierp: "℘",
			Wfr: "𝔚",
			wfr: "𝔴",
			Wopf: "𝕎",
			wopf: "𝕨",
			wp: "℘",
			wr: "≀",
			wreath: "≀",
			Wscr: "𝒲",
			wscr: "𝓌",
			xcap: "⋂",
			xcirc: "◯",
			xcup: "⋃",
			xdtri: "▽",
			Xfr: "𝔛",
			xfr: "𝔵",
			xhArr: "⟺",
			xharr: "⟷",
			Xi: "Ξ",
			xi: "ξ",
			xlArr: "⟸",
			xlarr: "⟵",
			xmap: "⟼",
			xnis: "⋻",
			xodot: "⨀",
			Xopf: "𝕏",
			xopf: "𝕩",
			xoplus: "⨁",
			xotime: "⨂",
			xrArr: "⟹",
			xrarr: "⟶",
			Xscr: "𝒳",
			xscr: "𝓍",
			xsqcup: "⨆",
			xuplus: "⨄",
			xutri: "△",
			xvee: "⋁",
			xwedge: "⋀",
			Yacute: "Ý",
			yacute: "ý",
			YAcy: "Я",
			yacy: "я",
			Ycirc: "Ŷ",
			ycirc: "ŷ",
			Ycy: "Ы",
			ycy: "ы",
			yen: "¥",
			Yfr: "𝔜",
			yfr: "𝔶",
			YIcy: "Ї",
			yicy: "ї",
			Yopf: "𝕐",
			yopf: "𝕪",
			Yscr: "𝒴",
			yscr: "𝓎",
			YUcy: "Ю",
			yucy: "ю",
			Yuml: "Ÿ",
			yuml: "ÿ",
			Zacute: "Ź",
			zacute: "ź",
			Zcaron: "Ž",
			zcaron: "ž",
			Zcy: "З",
			zcy: "з",
			Zdot: "Ż",
			zdot: "ż",
			zeetrf: "ℨ",
			ZeroWidthSpace: "​",
			Zeta: "Ζ",
			zeta: "ζ",
			Zfr: "ℨ",
			zfr: "𝔷",
			ZHcy: "Ж",
			zhcy: "ж",
			zigrarr: "⇝",
			Zopf: "ℤ",
			zopf: "𝕫",
			Zscr: "𝒵",
			zscr: "𝓏",
			zwj: "‍",
			zwnj: "‌"
		}), o.entityMap = o.HTML_ENTITIES
	}(entities)), entities
}
var sax = {},
	hasRequiredSax;

function requireSax() {
	if (hasRequiredSax) return sax;
	hasRequiredSax = 1;
	var o = requireConventions(),
		s = requireGrammar(),
		a = requireErrors(),
		l = o.isHTMLEscapableRawTextElement,
		c = o.isHTMLMimeType,
		d = o.isHTMLRawTextElement,
		f = o.hasOwn,
		m = o.NAMESPACE,
		g = a.ParseError,
		v = a.DOMException,
		y = 0,
		b = 1,
		C = 2,
		_ = 3,
		S = 4,
		w = 5,
		T = 6,
		A = 7;

	function k() {}
	k.prototype = {
		parse: function(ce, ae, fe) {
			var q = this.domBuilder;
			q.startDocument(), V(ae, ae = Object.create(null)), D(ce, ae, fe, q, this.errorHandler), q
				.endDocument()
		}
	};
	var M = /&#?\w+;?/g;

	function D(ce, ae, fe, q, le) {
		var de = c(q.mimeType);
		ce.indexOf(s.UNICODE_REPLACEMENT_CHARACTER) >= 0 && le.warning(
			"Unicode replacement character detected, source encoding issues?");

		function _e(rt) {
			if (rt > 65535) {
				rt -= 65536;
				var ut = 55296 + (rt >> 10),
					gt = 56320 + (rt & 1023);
				return String.fromCharCode(ut, gt)
			} else return String.fromCharCode(rt)
		}

		function ke(rt) {
			var ut = rt[rt.length - 1] === ";" ? rt : rt + ";";
			if (!de && ut !== rt) return le.error("EntityRef: expecting ;"), rt;
			var gt = s.Reference.exec(ut);
			if (!gt || gt[0].length !== ut.length) return le.error("entity not matching Reference production: " + rt),
				rt;
			var Et = ut.slice(1, -1);
			return f(fe, Et) ? fe[Et] : Et.charAt(0) === "#" ? _e(parseInt(Et.substring(1).replace("x", "0x"))) : (le
				.error("entity not found:" + rt), rt)
		}

		function De(rt) {
			if (rt > He) {
				var ut = ce.substring(He, rt).replace(M, ke);
				Ve && it(He), q.characters(ut, 0, rt - He), He = rt
			}
		}
		var Se = 0,
			be = 0,
			Me = /\r\n?|\n|$/g,
			Ve = q.locator;

		function it(rt, ut) {
			for (; rt >= be && (ut = Me.exec(ce));) Se = be, be = ut.index + ut[0].length, Ve.lineNumber++;
			Ve.columnNumber = rt - Se + 1
		}
		for (var pt = [{
				currentNSMap: ae
			}], dt = [], He = 0;;) {
			try {
				var Ae = ce.indexOf("<", He);
				if (Ae < 0) {
					if (!de && dt.length > 0) return le.fatalError("unclosed xml tag(s): " + dt.join(", "));
					if (!ce.substring(He).match(/^\s*$/)) {
						var xe = q.doc,
							ye = xe.createTextNode(ce.substring(He));
						if (xe.documentElement) return le.error("Extra content at the end of the document");
						xe.appendChild(ye), q.currentElement = ye
					}
					return
				}
				if (Ae > He) {
					var Le = ce.substring(He, Ae);
					!de && dt.length === 0 && (Le = Le.replace(new RegExp(s.S_OPT.source, "g"), ""), Le && le.error(
						"Unexpected content outside root element: '" + Le + "'")), De(Ae)
				}
				switch (ce.charAt(Ae + 1)) {
					case "/":
						var Fe = ce.indexOf(">", Ae + 2),
							Ue = ce.substring(Ae + 2, Fe > 0 ? Fe : void 0);
						if (!Ue) return le.fatalError("end tag name missing");
						var nt = Fe > 0 && s.reg("^", s.QName_group, s.S_OPT, "$").exec(Ue);
						if (!nt) return le.fatalError('end tag name contains invalid characters: "' + Ue + '"');
						if (!q.currentElement && !q.doc.documentElement) return;
						var ot = dt[dt.length - 1] || q.currentElement.tagName || q.doc.documentElement.tagName || "";
						if (ot !== nt[1]) {
							var at = nt[1].toLowerCase();
							if (!de || ot.toLowerCase() !== at) return le.fatalError(
								'Opening and ending tag mismatch: "' + ot + '" != "' + Ue + '"')
						}
						var Je = pt.pop();
						dt.pop();
						var Ne = Je.localNSMap;
						if (q.endElement(Je.uri, Je.localName, ot), Ne)
							for (var we in Ne) f(Ne, we) && q.endPrefixMapping(we);
						Fe++;
						break;
					case "?":
						Ve && it(Ae), Fe = me(ce, Ae, q, le);
						break;
					case "!":
						Ve && it(Ae), Fe = ge(ce, Ae, q, le, de);
						break;
					default:
						Ve && it(Ae);
						var Ce = new he,
							$e = pt[pt.length - 1].currentNSMap,
							Fe = R(ce, Ae, Ce, $e, ke, le, de),
							Ge = Ce.length;
						if (Ce.closed || (de && o.isHTMLVoidElement(Ce.tagName) ? Ce.closed = !0 : dt.push(Ce.tagName)),
							Ve && Ge) {
							for (var ze = F(Ve, {}), Oe = 0; Oe < Ge; Oe++) {
								var Xe = Ce[Oe];
								it(Xe.offset), Xe.locator = F(Ve, {})
							}
							q.locator = ze, O(Ce, q, $e) && pt.push(Ce), q.locator = Ve
						} else O(Ce, q, $e) && pt.push(Ce);
						de && !Ce.closed ? Fe = U(ce, Fe, Ce.tagName, ke, q) : Fe++
				}
			} catch (rt) {
				if (rt instanceof g) throw rt;
				if (rt instanceof v) throw new g(rt.name + ": " + rt.message, q.locator, rt);
				le.error("element parse error: " + rt), Fe = -1
			}
			Fe > He ? He = Fe : De(Math.max(Ae, He) + 1)
		}
	}

	function F(ce, ae) {
		return ae.lineNumber = ce.lineNumber, ae.columnNumber = ce.columnNumber, ae
	}

	function R(ce, ae, fe, q, le, de, _e) {
		function ke(it, pt, dt) {
			if (f(fe.attributeNames, it)) return de.fatalError("Attribute " + it + " redefined");
			if (!_e && pt.indexOf("<") >= 0) return de.fatalError("Unescaped '<' not allowed in attributes values");
			fe.addValue(it, pt.replace(/[\t\n\r]/g, " ").replace(M, le), dt)
		}
		for (var De, Se, be = ++ae, Me = y;;) {
			var Ve = ce.charAt(be);
			switch (Ve) {
				case "=":
					if (Me === b) De = ce.slice(ae, be), Me = _;
					else if (Me === C) Me = _;
					else throw new Error("attribute equal must after attrName");
					break;
				case "'":
				case '"':
					if (Me === _ || Me === b)
						if (Me === b && (de.warning('attribute value must after "="'), De = ce.slice(ae, be)), ae = be +
							1, be = ce.indexOf(Ve, ae), be > 0) Se = ce.slice(ae, be), ke(De, Se, ae - 1), Me = w;
						else throw new Error("attribute value no end '" + Ve + "' match");
					else if (Me == S) Se = ce.slice(ae, be), ke(De, Se, ae), de.warning('attribute "' + De +
						'" missed start quot(' + Ve + ")!!"), ae = be + 1, Me = w;
					else throw new Error('attribute value must after "="');
					break;
				case "/":
					switch (Me) {
						case y:
							fe.setTagName(ce.slice(ae, be));
						case w:
						case T:
						case A:
							Me = A, fe.closed = !0;
						case S:
						case b:
							break;
						case C:
							fe.closed = !0;
							break;
						default:
							throw new Error("attribute invalid close char('/')")
					}
					break;
				case "":
					return de.error("unexpected end of input"), Me == y && fe.setTagName(ce.slice(ae, be)), be;
				case ">":
					switch (Me) {
						case y:
							fe.setTagName(ce.slice(ae, be));
						case w:
						case T:
						case A:
							break;
						case S:
						case b:
							Se = ce.slice(ae, be), Se.slice(-1) === "/" && (fe.closed = !0, Se = Se.slice(0, -1));
						case C:
							Me === C && (Se = De), Me == S ? (de.warning('attribute "' + Se + '" missed quot(")!'), ke(
								De, Se, ae)) : (_e || de.warning('attribute "' + Se + '" missed value!! "' + Se +
								'" instead!!'), ke(Se, Se, ae));
							break;
						case _:
							if (!_e) return de.fatalError(`AttValue: ' or " expected`)
					}
					return be;
				case "":
					Ve = " ";
				default:
					if (Ve <= " ") switch (Me) {
						case y:
							fe.setTagName(ce.slice(ae, be)), Me = T;
							break;
						case b:
							De = ce.slice(ae, be), Me = C;
							break;
						case S:
							var Se = ce.slice(ae, be);
							de.warning('attribute "' + Se + '" missed quot(")!!'), ke(De, Se, ae);
						case w:
							Me = T;
							break
					} else switch (Me) {
						case C:
							_e || de.warning('attribute "' + De + '" missed value!! "' + De + '" instead2!!'),
								ke(De, De, ae), ae = be, Me = b;
							break;
						case w:
							de.warning('attribute space is required"' + De + '"!!');
						case T:
							Me = b, ae = be;
							break;
						case _:
							Me = S, ae = be;
							break;
						case A:
							throw new Error("elements closed character '/' and '>' must be connected to")
					}
			}
			be++
		}
	}

	function O(ce, ae, fe) {
		for (var q = ce.tagName, le = null, Me = ce.length; Me--;) {
			var de = ce[Me],
				_e = de.qName,
				ke = de.value,
				Ve = _e.indexOf(":");
			if (Ve > 0) var De = de.prefix = _e.slice(0, Ve),
				Se = _e.slice(Ve + 1),
				be = De === "xmlns" && Se;
			else Se = _e, De = null, be = _e === "xmlns" && "";
			de.localName = Se, be !== !1 && (le == null && (le = Object.create(null), V(fe, fe = Object.create(null))),
				fe[be] = le[be] = ke, de.uri = m.XMLNS, ae.startPrefixMapping(be, ke))
		}
		for (var Me = ce.length; Me--;) de = ce[Me], de.prefix && (de.prefix === "xml" && (de.uri = m.XML), de
			.prefix !== "xmlns" && (de.uri = fe[de.prefix]));
		var Ve = q.indexOf(":");
		Ve > 0 ? (De = ce.prefix = q.slice(0, Ve), Se = ce.localName = q.slice(Ve + 1)) : (De = null, Se = ce
			.localName = q);
		var it = ce.uri = fe[De || ""];
		if (ae.startElement(it, Se, q, ce), ce.closed) {
			if (ae.endElement(it, Se, q), le)
				for (De in le) f(le, De) && ae.endPrefixMapping(De)
		} else return ce.currentNSMap = fe, ce.localNSMap = le, !0
	}

	function U(ce, ae, fe, q, le) {
		var de = l(fe);
		if (de || d(fe)) {
			var _e = ce.indexOf("</" + fe + ">", ae),
				ke = ce.substring(ae + 1, _e);
			return de && (ke = ke.replace(M, q)), le.characters(ke, 0, ke.length), _e
		}
		return ae + 1
	}

	function V(ce, ae) {
		for (var fe in ce) f(ce, fe) && (ae[fe] = ce[fe])
	}

	function z(ce, ae) {
		var fe = ae;

		function q(be) {
			return be = be || 0, ce.charAt(fe + be)
		}

		function le(be) {
			be = be || 1, fe += be
		}

		function de() {
			for (var be = 0; fe < ce.length;) {
				var Me = q();
				if (Me !== " " && Me !== `
` && Me !== "	" && Me !== "\r") return be;
				be++, le()
			}
			return -1
		}

		function _e() {
			return ce.substring(fe)
		}

		function ke(be) {
			return ce.substring(fe, fe + be.length) === be
		}

		function De(be) {
			return ce.substring(fe, fe + be.length).toUpperCase() === be.toUpperCase()
		}

		function Se(be) {
			var Me = s.reg("^", be),
				Ve = Me.exec(_e());
			return Ve ? (le(Ve[0].length), Ve[0]) : null
		}
		return {
			char: q,
			getIndex: function() {
				return fe
			},
			getMatch: Se,
			getSource: function() {
				return ce
			},
			skip: le,
			skipBlanks: de,
			substringFromIndex: _e,
			substringStartsWith: ke,
			substringStartsWithCaseInsensitive: De
		}
	}

	function j(ce, ae) {
		function fe(ke, De) {
			var Se = s.PI.exec(ke.substringFromIndex());
			return Se ? Se[1].toLowerCase() === "xml" ? De.fatalError(
				"xml declaration is only allowed at the start of the document, but found at position " + ke
				.getIndex()) : (ke.skip(Se[0].length), Se[0]) : De.fatalError(
				"processing instruction is not well-formed at position " + ke.getIndex())
		}
		var q = ce.getSource();
		if (ce.char() === "[") {
			ce.skip(1);
			for (var le = ce.getIndex(); ce.getIndex() < q.length;) {
				if (ce.skipBlanks(), ce.char() === "]") {
					var de = q.substring(le, ce.getIndex());
					return ce.skip(1), de
				}
				var _e = null;
				if (ce.char() === "<" && ce.char(1) === "!") switch (ce.char(2)) {
						case "E":
							ce.char(3) === "L" ? _e = ce.getMatch(s.elementdecl) : ce.char(3) === "N" && (_e = ce
								.getMatch(s.EntityDecl));
							break;
						case "A":
							_e = ce.getMatch(s.AttlistDecl);
							break;
						case "N":
							_e = ce.getMatch(s.NotationDecl);
							break;
						case "-":
							_e = ce.getMatch(s.Comment);
							break
					} else if (ce.char() === "<" && ce.char(1) === "?") _e = fe(ce, ae);
					else if (ce.char() === "%") _e = ce.getMatch(s.PEReference);
				else return ae.fatalError("Error detected in Markup declaration");
				if (!_e) return ae.fatalError("Error in internal subset at position " + ce.getIndex())
			}
			return ae.fatalError("doctype internal subset is not well-formed, missing ]")
		}
	}

	function ge(ce, ae, fe, q, le) {
		var de = z(ce, ae);
		switch (le ? de.char(2).toUpperCase() : de.char(2)) {
			case "-":
				var _e = de.getMatch(s.Comment);
				return _e ? (fe.comment(_e, s.COMMENT_START.length, _e.length - s.COMMENT_START.length - s.COMMENT_END
					.length), de.getIndex()) : q.fatalError("comment is not well-formed at position " + de
				.getIndex());
			case "[":
				var ke = de.getMatch(s.CDSect);
				return ke ? !le && !fe.currentElement ? q.fatalError("CDATA outside of element") : (fe.startCDATA(), fe
					.characters(ke, s.CDATA_START.length, ke.length - s.CDATA_START.length - s.CDATA_END.length), fe
					.endCDATA(), de.getIndex()) : q.fatalError("Invalid CDATA starting at position " + ae);
			case "D": {
				if (fe.doc && fe.doc.documentElement) return q.fatalError(
					"Doctype not allowed inside or after documentElement at position " + de.getIndex());
				if (le ? !de.substringStartsWithCaseInsensitive(s.DOCTYPE_DECL_START) : !de.substringStartsWith(s
						.DOCTYPE_DECL_START)) return q.fatalError("Expected " + s.DOCTYPE_DECL_START + " at position " +
					de.getIndex());
				if (de.skip(s.DOCTYPE_DECL_START.length), de.skipBlanks() < 1) return q.fatalError(
					"Expected whitespace after " + s.DOCTYPE_DECL_START + " at position " + de.getIndex());
				var De = {
					name: void 0,
					publicId: void 0,
					systemId: void 0,
					internalSubset: void 0
				};
				if (De.name = de.getMatch(s.Name), !De.name) return q.fatalError(
					"doctype name missing or contains unexpected characters at position " + de.getIndex());
				if (le && De.name.toLowerCase() !== "html" && q.warning(
						"Unexpected DOCTYPE in HTML document at position " + de.getIndex()), de.skipBlanks(), de
					.substringStartsWith(s.PUBLIC) || de.substringStartsWith(s.SYSTEM)) {
					var Se = s.ExternalID_match.exec(de.substringFromIndex());
					if (!Se) return q.fatalError("doctype external id is not well-formed at position " + de.getIndex());
					Se.groups.SystemLiteralOnly !== void 0 ? De.systemId = Se.groups.SystemLiteralOnly : (De.systemId =
						Se.groups.SystemLiteral, De.publicId = Se.groups.PubidLiteral), de.skip(Se[0].length)
				} else if (le && de.substringStartsWithCaseInsensitive(s.SYSTEM)) {
					if (de.skip(s.SYSTEM.length), de.skipBlanks() < 1) return q.fatalError(
						"Expected whitespace after " + s.SYSTEM + " at position " + de.getIndex());
					if (De.systemId = de.getMatch(s.ABOUT_LEGACY_COMPAT_SystemLiteral), !De.systemId) return q
						.fatalError("Expected " + s.ABOUT_LEGACY_COMPAT + " in single or double quotes after " + s
							.SYSTEM + " at position " + de.getIndex())
				}
				return le && De.systemId && !s.ABOUT_LEGACY_COMPAT_SystemLiteral.test(De.systemId) && q.warning(
					"Unexpected doctype.systemId in HTML document at position " + de.getIndex()), le || (de
					.skipBlanks(), De.internalSubset = j(de, q)), de.skipBlanks(), de.char() !== ">" ? q.fatalError(
					"doctype not terminated with > at position " + de.getIndex()) : (de.skip(1), fe.startDTD(De
					.name, De.publicId, De.systemId, De.internalSubset), fe.endDTD(), de.getIndex())
			}
			default:
				return q.fatalError('Not well-formed XML starting with "<!" at position ' + ae)
		}
	}

	function me(ce, ae, fe, q) {
		var le = ce.substring(ae).match(s.PI);
		if (!le) return q.fatalError("Invalid processing instruction starting at position " + ae);
		if (le[1].toLowerCase() === "xml") {
			if (ae > 0) return q.fatalError("processing instruction at position " + ae +
				" is an xml declaration which is only at the start of the document");
			if (!s.XMLDecl.test(ce.substring(ae))) return q.fatalError("xml declaration is not well-formed")
		}
		return fe.processingInstruction(le[1], le[2]), ae + le[0].length
	}

	function he() {
		this.attributeNames = Object.create(null)
	}
	return he.prototype = {
		setTagName: function(ce) {
			if (!s.QName_exact.test(ce)) throw new Error("invalid tagName:" + ce);
			this.tagName = ce
		},
		addValue: function(ce, ae, fe) {
			if (!s.QName_exact.test(ce)) throw new Error("invalid attribute:" + ce);
			this.attributeNames[ce] = this.length, this[this.length++] = {
				qName: ce,
				value: ae,
				offset: fe
			}
		},
		length: 0,
		getLocalName: function(ce) {
			return this[ce].localName
		},
		getLocator: function(ce) {
			return this[ce].locator
		},
		getQName: function(ce) {
			return this[ce].qName
		},
		getURI: function(ce) {
			return this[ce].uri
		},
		getValue: function(ce) {
			return this[ce].value
		}
	}, sax.XMLReader = k, sax.parseUtils = z, sax.parseDoctypeCommentOrCData = ge, sax
}
var hasRequiredDomParser;

function requireDomParser() {
	if (hasRequiredDomParser) return domParser;
	hasRequiredDomParser = 1;
	var o = requireConventions(),
		s = requireDom(),
		a = requireErrors(),
		l = requireEntities(),
		c = requireSax(),
		d = s.DOMImplementation,
		f = o.hasDefaultHTMLNamespace,
		m = o.isHTMLMimeType,
		g = o.isValidMimeType,
		v = o.MIME_TYPE,
		y = o.NAMESPACE,
		b = a.ParseError,
		C = c.XMLReader;

	function _(R) {
		return R.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028\u2029]/g, `
`)
	}

	function S(R) {
		if (R = R || {}, R.locator === void 0 && (R.locator = !0), this.assign = R.assign || o.assign, this.domHandler =
			R.domHandler || w, this.onError = R.onError || R.errorHandler, R.errorHandler && typeof R.errorHandler !=
			"function") throw new TypeError("errorHandler object is no longer supported, switch to onError!");
		R.errorHandler && R.errorHandler("warning",
				"The `errorHandler` option has been deprecated, use `onError` instead!", this), this
			.normalizeLineEndings = R.normalizeLineEndings || _, this.locator = !!R.locator, this.xmlns = this.assign(
				Object.create(null), R.xmlns)
	}
	S.prototype.parseFromString = function(R, O) {
		if (!g(O)) throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + O +
		'" is not valid.');
		var U = this.assign(Object.create(null), this.xmlns),
			V = l.XML_ENTITIES,
			z = U[""] || null;
		f(O) ? (V = l.HTML_ENTITIES, z = y.HTML) : O === v.XML_SVG_IMAGE && (z = y.SVG), U[""] = z, U.xml = U.xml ||
			y.XML;
		var j = new this.domHandler({
				mimeType: O,
				defaultNamespace: z,
				onError: this.onError
			}),
			ge = this.locator ? {} : void 0;
		this.locator && j.setDocumentLocator(ge);
		var me = new C;
		me.errorHandler = j, me.domBuilder = j;
		var he = !o.isHTMLMimeType(O);
		return he && typeof R != "string" && me.errorHandler.fatalError("source is not a string"), me.parse(this
			.normalizeLineEndings(String(R)), U, V), j.doc.documentElement || me.errorHandler.fatalError(
			"missing root element"), j.doc
	};

	function w(R) {
		var O = R || {};
		this.mimeType = O.mimeType || v.XML_APPLICATION, this.defaultNamespace = O.defaultNamespace || null, this
			.cdata = !1, this.currentElement = void 0, this.doc = void 0, this.locator = void 0, this.onError = O
			.onError
	}

	function T(R, O) {
		O.lineNumber = R.lineNumber, O.columnNumber = R.columnNumber
	}
	w.prototype = {
		startDocument: function() {
			var R = new d;
			this.doc = m(this.mimeType) ? R.createHTMLDocument(!1) : R.createDocument(this.defaultNamespace, "")
		},
		startElement: function(R, O, U, V) {
			var z = this.doc,
				j = z.createElementNS(R, U || O),
				ge = V.length;
			M(this, j), this.currentElement = j, this.locator && T(this.locator, j);
			for (var me = 0; me < ge; me++) {
				var R = V.getURI(me),
					he = V.getValue(me),
					U = V.getQName(me),
					ce = z.createAttributeNS(R, U);
				this.locator && T(V.getLocator(me), ce), ce.value = ce.nodeValue = he, j.setAttributeNode(ce)
			}
		},
		endElement: function(R, O, U) {
			this.currentElement = this.currentElement.parentNode
		},
		startPrefixMapping: function(R, O) {},
		endPrefixMapping: function(R) {},
		processingInstruction: function(R, O) {
			var U = this.doc.createProcessingInstruction(R, O);
			this.locator && T(this.locator, U), M(this, U)
		},
		ignorableWhitespace: function(R, O, U) {},
		characters: function(R, O, U) {
			if (R = k.apply(this, arguments), R) {
				if (this.cdata) var V = this.doc.createCDATASection(R);
				else var V = this.doc.createTextNode(R);
				this.currentElement ? this.currentElement.appendChild(V) : /^\s*$/.test(R) && this.doc
					.appendChild(V), this.locator && T(this.locator, V)
			}
		},
		skippedEntity: function(R) {},
		endDocument: function() {
			this.doc.normalize()
		},
		setDocumentLocator: function(R) {
			R && (R.lineNumber = 0), this.locator = R
		},
		comment: function(R, O, U) {
			R = k.apply(this, arguments);
			var V = this.doc.createComment(R);
			this.locator && T(this.locator, V), M(this, V)
		},
		startCDATA: function() {
			this.cdata = !0
		},
		endCDATA: function() {
			this.cdata = !1
		},
		startDTD: function(R, O, U, V) {
			var z = this.doc.implementation;
			if (z && z.createDocumentType) {
				var j = z.createDocumentType(R, O, U, V);
				this.locator && T(this.locator, j), M(this, j), this.doc.doctype = j
			}
		},
		reportError: function(R, O) {
			if (typeof this.onError == "function") try {
				this.onError(R, O, this)
			} catch (U) {
				throw new b("Reporting " + R + ' "' + O + '" caused ' + U, this.locator)
			} else console.error("[xmldom " + R + "]	" + O, A(this.locator))
		},
		warning: function(R) {
			this.reportError("warning", R)
		},
		error: function(R) {
			this.reportError("error", R)
		},
		fatalError: function(R) {
			throw this.reportError("fatalError", R), new b(R, this.locator)
		}
	};

	function A(R) {
		if (R) return `
@#[line:` + R.lineNumber + ",col:" + R.columnNumber + "]"
	}

	function k(R, O, U) {
		return typeof R == "string" ? R.substr(O, U) : R.length >= O + U || O ? new java.lang.String(R, O, U) + "" : R
	}
	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl"
	.replace(/\w+/g, function(R) {
		w.prototype[R] = function() {
			return null
		}
	});

	function M(R, O) {
		R.currentElement ? R.currentElement.appendChild(O) : R.doc.appendChild(O)
	}

	function D(R) {
		if (R === "error") throw "onErrorStopParsing"
	}

	function F() {
		throw "onWarningStopParsing"
	}
	return domParser.__DOMHandler = w, domParser.DOMParser = S, domParser.normalizeLineEndings = _, domParser
		.onErrorStopParsing = D, domParser.onWarningStopParsing = F, domParser
}
var hasRequiredLib;

function requireLib() {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	var o = requireConventions();
	lib.assign = o.assign, lib.hasDefaultHTMLNamespace = o.hasDefaultHTMLNamespace, lib.isHTMLMimeType = o
		.isHTMLMimeType, lib.isValidMimeType = o.isValidMimeType, lib.MIME_TYPE = o.MIME_TYPE, lib.NAMESPACE = o
		.NAMESPACE;
	var s = requireErrors();
	lib.DOMException = s.DOMException, lib.DOMExceptionName = s.DOMExceptionName, lib.ExceptionCode = s.ExceptionCode,
		lib.ParseError = s.ParseError;
	var a = requireDom();
	lib.Attr = a.Attr, lib.CDATASection = a.CDATASection, lib.CharacterData = a.CharacterData, lib.Comment = a.Comment,
		lib.Document = a.Document, lib.DocumentFragment = a.DocumentFragment, lib.DocumentType = a.DocumentType, lib
		.DOMImplementation = a.DOMImplementation, lib.Element = a.Element, lib.Entity = a.Entity, lib.EntityReference =
		a.EntityReference, lib.LiveNodeList = a.LiveNodeList, lib.NamedNodeMap = a.NamedNodeMap, lib.Node = a.Node, lib
		.NodeList = a.NodeList, lib.Notation = a.Notation, lib.ProcessingInstruction = a.ProcessingInstruction, lib
		.Text = a.Text, lib.XMLSerializer = a.XMLSerializer;
	var l = requireDomParser();
	return lib.DOMParser = l.DOMParser, lib.normalizeLineEndings = l.normalizeLineEndings, lib.onErrorStopParsing = l
		.onErrorStopParsing, lib.onWarningStopParsing = l.onWarningStopParsing, lib
}
var libExports = requireLib();
const _box$1 = new Box3,
	_vector = new Vector3$1;
class LineSegmentsGeometry extends InstancedBufferGeometry {
	constructor() {
		super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
		const s = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0],
			a = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
			l = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
		this.setIndex(l), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("uv",
			new Float32BufferAttribute(a, 2))
	}
	applyMatrix4(s) {
		const a = this.attributes.instanceStart,
			l = this.attributes.instanceEnd;
		return a !== void 0 && (a.applyMatrix4(s), l.applyMatrix4(s), a.needsUpdate = !0), this.boundingBox !==
			null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
	}
	setPositions(s) {
		let a;
		s instanceof Float32Array ? a = s : Array.isArray(s) && (a = new Float32Array(s));
		const l = new InstancedInterleavedBuffer(a, 6, 1);
		return this.setAttribute("instanceStart", new InterleavedBufferAttribute(l, 3, 0)), this.setAttribute(
				"instanceEnd", new InterleavedBufferAttribute(l, 3, 3)), this.instanceCount = this.attributes
			.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this
	}
	setColors(s) {
		let a;
		s instanceof Float32Array ? a = s : Array.isArray(s) && (a = new Float32Array(s));
		const l = new InstancedInterleavedBuffer(a, 6, 1);
		return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(l, 3, 0)), this.setAttribute(
			"instanceColorEnd", new InterleavedBufferAttribute(l, 3, 3)), this
	}
	fromWireframeGeometry(s) {
		return this.setPositions(s.attributes.position.array), this
	}
	fromEdgesGeometry(s) {
		return this.setPositions(s.attributes.position.array), this
	}
	fromMesh(s) {
		return this.fromWireframeGeometry(new WireframeGeometry(s.geometry)), this
	}
	fromLineSegments(s) {
		const a = s.geometry;
		return this.setPositions(a.attributes.position.array), this
	}
	computeBoundingBox() {
		this.boundingBox === null && (this.boundingBox = new Box3);
		const s = this.attributes.instanceStart,
			a = this.attributes.instanceEnd;
		s !== void 0 && a !== void 0 && (this.boundingBox.setFromBufferAttribute(s), _box$1.setFromBufferAttribute(
			a), this.boundingBox.union(_box$1))
	}
	computeBoundingSphere() {
		this.boundingSphere === null && (this.boundingSphere = new Sphere), this.boundingBox === null && this
			.computeBoundingBox();
		const s = this.attributes.instanceStart,
			a = this.attributes.instanceEnd;
		if (s !== void 0 && a !== void 0) {
			const l = this.boundingSphere.center;
			this.boundingBox.getCenter(l);
			let c = 0;
			for (let d = 0, f = s.count; d < f; d++) _vector.fromBufferAttribute(s, d), c = Math.max(c, l
				.distanceToSquared(_vector)), _vector.fromBufferAttribute(a, d), c = Math.max(c, l
				.distanceToSquared(_vector));
			this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error(
				"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
				this)
		}
	}
	toJSON() {}
}
UniformsLib.line = {
	worldUnits: {
		value: 1
	},
	linewidth: {
		value: 1
	},
	resolution: {
		value: new Vector2(1, 1)
	},
	dashOffset: {
		value: 0
	},
	dashScale: {
		value: 1
	},
	dashSize: {
		value: 1
	},
	gapSize: {
		value: 1
	}
};
ShaderLib.line = {
	uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]),
	vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
	fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class LineMaterial extends ShaderMaterial {
	constructor(s) {
		super({
			type: "LineMaterial",
			uniforms: UniformsUtils.clone(ShaderLib.line.uniforms),
			vertexShader: ShaderLib.line.vertexShader,
			fragmentShader: ShaderLib.line.fragmentShader,
			clipping: !0
		}), this.isLineMaterial = !0, this.setValues(s)
	}
	get color() {
		return this.uniforms.diffuse.value
	}
	set color(s) {
		this.uniforms.diffuse.value = s
	}
	get worldUnits() {
		return "WORLD_UNITS" in this.defines
	}
	set worldUnits(s) {
		s === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
	}
	get linewidth() {
		return this.uniforms.linewidth.value
	}
	set linewidth(s) {
		this.uniforms.linewidth && (this.uniforms.linewidth.value = s)
	}
	get dashed() {
		return "USE_DASH" in this.defines
	}
	set dashed(s) {
		s === !0 !== this.dashed && (this.needsUpdate = !0), s === !0 ? this.defines.USE_DASH = "" : delete this
			.defines.USE_DASH
	}
	get dashScale() {
		return this.uniforms.dashScale.value
	}
	set dashScale(s) {
		this.uniforms.dashScale.value = s
	}
	get dashSize() {
		return this.uniforms.dashSize.value
	}
	set dashSize(s) {
		this.uniforms.dashSize.value = s
	}
	get dashOffset() {
		return this.uniforms.dashOffset.value
	}
	set dashOffset(s) {
		this.uniforms.dashOffset.value = s
	}
	get gapSize() {
		return this.uniforms.gapSize.value
	}
	set gapSize(s) {
		this.uniforms.gapSize.value = s
	}
	get opacity() {
		return this.uniforms.opacity.value
	}
	set opacity(s) {
		this.uniforms && (this.uniforms.opacity.value = s)
	}
	get resolution() {
		return this.uniforms.resolution.value
	}
	set resolution(s) {
		this.uniforms.resolution.value.copy(s)
	}
	get alphaToCoverage() {
		return "USE_ALPHA_TO_COVERAGE" in this.defines
	}
	set alphaToCoverage(s) {
		this.defines && (s === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), s === !0 ? this.defines
			.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE)
	}
}
const _viewport = new Vector4,
	_start = new Vector3$1,
	_end = new Vector3$1,
	_start4 = new Vector4,
	_end4 = new Vector4,
	_ssOrigin = new Vector4,
	_ssOrigin3 = new Vector3$1,
	_mvMatrix = new Matrix4,
	_line = new Line3,
	_closestPoint = new Vector3$1,
	_box = new Box3,
	_sphere = new Sphere,
	_clipToWorldVector = new Vector4;
let _ray, _lineWidth;

function getWorldSpaceHalfWidth(o, s, a) {
	return _clipToWorldVector.set(0, 0, -s, 1).applyMatrix4(o.projectionMatrix), _clipToWorldVector.multiplyScalar(1 /
			_clipToWorldVector.w), _clipToWorldVector.x = _lineWidth / a.width, _clipToWorldVector.y = _lineWidth / a
		.height, _clipToWorldVector.applyMatrix4(o.projectionMatrixInverse), _clipToWorldVector.multiplyScalar(1 /
			_clipToWorldVector.w), Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))
}

function raycastWorldUnits(o, s) {
	const a = o.matrixWorld,
		l = o.geometry,
		c = l.attributes.instanceStart,
		d = l.attributes.instanceEnd,
		f = Math.min(l.instanceCount, c.count);
	for (let m = 0, g = f; m < g; m++) {
		_line.start.fromBufferAttribute(c, m), _line.end.fromBufferAttribute(d, m), _line.applyMatrix4(a);
		const v = new Vector3$1,
			y = new Vector3$1;
		_ray.distanceSqToSegment(_line.start, _line.end, y, v), y.distanceTo(v) < _lineWidth * .5 && s.push({
			point: y,
			pointOnLine: v,
			distance: _ray.origin.distanceTo(y),
			object: o,
			face: null,
			faceIndex: m,
			uv: null,
			uv1: null
		})
	}
}

function raycastScreenSpace(o, s, a) {
	const l = s.projectionMatrix,
		d = o.material.resolution,
		f = o.matrixWorld,
		m = o.geometry,
		g = m.attributes.instanceStart,
		v = m.attributes.instanceEnd,
		y = Math.min(m.instanceCount, g.count),
		b = -s.near;
	_ray.at(1, _ssOrigin), _ssOrigin.w = 1, _ssOrigin.applyMatrix4(s.matrixWorldInverse), _ssOrigin.applyMatrix4(l),
		_ssOrigin.multiplyScalar(1 / _ssOrigin.w), _ssOrigin.x *= d.x / 2, _ssOrigin.y *= d.y / 2, _ssOrigin.z = 0,
		_ssOrigin3.copy(_ssOrigin), _mvMatrix.multiplyMatrices(s.matrixWorldInverse, f);
	for (let C = 0, _ = y; C < _; C++) {
		if (_start4.fromBufferAttribute(g, C), _end4.fromBufferAttribute(v, C), _start4.w = 1, _end4.w = 1, _start4
			.applyMatrix4(_mvMatrix), _end4.applyMatrix4(_mvMatrix), _start4.z > b && _end4.z > b) continue;
		if (_start4.z > b) {
			const M = _start4.z - _end4.z,
				D = (_start4.z - b) / M;
			_start4.lerp(_end4, D)
		} else if (_end4.z > b) {
			const M = _end4.z - _start4.z,
				D = (_end4.z - b) / M;
			_end4.lerp(_start4, D)
		}
		_start4.applyMatrix4(l), _end4.applyMatrix4(l), _start4.multiplyScalar(1 / _start4.w), _end4.multiplyScalar(1 /
				_end4.w), _start4.x *= d.x / 2, _start4.y *= d.y / 2, _end4.x *= d.x / 2, _end4.y *= d.y / 2, _line
			.start.copy(_start4), _line.start.z = 0, _line.end.copy(_end4), _line.end.z = 0;
		const w = _line.closestPointToPointParameter(_ssOrigin3, !0);
		_line.at(w, _closestPoint);
		const T = MathUtils.lerp(_start4.z, _end4.z, w),
			A = T >= -1 && T <= 1,
			k = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * .5;
		if (A && k) {
			_line.start.fromBufferAttribute(g, C), _line.end.fromBufferAttribute(v, C), _line.start.applyMatrix4(f),
				_line.end.applyMatrix4(f);
			const M = new Vector3$1,
				D = new Vector3$1;
			_ray.distanceSqToSegment(_line.start, _line.end, D, M), a.push({
				point: D,
				pointOnLine: M,
				distance: _ray.origin.distanceTo(D),
				object: o,
				face: null,
				faceIndex: C,
				uv: null,
				uv1: null
			})
		}
	}
}
class LineSegments2 extends Mesh {
	constructor(s = new LineSegmentsGeometry, a = new LineMaterial({
		color: Math.random() * 16777215
	})) {
		super(s, a), this.isLineSegments2 = !0, this.type = "LineSegments2"
	}
	computeLineDistances() {
		const s = this.geometry,
			a = s.attributes.instanceStart,
			l = s.attributes.instanceEnd,
			c = new Float32Array(2 * a.count);
		for (let f = 0, m = 0, g = a.count; f < g; f++, m += 2) _start.fromBufferAttribute(a, f), _end
			.fromBufferAttribute(l, f), c[m] = m === 0 ? 0 : c[m - 1], c[m + 1] = c[m] + _start.distanceTo(_end);
		const d = new InstancedInterleavedBuffer(c, 2, 1);
		return s.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(d, 1, 0)), s.setAttribute(
			"instanceDistanceEnd", new InterleavedBufferAttribute(d, 1, 1)), this
	}
	raycast(s, a) {
		const l = this.material.worldUnits,
			c = s.camera;
		c === null && !l && console.error(
			'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'
			);
		const d = s.params.Line2 !== void 0 && s.params.Line2.threshold || 0;
		_ray = s.ray;
		const f = this.matrixWorld,
			m = this.geometry,
			g = this.material;
		_lineWidth = g.linewidth + d, m.boundingSphere === null && m.computeBoundingSphere(), _sphere.copy(m
			.boundingSphere).applyMatrix4(f);
		let v;
		if (l) v = _lineWidth * .5;
		else {
			const b = Math.max(c.near, _sphere.distanceToPoint(_ray.origin));
			v = getWorldSpaceHalfWidth(c, b, g.resolution)
		}
		if (_sphere.radius += v, _ray.intersectsSphere(_sphere) === !1) return;
		m.boundingBox === null && m.computeBoundingBox(), _box.copy(m.boundingBox).applyMatrix4(f);
		let y;
		if (l) y = _lineWidth * .5;
		else {
			const b = Math.max(c.near, _box.distanceToPoint(_ray.origin));
			y = getWorldSpaceHalfWidth(c, b, g.resolution)
		}
		_box.expandByScalar(y), _ray.intersectsBox(_box) !== !1 && (l ? raycastWorldUnits(this, a) :
			raycastScreenSpace(this, c, a))
	}
	onBeforeRender(s) {
		const a = this.material.uniforms;
		a && a.resolution && (s.getViewport(_viewport), this.material.uniforms.resolution.value.set(_viewport.z,
			_viewport.w))
	}
}
class LineGeometry extends LineSegmentsGeometry {
	constructor() {
		super(), this.isLineGeometry = !0, this.type = "LineGeometry"
	}
	setPositions(s) {
		const a = s.length - 3,
			l = new Float32Array(2 * a);
		for (let c = 0; c < a; c += 3) l[2 * c] = s[c], l[2 * c + 1] = s[c + 1], l[2 * c + 2] = s[c + 2], l[2 * c +
			3] = s[c + 3], l[2 * c + 4] = s[c + 4], l[2 * c + 5] = s[c + 5];
		return super.setPositions(l), this
	}
	setColors(s) {
		const a = s.length - 3,
			l = new Float32Array(2 * a);
		for (let c = 0; c < a; c += 3) l[2 * c] = s[c], l[2 * c + 1] = s[c + 1], l[2 * c + 2] = s[c + 2], l[2 * c +
			3] = s[c + 3], l[2 * c + 4] = s[c + 4], l[2 * c + 5] = s[c + 5];
		return super.setColors(l), this
	}
	setFromPoints(s) {
		const a = s.length - 1,
			l = new Float32Array(6 * a);
		for (let c = 0; c < a; c++) l[6 * c] = s[c].x, l[6 * c + 1] = s[c].y, l[6 * c + 2] = s[c].z || 0, l[6 * c +
			3] = s[c + 1].x, l[6 * c + 4] = s[c + 1].y, l[6 * c + 5] = s[c + 1].z || 0;
		return super.setPositions(l), this
	}
	fromLine(s) {
		const a = s.geometry;
		return this.setPositions(a.attributes.position.array), this
	}
}
class Line2 extends LineSegments2 {
	constructor(s = new LineGeometry, a = new LineMaterial({
		color: Math.random() * 16777215
	})) {
		super(s, a), this.isLine2 = !0, this.type = "Line2"
	}
}
var Re = Object.defineProperty,
	Ee = (o, s, a) => s in o ? Re(o, s, {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: a
	}) : o[s] = a,
	u = (o, s, a) => Ee(o, typeof s != "symbol" ? s + "" : s, a);
const makeColorMaterial = (o, s, a, l) => {
		const c = new Color;
		return c.setRGB(o, s, a), l <= .99 ? new MeshBasicMaterial({
			color: c.getHex(),
			opacity: l + .1,
			transparent: !0,
			depthWrite: !0,
			blendSrc: SrcAlphaFactor,
			blendDst: OneMinusSrcAlphaFactor,
			blendEquation: ReverseSubtractEquation,
			blending: NormalBlending
		}) : new MeshPhongMaterial({
			color: c.getHex(),
			opacity: l,
			blending: NormalBlending
		})
	},
	intersectPlane = (o, s, a) => {
		const l = new Vector3$1,
			c = new Vector3$1;
		l.subVectors(s, o.origin);
		const d = o.direction.dot(a);
		if (Math.abs(d) < o.precision) return;
		const f = a.dot(l) / d;
		return c.addVectors(o.origin, o.direction.clone().multiplyScalar(f)), c
	},
	findClosestPoint = (o, s) => {
		const a = new Vector3$1;
		a.subVectors(o.origin, s.origin);
		const l = s.direction.clone(),
			c = o.direction.clone(),
			d = a.dot(l),
			f = l.dot(c),
			m = a.dot(c),
			g = l.dot(l),
			v = c.dot(c) * g - f * f;
		if (!(Math.abs(v) <= 1e-4)) return (d * f - m * g) / v
	},
	closestAxisPoint = (o, s, a) => {
		const l = o.origin.clone();
		l.project(s);
		const c = o.direction.clone().add(o.origin);
		c.project(s);
		const d = c.clone().sub(l),
			f = new Vector2().subVectors(a, l).dot(d) / d.dot(d),
			m = new Vector2;
		m.addVectors(l, d.clone().multiplyScalar(f));
		const g = new Vector3$1(m.x, m.y, .5);
		g.unproject(s);
		const v = new Ray(s.position, g.sub(s.position).normalize());
		return findClosestPoint(o, v)
	},
	getRandomVibrantHexColor = () => {
		const o = Math.floor(256 * Math.random()),
			s = Math.floor(256 * Math.random()),
			a = Math.floor(256 * Math.random()),
			l = Math.max(o, s, a),
			c = Math.min(o, s, a);
		if (l < 200 || l - c < 50) return getRandomVibrantHexColor();
		const d = f => f.toString(16).padStart(2, "0");
		return `#${d(o)}${d(s)}${d(a)}`
	},
	rotation90 = new Quaternion$1().setFromAxisAngle(new Vector3$1(0, 0, 1), Math.PI / 2),
	convertToROSRotation = o => o.multiply(rotation90),
	isMobileDevice = () => {
		const o = navigator.userAgent,
			s = ["Android", "webOS", "iPhone", "iPad", "iPod", "BlackBerry", "Windows Phone"];
		for (let a = 0; a < s.length; a++)
			if (o.indexOf(s[a]) > -1) return !0;
		return !1
	},
	MARKER_ARROW = 0,
	MARKER_CUBE = 1,
	MARKER_SPHERE = 2,
	MARKER_CYLINDER = 3,
	MARKER_LINE_STRIP = 4,
	MARKER_LINE_LIST = 5,
	MARKER_CUBE_LIST = 6,
	MARKER_SPHERE_LIST = 7,
	MARKER_POINTS = 8,
	MARKER_TEXT_VIEW_FACING = 9,
	MARKER_MESH_RESOURCE = 10,
	MARKER_TRIANGLE_LIST = 11;
var OcTreeVoxelRenderMode = (o => (o.OCCUPIED = "occupied", o.FREE = "free", o.ALL = "all", o))(OcTreeVoxelRenderMode ||
	{}),
	OcTreeColorMode = (o => (o.CELL_COLOR = "cellColor", o.Z_AXIS_COLOR = "zAxisColor", o.PROBABILITY_COLOR =
		"probabilityColor", o))(OcTreeColorMode || {});
const ve = class br extends Object3D {
	constructor(s) {
		super(), u(this, "lineGeom"), u(this, "headGeom");
		const {
			shaftRadius: a,
			headRadius: l,
			headLength: c,
			scale: d,
			lineType: f,
			lineDashLength: m
		} = {
			...br.defaultOptions,
			...s
		};
		this.scale.set(d, d, d), this.lineGeom = new CylinderGeometry(a, a, 1 - c), this.headGeom =
			new CylinderGeometry(0, l, c), [new Vector3$1(1, 0, 0), new Vector3$1(0, 1, 0), new Vector3$1(0, 0,
				1)].forEach(g => this.addAxis(g, a, f, m, c)), this.frustumCulled = !1
	}
	addAxis(s, a, l, c, d) {
		const f = new Color().setRGB(s.x, s.y, s.z),
			m = new MeshBasicMaterial({
				color: f.getHex()
			}),
			g = this.getRotation(s);
		l === "dashed" ? this.createDashedLine(m, s, g, a, c, d) : l === "full" && this.createFullLine(m, s, g,
			d);
		const v = this.createArrow(m, s, g, d);
		this.add(v)
	}
	getRotation(s) {
		const a = new Vector3$1().crossVectors(s, new Vector3$1(0, -1, 0)),
			l = new Quaternion$1;
		return l.setFromAxisAngle(a, .5 * Math.PI), l
	}
	createArrow(s, a, l, c) {
		const d = new Mesh(this.headGeom, s);
		return d.position.copy(a).multiplyScalar(1 - c / 2), d.quaternion.copy(l), d.updateMatrix(), d
			.frustumCulled = !1, d
	}
	createDashedLine(s, a, l, c, d, f) {
		const m = 1 - f;
		for (let g = 0; d / 2 + 3 * d * g + d / 2 <= m; ++g) {
			const v = new CylinderGeometry(c, c, d),
				y = new Mesh(v, s);
			y.position.copy(a).multiplyScalar(d / 2 + 3 * d * g + d / 2), y.quaternion.copy(l), y
			.updateMatrix(), y.frustumCulled = !1, this.add(y)
		}
	}
	createFullLine(s, a, l, c) {
		const d = new Mesh(this.lineGeom, s);
		d.position.copy(a).multiplyScalar((1 - c) / 2), d.quaternion.copy(l), d.updateMatrix(), d
			.frustumCulled = !1, this.add(d)
	}
};
u(ve, "defaultOptions", {
	shaftRadius: .008,
	headRadius: .023,
	headLength: .1,
	scale: 1,
	lineType: "full",
	lineDashLength: .1
});
let Axes = ve;
class Grid extends Object3D {
	constructor(s) {
		super(), this.frustumCulled = !1;
		const a = (s = s ?? {}).numCells ?? 10,
			l = s.color ?? "#cccccc",
			c = s.lineWidth ?? 1,
			d = s.cellSize ?? 1,
			f = s.position ?? {
				x: 0,
				y: 0,
				z: .01
			};
		this.position.set(f.x, f.y, f.z);
		const m = new LineBasicMaterial({
			color: l,
			linewidth: c
		});
		for (let g = 0; g <= a; ++g) {
			const v = d * a / 2,
				y = v - g * d,
				b = new Float32Array([-v, y, 0, v, y, 0]),
				C = new BufferGeometry;
			C.setAttribute("position", new BufferAttribute(b, 3));
			const _ = new Float32Array([y, -v, 0, y, v, 0]),
				S = new BufferGeometry;
			S.setAttribute("position", new BufferAttribute(_, 3));
			const w = new Line(C, m);
			w.frustumCulled = !1;
			const T = new Line(S, m);
			T.frustumCulled = !1, this.add(w), this.add(T)
		}
	}
}
const MeshLoader = {
	loaders: {
		dae: (o, s, a) => {
			const l = new Blob([s.buffer.slice(s.byteOffset)], {
					type: "application/octet-stream"
				}),
				c = URL.createObjectURL(l),
				d = a.material || null,
				f = new ColladaLoader;
			return f.loadAsync(c).then(m => {
				URL.revokeObjectURL(c), d !== null && m.scene.traverse(g => {
					g instanceof Mesh && g.material === void 0 && (g.material = d)
				}), m.scene.frustumCulled = !1, o.add(m.scene)
			}).catch(m => {
				URL.revokeObjectURL(c), console.error(m)
			}), f
		},
		obj: (o, s, a) => {
			const l = new Blob([s.buffer.slice(s.byteOffset)], {
					type: "application/octet-stream"
				}),
				c = URL.createObjectURL(l),
				d = new OBJLoader;
			return d.loadAsync(c).then(f => {
				URL.revokeObjectURL(c), f.frustumCulled = !1, o.add(f)
			}).catch(f => {
				URL.revokeObjectURL(c), console.error(f)
			}), d
		},
		stl: (o, s, a) => {
			const l = new Blob([s.buffer.slice(s.byteOffset)], {
					type: "application/octet-stream"
				}),
				c = URL.createObjectURL(l),
				d = a.material || null,
				f = new STLLoader;
			return f.loadAsync(c).then(m => {
				let g;
				URL.revokeObjectURL(c), m.computeVertexNormals(), g = d !== null ? new Mesh(m, d) :
					new Mesh(m, new MeshBasicMaterial({
						color: 10066329
					})), g.frustumCulled = !1, o.add(g)
			}).catch(m => {
				URL.revokeObjectURL(c), console.error(m)
			}), f
		}
	}
};
class MeshResource extends Object3D {
	constructor(s) {
		super(), this.frustumCulled = !1;
		const {
			data: a,
			fileType: l,
			material: c
		} = s, d = MeshLoader.loaders[l];
		d ? d(this, a, {
			material: c ? c instanceof Material ? c : new MeshBasicMaterial(c) : null
		}) : console.warn(`Unsupported loader for file type: '${l}'`)
	}
}
class Arrow extends Mesh {
	constructor(s = {}) {
		const a = s.origin ?? new Vector3$1(0, 0, 0),
			l = s.direction ?? new Vector3$1(1, 0, 0),
			c = s.length ?? 1,
			d = s.headLength ?? .2,
			f = s.shaftDiameter ?? .05,
			m = s.headDiameter ?? .1,
			g = s.material ?? new MeshBasicMaterial,
			v = c - d,
			y = new CylinderGeometry(.5 * f, .5 * f, v, 12, 1),
			b = new Matrix4;
		b.setPosition(new Vector3$1(0, .5 * v, 0)), y.applyMatrix4(b);
		const C = new CylinderGeometry(0, .5 * m, d, 12, 1);
		b.setPosition(new Vector3$1(0, v + .5 * d, 0)), C.applyMatrix4(b), super(mergeGeometries([y, C]), g), this
			.position.copy(a), this.setDirection(l), this.frustumCulled = !1
	}
	setDirection(s) {
		const a = new Vector3$1;
		s.x === 0 && s.z === 0 ? a.set(1, 0, 0) : a.set(0, 1, 0).cross(s);
		const l = Math.acos(new Vector3$1(0, 1, 0).dot(s.clone().normalize()));
		this.matrix = new Matrix4().makeRotationAxis(a.normalize(), l), this.rotation.setFromRotationMatrix(this
			.matrix, this.rotation.order)
	}
	setLength(s) {
		this.scale.set(s, s, s)
	}
	setColor(s) {
		this.material.color.setHex(s)
	}
	dispose() {
		this.geometry !== void 0 && this.geometry.dispose(), this.material !== void 0 && this.material.dispose()
	}
}
class TriangleList extends Object3D {
	constructor(s) {
		super(), this.frustumCulled = !1;
		const a = s.material ?? new MeshBasicMaterial,
			l = s.vertices,
			c = s.colors;
		a.side = DoubleSide;
		const d = new BufferGeometry,
			f = new Float32Array(3 * l.length);
		for (let g = 0; g < l.length; g++) f[3 * g] = l[g].x, f[3 * g + 1] = l[g].y, f[3 * g + 2] = l[g].z;
		if (d.setAttribute("position", new BufferAttribute(f, 3)), c.length === l.length) {
			const g = new Float32Array(3 * c.length);
			for (let v = 0; v < c.length; v++) g[3 * v] = c[v].r, g[3 * v + 1] = c[v].g, g[3 * v + 2] = c[v].b;
			d.setAttribute("color", new BufferAttribute(g, 3)), a.vertexColors = !0
		} else if (c.length === l.length / 3) {
			const g = new Float32Array(3 * l.length);
			for (let v = 0; v < c.length; v++)
				for (let y = 0; y < 3; y++) g[9 * v + 3 * y] = c[v].r, g[9 * v + 3 * y + 1] = c[v].g, g[9 * v + 3 *
					y + 2] = c[v].b;
			d.setAttribute("color", new BufferAttribute(g, 3)), a.vertexColors = !0
		}
		d.computeVertexNormals();
		const m = new Mesh(d, a);
		m.frustumCulled = !1, this.add(m)
	}
	setColor(s) {
		this.traverse(a => {
			a instanceof Mesh && a.material.color.setHex(s)
		})
	}
}
class GridClient {
	constructor(s) {
		u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "defaultHide"), u(this, "sn"), u(this,
				"numCells", 10), u(this, "cellSize", 1), u(this, "color", "#CCCCCC"), u(this, "frameId"), u(this,
				"position"), this.ros = s.ros, this.tfClient = s.tfClient, this.viewer = s.viewer, this
			.defaultHide = s.defaultHide, this.setOptions(s)
	}
	setOptions(s) {
		this.numCells = s.numCells ?? 10, this.cellSize = s.cellSize ?? 1, this.color = s.color ?? "#cccccc", this
			.frameId = s.frameId ?? this.tfClient.fixedFrame, this.position = s.position, this.defaultHide || this
			.show()
	}
	show() {
		this.dispose();
		const s = new Grid({
			color: this.color,
			cellSize: this.cellSize,
			numCells: this.numCells,
			position: this.position
		});
		this.sn = new SceneNode({
			viewer: this.viewer,
			tfClient: this.tfClient,
			frameId: this.frameId ?? this.tfClient.fixedFrame,
			object: s
		}), this.viewer.addObject(this.sn)
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.sn && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn = void 0)
	}
}
class AxesClient {
	constructor(s) {
		u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "defaultHide"), u(this, "sn"), u(this,
				"frameId"), u(this, "lineType"), this.ros = s.ros, this.tfClient = s.tfClient, this.viewer = s
			.viewer, this.defaultHide = s.defaultHide, this.setOptions(s)
	}
	setOptions(s) {
		this.frameId = s.frameId ?? this.tfClient.fixedFrame, this.lineType = s.lineType ?? "full", this
			.defaultHide || this.show()
	}
	show() {
		this.dispose();
		const s = new Axes({
			shaftRadius: .025,
			headRadius: .07,
			headLength: .2,
			lineType: this.lineType
		});
		this.sn = new SceneNode({
			viewer: this.viewer,
			tfClient: this.tfClient,
			frameId: this.frameId ?? this.tfClient.fixedFrame,
			object: s
		}), this.viewer.addObject(this.sn)
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.sn && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn = void 0)
	}
}
const SET_PREFIX = "#SET#",
	GET_PREFIX = "#GET#",
	TOPIC_PREFIX = "#TOPIC#",
	ASSET_PREFIX = "#ASSET#",
	ADVERTISE_SUFFIX = "#ADVERTISE",
	UNADVERTISE_SUFFIX = "#UNADVERTISE",
	INITIAL_PARAM_REQUEST = "initialRequest";
class Vector3 {
	constructor(s) {
		u(this, "x"), u(this, "y"), u(this, "z"), s = s ?? {}, this.x = s.x ?? 0, this.y = s.y ?? 0, this.z = s.z ??
			0
	}
	add(s) {
		this.x += s.x, this.y += s.y, this.z += s.z
	}
	subtract(s) {
		this.x -= s.x, this.y -= s.y, this.z -= s.z
	}
	multiplyQuaternion(s) {
		const a = s.w * this.x + s.y * this.z - s.z * this.y,
			l = s.w * this.y + s.z * this.x - s.x * this.z,
			c = s.w * this.z + s.x * this.y - s.y * this.x,
			d = -s.x * this.x - s.y * this.y - s.z * this.z;
		this.x = a * s.w + d * -s.x + l * -s.z - c * -s.y, this.y = l * s.w + d * -s.y + c * -s.x - a * -s.z, this
			.z = c * s.w + d * -s.z + a * -s.y - l * -s.x
	}
	clone() {
		return new Vector3(this)
	}
}
class Quaternion {
	constructor(s) {
		u(this, "x"), u(this, "y"), u(this, "z"), u(this, "w"), s = s ?? {}, this.x = s.x ?? 0, this.y = s.y ?? 0,
			this.z = s.z ?? 0, this.w = typeof s.w == "number" ? s.w : 1
	}
	conjugate() {
		this.x *= -1, this.y *= -1, this.z *= -1
	}
	norm() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
	}
	normalize() {
		let s = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		s === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (s = 1 / s, this.x = this.x * s, this.y = this
			.y * s, this.z = this.z * s, this.w = this.w * s)
	}
	invert() {
		this.conjugate(), this.normalize()
	}
	multiply(s) {
		const a = this.x * s.w + this.y * s.z - this.z * s.y + this.w * s.x,
			l = -this.x * s.z + this.y * s.w + this.z * s.x + this.w * s.y,
			c = this.x * s.y - this.y * s.x + this.z * s.w + this.w * s.z,
			d = -this.x * s.x - this.y * s.y - this.z * s.z + this.w * s.w;
		this.x = a, this.y = l, this.z = c, this.w = d
	}
	clone() {
		return new Quaternion(this)
	}
}
class Transform {
	constructor(s) {
		u(this, "translation"), u(this, "rotation"), s = s ?? {}, this.translation = new Vector3(s.translation),
			this.rotation = new Quaternion(s.rotation)
	}
	clone() {
		return new Transform(this)
	}
}
class Pose {
	constructor(s) {
		u(this, "position"), u(this, "orientation"), s = s ?? {}, this.position = new Vector3(s.position), this
			.orientation = new Quaternion(s.orientation)
	}
	applyTransform(s) {
		this.position.multiplyQuaternion(s.rotation), this.position.add(s.translation);
		const a = s.rotation.clone();
		a.multiply(this.orientation), this.orientation = a
	}
	clone() {
		return new Pose(this)
	}
	multiply(s) {
		const a = s.clone();
		return a.applyTransform(new Transform({
			rotation: this.orientation,
			translation: this.position
		})), a
	}
	getInverse() {
		const s = this.clone();
		return s.orientation.invert(), s.position.multiplyQuaternion(s.orientation), s.position.x *= -1, s.position
			.y *= -1, s.position.z *= -1, s
	}
}
const transformToMatrix = o => {
		const {
			translation: s,
			rotation: a
		} = o, l = matrix([
			[1, 0, 0, s.x],
			[0, 1, 0, s.y],
			[0, 0, 1, s.z],
			[0, 0, 0, 1]
		]), {
			x: c,
			y: d,
			z: f,
			w: m
		} = a, g = matrix([
			[1 - 2 * d * d - 2 * f * f, 2 * c * d - 2 * f * m, 2 * c * f + 2 * d * m, 0],
			[2 * c * d + 2 * f * m, 1 - 2 * c * c - 2 * f * f, 2 * d * f - 2 * c * m, 0],
			[2 * c * f - 2 * d * m, 2 * d * f + 2 * c * m, 1 - 2 * c * c - 2 * d * d, 0],
			[0, 0, 0, 1]
		]);
		return multiply(l, g)
	},
	matrixToTransform = o => {
		const s = {
				x: o.get([0, 3]),
				y: o.get([1, 3]),
				z: o.get([2, 3])
			},
			a = [
				[o.get([0, 0]), o.get([0, 1]), o.get([0, 2])],
				[o.get([1, 0]), o.get([1, 1]), o.get([1, 2])],
				[o.get([2, 0]), o.get([2, 1]), o.get([2, 2])]
			],
			l = a[0][0] + a[1][1] + a[2][2];
		let c, d, f, m;
		if (l > 0) {
			const v = .5 / Math.sqrt(l + 1);
			m = .25 / v, c = (a[2][1] - a[1][2]) * v, d = (a[0][2] - a[2][0]) * v, f = (a[1][0] - a[0][1]) * v
		} else if (a[0][0] > a[1][1] && a[0][0] > a[2][2]) {
			const v = 2 * Math.sqrt(1 + a[0][0] - a[1][1] - a[2][2]);
			m = (a[2][1] - a[1][2]) / v, c = .25 * v, d = (a[0][1] + a[1][0]) / v, f = (a[0][2] + a[2][0]) / v
		} else if (a[1][1] > a[2][2]) {
			const v = 2 * Math.sqrt(1 + a[1][1] - a[0][0] - a[2][2]);
			m = (a[0][2] - a[2][0]) / v, c = (a[0][1] + a[1][0]) / v, d = .25 * v, f = (a[1][2] + a[2][1]) / v
		} else {
			const v = 2 * Math.sqrt(1 + a[2][2] - a[0][0] - a[1][1]);
			m = (a[1][0] - a[0][1]) / v, c = (a[0][2] + a[2][0]) / v, d = (a[1][2] + a[2][1]) / v, f = .25 * v
		}
		const g = Math.sqrt(c * c + d * d + f * f + m * m);
		return c /= g, d /= g, f /= g, m /= g, new Transform({
			translation: new Vector3({
				x: s.x,
				y: s.y,
				z: s.z
			}),
			rotation: new Quaternion({
				x: c,
				y: d,
				z: f,
				w: m
			})
		})
	},
	loadMsgFile = async o => await (await fetch(o)).text(), sleep = o => new Promise(s => setTimeout(s, o)),
		getRandomPositiveInteger = (o = 1, s = 1e6) => (o = Math.ceil(o), s = Math.floor(s), Math.floor(Math.random() *
			(s - o + 1)) + o), throttle = (o, s) => {
			let a = 0;
			return (...l) => {
				const c = Date.now();
				c - a >= s && (o.apply(void 0, l), a = c)
			}
		}, debounce = (o, s) => {
			let a;
			return (...l) => {
				clearTimeout(a), a = setTimeout(() => {
					o.apply(void 0, l)
				}, s)
			}
		}, SUPPORTED_VIEW_ROS1_TOPIC_MSG = ["nav_msgs/OccupancyGrid", "nav_msgs/Odometry", "nav_msgs/Path",
			"geometry_msgs/PointStamped", "geometry_msgs/PolygonStamped", "geometry_msgs/PoseStamped",
			"geometry_msgs/PoseArray", "geometry_msgs/PoseWithCovarianceStamped", "sensor_msgs/LaserScan",
			"sensor_msgs/PointCloud2", "sensor_msgs/Image", "sensor_msgs/Imu", "visualization_msgs/MarkerArray",
			"octomap_msgs/Octomap"
		], SUPPORTED_VIEW_ROS2_TOPIC_MSG = ["nav_msgs/msg/OccupancyGrid", "nav_msgs/msg/Odometry", "nav_msgs/msg/Path",
			"geometry_msgs/msg/PointStamped", "geometry_msgs/msg/PolygonStamped", "geometry_msgs/msg/PoseStamped",
			"geometry_msgs/msg/PoseArray", "geometry_msgs/msg/PoseWithCovarianceStamped", "sensor_msgs/msg/LaserScan",
			"sensor_msgs/msg/PointCloud2", "sensor_msgs/msg/Image", "sensor_msgs/msg/Imu",
			"visualization_msgs/msg/MarkerArray", "octomap_msgs/msg/Octomap"
		];
class Ros extends EventEmitter {
	constructor(s) {
		super(), u(this, "socket"), u(this, "serverInfo"), u(this, "parameters", {}), u(this, "time", 0n), u(this,
			"isConnected", !1), u(this, "topics", {}), u(this, "SUPPORTED_VIEW_TOPIC_MSG_TYPE", [...
			SUPPORTED_VIEW_ROS1_TOPIC_MSG, ...SUPPORTED_VIEW_ROS2_TOPIC_MSG
		]), (s = s ?? {}).url && this.connect(s.url)
	}
	connect(s) {
		this.socket && (this.socket.close(), this.socket = void 0);
		const a = s.startsWith("ws://") || s.startsWith("wss://") ? s : `ws://${s}`;
		this.socket = new FoxgloveClient({
			ws: new WebSocket(a, [FoxgloveClient.SUPPORTED_SUBPROTOCOL])
		}), this.socket.on("open", () => {
			var l;
			this.isConnected = !0, this.emit("connection"), this.emit("runReady"), (l = this.socket) ==
				null || l.getParameters([], INITIAL_PARAM_REQUEST)
		}), this.socket.on("error", l => {
			this.isConnected = !1, this.emit("error", l)
		}), this.socket.on("close", l => {
			this.isConnected = !1, this.emit("close", l)
		}), this.socket.on("serverInfo", l => {
			this.serverInfo = l, this.emit("serverInfo", this.serverInfo)
		}), this.socket.on("status", l => {
			console.log("status", JSON.stringify(l))
		}), this.socket.on("removeStatus", l => {
			console.log("removeStatus", JSON.stringify(l))
		}), this.socket.on("time", l => {
			this.time = l.timestamp, this.emit("runTimeReady"), this.emit("time", this.time)
		}), this.socket.on("parameterValues", l => {
			for (const c of l.parameters) this.parameters[c.name] = c.value, this.emit(
				`${GET_PREFIX}${c.name}`, c.value)
		}), this.socket.on("advertise", l => {
			for (const c of l) this.topics[c.topic] = c, this.emit(
				`${TOPIC_PREFIX}${c.topic}${ADVERTISE_SUFFIX}`, c);
			this.emit("topics", this.topics), this.emit("supportViewTopics", Object.fromEntries(Object
				.entries(this.topics).filter(([, c]) => this.SUPPORTED_VIEW_TOPIC_MSG_TYPE.includes(
					c.schemaName))))
		}), this.socket.on("unadvertise", l => {
			for (const c of l) delete this.topics[c], this.emit(`${TOPIC_PREFIX}${c}${UNADVERTISE_SUFFIX}`,
				c);
			this.emit("topics", this.topics)
		}), this.socket.on("message", l => {
			l.subscriptionId !== void 0 && this.emit(`${TOPIC_PREFIX}${l.subscriptionId}`, l.data)
		}), this.socket.on("fetchAssetResponse", l => {
			l.status === FetchAssetStatus.SUCCESS ? this.emit(`${ASSET_PREFIX}${l.requestId}`, l.data) :
				this.emit(`${ASSET_PREFIX}${l.requestId}`)
		})
	}
	close() {
		this.socket && this.socket.close()
	}
	runReady(s) {
		this.once("runReady", s), this.isConnected && this.emit("runReady")
	}
	runTimeReady(s) {
		this.once("runTimeReady", s), this.time != 0n && this.emit("runTimeReady")
	}
	getTopics(s) {
		this.once("topics", s), Object.keys(this.topics).length > 0 && this.emit("topics", this.topics)
	}
	onTopicAdvertise(s, a) {
		const l = `${TOPIC_PREFIX}${s}${ADVERTISE_SUFFIX}`;
		if (this.on(l, a), Object.keys(this.topics).length > 0) {
			const c = this.topics[s];
			c && this.emit(l, c)
		}
	}
	offTopicAdvertise(s) {
		const a = `${TOPIC_PREFIX}${s}${ADVERTISE_SUFFIX}`;
		this.off(a)
	}
	onTopicUnAdvertise(s, a) {
		const l = `${TOPIC_PREFIX}${s}${UNADVERTISE_SUFFIX}`;
		this.once(l, a)
	}
	offTopicUnAdvertise(s) {
		const a = `${TOPIC_PREFIX}${s}${UNADVERTISE_SUFFIX}`;
		this.off(a)
	}
	getServerInfo(s) {
		this.once("serverInfo", s), this.serverInfo && this.emit("serverInfo", this.serverInfo)
	}
	subscribe(s) {
		var a;
		return ((a = this.socket) == null ? void 0 : a.subscribe(s)) ?? -1
	}
	unsubscribe(s) {
		var a;
		(a = this.socket) == null || a.unsubscribe(s)
	}
	advertise(s) {
		var a;
		return ((a = this.socket) == null ? void 0 : a.advertise(s)) ?? -1
	}
	unadvertise(s) {
		var a;
		(a = this.socket) == null || a.unadvertise(s)
	}
	getParameters(s, a) {
		var l;
		(l = this.socket) == null || l.getParameters(s, a)
	}
	setParameters(s, a) {
		var l;
		(l = this.socket) == null || l.setParameters(s, a)
	}
	subscribeParameterUpdates(s) {
		var a;
		(a = this.socket) == null || a.subscribeParameterUpdates(s)
	}
	unsubscribeParameterUpdates(s) {
		var a;
		(a = this.socket) == null || a.unsubscribeParameterUpdates(s)
	}
	sendMessage(s, a) {
		var l;
		(l = this.socket) == null || l.sendMessage(s, a)
	}
	sendServiceCallRequest(s) {
		var a;
		(a = this.socket) == null || a.sendServiceCallRequest(s)
	}
	subscribeConnectionGraph() {
		var s;
		(s = this.socket) == null || s.subscribeConnectionGraph()
	}
	unsubscribeConnectionGraph() {
		var s;
		(s = this.socket) == null || s.unsubscribeConnectionGraph()
	}
	fetchAsset(s, a = getRandomPositiveInteger()) {
		var l;
		return (l = this.socket) == null || l.fetchAsset(s, a), new Promise(c => {
			this.once(`${ASSET_PREFIX}${a}`, c)
		})
	}
	now() {
		return {
			sec: Number(this.time / BigInt(1e9)),
			nsec: Number(this.time % BigInt(1e9))
		}
	}
}
class Param {
	constructor(s) {
		u(this, "ros"), u(this, "name"), this.ros = s.ros, this.name = s.name
	}
	get(s) {
		const a = `${GET_PREFIX}${this.name}`;
		this.ros.on(a, l => {
			this.ros.off(a), this.ros.unsubscribeParameterUpdates([this.name]), s(l)
		}), this.ros.runReady(() => {
			this.ros.getParameters([this.name], a), this.ros.subscribeParameterUpdates([this.name])
		})
	}
	set(s, a, l) {
		const c = `${SET_PREFIX}${this.name}`;
		this.ros.once(c, d => {
			d.length > 0 ? a == null || a(d[0].value) : l == null || l()
		}), this.ros.runReady(() => {
			this.ros.setParameters([{
				name: this.name,
				value: s
			}], c)
		})
	}
	delete() {
		throw new Error("Unsupported operation: delete")
	}
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ?
	global : typeof self < "u" ? self : {},
	descriptor = {
		exports: {}
	},
	src = {
		exports: {}
	},
	indexLight = {
		exports: {}
	},
	indexMinimal = {},
	minimal = {},
	aspromise, hasRequiredAspromise;

function requireAspromise() {
	return hasRequiredAspromise || (hasRequiredAspromise = 1, aspromise = function(o, s) {
		for (var a = new Array(arguments.length - 1), l = 0, c = 2, d = !0; c < arguments.length;) a[l++] =
			arguments[c++];
		return new Promise(function(f, m) {
			a[l] = function(g) {
				if (d)
					if (d = !1, g) m(g);
					else {
						for (var v = new Array(arguments.length - 1), y = 0; y < v.length;) v[y++] =
							arguments[y];
						f.apply(null, v)
					}
			};
			try {
				o.apply(s || null, a)
			} catch (g) {
				d && (d = !1, m(g))
			}
		})
	}), aspromise
}
var base64 = {},
	hasRequiredBase64, eventemitter, hasRequiredEventemitter, float, hasRequiredFloat, inquire_1, hasRequiredInquire;

function requireBase64() {
	return hasRequiredBase64 || (hasRequiredBase64 = 1, function(o) {
		var s = o;
		s.length = function(f) {
			var m = f.length;
			if (!m) return 0;
			for (var g = 0; --m % 4 > 1 && f.charAt(m) === "=";) ++g;
			return Math.ceil(3 * f.length) / 4 - g
		};
		for (var a = new Array(64), l = new Array(123), c = 0; c < 64;) l[a[c] = c < 26 ? c + 65 : c < 52 ? c +
			71 : c < 62 ? c - 4 : c - 59 | 43] = c++;
		s.encode = function(f, m, g) {
			for (var v, y = null, b = [], C = 0, _ = 0; m < g;) {
				var S = f[m++];
				switch (_) {
					case 0:
						b[C++] = a[S >> 2], v = (3 & S) << 4, _ = 1;
						break;
					case 1:
						b[C++] = a[v | S >> 4], v = (15 & S) << 2, _ = 2;
						break;
					case 2:
						b[C++] = a[v | S >> 6], b[C++] = a[63 & S], _ = 0
				}
				C > 8191 && ((y || (y = [])).push(String.fromCharCode.apply(String, b)), C = 0)
			}
			return _ && (b[C++] = a[v], b[C++] = 61, _ === 1 && (b[C++] = 61)), y ? (C && y.push(String
				.fromCharCode.apply(String, b.slice(0, C))), y.join("")) : String.fromCharCode.apply(
				String, b.slice(0, C))
		};
		var d = "invalid encoding";
		s.decode = function(f, m, g) {
			for (var v, y = g, b = 0, C = 0; C < f.length;) {
				var _ = f.charCodeAt(C++);
				if (_ === 61 && b > 1) break;
				if ((_ = l[_]) === void 0) throw Error(d);
				switch (b) {
					case 0:
						v = _, b = 1;
						break;
					case 1:
						m[g++] = v << 2 | (48 & _) >> 4, v = _, b = 2;
						break;
					case 2:
						m[g++] = (15 & v) << 4 | (60 & _) >> 2, v = _, b = 3;
						break;
					case 3:
						m[g++] = (3 & v) << 6 | _, b = 0
				}
			}
			if (b === 1) throw Error(d);
			return g - y
		}, s.test = function(f) {
			return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(f)
		}
	}(base64)), base64
}

function requireEventemitter() {
	if (hasRequiredEventemitter) return eventemitter;

	function o() {
		this._listeners = {}
	}
	return hasRequiredEventemitter = 1, eventemitter = o, o.prototype.on = function(s, a, l) {
		return (this._listeners[s] || (this._listeners[s] = [])).push({
			fn: a,
			ctx: l || this
		}), this
	}, o.prototype.off = function(s, a) {
		if (s === void 0) this._listeners = {};
		else if (a === void 0) this._listeners[s] = [];
		else
			for (var l = this._listeners[s], c = 0; c < l.length;) l[c].fn === a ? l.splice(c, 1) : ++c;
		return this
	}, o.prototype.emit = function(s) {
		var a = this._listeners[s];
		if (a) {
			for (var l = [], c = 1; c < arguments.length;) l.push(arguments[c++]);
			for (c = 0; c < a.length;) a[c].fn.apply(a[c++].ctx, l)
		}
		return this
	}, eventemitter
}

function requireFloat() {
	if (hasRequiredFloat) return float;

	function o(d) {
		return typeof Float32Array < "u" ? function() {
			var f = new Float32Array([-0]),
				m = new Uint8Array(f.buffer),
				g = m[3] === 128;

			function v(_, S, w) {
				f[0] = _, S[w] = m[0], S[w + 1] = m[1], S[w + 2] = m[2], S[w + 3] = m[3]
			}

			function y(_, S, w) {
				f[0] = _, S[w] = m[3], S[w + 1] = m[2], S[w + 2] = m[1], S[w + 3] = m[0]
			}

			function b(_, S) {
				return m[0] = _[S], m[1] = _[S + 1], m[2] = _[S + 2], m[3] = _[S + 3], f[0]
			}

			function C(_, S) {
				return m[3] = _[S], m[2] = _[S + 1], m[1] = _[S + 2], m[0] = _[S + 3], f[0]
			}
			d.writeFloatLE = g ? v : y, d.writeFloatBE = g ? y : v, d.readFloatLE = g ? b : C, d.readFloatBE = g ?
				C : b
		}() : function() {
			function f(g, v, y, b) {
				var C = v < 0 ? 1 : 0;
				if (C && (v = -v), v === 0) g(1 / v > 0 ? 0 : 2147483648, y, b);
				else if (isNaN(v)) g(2143289344, y, b);
				else if (v > 34028234663852886e22) g((C << 31 | 2139095040) >>> 0, y, b);
				else if (v < 11754943508222875e-54) g((C << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, y, b);
				else {
					var _ = Math.floor(Math.log(v) / Math.LN2);
					g((C << 31 | _ + 127 << 23 | 8388607 & Math.round(v * Math.pow(2, -_) * 8388608)) >>> 0, y, b)
				}
			}

			function m(g, v, y) {
				var b = g(v, y),
					C = 2 * (b >> 31) + 1,
					_ = b >>> 23 & 255,
					S = 8388607 & b;
				return _ === 255 ? S ? NaN : C * (1 / 0) : _ === 0 ? 1401298464324817e-60 * C * S : C * Math.pow(2,
					_ - 150) * (S + 8388608)
			}
			d.writeFloatLE = f.bind(null, s), d.writeFloatBE = f.bind(null, a), d.readFloatLE = m.bind(null, l), d
				.readFloatBE = m.bind(null, c)
		}(), typeof Float64Array < "u" ? function() {
			var f = new Float64Array([-0]),
				m = new Uint8Array(f.buffer),
				g = m[7] === 128;

			function v(_, S, w) {
				f[0] = _, S[w] = m[0], S[w + 1] = m[1], S[w + 2] = m[2], S[w + 3] = m[3], S[w + 4] = m[4], S[w +
					5] = m[5], S[w + 6] = m[6], S[w + 7] = m[7]
			}

			function y(_, S, w) {
				f[0] = _, S[w] = m[7], S[w + 1] = m[6], S[w + 2] = m[5], S[w + 3] = m[4], S[w + 4] = m[3], S[w +
					5] = m[2], S[w + 6] = m[1], S[w + 7] = m[0]
			}

			function b(_, S) {
				return m[0] = _[S], m[1] = _[S + 1], m[2] = _[S + 2], m[3] = _[S + 3], m[4] = _[S + 4], m[5] = _[S +
					5], m[6] = _[S + 6], m[7] = _[S + 7], f[0]
			}

			function C(_, S) {
				return m[7] = _[S], m[6] = _[S + 1], m[5] = _[S + 2], m[4] = _[S + 3], m[3] = _[S + 4], m[2] = _[S +
					5], m[1] = _[S + 6], m[0] = _[S + 7], f[0]
			}
			d.writeDoubleLE = g ? v : y, d.writeDoubleBE = g ? y : v, d.readDoubleLE = g ? b : C, d.readDoubleBE =
				g ? C : b
		}() : function() {
			function f(g, v, y, b, C, _) {
				var S = b < 0 ? 1 : 0;
				if (S && (b = -b), b === 0) g(0, C, _ + v), g(1 / b > 0 ? 0 : 2147483648, C, _ + y);
				else if (isNaN(b)) g(0, C, _ + v), g(2146959360, C, _ + y);
				else if (b > 17976931348623157e292) g(0, C, _ + v), g((S << 31 | 2146435072) >>> 0, C, _ + y);
				else {
					var w;
					if (b < 22250738585072014e-324) g((w = b / 5e-324) >>> 0, C, _ + v), g((S << 31 | w /
						4294967296) >>> 0, C, _ + y);
					else {
						var T = Math.floor(Math.log(b) / Math.LN2);
						T === 1024 && (T = 1023), g(4503599627370496 * (w = b * Math.pow(2, -T)) >>> 0, C, _ + v),
							g((S << 31 | T + 1023 << 20 | 1048576 * w & 1048575) >>> 0, C, _ + y)
					}
				}
			}

			function m(g, v, y, b, C) {
				var _ = g(b, C + v),
					S = g(b, C + y),
					w = 2 * (S >> 31) + 1,
					T = S >>> 20 & 2047,
					A = 4294967296 * (1048575 & S) + _;
				return T === 2047 ? A ? NaN : w * (1 / 0) : T === 0 ? 5e-324 * w * A : w * Math.pow(2, T - 1075) * (
					A + 4503599627370496)
			}
			d.writeDoubleLE = f.bind(null, s, 0, 4), d.writeDoubleBE = f.bind(null, a, 4, 0), d.readDoubleLE = m
				.bind(null, l, 0, 4), d.readDoubleBE = m.bind(null, c, 4, 0)
		}(), d
	}

	function s(d, f, m) {
		f[m] = 255 & d, f[m + 1] = d >>> 8 & 255, f[m + 2] = d >>> 16 & 255, f[m + 3] = d >>> 24
	}

	function a(d, f, m) {
		f[m] = d >>> 24, f[m + 1] = d >>> 16 & 255, f[m + 2] = d >>> 8 & 255, f[m + 3] = 255 & d
	}

	function l(d, f) {
		return (d[f] | d[f + 1] << 8 | d[f + 2] << 16 | d[f + 3] << 24) >>> 0
	}

	function c(d, f) {
		return (d[f] << 24 | d[f + 1] << 16 | d[f + 2] << 8 | d[f + 3]) >>> 0
	}
	return hasRequiredFloat = 1, float = o(o)
}

function requireInquire() {
	if (hasRequiredInquire) return inquire_1;

	function inquire(moduleName) {
		try {
			var mod = eval("quire".replace(/^/, "re"))(moduleName);
			if (mod && (mod.length || Object.keys(mod).length)) return mod
		} catch (o) {}
		return null
	}
	return hasRequiredInquire = 1, inquire_1 = inquire, inquire_1
}
var utf8 = {},
	hasRequiredUtf8, pool_1, hasRequiredPool, longbits, hasRequiredLongbits, hasRequiredMinimal, writer,
	hasRequiredWriter, writer_buffer, hasRequiredWriter_buffer, reader, hasRequiredReader, reader_buffer,
	hasRequiredReader_buffer;

function requireUtf8() {
	return hasRequiredUtf8 || (hasRequiredUtf8 = 1, function(o) {
		var s = o;
		s.length = function(a) {
			for (var l = 0, c = 0, d = 0; d < a.length; ++d)(c = a.charCodeAt(d)) < 128 ? l += 1 : c <
				2048 ? l += 2 : (64512 & c) == 55296 && (64512 & a.charCodeAt(d + 1)) == 56320 ? (++d, l +=
					4) : l += 3;
			return l
		}, s.read = function(a, l, c) {
			if (c - l < 1) return "";
			for (var d, f = null, m = [], g = 0; l < c;)(d = a[l++]) < 128 ? m[g++] = d : d > 191 && d <
				224 ? m[g++] = (31 & d) << 6 | 63 & a[l++] : d > 239 && d < 365 ? (d = ((7 & d) << 18 | (
					63 & a[l++]) << 12 | (63 & a[l++]) << 6 | 63 & a[l++]) - 65536, m[g++] = 55296 + (
					d >> 10), m[g++] = 56320 + (1023 & d)) : m[g++] = (15 & d) << 12 | (63 & a[l++]) << 6 |
				63 & a[l++], g > 8191 && ((f || (f = [])).push(String.fromCharCode.apply(String, m)), g =
				0);
			return f ? (g && f.push(String.fromCharCode.apply(String, m.slice(0, g))), f.join("")) : String
				.fromCharCode.apply(String, m.slice(0, g))
		}, s.write = function(a, l, c) {
			for (var d, f, m = c, g = 0; g < a.length; ++g)(d = a.charCodeAt(g)) < 128 ? l[c++] = d : d <
				2048 ? (l[c++] = d >> 6 | 192, l[c++] = 63 & d | 128) : (64512 & d) == 55296 && (64512 & (
					f = a.charCodeAt(g + 1))) == 56320 ? (d = 65536 + ((1023 & d) << 10) + (1023 & f), ++g,
					l[c++] = d >> 18 | 240, l[c++] = d >> 12 & 63 | 128, l[c++] = d >> 6 & 63 | 128, l[
					c++] = 63 & d | 128) : (l[c++] = d >> 12 | 224, l[c++] = d >> 6 & 63 | 128, l[c++] =
					63 & d | 128);
			return c - m
		}
	}(utf8)), utf8
}

function requirePool() {
	return hasRequiredPool ? pool_1 : (hasRequiredPool = 1, pool_1 = function(o, s, a) {
		var l = a || 8192,
			c = l >>> 1,
			d = null,
			f = l;
		return function(m) {
			if (m < 1 || m > c) return o(m);
			f + m > l && (d = o(l), f = 0);
			var g = s.call(d, f, f += m);
			return 7 & f && (f = 1 + (7 | f)), g
		}
	})
}

function requireLongbits() {
	if (hasRequiredLongbits) return longbits;
	hasRequiredLongbits = 1, longbits = s;
	var o = requireMinimal();

	function s(d, f) {
		this.lo = d >>> 0, this.hi = f >>> 0
	}
	var a = s.zero = new s(0, 0);
	a.toNumber = function() {
		return 0
	}, a.zzEncode = a.zzDecode = function() {
		return this
	}, a.length = function() {
		return 1
	};
	var l = s.zeroHash = "\0\0\0\0\0\0\0\0";
	s.fromNumber = function(d) {
		if (d === 0) return a;
		var f = d < 0;
		f && (d = -d);
		var m = d >>> 0,
			g = (d - m) / 4294967296 >>> 0;
		return f && (g = ~g >>> 0, m = ~m >>> 0, ++m > 4294967295 && (m = 0, ++g > 4294967295 && (g = 0))), new s(m,
			g)
	}, s.from = function(d) {
		if (typeof d == "number") return s.fromNumber(d);
		if (o.isString(d)) {
			if (!o.Long) return s.fromNumber(parseInt(d, 10));
			d = o.Long.fromString(d)
		}
		return d.low || d.high ? new s(d.low >>> 0, d.high >>> 0) : a
	}, s.prototype.toNumber = function(d) {
		if (!d && this.hi >>> 31) {
			var f = 1 + ~this.lo >>> 0,
				m = ~this.hi >>> 0;
			return f || (m = m + 1 >>> 0), -(f + 4294967296 * m)
		}
		return this.lo + 4294967296 * this.hi
	}, s.prototype.toLong = function(d) {
		return o.Long ? new o.Long(0 | this.lo, 0 | this.hi, !!d) : {
			low: 0 | this.lo,
			high: 0 | this.hi,
			unsigned: !!d
		}
	};
	var c = String.prototype.charCodeAt;
	return s.fromHash = function(d) {
		return d === l ? a : new s((c.call(d, 0) | c.call(d, 1) << 8 | c.call(d, 2) << 16 | c.call(d, 3) << 24) >>>
			0, (c.call(d, 4) | c.call(d, 5) << 8 | c.call(d, 6) << 16 | c.call(d, 7) << 24) >>> 0)
	}, s.prototype.toHash = function() {
		return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 &
			this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
	}, s.prototype.zzEncode = function() {
		var d = this.hi >> 31;
		return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ d) >>> 0, this.lo = (this.lo << 1 ^ d) >>> 0, this
	}, s.prototype.zzDecode = function() {
		var d = -(1 & this.lo);
		return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ d) >>> 0, this.hi = (this.hi >>> 1 ^ d) >>> 0, this
	}, s.prototype.length = function() {
		var d = this.lo,
			f = (this.lo >>> 28 | this.hi << 4) >>> 0,
			m = this.hi >>> 24;
		return m === 0 ? f === 0 ? d < 16384 ? d < 128 ? 1 : 2 : d < 2097152 ? 3 : 4 : f < 16384 ? f < 128 ? 5 : 6 :
			f < 2097152 ? 7 : 8 : m < 128 ? 9 : 10
	}, longbits
}

function requireMinimal() {
	return hasRequiredMinimal || (hasRequiredMinimal = 1, function() {
		var o = minimal;

		function s(l, c, d) {
			for (var f = Object.keys(c), m = 0; m < f.length; ++m) l[f[m]] !== void 0 && d || (l[f[m]] = c[f[
				m]]);
			return l
		}

		function a(l) {
			function c(d, f) {
				if (!(this instanceof c)) return new c(d, f);
				Object.defineProperty(this, "message", {
					get: function() {
						return d
					}
				}), Error.captureStackTrace ? Error.captureStackTrace(this, c) : Object.defineProperty(this,
					"stack", {
						value: new Error().stack || ""
					}), f && s(this, f)
			}
			return c.prototype = Object.create(Error.prototype, {
				constructor: {
					value: c,
					writable: !0,
					enumerable: !1,
					configurable: !0
				},
				name: {
					get: function() {
						return l
					},
					set: void 0,
					enumerable: !1,
					configurable: !0
				},
				toString: {
					value: function() {
						return this.name + ": " + this.message
					},
					writable: !0,
					enumerable: !1,
					configurable: !0
				}
			}), c
		}
		o.asPromise = requireAspromise(), o.base64 = requireBase64(), o.EventEmitter = requireEventemitter(), o
			.float = requireFloat(), o.inquire = requireInquire(), o.utf8 = requireUtf8(), o.pool =
			requirePool(), o.LongBits = requireLongbits(), o.isNode = !!(commonjsGlobal !== void 0 &&
				commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal
				.process.versions.node), o.global = o.isNode && commonjsGlobal || typeof window < "u" &&
			window || typeof self < "u" && self || minimal, o.emptyArray = Object.freeze ? Object.freeze([]) :
			[], o.emptyObject = Object.freeze ? Object.freeze({}) : {}, o.isInteger = Number.isInteger ||
			function(l) {
				return typeof l == "number" && isFinite(l) && Math.floor(l) === l
			}, o.isString = function(l) {
				return typeof l == "string" || l instanceof String
			}, o.isObject = function(l) {
				return l && typeof l == "object"
			}, o.isset = o.isSet = function(l, c) {
				var d = l[c];
				return !(d == null || !l.hasOwnProperty(c)) && (typeof d != "object" || (Array.isArray(d) ? d
					.length : Object.keys(d).length) > 0)
			}, o.Buffer = function() {
				try {
					var l = o.inquire("buffer").Buffer;
					return l.prototype.utf8Write ? l : null
				} catch {
					return null
				}
			}(), o._Buffer_from = null, o._Buffer_allocUnsafe = null, o.newBuffer = function(l) {
				return typeof l == "number" ? o.Buffer ? o._Buffer_allocUnsafe(l) : new o.Array(l) : o.Buffer ?
					o._Buffer_from(l) : typeof Uint8Array > "u" ? l : new Uint8Array(l)
			}, o.Array = typeof Uint8Array < "u" ? Uint8Array : Array, o.Long = o.global.dcodeIO && o.global
			.dcodeIO.Long || o.global.Long || o.inquire("long"), o.key2Re = /^true|false|0|1$/, o.key32Re =
			/^-?(?:0|[1-9][0-9]*)$/, o.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, o.longToHash =
			function(l) {
				return l ? o.LongBits.from(l).toHash() : o.LongBits.zeroHash
			}, o.longFromHash = function(l, c) {
				var d = o.LongBits.fromHash(l);
				return o.Long ? o.Long.fromBits(d.lo, d.hi, c) : d.toNumber(!!c)
			}, o.merge = s, o.lcFirst = function(l) {
				return l.charAt(0).toLowerCase() + l.substring(1)
			}, o.newError = a, o.ProtocolError = a("ProtocolError"), o.oneOfGetter = function(l) {
				for (var c = {}, d = 0; d < l.length; ++d) c[l[d]] = 1;
				return function() {
					for (var f = Object.keys(this), m = f.length - 1; m > -1; --m)
						if (c[f[m]] === 1 && this[f[m]] !== void 0 && this[f[m]] !== null) return f[m]
				}
			}, o.oneOfSetter = function(l) {
				return function(c) {
					for (var d = 0; d < l.length; ++d) l[d] !== c && delete this[l[d]]
				}
			}, o.toJSONOptions = {
				longs: String,
				enums: String,
				bytes: String,
				json: !0
			}, o._configure = function() {
				var l = o.Buffer;
				l ? (o._Buffer_from = l.from !== Uint8Array.from && l.from || function(c, d) {
					return new l(c, d)
				}, o._Buffer_allocUnsafe = l.allocUnsafe || function(c) {
					return new l(c)
				}) : o._Buffer_from = o._Buffer_allocUnsafe = null
			}
	}()), minimal
}

function requireWriter() {
	if (hasRequiredWriter) return writer;
	hasRequiredWriter = 1, writer = g;
	var o, s = requireMinimal(),
		a = s.LongBits,
		l = s.base64,
		c = s.utf8;

	function d(w, T, A) {
		this.fn = w, this.len = T, this.next = void 0, this.val = A
	}

	function f() {}

	function m(w) {
		this.head = w.head, this.tail = w.tail, this.len = w.len, this.next = w.states
	}

	function g() {
		this.len = 0, this.head = new d(f, 0, 0), this.tail = this.head, this.states = null
	}
	var v = function() {
		return s.Buffer ? function() {
			return (g.create = function() {
				return new o
			})()
		} : function() {
			return new g
		}
	};

	function y(w, T, A) {
		T[A] = 255 & w
	}

	function b(w, T) {
		this.len = w, this.next = void 0, this.val = T
	}

	function C(w, T, A) {
		for (; w.hi;) T[A++] = 127 & w.lo | 128, w.lo = (w.lo >>> 7 | w.hi << 25) >>> 0, w.hi >>>= 7;
		for (; w.lo > 127;) T[A++] = 127 & w.lo | 128, w.lo = w.lo >>> 7;
		T[A++] = w.lo
	}

	function _(w, T, A) {
		T[A] = 255 & w, T[A + 1] = w >>> 8 & 255, T[A + 2] = w >>> 16 & 255, T[A + 3] = w >>> 24
	}
	g.create = v(), g.alloc = function(w) {
		return new s.Array(w)
	}, s.Array !== Array && (g.alloc = s.pool(g.alloc, s.Array.prototype.subarray)), g.prototype._push = function(w,
		T, A) {
		return this.tail = this.tail.next = new d(w, T, A), this.len += T, this
	}, b.prototype = Object.create(d.prototype), b.prototype.fn = function(w, T, A) {
		for (; w > 127;) T[A++] = 127 & w | 128, w >>>= 7;
		T[A] = w
	}, g.prototype.uint32 = function(w) {
		return this.len += (this.tail = this.tail.next = new b((w >>>= 0) < 128 ? 1 : w < 16384 ? 2 : w < 2097152 ?
			3 : w < 268435456 ? 4 : 5, w)).len, this
	}, g.prototype.int32 = function(w) {
		return w < 0 ? this._push(C, 10, a.fromNumber(w)) : this.uint32(w)
	}, g.prototype.sint32 = function(w) {
		return this.uint32((w << 1 ^ w >> 31) >>> 0)
	}, g.prototype.uint64 = function(w) {
		var T = a.from(w);
		return this._push(C, T.length(), T)
	}, g.prototype.int64 = g.prototype.uint64, g.prototype.sint64 = function(w) {
		var T = a.from(w).zzEncode();
		return this._push(C, T.length(), T)
	}, g.prototype.bool = function(w) {
		return this._push(y, 1, w ? 1 : 0)
	}, g.prototype.fixed32 = function(w) {
		return this._push(_, 4, w >>> 0)
	}, g.prototype.sfixed32 = g.prototype.fixed32, g.prototype.fixed64 = function(w) {
		var T = a.from(w);
		return this._push(_, 4, T.lo)._push(_, 4, T.hi)
	}, g.prototype.sfixed64 = g.prototype.fixed64, g.prototype.float = function(w) {
		return this._push(s.float.writeFloatLE, 4, w)
	}, g.prototype.double = function(w) {
		return this._push(s.float.writeDoubleLE, 8, w)
	};
	var S = s.Array.prototype.set ? function(w, T, A) {
		T.set(w, A)
	} : function(w, T, A) {
		for (var k = 0; k < w.length; ++k) T[A + k] = w[k]
	};
	return g.prototype.bytes = function(w) {
		var T = w.length >>> 0;
		if (!T) return this._push(y, 1, 0);
		if (s.isString(w)) {
			var A = g.alloc(T = l.length(w));
			l.decode(w, A, 0), w = A
		}
		return this.uint32(T)._push(S, T, w)
	}, g.prototype.string = function(w) {
		var T = c.length(w);
		return T ? this.uint32(T)._push(c.write, T, w) : this._push(y, 1, 0)
	}, g.prototype.fork = function() {
		return this.states = new m(this), this.head = this.tail = new d(f, 0, 0), this.len = 0, this
	}, g.prototype.reset = function() {
		return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states
			.len, this.states = this.states.next) : (this.head = this.tail = new d(f, 0, 0), this.len = 0), this
	}, g.prototype.ldelim = function() {
		var w = this.head,
			T = this.tail,
			A = this.len;
		return this.reset().uint32(A), A && (this.tail.next = w.next, this.tail = T, this.len += A), this
	}, g.prototype.finish = function() {
		for (var w = this.head.next, T = this.constructor.alloc(this.len), A = 0; w;) w.fn(w.val, T, A), A += w.len,
			w = w.next;
		return T
	}, g._configure = function(w) {
		o = w, g.create = v(), o._configure()
	}, writer
}

function requireWriter_buffer() {
	if (hasRequiredWriter_buffer) return writer_buffer;
	hasRequiredWriter_buffer = 1, writer_buffer = a;
	var o = requireWriter();
	(a.prototype = Object.create(o.prototype)).constructor = a;
	var s = requireMinimal();

	function a() {
		o.call(this)
	}

	function l(c, d, f) {
		c.length < 40 ? s.utf8.write(c, d, f) : d.utf8Write ? d.utf8Write(c, f) : d.write(c, f)
	}
	return a._configure = function() {
		a.alloc = s._Buffer_allocUnsafe, a.writeBytesBuffer = s.Buffer && s.Buffer
			.prototype instanceof Uint8Array && s.Buffer.prototype.set.name === "set" ? function(c, d, f) {
				d.set(c, f)
			} : function(c, d, f) {
				if (c.copy) c.copy(d, f, 0, c.length);
				else
					for (var m = 0; m < c.length;) d[f++] = c[m++]
			}
	}, a.prototype.bytes = function(c) {
		s.isString(c) && (c = s._Buffer_from(c, "base64"));
		var d = c.length >>> 0;
		return this.uint32(d), d && this._push(a.writeBytesBuffer, d, c), this
	}, a.prototype.string = function(c) {
		var d = s.Buffer.byteLength(c);
		return this.uint32(d), d && this._push(l, d, c), this
	}, a._configure(), writer_buffer
}

function requireReader() {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1, reader = d;
	var o, s = requireMinimal(),
		a = s.LongBits,
		l = s.utf8;

	function c(C, _) {
		return RangeError("index out of range: " + C.pos + " + " + (_ || 1) + " > " + C.len)
	}

	function d(C) {
		this.buf = C, this.pos = 0, this.len = C.length
	}
	var f, m = typeof Uint8Array < "u" ? function(C) {
			if (C instanceof Uint8Array || Array.isArray(C)) return new d(C);
			throw Error("illegal buffer")
		} : function(C) {
			if (Array.isArray(C)) return new d(C);
			throw Error("illegal buffer")
		},
		g = function() {
			return s.Buffer ? function(C) {
				return (d.create = function(_) {
					return s.Buffer.isBuffer(_) ? new o(_) : m(_)
				})(C)
			} : m
		};

	function v() {
		var C = new a(0, 0),
			_ = 0;
		if (!(this.len - this.pos > 4)) {
			for (; _ < 3; ++_) {
				if (this.pos >= this.len) throw c(this);
				if (C.lo = (C.lo | (127 & this.buf[this.pos]) << 7 * _) >>> 0, this.buf[this.pos++] < 128) return C
			}
			return C.lo = (C.lo | (127 & this.buf[this.pos++]) << 7 * _) >>> 0, C
		}
		for (; _ < 4; ++_)
			if (C.lo = (C.lo | (127 & this.buf[this.pos]) << 7 * _) >>> 0, this.buf[this.pos++] < 128) return C;
		if (C.lo = (C.lo | (127 & this.buf[this.pos]) << 28) >>> 0, C.hi = (C.hi | (127 & this.buf[this.pos]) >> 4) >>>
			0, this.buf[this.pos++] < 128) return C;
		if (_ = 0, this.len - this.pos > 4) {
			for (; _ < 5; ++_)
				if (C.hi = (C.hi | (127 & this.buf[this.pos]) << 7 * _ + 3) >>> 0, this.buf[this.pos++] < 128) return C
		} else
			for (; _ < 5; ++_) {
				if (this.pos >= this.len) throw c(this);
				if (C.hi = (C.hi | (127 & this.buf[this.pos]) << 7 * _ + 3) >>> 0, this.buf[this.pos++] < 128) return C
			}
		throw Error("invalid varint encoding")
	}

	function y(C, _) {
		return (C[_ - 4] | C[_ - 3] << 8 | C[_ - 2] << 16 | C[_ - 1] << 24) >>> 0
	}

	function b() {
		if (this.pos + 8 > this.len) throw c(this, 8);
		return new a(y(this.buf, this.pos += 4), y(this.buf, this.pos += 4))
	}
	return d.create = g(), d.prototype._slice = s.Array.prototype.subarray || s.Array.prototype.slice, d.prototype
		.uint32 = (f = 4294967295, function() {
			if (f = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128 || (f = (f | (127 & this.buf[this
					.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) || (f = (f | (127 & this.buf[this.pos]) <<
					14) >>> 0, this.buf[this.pos++] < 128) || (f = (f | (127 & this.buf[this.pos]) << 21) >>> 0,
					this.buf[this.pos++] < 128) || (f = (f | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this
					.pos++] < 128)) return f;
			if ((this.pos += 5) > this.len) throw this.pos = this.len, c(this, 10);
			return f
		}), d.prototype.int32 = function() {
			return 0 | this.uint32()
		}, d.prototype.sint32 = function() {
			var C = this.uint32();
			return C >>> 1 ^ -(1 & C)
		}, d.prototype.bool = function() {
			return this.uint32() !== 0
		}, d.prototype.fixed32 = function() {
			if (this.pos + 4 > this.len) throw c(this, 4);
			return y(this.buf, this.pos += 4)
		}, d.prototype.sfixed32 = function() {
			if (this.pos + 4 > this.len) throw c(this, 4);
			return 0 | y(this.buf, this.pos += 4)
		}, d.prototype.float = function() {
			if (this.pos + 4 > this.len) throw c(this, 4);
			var C = s.float.readFloatLE(this.buf, this.pos);
			return this.pos += 4, C
		}, d.prototype.double = function() {
			if (this.pos + 8 > this.len) throw c(this, 4);
			var C = s.float.readDoubleLE(this.buf, this.pos);
			return this.pos += 8, C
		}, d.prototype.bytes = function() {
			var C = this.uint32(),
				_ = this.pos,
				S = this.pos + C;
			if (S > this.len) throw c(this, C);
			if (this.pos += C, Array.isArray(this.buf)) return this.buf.slice(_, S);
			if (_ === S) {
				var w = s.Buffer;
				return w ? w.alloc(0) : new this.buf.constructor(0)
			}
			return this._slice.call(this.buf, _, S)
		}, d.prototype.string = function() {
			var C = this.bytes();
			return l.read(C, 0, C.length)
		}, d.prototype.skip = function(C) {
			if (typeof C == "number") {
				if (this.pos + C > this.len) throw c(this, C);
				this.pos += C
			} else
				do
					if (this.pos >= this.len) throw c(this); while (128 & this.buf[this.pos++]);
			return this
		}, d.prototype.skipType = function(C) {
			switch (C) {
				case 0:
					this.skip();
					break;
				case 1:
					this.skip(8);
					break;
				case 2:
					this.skip(this.uint32());
					break;
				case 3:
					for (;
						(C = 7 & this.uint32()) != 4;) this.skipType(C);
					break;
				case 5:
					this.skip(4);
					break;
				default:
					throw Error("invalid wire type " + C + " at offset " + this.pos)
			}
			return this
		}, d._configure = function(C) {
			o = C, d.create = g(), o._configure();
			var _ = s.Long ? "toLong" : "toNumber";
			s.merge(d.prototype, {
				int64: function() {
					return v.call(this)[_](!1)
				},
				uint64: function() {
					return v.call(this)[_](!0)
				},
				sint64: function() {
					return v.call(this).zzDecode()[_](!1)
				},
				fixed64: function() {
					return b.call(this)[_](!0)
				},
				sfixed64: function() {
					return b.call(this)[_](!1)
				}
			})
		}, reader
}

function requireReader_buffer() {
	if (hasRequiredReader_buffer) return reader_buffer;
	hasRequiredReader_buffer = 1, reader_buffer = a;
	var o = requireReader();
	(a.prototype = Object.create(o.prototype)).constructor = a;
	var s = requireMinimal();

	function a(l) {
		o.call(this, l)
	}
	return a._configure = function() {
		s.Buffer && (a.prototype._slice = s.Buffer.prototype.slice)
	}, a.prototype.string = function() {
		var l = this.uint32();
		return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + l, this.len)) : this
			.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + l, this.len))
	}, a._configure(), reader_buffer
}
var rpc = {},
	service$1, hasRequiredService$1, hasRequiredRpc, roots, hasRequiredRoots, hasRequiredIndexMinimal;

function requireService$1() {
	if (hasRequiredService$1) return service$1;
	hasRequiredService$1 = 1, service$1 = s;
	var o = requireMinimal();

	function s(a, l, c) {
		if (typeof a != "function") throw TypeError("rpcImpl must be a function");
		o.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!l, this.responseDelimited = !!c
	}
	return (s.prototype = Object.create(o.EventEmitter.prototype)).constructor = s, s.prototype.rpcCall = function a(l,
		c, d, f, m) {
		if (!f) throw TypeError("request must be specified");
		var g = this;
		if (!m) return o.asPromise(a, g, l, c, d, f);
		if (g.rpcImpl) try {
			return g.rpcImpl(l, c[g.requestDelimited ? "encodeDelimited" : "encode"](f).finish(), function(v,
			y) {
				if (v) return g.emit("error", v, l), m(v);
				if (y !== null) {
					if (!(y instanceof d)) try {
						y = d[g.responseDelimited ? "decodeDelimited" : "decode"](y)
					} catch (b) {
						return g.emit("error", b, l), m(b)
					}
					return g.emit("data", y, l), m(null, y)
				}
				g.end(!0)
			})
		} catch (v) {
			return g.emit("error", v, l), void setTimeout(function() {
				m(v)
			}, 0)
		} else setTimeout(function() {
			m(Error("already ended"))
		}, 0)
	}, s.prototype.end = function(a) {
		return this.rpcImpl && (a || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()),
			this
	}, service$1
}

function requireRpc() {
	return hasRequiredRpc || (hasRequiredRpc = 1, rpc.Service = requireService$1()), rpc
}

function requireRoots() {
	return hasRequiredRoots ? roots : (hasRequiredRoots = 1, roots = {})
}

function requireIndexMinimal() {
	return hasRequiredIndexMinimal || (hasRequiredIndexMinimal = 1, function() {
		var o = indexMinimal;

		function s() {
			o.util._configure(), o.Writer._configure(o.BufferWriter), o.Reader._configure(o.BufferReader)
		}
		o.build = "minimal", o.Writer = requireWriter(), o.BufferWriter = requireWriter_buffer(), o.Reader =
			requireReader(), o.BufferReader = requireReader_buffer(), o.util = requireMinimal(), o.rpc =
			requireRpc(), o.roots = requireRoots(), o.configure = s, s()
	}()), indexMinimal
}
var util = {
		exports: {}
	},
	codegen_1, hasRequiredCodegen, fetch_1, hasRequiredFetch;

function requireCodegen() {
	if (hasRequiredCodegen) return codegen_1;

	function o(s, a) {
		typeof s == "string" && (a = s, s = void 0);
		var l = [];

		function c(f) {
			if (typeof f != "string") {
				var m = d();
				if (o.verbose && console.log("codegen: " + m), m = "return " + m, f) {
					for (var g = Object.keys(f), v = new Array(g.length + 1), y = new Array(g.length), b = 0; b < g
						.length;) v[b] = g[b], y[b] = f[g[b++]];
					return v[b] = m, Function.apply(null, v).apply(null, y)
				}
				return Function(m)()
			}
			for (var C = new Array(arguments.length - 1), _ = 0; _ < C.length;) C[_] = arguments[++_];
			if (_ = 0, f = f.replace(/%([%dfijs])/g, function(S, w) {
					var T = C[_++];
					switch (w) {
						case "d":
						case "f":
							return String(Number(T));
						case "i":
							return String(Math.floor(T));
						case "j":
							return JSON.stringify(T);
						case "s":
							return String(T)
					}
					return "%"
				}), _ !== C.length) throw Error("parameter count mismatch");
			return l.push(f), c
		}

		function d(f) {
			return "function " + (f || a || "") + "(" + (s && s.join(",") || "") + `){
  ` + l.join(`
  `) + `
}`
		}
		return c.toString = d, c
	}
	return hasRequiredCodegen = 1, codegen_1 = o, o.verbose = !1, codegen_1
}

function requireFetch() {
	if (hasRequiredFetch) return fetch_1;
	hasRequiredFetch = 1, fetch_1 = a;
	var o = requireAspromise(),
		s = requireInquire()("fs");

	function a(l, c, d) {
		return typeof c == "function" ? (d = c, c = {}) : c || (c = {}), d ? !c.xhr && s && s.readFile ? s.readFile(l,
			function(f, m) {
				return f && typeof XMLHttpRequest < "u" ? a.xhr(l, c, d) : f ? d(f) : d(null, c.binary ? m : m
					.toString("utf8"))
			}) : a.xhr(l, c, d) : o(a, this, l, c)
	}
	return a.xhr = function(l, c, d) {
		var f = new XMLHttpRequest;
		f.onreadystatechange = function() {
			if (f.readyState === 4) {
				if (f.status !== 0 && f.status !== 200) return d(Error("status " + f.status));
				if (c.binary) {
					var m = f.response;
					if (!m) {
						m = [];
						for (var g = 0; g < f.responseText.length; ++g) m.push(255 & f.responseText.charCodeAt(
							g))
					}
					return d(null, typeof Uint8Array < "u" ? new Uint8Array(m) : m)
				}
				return d(null, f.responseText)
			}
		}, c.binary && ("overrideMimeType" in f && f.overrideMimeType("text/plain; charset=x-user-defined"), f
			.responseType = "arraybuffer"), f.open("GET", l), f.send()
	}, fetch_1
}
var path = {},
	hasRequiredPath;

function requirePath() {
	return hasRequiredPath || (hasRequiredPath = 1, function(o) {
		var s = o,
			a = s.isAbsolute = function(c) {
				return /^(?:\/|\w+:)/.test(c)
			},
			l = s.normalize = function(c) {
				var d = (c = c.replace(/\\/g, "/").replace(/\/{2,}/g, "/")).split("/"),
					f = a(c),
					m = "";
				f && (m = d.shift() + "/");
				for (var g = 0; g < d.length;) d[g] === ".." ? g > 0 && d[g - 1] !== ".." ? d.splice(--g, 2) :
					f ? d.splice(g, 1) : ++g : d[g] === "." ? d.splice(g, 1) : ++g;
				return m + d.join("/")
			};
		s.resolve = function(c, d, f) {
			return f || (d = l(d)), a(d) ? d : (f || (c = l(c)), (c = c.replace(/(?:\/|^)[^/]+$/, ""))
				.length ? l(c + "/" + d) : d)
		}
	}(path)), path
}
var types = {},
	hasRequiredTypes, field, hasRequiredField, oneof, hasRequiredOneof, namespace, hasRequiredNamespace, mapfield,
	hasRequiredMapfield, method, hasRequiredMethod, service, hasRequiredService, message, hasRequiredMessage, decoder_1,
	hasRequiredDecoder, verifier_1, hasRequiredVerifier;

function requireTypes() {
	return hasRequiredTypes || (hasRequiredTypes = 1, function(o) {
		var s = o,
			a = requireUtil(),
			l = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64",
				"sint64", "fixed64", "sfixed64", "bool", "string", "bytes"
			];

		function c(d, f) {
			var m = 0,
				g = {};
			for (f |= 0; m < d.length;) g[l[m + f]] = d[m++];
			return g
		}
		s.basic = c([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), s.defaults = c([0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, !1, "", a.emptyArray, null
			]), s.long = c([0, 0, 0, 1, 1], 7), s.mapKey = c([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), s
			.packed = c([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0])
	}(types)), types
}

function requireField() {
	if (hasRequiredField) return field;
	hasRequiredField = 1, field = f;
	var o = requireObject();
	((f.prototype = Object.create(o.prototype)).constructor = f).className = "Field";
	var s, a = require_enum(),
		l = requireTypes(),
		c = requireUtil(),
		d = /^required|optional|repeated$/;

	function f(m, g, v, y, b, C, _) {
		if (c.isObject(y) ? (_ = b, C = y, y = b = void 0) : c.isObject(b) && (_ = C, C = b, b = void 0), o.call(this,
				m, C), !c.isInteger(g) || g < 0) throw TypeError("id must be a non-negative integer");
		if (!c.isString(v)) throw TypeError("type must be a string");
		if (y !== void 0 && !d.test(y = y.toString().toLowerCase())) throw TypeError("rule must be a string rule");
		if (b !== void 0 && !c.isString(b)) throw TypeError("extend must be a string");
		y === "proto3_optional" && (y = "optional"), this.rule = y && y !== "optional" ? y : void 0, this.type = v, this
			.id = g, this.extend = b || void 0, this.required = y === "required", this.optional = !this.required, this
			.repeated = y === "repeated", this.map = !1, this.message = null, this.partOf = null, this.typeDefault =
			null, this.defaultValue = null, this.long = !!c.Long && l.long[v] !== void 0, this.bytes = v === "bytes",
			this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this
			.comment = _
	}
	return f.fromJSON = function(m, g) {
		return new f(m, g.id, g.type, g.rule, g.extend, g.options, g.comment)
	}, Object.defineProperty(f.prototype, "packed", {
		get: function() {
			return this._packed === null && (this._packed = this.getOption("packed") !== !1), this._packed
		}
	}), f.prototype.setOption = function(m, g, v) {
		return m === "packed" && (this._packed = null), o.prototype.setOption.call(this, m, g, v)
	}, f.prototype.toJSON = function(m) {
		var g = !!m && !!m.keepComments;
		return c.toObject(["rule", this.rule !== "optional" && this.rule || void 0, "type", this.type, "id", this
			.id, "extend", this.extend, "options", this.options, "comment", g ? this.comment : void 0
		])
	}, f.prototype.resolve = function() {
		if (this.resolved) return this;
		if ((this.typeDefault = l.defaults[this.type]) === void 0 ? (this.resolvedType = (this.declaringField ? this
					.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this
				.resolvedType instanceof s ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[
					Object.keys(this.resolvedType.values)[0]]) : this.options && this.options.proto3_optional && (
				this.typeDefault = null), this.options && this.options.default != null && (this.typeDefault = this
				.options.default, this.resolvedType instanceof a && typeof this.typeDefault == "string" && (this
					.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (this.options
				.packed !== !0 && (this.options.packed === void 0 || !this.resolvedType || this
					.resolvedType instanceof a) || delete this.options.packed, Object.keys(this.options).length || (
					this.options = void 0)), this.long) this.typeDefault = c.Long.fromNumber(this.typeDefault, this
			.type.charAt(0) === "u"), Object.freeze && Object.freeze(this.typeDefault);
		else if (this.bytes && typeof this.typeDefault == "string") {
			var m;
			c.base64.test(this.typeDefault) ? c.base64.decode(this.typeDefault, m = c.newBuffer(c.base64.length(this
				.typeDefault)), 0) : c.utf8.write(this.typeDefault, m = c.newBuffer(c.utf8.length(this
				.typeDefault)), 0), this.typeDefault = m
		}
		return this.map ? this.defaultValue = c.emptyObject : this.repeated ? this.defaultValue = c.emptyArray :
			this.defaultValue = this.typeDefault, this.parent instanceof s && (this.parent.ctor.prototype[this
				.name] = this.defaultValue), o.prototype.resolve.call(this)
	}, f.d = function(m, g, v, y) {
		return typeof g == "function" ? g = c.decorateType(g).name : g && typeof g == "object" && (g = c
				.decorateEnum(g).name),
			function(b, C) {
				c.decorateType(b.constructor).add(new f(C, m, g, v, {
					default: y
				}))
			}
	}, f._configure = function(m) {
		s = m
	}, field
}

function requireOneof() {
	if (hasRequiredOneof) return oneof;
	hasRequiredOneof = 1, oneof = l;
	var o = requireObject();
	((l.prototype = Object.create(o.prototype)).constructor = l).className = "OneOf";
	var s = requireField(),
		a = requireUtil();

	function l(d, f, m, g) {
		if (Array.isArray(f) || (m = f, f = void 0), o.call(this, d, m), f !== void 0 && !Array.isArray(f))
		throw TypeError("fieldNames must be an Array");
		this.oneof = f || [], this.fieldsArray = [], this.comment = g
	}

	function c(d) {
		if (d.parent)
			for (var f = 0; f < d.fieldsArray.length; ++f) d.fieldsArray[f].parent || d.parent.add(d.fieldsArray[f])
	}
	return l.fromJSON = function(d, f) {
		return new l(d, f.oneof, f.options, f.comment)
	}, l.prototype.toJSON = function(d) {
		var f = !!d && !!d.keepComments;
		return a.toObject(["options", this.options, "oneof", this.oneof, "comment", f ? this.comment : void 0])
	}, l.prototype.add = function(d) {
		if (!(d instanceof s)) throw TypeError("field must be a Field");
		return d.parent && d.parent !== this.parent && d.parent.remove(d), this.oneof.push(d.name), this.fieldsArray
			.push(d), d.partOf = this, c(this), this
	}, l.prototype.remove = function(d) {
		if (!(d instanceof s)) throw TypeError("field must be a Field");
		var f = this.fieldsArray.indexOf(d);
		if (f < 0) throw Error(d + " is not a member of " + this);
		return this.fieldsArray.splice(f, 1), (f = this.oneof.indexOf(d.name)) > -1 && this.oneof.splice(f, 1), d
			.partOf = null, this
	}, l.prototype.onAdd = function(d) {
		o.prototype.onAdd.call(this, d);
		for (var f = 0; f < this.oneof.length; ++f) {
			var m = d.get(this.oneof[f]);
			m && !m.partOf && (m.partOf = this, this.fieldsArray.push(m))
		}
		c(this)
	}, l.prototype.onRemove = function(d) {
		for (var f, m = 0; m < this.fieldsArray.length; ++m)(f = this.fieldsArray[m]).parent && f.parent.remove(f);
		o.prototype.onRemove.call(this, d)
	}, l.d = function() {
		for (var d = new Array(arguments.length), f = 0; f < arguments.length;) d[f] = arguments[f++];
		return function(m, g) {
			a.decorateType(m.constructor).add(new l(g, d)), Object.defineProperty(m, g, {
				get: a.oneOfGetter(d),
				set: a.oneOfSetter(d)
			})
		}
	}, oneof
}

function requireNamespace() {
	if (hasRequiredNamespace) return namespace;
	hasRequiredNamespace = 1, namespace = g;
	var o = requireObject();
	((g.prototype = Object.create(o.prototype)).constructor = g).className = "Namespace";
	var s, a, l, c = requireField(),
		d = requireUtil(),
		f = requireOneof();

	function m(y, b) {
		if (y && y.length) {
			for (var C = {}, _ = 0; _ < y.length; ++_) C[y[_].name] = y[_].toJSON(b);
			return C
		}
	}

	function g(y, b) {
		o.call(this, y, b), this.nested = void 0, this._nestedArray = null
	}

	function v(y) {
		return y._nestedArray = null, y
	}
	return g.fromJSON = function(y, b) {
		return new g(y, b.options).addJSON(b.nested)
	}, g.arrayToJSON = m, g.isReservedId = function(y, b) {
		if (y) {
			for (var C = 0; C < y.length; ++C)
				if (typeof y[C] != "string" && y[C][0] <= b && y[C][1] > b) return !0
		}
		return !1
	}, g.isReservedName = function(y, b) {
		if (y) {
			for (var C = 0; C < y.length; ++C)
				if (y[C] === b) return !0
		}
		return !1
	}, Object.defineProperty(g.prototype, "nestedArray", {
		get: function() {
			return this._nestedArray || (this._nestedArray = d.toArray(this.nested))
		}
	}), g.prototype.toJSON = function(y) {
		return d.toObject(["options", this.options, "nested", m(this.nestedArray, y)])
	}, g.prototype.addJSON = function(y) {
		if (y)
			for (var b, C = Object.keys(y), _ = 0; _ < C.length; ++_) b = y[C[_]], this.add((b.fields !== void 0 ? s
				.fromJSON : b.values !== void 0 ? l.fromJSON : b.methods !== void 0 ? a.fromJSON : b.id !==
				void 0 ? c.fromJSON : g.fromJSON)(C[_], b));
		return this
	}, g.prototype.get = function(y) {
		return this.nested && this.nested[y] || null
	}, g.prototype.getEnum = function(y) {
		if (this.nested && this.nested[y] instanceof l) return this.nested[y].values;
		throw Error("no such enum: " + y)
	}, g.prototype.add = function(y) {
		if (!(y instanceof c && y.extend !== void 0 || y instanceof s || y instanceof f || y instanceof l ||
				y instanceof a || y instanceof g)) throw TypeError("object must be a valid nested object");
		if (this.nested) {
			var b = this.get(y.name);
			if (b) {
				if (!(b instanceof g && y instanceof g) || b instanceof s || b instanceof a) throw Error(
					"duplicate name '" + y.name + "' in " + this);
				for (var C = b.nestedArray, _ = 0; _ < C.length; ++_) y.add(C[_]);
				this.remove(b), this.nested || (this.nested = {}), y.setOptions(b.options, !0)
			}
		} else this.nested = {};
		return this.nested[y.name] = y, y.onAdd(this), v(this)
	}, g.prototype.remove = function(y) {
		if (!(y instanceof o)) throw TypeError("object must be a ReflectionObject");
		if (y.parent !== this) throw Error(y + " is not a member of " + this);
		return delete this.nested[y.name], Object.keys(this.nested).length || (this.nested = void 0), y.onRemove(
			this), v(this)
	}, g.prototype.define = function(y, b) {
		if (d.isString(y)) y = y.split(".");
		else if (!Array.isArray(y)) throw TypeError("illegal path");
		if (y && y.length && y[0] === "") throw Error("path must be relative");
		for (var C = this; y.length > 0;) {
			var _ = y.shift();
			if (C.nested && C.nested[_]) {
				if (!((C = C.nested[_]) instanceof g)) throw Error("path conflicts with non-namespace objects")
			} else C.add(C = new g(_))
		}
		return b && C.addJSON(b), C
	}, g.prototype.resolveAll = function() {
		for (var y = this.nestedArray, b = 0; b < y.length;) y[b] instanceof g ? y[b++].resolveAll() : y[b++]
			.resolve();
		return this.resolve()
	}, g.prototype.lookup = function(y, b, C) {
		if (typeof b == "boolean" ? (C = b, b = void 0) : b && !Array.isArray(b) && (b = [b]), d.isString(y) && y
			.length) {
			if (y === ".") return this.root;
			y = y.split(".")
		} else if (!y.length) return this;
		if (y[0] === "") return this.root.lookup(y.slice(1), b);
		var _ = this.get(y[0]);
		if (_) {
			if (y.length === 1) {
				if (!b || b.indexOf(_.constructor) > -1) return _
			} else if (_ instanceof g && (_ = _.lookup(y.slice(1), b, !0))) return _
		} else
			for (var S = 0; S < this.nestedArray.length; ++S)
				if (this._nestedArray[S] instanceof g && (_ = this._nestedArray[S].lookup(y, b, !0))) return _;
		return this.parent === null || C ? null : this.parent.lookup(y, b)
	}, g.prototype.lookupType = function(y) {
		var b = this.lookup(y, [s]);
		if (!b) throw Error("no such type: " + y);
		return b
	}, g.prototype.lookupEnum = function(y) {
		var b = this.lookup(y, [l]);
		if (!b) throw Error("no such Enum '" + y + "' in " + this);
		return b
	}, g.prototype.lookupTypeOrEnum = function(y) {
		var b = this.lookup(y, [s, l]);
		if (!b) throw Error("no such Type or Enum '" + y + "' in " + this);
		return b
	}, g.prototype.lookupService = function(y) {
		var b = this.lookup(y, [a]);
		if (!b) throw Error("no such Service '" + y + "' in " + this);
		return b
	}, g._configure = function(y, b, C) {
		s = y, a = b, l = C
	}, namespace
}

function requireMapfield() {
	if (hasRequiredMapfield) return mapfield;
	hasRequiredMapfield = 1, mapfield = l;
	var o = requireField();
	((l.prototype = Object.create(o.prototype)).constructor = l).className = "MapField";
	var s = requireTypes(),
		a = requireUtil();

	function l(c, d, f, m, g, v) {
		if (o.call(this, c, d, m, void 0, void 0, g, v), !a.isString(f)) throw TypeError("keyType must be a string");
		this.keyType = f, this.resolvedKeyType = null, this.map = !0
	}
	return l.fromJSON = function(c, d) {
		return new l(c, d.id, d.keyType, d.type, d.options, d.comment)
	}, l.prototype.toJSON = function(c) {
		var d = !!c && !!c.keepComments;
		return a.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend,
			"options", this.options, "comment", d ? this.comment : void 0
		])
	}, l.prototype.resolve = function() {
		if (this.resolved) return this;
		if (s.mapKey[this.keyType] === void 0) throw Error("invalid key type: " + this.keyType);
		return o.prototype.resolve.call(this)
	}, l.d = function(c, d, f) {
		return typeof f == "function" ? f = a.decorateType(f).name : f && typeof f == "object" && (f = a
				.decorateEnum(f).name),
			function(m, g) {
				a.decorateType(m.constructor).add(new l(g, c, d, f))
			}
	}, mapfield
}

function requireMethod() {
	if (hasRequiredMethod) return method;
	hasRequiredMethod = 1, method = a;
	var o = requireObject();
	((a.prototype = Object.create(o.prototype)).constructor = a).className = "Method";
	var s = requireUtil();

	function a(l, c, d, f, m, g, v, y, b) {
		if (s.isObject(m) ? (v = m, m = g = void 0) : s.isObject(g) && (v = g, g = void 0), c !== void 0 && !s.isString(
				c)) throw TypeError("type must be a string");
		if (!s.isString(d)) throw TypeError("requestType must be a string");
		if (!s.isString(f)) throw TypeError("responseType must be a string");
		o.call(this, l, v), this.type = c || "rpc", this.requestType = d, this.requestStream = !!m || void 0, this
			.responseType = f, this.responseStream = !!g || void 0, this.resolvedRequestType = null, this
			.resolvedResponseType = null, this.comment = y, this.parsedOptions = b
	}
	return a.fromJSON = function(l, c) {
		return new a(l, c.type, c.requestType, c.responseType, c.requestStream, c.responseStream, c.options, c
			.comment, c.parsedOptions)
	}, a.prototype.toJSON = function(l) {
		var c = !!l && !!l.keepComments;
		return s.toObject(["type", this.type !== "rpc" && this.type || void 0, "requestType", this.requestType,
			"requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this
			.responseStream, "options", this.options, "comment", c ? this.comment : void 0, "parsedOptions",
			this.parsedOptions
		])
	}, a.prototype.resolve = function() {
		return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this
			.resolvedResponseType = this.parent.lookupType(this.responseType), o.prototype.resolve.call(this))
	}, method
}

function requireService() {
	if (hasRequiredService) return service;
	hasRequiredService = 1, service = c;
	var o = requireNamespace();
	((c.prototype = Object.create(o.prototype)).constructor = c).className = "Service";
	var s = requireMethod(),
		a = requireUtil(),
		l = requireRpc();

	function c(f, m) {
		o.call(this, f, m), this.methods = {}, this._methodsArray = null
	}

	function d(f) {
		return f._methodsArray = null, f
	}
	return c.fromJSON = function(f, m) {
		var g = new c(f, m.options);
		if (m.methods)
			for (var v = Object.keys(m.methods), y = 0; y < v.length; ++y) g.add(s.fromJSON(v[y], m.methods[v[y]]));
		return m.nested && g.addJSON(m.nested), g.comment = m.comment, g
	}, c.prototype.toJSON = function(f) {
		var m = o.prototype.toJSON.call(this, f),
			g = !!f && !!f.keepComments;
		return a.toObject(["options", m && m.options || void 0, "methods", o.arrayToJSON(this.methodsArray, f) ||
			{}, "nested", m && m.nested || void 0, "comment", g ? this.comment : void 0
		])
	}, Object.defineProperty(c.prototype, "methodsArray", {
		get: function() {
			return this._methodsArray || (this._methodsArray = a.toArray(this.methods))
		}
	}), c.prototype.get = function(f) {
		return this.methods[f] || o.prototype.get.call(this, f)
	}, c.prototype.resolveAll = function() {
		for (var f = this.methodsArray, m = 0; m < f.length; ++m) f[m].resolve();
		return o.prototype.resolve.call(this)
	}, c.prototype.add = function(f) {
		if (this.get(f.name)) throw Error("duplicate name '" + f.name + "' in " + this);
		return f instanceof s ? (this.methods[f.name] = f, f.parent = this, d(this)) : o.prototype.add.call(this, f)
	}, c.prototype.remove = function(f) {
		if (f instanceof s) {
			if (this.methods[f.name] !== f) throw Error(f + " is not a member of " + this);
			return delete this.methods[f.name], f.parent = null, d(this)
		}
		return o.prototype.remove.call(this, f)
	}, c.prototype.create = function(f, m, g) {
		for (var v, y = new l.Service(f, m, g), b = 0; b < this.methodsArray.length; ++b) {
			var C = a.lcFirst((v = this._methodsArray[b]).resolve().name).replace(/[^$\w_]/g, "");
			y[C] = a.codegen(["r", "c"], a.isReserved(C) ? C + "_" : C)("return this.rpcCall(m,q,s,r,c)")({
				m: v,
				q: v.resolvedRequestType.ctor,
				s: v.resolvedResponseType.ctor
			})
		}
		return y
	}, service
}

function requireMessage() {
	if (hasRequiredMessage) return message;
	hasRequiredMessage = 1, message = s;
	var o = requireMinimal();

	function s(a) {
		if (a)
			for (var l = Object.keys(a), c = 0; c < l.length; ++c) this[l[c]] = a[l[c]]
	}
	return s.create = function(a) {
		return this.$type.create(a)
	}, s.encode = function(a, l) {
		return this.$type.encode(a, l)
	}, s.encodeDelimited = function(a, l) {
		return this.$type.encodeDelimited(a, l)
	}, s.decode = function(a) {
		return this.$type.decode(a)
	}, s.decodeDelimited = function(a) {
		return this.$type.decodeDelimited(a)
	}, s.verify = function(a) {
		return this.$type.verify(a)
	}, s.fromObject = function(a) {
		return this.$type.fromObject(a)
	}, s.toObject = function(a, l) {
		return this.$type.toObject(a, l)
	}, s.prototype.toJSON = function() {
		return this.$type.toObject(this, o.toJSONOptions)
	}, message
}

function requireDecoder() {
	if (hasRequiredDecoder) return decoder_1;
	hasRequiredDecoder = 1, decoder_1 = function(c) {
		var d = a.codegen(["r", "l"], c.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")(
			"var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (c.fieldsArray.filter(function(b) {
				return b.map
			}).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
		c.group && d("if((t&7)===4)")("break"), d("switch(t>>>3){");
		for (var f = 0; f < c.fieldsArray.length; ++f) {
			var m = c._fieldsArray[f].resolve(),
				g = m.resolvedType instanceof o ? "int32" : m.type,
				v = "m" + a.safeProp(m.name);
			d("case %i: {", m.id), m.map ? (d("if(%s===util.emptyObject)", v)("%s={}", v)(
					"var c2 = r.uint32()+r.pos"), s.defaults[m.keyType] !== void 0 ? d("k=%j", s.defaults[m
					.keyType]) : d("k=null"), s.defaults[g] !== void 0 ? d("value=%j", s.defaults[g]) : d(
					"value=null"), d("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")(
					"case 1: k=r.%s(); break", m.keyType)("case 2:"), s.basic[g] === void 0 ? d(
					"value=types[%i].decode(r,r.uint32())", f) : d("value=r.%s()", g), d("break")("default:")(
					"r.skipType(tag2&7)")("break")("}")("}"), s.long[m.keyType] !== void 0 ? d(
					'%s[typeof k==="object"?util.longToHash(k):k]=value', v) : d("%s[k]=value", v)) : m.repeated ? (
					d("if(!(%s&&%s.length))", v, v)("%s=[]", v), s.packed[g] !== void 0 && d("if((t&7)===2){")(
						"var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", v, g)("}else"), s.basic[
					g] === void 0 ? d(m.resolvedType.group ? "%s.push(types[%i].decode(r))" :
						"%s.push(types[%i].decode(r,r.uint32()))", v, f) : d("%s.push(r.%s())", v, g)) : s.basic[
				g] === void 0 ? d(m.resolvedType.group ? "%s=types[%i].decode(r)" :
					"%s=types[%i].decode(r,r.uint32())", v, f) : d("%s=r.%s()", v, g), d("break")("}")
		}
		for (d("default:")("r.skipType(t&7)")("break")("}")("}"), f = 0; f < c._fieldsArray.length; ++f) {
			var y = c._fieldsArray[f];
			y.required && d("if(!m.hasOwnProperty(%j))", y.name)("throw util.ProtocolError(%j,{instance:m})", l(y))
		}
		return d("return m")
	};
	var o = require_enum(),
		s = requireTypes(),
		a = requireUtil();

	function l(c) {
		return "missing required '" + c.name + "'"
	}
	return decoder_1
}

function requireVerifier() {
	if (hasRequiredVerifier) return verifier_1;
	hasRequiredVerifier = 1, verifier_1 = function(d) {
		var f = s.codegen(["m"], d.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j",
				"object expected"),
			m = d.oneofsArray,
			g = {};
		m.length && f("var p={}");
		for (var v = 0; v < d.fieldsArray.length; ++v) {
			var y = d._fieldsArray[v].resolve(),
				b = "m" + s.safeProp(y.name);
			if (y.optional && f("if(%s!=null&&m.hasOwnProperty(%j)){", b, y.name), y.map) f(
				"if(!util.isObject(%s))", b)("return%j", a(y, "object"))("var k=Object.keys(%s)", b)(
				"for(var i=0;i<k.length;++i){"), c(f, y, "k[i]"), l(f, y, v, b + "[k[i]]")("}");
			else if (y.repeated) f("if(!Array.isArray(%s))", b)("return%j", a(y, "array"))(
				"for(var i=0;i<%s.length;++i){", b), l(f, y, v, b + "[i]")("}");
			else {
				if (y.partOf) {
					var C = s.safeProp(y.partOf.name);
					g[y.partOf.name] === 1 && f("if(p%s===1)", C)("return%j", y.partOf.name + ": multiple values"),
						g[y.partOf.name] = 1, f("p%s=1", C)
				}
				l(f, y, v, b)
			}
			y.optional && f("}")
		}
		return f("return null")
	};
	var o = require_enum(),
		s = requireUtil();

	function a(d, f) {
		return d.name + ": " + f + (d.repeated && f !== "array" ? "[]" : d.map && f !== "object" ? "{k:" + d.keyType +
			"}" : "") + " expected"
	}

	function l(d, f, m, g) {
		if (f.resolvedType)
			if (f.resolvedType instanceof o) {
				d("switch(%s){", g)("default:")("return%j", a(f, "enum value"));
				for (var v = Object.keys(f.resolvedType.values), y = 0; y < v.length; ++y) d("case %i:", f.resolvedType
					.values[v[y]]);
				d("break")("}")
			} else d("{")("var e=types[%i].verify(%s);", m, g)("if(e)")("return%j+e", f.name + ".")("}");
		else switch (f.type) {
			case "int32":
			case "uint32":
			case "sint32":
			case "fixed32":
			case "sfixed32":
				d("if(!util.isInteger(%s))", g)("return%j", a(f, "integer"));
				break;
			case "int64":
			case "uint64":
			case "sint64":
			case "fixed64":
			case "sfixed64":
				d("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", g, g, g, g)(
					"return%j", a(f, "integer|Long"));
				break;
			case "float":
			case "double":
				d('if(typeof %s!=="number")', g)("return%j", a(f, "number"));
				break;
			case "bool":
				d('if(typeof %s!=="boolean")', g)("return%j", a(f, "boolean"));
				break;
			case "string":
				d("if(!util.isString(%s))", g)("return%j", a(f, "string"));
				break;
			case "bytes":
				d('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', g, g, g)("return%j", a(f, "buffer"))
		}
		return d
	}

	function c(d, f, m) {
		switch (f.keyType) {
			case "int32":
			case "uint32":
			case "sint32":
			case "fixed32":
			case "sfixed32":
				d("if(!util.key32Re.test(%s))", m)("return%j", a(f, "integer key"));
				break;
			case "int64":
			case "uint64":
			case "sint64":
			case "fixed64":
			case "sfixed64":
				d("if(!util.key64Re.test(%s))", m)("return%j", a(f, "integer|Long key"));
				break;
			case "bool":
				d("if(!util.key2Re.test(%s))", m)("return%j", a(f, "boolean key"))
		}
		return d
	}
	return verifier_1
}
var converter = {},
	hasRequiredConverter;

function requireConverter() {
	return hasRequiredConverter || (hasRequiredConverter = 1, function(o) {
		var s = o,
			a = require_enum(),
			l = requireUtil();

		function c(f, m, g, v) {
			var y = !1;
			if (m.resolvedType)
				if (m.resolvedType instanceof a) {
					f("switch(d%s){", v);
					for (var b = m.resolvedType.values, C = Object.keys(b), _ = 0; _ < C.length; ++_) b[C[
						_]] !== m.typeDefault || y || (f("default:")(
								'if(typeof(d%s)==="number"){m%s=d%s;break}', v, v, v), m.repeated || f("break"),
							y = !0), f("case%j:", C[_])("case %i:", b[C[_]])("m%s=%j", v, b[C[_]])("break");
					f("}")
				} else f('if(typeof d%s!=="object")', v)("throw TypeError(%j)", m.fullName +
					": object expected")("m%s=types[%i].fromObject(d%s)", v, g, v);
			else {
				var S = !1;
				switch (m.type) {
					case "double":
					case "float":
						f("m%s=Number(d%s)", v, v);
						break;
					case "uint32":
					case "fixed32":
						f("m%s=d%s>>>0", v, v);
						break;
					case "int32":
					case "sint32":
					case "sfixed32":
						f("m%s=d%s|0", v, v);
						break;
					case "uint64":
						S = !0;
					case "int64":
					case "sint64":
					case "fixed64":
					case "sfixed64":
						f("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", v, v, S)(
							'else if(typeof d%s==="string")', v)("m%s=parseInt(d%s,10)", v, v)(
							'else if(typeof d%s==="number")', v)("m%s=d%s", v, v)(
							'else if(typeof d%s==="object")', v)(
							"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", v, v, v, S ?
							"true" : "");
						break;
					case "bytes":
						f('if(typeof d%s==="string")', v)(
							"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", v, v, v
							)("else if(d%s.length >= 0)", v)("m%s=d%s", v, v);
						break;
					case "string":
						f("m%s=String(d%s)", v, v);
						break;
					case "bool":
						f("m%s=Boolean(d%s)", v, v)
				}
			}
			return f
		}

		function d(f, m, g, v) {
			if (m.resolvedType) m.resolvedType instanceof a ? f(
				"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", v,
				g, v, v, g, v, v) : f("d%s=types[%i].toObject(m%s,o)", v, g, v);
			else {
				var y = !1;
				switch (m.type) {
					case "double":
					case "float":
						f("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", v, v, v, v);
						break;
					case "uint64":
						y = !0;
					case "int64":
					case "sint64":
					case "fixed64":
					case "sfixed64":
						f('if(typeof m%s==="number")', v)("d%s=o.longs===String?String(m%s):m%s", v, v, v)(
							"else")(
							"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",
							v, v, v, v, y ? "true" : "", v);
						break;
					case "bytes":
						f("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",
							v, v, v, v, v);
						break;
					default:
						f("d%s=m%s", v, v)
				}
			}
			return f
		}
		s.fromObject = function(f) {
			var m = f.fieldsArray,
				g = l.codegen(["d"], f.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
			if (!m.length) return g("return new this.ctor");
			g("var m=new this.ctor");
			for (var v = 0; v < m.length; ++v) {
				var y = m[v].resolve(),
					b = l.safeProp(y.name);
				y.map ? (g("if(d%s){", b)('if(typeof d%s!=="object")', b)("throw TypeError(%j)", y
					.fullName + ": object expected")("m%s={}", b)(
					"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", b), c(g, y, v, b +
					"[ks[i]]")("}")("}")) : y.repeated ? (g("if(d%s){", b)("if(!Array.isArray(d%s))", b)
					("throw TypeError(%j)", y.fullName + ": array expected")("m%s=[]", b)(
						"for(var i=0;i<d%s.length;++i){", b), c(g, y, v, b + "[i]")("}")("}")) : (y
					.resolvedType instanceof a || g("if(d%s!=null){", b), c(g, y, v, b), y
					.resolvedType instanceof a || g("}"))
			}
			return g("return m")
		}, s.toObject = function(f) {
			var m = f.fieldsArray.slice().sort(l.compareFieldsById);
			if (!m.length) return l.codegen()("return {}");
			for (var g = l.codegen(["m", "o"], f.name + "$toObject")("if(!o)")("o={}")("var d={}"), v = [],
					y = [], b = [], C = 0; C < m.length; ++C) m[C].partOf || (m[C].resolve().repeated ? v :
				m[C].map ? y : b).push(m[C]);
			if (v.length) {
				for (g("if(o.arrays||o.defaults){"), C = 0; C < v.length; ++C) g("d%s=[]", l.safeProp(v[C]
					.name));
				g("}")
			}
			if (y.length) {
				for (g("if(o.objects||o.defaults){"), C = 0; C < y.length; ++C) g("d%s={}", l.safeProp(y[C]
					.name));
				g("}")
			}
			if (b.length) {
				for (g("if(o.defaults){"), C = 0; C < b.length; ++C) {
					var _ = b[C],
						S = l.safeProp(_.name);
					if (_.resolvedType instanceof a) g("d%s=o.enums===String?%j:%j", S, _.resolvedType
						.valuesById[_.typeDefault], _.typeDefault);
					else if (_.long) g("if(util.Long){")("var n=new util.Long(%i,%i,%j)", _.typeDefault.low,
							_.typeDefault.high, _.typeDefault.unsigned)(
							"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", S)("}else")
						("d%s=o.longs===String?%j:%i", S, _.typeDefault.toString(), _.typeDefault
						.toNumber());
					else if (_.bytes) {
						var w = "[" + Array.prototype.slice.call(_.typeDefault).join(",") + "]";
						g("if(o.bytes===String)d%s=%j", S, String.fromCharCode.apply(String, _.typeDefault))
							("else{")("d%s=%s", S, w)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", S, S)(
								"}")
					} else g("d%s=%j", S, _.typeDefault)
				}
				g("}")
			}
			var T = !1;
			for (C = 0; C < m.length; ++C) {
				_ = m[C];
				var A = f._fieldsArray.indexOf(_);
				S = l.safeProp(_.name), _.map ? (T || (T = !0, g("var ks2")), g(
					"if(m%s&&(ks2=Object.keys(m%s)).length){", S, S)("d%s={}", S)(
					"for(var j=0;j<ks2.length;++j){"), d(g, _, A, S + "[ks2[j]]")("}")) : _.repeated ? (
					g("if(m%s&&m%s.length){", S, S)("d%s=[]", S)("for(var j=0;j<m%s.length;++j){", S),
					d(g, _, A, S + "[j]")("}")) : (g("if(m%s!=null&&m.hasOwnProperty(%j)){", S, _.name),
					d(g, _, A, S), _.partOf && g("if(o.oneofs)")("d%s=%j", l.safeProp(_.partOf.name), _
						.name)), g("}")
			}
			return g("return d")
		}
	}(converter)), converter
}
var wrappers = {},
	hasRequiredWrappers, type, hasRequiredType, root, hasRequiredRoot, hasRequiredUtil, object, hasRequiredObject,
	_enum, hasRequired_enum, encoder_1, hasRequiredEncoder, hasRequiredIndexLight, tokenize_1, hasRequiredTokenize,
	parse_1, hasRequiredParse, common_1, hasRequiredCommon, hasRequiredSrc, protobufjs, hasRequiredProtobufjs;

function requireWrappers() {
	return hasRequiredWrappers || (hasRequiredWrappers = 1, function(o) {
		var s = o,
			a = requireMessage();
		s[".google.protobuf.Any"] = {
			fromObject: function(l) {
				if (l && l["@type"]) {
					var c = l["@type"].substring(l["@type"].lastIndexOf("/") + 1),
						d = this.lookup(c);
					if (d) {
						var f = l["@type"].charAt(0) === "." ? l["@type"].slice(1) : l["@type"];
						return f.indexOf("/") === -1 && (f = "/" + f), this.create({
							type_url: f,
							value: d.encode(d.fromObject(l)).finish()
						})
					}
				}
				return this.fromObject(l)
			},
			toObject: function(l, c) {
				var d = "",
					f = "";
				if (c && c.json && l.type_url && l.value) {
					f = l.type_url.substring(l.type_url.lastIndexOf("/") + 1), d = l.type_url.substring(
						0, l.type_url.lastIndexOf("/") + 1);
					var m = this.lookup(f);
					m && (l = m.decode(l.value))
				}
				if (!(l instanceof this.ctor) && l instanceof a) {
					var g = l.$type.toObject(l, c);
					return d === "" && (d = "type.googleapis.com/"), f = d + (l.$type.fullName[0] ===
						"." ? l.$type.fullName.slice(1) : l.$type.fullName), g["@type"] = f, g
				}
				return this.toObject(l, c)
			}
		}
	}(wrappers)), wrappers
}

function requireType() {
	if (hasRequiredType) return type;
	hasRequiredType = 1, type = w;
	var o = requireNamespace();
	((w.prototype = Object.create(o.prototype)).constructor = w).className = "Type";
	var s = require_enum(),
		a = requireOneof(),
		l = requireField(),
		c = requireMapfield(),
		d = requireService(),
		f = requireMessage(),
		m = requireReader(),
		g = requireWriter(),
		v = requireUtil(),
		y = requireEncoder(),
		b = requireDecoder(),
		C = requireVerifier(),
		_ = requireConverter(),
		S = requireWrappers();

	function w(A, k) {
		o.call(this, A, k), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0,
			this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this
			._ctor = null
	}

	function T(A) {
		return A._fieldsById = A._fieldsArray = A._oneofsArray = null, delete A.encode, delete A.decode, delete A
			.verify, A
	}
	return Object.defineProperties(w.prototype, {
		fieldsById: {
			get: function() {
				if (this._fieldsById) return this._fieldsById;
				this._fieldsById = {};
				for (var A = Object.keys(this.fields), k = 0; k < A.length; ++k) {
					var M = this.fields[A[k]],
						D = M.id;
					if (this._fieldsById[D]) throw Error("duplicate id " + D + " in " + this);
					this._fieldsById[D] = M
				}
				return this._fieldsById
			}
		},
		fieldsArray: {
			get: function() {
				return this._fieldsArray || (this._fieldsArray = v.toArray(this.fields))
			}
		},
		oneofsArray: {
			get: function() {
				return this._oneofsArray || (this._oneofsArray = v.toArray(this.oneofs))
			}
		},
		ctor: {
			get: function() {
				return this._ctor || (this.ctor = w.generateConstructor(this)())
			},
			set: function(A) {
				var k = A.prototype;
				k instanceof f || ((A.prototype = new f).constructor = A, v.merge(A.prototype, k)), A
					.$type = A.prototype.$type = this, v.merge(A, f, !0), this._ctor = A;
				for (var M = 0; M < this.fieldsArray.length; ++M) this._fieldsArray[M].resolve();
				var D = {};
				for (M = 0; M < this.oneofsArray.length; ++M) D[this._oneofsArray[M].resolve().name] = {
					get: v.oneOfGetter(this._oneofsArray[M].oneof),
					set: v.oneOfSetter(this._oneofsArray[M].oneof)
				};
				M && Object.defineProperties(A.prototype, D)
			}
		}
	}), w.generateConstructor = function(A) {
		for (var k, M = v.codegen(["p"], A.name), D = 0; D < A.fieldsArray.length; ++D)(k = A._fieldsArray[D]).map ?
			M("this%s={}", v.safeProp(k.name)) : k.repeated && M("this%s=[]", v.safeProp(k.name));
		return M("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]")
	}, w.fromJSON = function(A, k) {
		var M = new w(A, k.options);
		M.extensions = k.extensions, M.reserved = k.reserved;
		for (var D = Object.keys(k.fields), F = 0; F < D.length; ++F) M.add((k.fields[D[F]].keyType !== void 0 ? c
			.fromJSON : l.fromJSON)(D[F], k.fields[D[F]]));
		if (k.oneofs)
			for (D = Object.keys(k.oneofs), F = 0; F < D.length; ++F) M.add(a.fromJSON(D[F], k.oneofs[D[F]]));
		if (k.nested)
			for (D = Object.keys(k.nested), F = 0; F < D.length; ++F) {
				var R = k.nested[D[F]];
				M.add((R.id !== void 0 ? l.fromJSON : R.fields !== void 0 ? w.fromJSON : R.values !== void 0 ? s
					.fromJSON : R.methods !== void 0 ? d.fromJSON : o.fromJSON)(D[F], R))
			}
		return k.extensions && k.extensions.length && (M.extensions = k.extensions), k.reserved && k.reserved
			.length && (M.reserved = k.reserved), k.group && (M.group = !0), k.comment && (M.comment = k.comment), M
	}, w.prototype.toJSON = function(A) {
		var k = o.prototype.toJSON.call(this, A),
			M = !!A && !!A.keepComments;
		return v.toObject(["options", k && k.options || void 0, "oneofs", o.arrayToJSON(this.oneofsArray, A),
			"fields", o.arrayToJSON(this.fieldsArray.filter(function(D) {
				return !D.declaringField
			}), A) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions :
			void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group",
			this.group || void 0, "nested", k && k.nested || void 0, "comment", M ? this.comment : void 0
		])
	}, w.prototype.resolveAll = function() {
		for (var A = this.fieldsArray, k = 0; k < A.length;) A[k++].resolve();
		var M = this.oneofsArray;
		for (k = 0; k < M.length;) M[k++].resolve();
		return o.prototype.resolveAll.call(this)
	}, w.prototype.get = function(A) {
		return this.fields[A] || this.oneofs && this.oneofs[A] || this.nested && this.nested[A] || null
	}, w.prototype.add = function(A) {
		if (this.get(A.name)) throw Error("duplicate name '" + A.name + "' in " + this);
		if (A instanceof l && A.extend === void 0) {
			if (this._fieldsById ? this._fieldsById[A.id] : this.fieldsById[A.id]) throw Error("duplicate id " + A
				.id + " in " + this);
			if (this.isReservedId(A.id)) throw Error("id " + A.id + " is reserved in " + this);
			if (this.isReservedName(A.name)) throw Error("name '" + A.name + "' is reserved in " + this);
			return A.parent && A.parent.remove(A), this.fields[A.name] = A, A.message = this, A.onAdd(this), T(this)
		}
		return A instanceof a ? (this.oneofs || (this.oneofs = {}), this.oneofs[A.name] = A, A.onAdd(this), T(
			this)) : o.prototype.add.call(this, A)
	}, w.prototype.remove = function(A) {
		if (A instanceof l && A.extend === void 0) {
			if (!this.fields || this.fields[A.name] !== A) throw Error(A + " is not a member of " + this);
			return delete this.fields[A.name], A.parent = null, A.onRemove(this), T(this)
		}
		if (A instanceof a) {
			if (!this.oneofs || this.oneofs[A.name] !== A) throw Error(A + " is not a member of " + this);
			return delete this.oneofs[A.name], A.parent = null, A.onRemove(this), T(this)
		}
		return o.prototype.remove.call(this, A)
	}, w.prototype.isReservedId = function(A) {
		return o.isReservedId(this.reserved, A)
	}, w.prototype.isReservedName = function(A) {
		return o.isReservedName(this.reserved, A)
	}, w.prototype.create = function(A) {
		return new this.ctor(A)
	}, w.prototype.setup = function() {
		for (var A = this.fullName, k = [], M = 0; M < this.fieldsArray.length; ++M) k.push(this._fieldsArray[M]
			.resolve().resolvedType);
		this.encode = y(this)({
			Writer: g,
			types: k,
			util: v
		}), this.decode = b(this)({
			Reader: m,
			types: k,
			util: v
		}), this.verify = C(this)({
			types: k,
			util: v
		}), this.fromObject = _.fromObject(this)({
			types: k,
			util: v
		}), this.toObject = _.toObject(this)({
			types: k,
			util: v
		});
		var D = S[A];
		if (D) {
			var F = Object.create(this);
			F.fromObject = this.fromObject, this.fromObject = D.fromObject.bind(F), F.toObject = this.toObject, this
				.toObject = D.toObject.bind(F)
		}
		return this
	}, w.prototype.encode = function(A, k) {
		return this.setup().encode(A, k)
	}, w.prototype.encodeDelimited = function(A, k) {
		return this.encode(A, k && k.len ? k.fork() : k).ldelim()
	}, w.prototype.decode = function(A, k) {
		return this.setup().decode(A, k)
	}, w.prototype.decodeDelimited = function(A) {
		return A instanceof m || (A = m.create(A)), this.decode(A, A.uint32())
	}, w.prototype.verify = function(A) {
		return this.setup().verify(A)
	}, w.prototype.fromObject = function(A) {
		return this.setup().fromObject(A)
	}, w.prototype.toObject = function(A, k) {
		return this.setup().toObject(A, k)
	}, w.d = function(A) {
		return function(k) {
			v.decorateType(k, A)
		}
	}, type
}

function requireRoot() {
	if (hasRequiredRoot) return root;
	hasRequiredRoot = 1, root = g;
	var o = requireNamespace();
	((g.prototype = Object.create(o.prototype)).constructor = g).className = "Root";
	var s, a, l, c = requireField(),
		d = require_enum(),
		f = requireOneof(),
		m = requireUtil();

	function g(C) {
		o.call(this, "", C), this.deferred = [], this.files = []
	}

	function v() {}
	g.fromJSON = function(C, _) {
		return _ || (_ = new g), C.options && _.setOptions(C.options), _.addJSON(C.nested)
	}, g.prototype.resolvePath = m.path.resolve, g.prototype.fetch = m.fetch, g.prototype.load = function C(_, S,
	w) {
		typeof S == "function" && (w = S, S = void 0);
		var T = this;
		if (!w) return m.asPromise(C, T, _, S);
		var A = w === v;

		function k(V, z) {
			if (w) {
				if (A) throw V;
				var j = w;
				w = null, j(V, z)
			}
		}

		function M(V) {
			var z = V.lastIndexOf("google/protobuf/");
			if (z > -1) {
				var j = V.substring(z);
				if (j in l) return j
			}
			return null
		}

		function D(V, z) {
			try {
				if (m.isString(z) && z.charAt(0) === "{" && (z = JSON.parse(z)), m.isString(z)) {
					a.filename = V;
					var j, ge = a(z, T, S),
						me = 0;
					if (ge.imports)
						for (; me < ge.imports.length; ++me)(j = M(ge.imports[me]) || T.resolvePath(V, ge.imports[
							me])) && F(j);
					if (ge.weakImports)
						for (me = 0; me < ge.weakImports.length; ++me)(j = M(ge.weakImports[me]) || T.resolvePath(V,
							ge.weakImports[me])) && F(j, !0)
				} else T.setOptions(z.options).addJSON(z.nested)
			} catch (he) {
				k(he)
			}
			A || R || k(null, T)
		}

		function F(V, z) {
			if (V = M(V) || V, !(T.files.indexOf(V) > -1))
				if (T.files.push(V), V in l) A ? D(V, l[V]) : (++R, setTimeout(function() {
					--R, D(V, l[V])
				}));
				else if (A) {
				var j;
				try {
					j = m.fs.readFileSync(V).toString("utf8")
				} catch (ge) {
					return void(z || k(ge))
				}
				D(V, j)
			} else ++R, T.fetch(V, function(ge, me) {
				--R, w && (ge ? z ? R || k(null, T) : k(ge) : D(V, me))
			})
		}
		var R = 0;
		m.isString(_) && (_ = [_]);
		for (var O, U = 0; U < _.length; ++U)(O = T.resolvePath("", _[U])) && F(O);
		if (A) return T;
		R || k(null, T)
	}, g.prototype.loadSync = function(C, _) {
		if (!m.isNode) throw Error("not supported");
		return this.load(C, _, v)
	}, g.prototype.resolveAll = function() {
		if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function(C) {
			return "'extend " + C.extend + "' in " + C.parent.fullName
		}).join(", "));
		return o.prototype.resolveAll.call(this)
	};
	var y = /^[A-Z]/;

	function b(C, _) {
		var S = _.parent.lookup(_.extend);
		if (S) {
			var w = new c(_.fullName, _.id, _.type, _.rule, void 0, _.options);
			return S.get(w.name) || (w.declaringField = _, _.extensionField = w, S.add(w)), !0
		}
		return !1
	}
	return g.prototype._handleAdd = function(C) {
		if (C instanceof c) C.extend === void 0 || C.extensionField || b(0, C) || this.deferred.push(C);
		else if (C instanceof d) y.test(C.name) && (C.parent[C.name] = C.values);
		else if (!(C instanceof f)) {
			if (C instanceof s)
				for (var _ = 0; _ < this.deferred.length;) b(0, this.deferred[_]) ? this.deferred.splice(_, 1) : ++
				_;
			for (var S = 0; S < C.nestedArray.length; ++S) this._handleAdd(C._nestedArray[S]);
			y.test(C.name) && (C.parent[C.name] = C)
		}
	}, g.prototype._handleRemove = function(C) {
		if (C instanceof c) {
			if (C.extend !== void 0)
				if (C.extensionField) C.extensionField.parent.remove(C.extensionField), C.extensionField = null;
				else {
					var _ = this.deferred.indexOf(C);
					_ > -1 && this.deferred.splice(_, 1)
				}
		} else if (C instanceof d) y.test(C.name) && delete C.parent[C.name];
		else if (C instanceof o) {
			for (var S = 0; S < C.nestedArray.length; ++S) this._handleRemove(C._nestedArray[S]);
			y.test(C.name) && delete C.parent[C.name]
		}
	}, g._configure = function(C, _, S) {
		s = C, a = _, l = S
	}, root
}

function requireUtil() {
	if (hasRequiredUtil) return util.exports;
	hasRequiredUtil = 1;
	var o, s, a = util.exports = requireMinimal(),
		l = requireRoots();
	a.codegen = requireCodegen(), a.fetch = requireFetch(), a.path = requirePath(), a.fs = a.inquire("fs"), a.toArray =
		function(g) {
			if (g) {
				for (var v = Object.keys(g), y = new Array(v.length), b = 0; b < v.length;) y[b] = g[v[b++]];
				return y
			}
			return []
		}, a.toObject = function(g) {
			for (var v = {}, y = 0; y < g.length;) {
				var b = g[y++],
					C = g[y++];
				C !== void 0 && (v[b] = C)
			}
			return v
		};
	var c = /\\/g,
		d = /"/g;
	a.isReserved = function(g) {
		return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/
			.test(g)
	}, a.safeProp = function(g) {
		return !/^[$\w_]+$/.test(g) || a.isReserved(g) ? '["' + g.replace(c, "\\\\").replace(d, '\\"') + '"]' :
			"." + g
	}, a.ucFirst = function(g) {
		return g.charAt(0).toUpperCase() + g.substring(1)
	};
	var f = /_([a-z])/g;
	a.camelCase = function(g) {
		return g.substring(0, 1) + g.substring(1).replace(f, function(v, y) {
			return y.toUpperCase()
		})
	}, a.compareFieldsById = function(g, v) {
		return g.id - v.id
	}, a.decorateType = function(g, v) {
		if (g.$type) return v && g.$type.name !== v && (a.decorateRoot.remove(g.$type), g.$type.name = v, a
			.decorateRoot.add(g.$type)), g.$type;
		o || (o = requireType());
		var y = new o(v || g.name);
		return a.decorateRoot.add(y), y.ctor = g, Object.defineProperty(g, "$type", {
			value: y,
			enumerable: !1
		}), Object.defineProperty(g.prototype, "$type", {
			value: y,
			enumerable: !1
		}), y
	};
	var m = 0;
	return a.decorateEnum = function(g) {
		if (g.$type) return g.$type;
		s || (s = require_enum());
		var v = new s("Enum" + m++, g);
		return a.decorateRoot.add(v), Object.defineProperty(g, "$type", {
			value: v,
			enumerable: !1
		}), v
	}, a.setProperty = function(g, v, y) {
		if (typeof g != "object") throw TypeError("dst must be an object");
		if (!v) throw TypeError("path must be specified");
		return function b(C, _, S) {
			var w = _.shift();
			if (w === "__proto__" || w === "prototype") return C;
			if (_.length > 0) C[w] = b(C[w] || {}, _, S);
			else {
				var T = C[w];
				T && (S = [].concat(T).concat(S)), C[w] = S
			}
			return C
		}(g, v = v.split("."), y)
	}, Object.defineProperty(a, "decorateRoot", {
		get: function() {
			return l.decorated || (l.decorated = new(requireRoot()))
		}
	}), util.exports
}

function requireObject() {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1, object = a, a.className = "ReflectionObject";
	var o, s = requireUtil();

	function a(l, c) {
		if (!s.isString(l)) throw TypeError("name must be a string");
		if (c && !s.isObject(c)) throw TypeError("options must be an object");
		this.options = c, this.parsedOptions = null, this.name = l, this.parent = null, this.resolved = !1, this
			.comment = null, this.filename = null
	}
	return Object.defineProperties(a.prototype, {
		root: {
			get: function() {
				for (var l = this; l.parent !== null;) l = l.parent;
				return l
			}
		},
		fullName: {
			get: function() {
				for (var l = [this.name], c = this.parent; c;) l.unshift(c.name), c = c.parent;
				return l.join(".")
			}
		}
	}), a.prototype.toJSON = function() {
		throw Error()
	}, a.prototype.onAdd = function(l) {
		this.parent && this.parent !== l && this.parent.remove(this), this.parent = l, this.resolved = !1;
		var c = l.root;
		c instanceof o && c._handleAdd(this)
	}, a.prototype.onRemove = function(l) {
		var c = l.root;
		c instanceof o && c._handleRemove(this), this.parent = null, this.resolved = !1
	}, a.prototype.resolve = function() {
		return this.resolved || this.root instanceof o && (this.resolved = !0), this
	}, a.prototype.getOption = function(l) {
		if (this.options) return this.options[l]
	}, a.prototype.setOption = function(l, c, d) {
		return d && this.options && this.options[l] !== void 0 || ((this.options || (this.options = {}))[l] = c),
			this
	}, a.prototype.setParsedOption = function(l, c, d) {
		this.parsedOptions || (this.parsedOptions = []);
		var f = this.parsedOptions;
		if (d) {
			var m = f.find(function(y) {
				return Object.prototype.hasOwnProperty.call(y, l)
			});
			if (m) {
				var g = m[l];
				s.setProperty(g, d, c)
			} else(m = {})[l] = s.setProperty({}, d, c), f.push(m)
		} else {
			var v = {};
			v[l] = c, f.push(v)
		}
		return this
	}, a.prototype.setOptions = function(l, c) {
		if (l)
			for (var d = Object.keys(l), f = 0; f < d.length; ++f) this.setOption(d[f], l[d[f]], c);
		return this
	}, a.prototype.toString = function() {
		var l = this.constructor.className,
			c = this.fullName;
		return c.length ? l + " " + c : l
	}, a._configure = function(l) {
		o = l
	}, object
}

function require_enum() {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1, _enum = l;
	var o = requireObject();
	((l.prototype = Object.create(o.prototype)).constructor = l).className = "Enum";
	var s = requireNamespace(),
		a = requireUtil();

	function l(c, d, f, m, g, v) {
		if (o.call(this, c, f), d && typeof d != "object") throw TypeError("values must be an object");
		if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = m, this.comments = g ||
			{}, this.valuesOptions = v, this.reserved = void 0, d)
			for (var y = Object.keys(d), b = 0; b < y.length; ++b) typeof d[y[b]] == "number" && (this.valuesById[this
				.values[y[b]] = d[y[b]]] = y[b])
	}
	return l.fromJSON = function(c, d) {
		var f = new l(c, d.values, d.options, d.comment, d.comments);
		return f.reserved = d.reserved, f
	}, l.prototype.toJSON = function(c) {
		var d = !!c && !!c.keepComments;
		return a.toObject(["options", this.options, "valuesOptions", this.valuesOptions, "values", this.values,
			"reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", d ? this
			.comment : void 0, "comments", d ? this.comments : void 0
		])
	}, l.prototype.add = function(c, d, f, m) {
		if (!a.isString(c)) throw TypeError("name must be a string");
		if (!a.isInteger(d)) throw TypeError("id must be an integer");
		if (this.values[c] !== void 0) throw Error("duplicate name '" + c + "' in " + this);
		if (this.isReservedId(d)) throw Error("id " + d + " is reserved in " + this);
		if (this.isReservedName(c)) throw Error("name '" + c + "' is reserved in " + this);
		if (this.valuesById[d] !== void 0) {
			if (!this.options || !this.options.allow_alias) throw Error("duplicate id " + d + " in " + this);
			this.values[c] = d
		} else this.valuesById[this.values[c] = d] = c;
		return m && (this.valuesOptions === void 0 && (this.valuesOptions = {}), this.valuesOptions[c] = m || null),
			this.comments[c] = f || null, this
	}, l.prototype.remove = function(c) {
		if (!a.isString(c)) throw TypeError("name must be a string");
		var d = this.values[c];
		if (d == null) throw Error("name '" + c + "' does not exist in " + this);
		return delete this.valuesById[d], delete this.values[c], delete this.comments[c], this.valuesOptions &&
			delete this.valuesOptions[c], this
	}, l.prototype.isReservedId = function(c) {
		return s.isReservedId(this.reserved, c)
	}, l.prototype.isReservedName = function(c) {
		return s.isReservedName(this.reserved, c)
	}, _enum
}

function requireEncoder() {
	if (hasRequiredEncoder) return encoder_1;
	hasRequiredEncoder = 1, encoder_1 = function(c) {
		for (var d, f = a.codegen(["m", "w"], c.name + "$encode")("if(!w)")("w=Writer.create()"), m = c.fieldsArray
				.slice().sort(a.compareFieldsById), g = 0; g < m.length; ++g) {
			var v = m[g].resolve(),
				y = c._fieldsArray.indexOf(v),
				b = v.resolvedType instanceof o ? "int32" : v.type,
				C = s.basic[b];
			d = "m" + a.safeProp(v.name), v.map ? (f("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", d, v.name)(
				"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", d)(
				"w.uint32(%i).fork().uint32(%i).%s(ks[i])", (v.id << 3 | 2) >>> 0, 8 | s.mapKey[v.keyType],
				v.keyType), C === void 0 ? f(
				"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", y, d) : f(
				".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | C, b, d), f("}")("}")) : v.repeated ? (f(
				"if(%s!=null&&%s.length){", d, d), v.packed && s.packed[b] !== void 0 ? f(
				"w.uint32(%i).fork()", (v.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", d)(
				"w.%s(%s[i])", b, d)("w.ldelim()") : (f("for(var i=0;i<%s.length;++i)", d), C === void 0 ?
				l(f, v, y, d + "[i]") : f("w.uint32(%i).%s(%s[i])", (v.id << 3 | C) >>> 0, b, d)), f("}")) : (v
				.optional && f("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", d, v.name), C === void 0 ? l(f,
					v, y, d) : f("w.uint32(%i).%s(%s)", (v.id << 3 | C) >>> 0, b, d))
		}
		return f("return w")
	};
	var o = require_enum(),
		s = requireTypes(),
		a = requireUtil();

	function l(c, d, f, m) {
		return d.resolvedType.group ? c("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", f, m, (d.id << 3 | 3) >>> 0, (d
			.id << 3 | 4) >>> 0) : c("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", f, m, (d.id << 3 | 2) >>>
			0)
	}
	return encoder_1
}

function requireIndexLight() {
	if (hasRequiredIndexLight) return indexLight.exports;
	hasRequiredIndexLight = 1;
	var o = indexLight.exports = requireIndexMinimal();
	return o.build = "light", o.load = function(s, a, l) {
			return typeof a == "function" ? (l = a, a = new o.Root) : a || (a = new o.Root), a.load(s, l)
		}, o.loadSync = function(s, a) {
			return a || (a = new o.Root), a.loadSync(s)
		}, o.encoder = requireEncoder(), o.decoder = requireDecoder(), o.verifier = requireVerifier(), o.converter =
		requireConverter(), o.ReflectionObject = requireObject(), o.Namespace = requireNamespace(), o.Root =
		requireRoot(), o.Enum = require_enum(), o.Type = requireType(), o.Field = requireField(), o.OneOf =
		requireOneof(), o.MapField = requireMapfield(), o.Service = requireService(), o.Method = requireMethod(), o
		.Message = requireMessage(), o.wrappers = requireWrappers(), o.types = requireTypes(), o.util = requireUtil(), o
		.ReflectionObject._configure(o.Root), o.Namespace._configure(o.Type, o.Service, o.Enum), o.Root._configure(o
			.Type), o.Field._configure(o.Type), indexLight.exports
}

function requireTokenize() {
	if (hasRequiredTokenize) return tokenize_1;
	hasRequiredTokenize = 1, tokenize_1 = y;
	var o = /[\s{}=;:[\],'"()<>]/g,
		s = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
		a = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
		l = /^ *[*/]+ */,
		c = /^\s*\*?\/*/,
		d = /\n/g,
		f = /\s/,
		m = /\\(.?)/g,
		g = {
			0: "\0",
			r: "\r",
			n: `
`,
			t: "	"
		};

	function v(b) {
		return b.replace(m, function(C, _) {
			switch (_) {
				case "\\":
				case "":
					return _;
				default:
					return g[_] || ""
			}
		})
	}

	function y(b, C) {
		b = b.toString();
		var _ = 0,
			S = b.length,
			w = 1,
			T = 0,
			A = {},
			k = [],
			M = null;

		function D(ge) {
			return Error("illegal " + ge + " (line " + w + ")")
		}

		function F(ge) {
			return b.charAt(ge)
		}

		function R(ge, me, he) {
			var ce, ae = {
					type: b.charAt(ge++),
					lineEmpty: !1,
					leading: he
				},
				fe = ge - (C ? 2 : 3);
			do
				if (--fe < 0 || (ce = b.charAt(fe)) === `
`) {
					ae.lineEmpty = !0;
					break
				} while (ce === " " || ce === "	");
			for (var q = b.substring(ge, me).split(d), le = 0; le < q.length; ++le) q[le] = q[le].replace(C ? c : l, "")
				.trim();
			ae.text = q.join(`
`).trim(), A[w] = ae, T = w
		}

		function O(ge) {
			var me = U(ge),
				he = b.substring(ge, me);
			return /^\s*\/\//.test(he)
		}

		function U(ge) {
			for (var me = ge; me < S && F(me) !== `
`;) me++;
			return me
		}

		function V() {
			if (k.length > 0) return k.shift();
			if (M) return function() {
				var de = M === "'" ? a : s;
				de.lastIndex = _ - 1;
				var _e = de.exec(b);
				if (!_e) throw D("string");
				return _ = de.lastIndex, z(M), M = null, v(_e[1])
			}();
			var ge, me, he, ce, ae, fe = _ === 0;
			do {
				if (_ === S) return null;
				for (ge = !1; f.test(he = F(_));)
					if (he === `
` && (fe = !0, ++w), ++_ === S) return null;
				if (F(_) === "/") {
					if (++_ === S) throw D("comment");
					if (F(_) === "/")
						if (C) {
							if (ce = _, ae = !1, O(_ - 1)) {
								ae = !0;
								do
									if ((_ = U(_)) === S || (_++, !fe)) break; while (O(_))
							} else _ = Math.min(S, U(_) + 1);
							ae && (R(ce, _, fe), fe = !0), w++, ge = !0
						} else {
							for (ae = F(ce = _ + 1) === "/"; F(++_) !== `
`;)
								if (_ === S) return null;
							++_, ae && (R(ce, _ - 1, fe), fe = !0), ++w, ge = !0
						}
					else {
						if ((he = F(_)) !== "*") return "/";
						ce = _ + 1, ae = C || F(ce) === "*";
						do {
							if (he === `
` && ++w, ++_ === S) throw D("comment");
							me = he, he = F(_)
						} while (me !== "*" || he !== "/");
						++_, ae && (R(ce, _ - 2, fe), fe = !0), ge = !0
					}
				}
			} while (ge);
			var q = _;
			if (o.lastIndex = 0, !o.test(F(q++)))
				for (; q < S && !o.test(F(q));) ++q;
			var le = b.substring(_, _ = q);
			return le !== '"' && le !== "'" || (M = le), le
		}

		function z(ge) {
			k.push(ge)
		}

		function j() {
			if (!k.length) {
				var ge = V();
				if (ge === null) return null;
				z(ge)
			}
			return k[0]
		}
		return Object.defineProperty({
			next: V,
			peek: j,
			push: z,
			skip: function(ge, me) {
				var he = j();
				if (he === ge) return V(), !0;
				if (!me) throw D("token '" + he + "', '" + ge + "' expected");
				return !1
			},
			cmnt: function(ge) {
				var me, he = null;
				return ge === void 0 ? (me = A[w - 1], delete A[w - 1], me && (C || me.type === "*" || me
					.lineEmpty) && (he = me.leading ? me.text : null)) : (T < ge && j(), me = A[ge],
					delete A[ge], !me || me.lineEmpty || !C && me.type !== "/" || (he = me.leading ?
						null : me.text)), he
			}
		}, "line", {
			get: function() {
				return w
			}
		})
	}
	return y.unescape = v, tokenize_1
}

function requireParse() {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1, parse_1 = F, F.filename = null, F.defaults = {
		keepCase: !1
	};
	var o = requireTokenize(),
		s = requireRoot(),
		a = requireType(),
		l = requireField(),
		c = requireMapfield(),
		d = requireOneof(),
		f = require_enum(),
		m = requireService(),
		g = requireMethod(),
		v = requireTypes(),
		y = requireUtil(),
		b = /^[1-9][0-9]*$/,
		C = /^-?[1-9][0-9]*$/,
		_ = /^0[x][0-9a-fA-F]+$/,
		S = /^-?0[x][0-9a-fA-F]+$/,
		w = /^0[0-7]+$/,
		T = /^-?0[0-7]+$/,
		A = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
		k = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
		M = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
		D = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

	function F(R, O, U) {
		O instanceof s || (U = O, O = new s), U || (U = F.defaults);
		var V, z, j, ge, me, he = U.preferTrailingComment || !1,
			ce = o(R, U.alternateCommentMode || !1),
			ae = ce.next,
			fe = ce.push,
			q = ce.peek,
			le = ce.skip,
			de = ce.cmnt,
			_e = !0,
			ke = !1,
			De = O,
			Se = U.keepCase ? function(we) {
				return we
			} : y.camelCase;

		function be(we, Ce, $e) {
			var Fe = F.filename;
			return $e || (F.filename = null), Error("illegal " + (Ce || "token") + " '" + we + "' (" + (Fe ? Fe + ", " :
				"") + "line " + ce.line + ")")
		}

		function Me() {
			var we, Ce = [];
			do {
				if ((we = ae()) !== '"' && we !== "'") throw be(we);
				Ce.push(ae()), le(we), we = q()
			} while (we === '"' || we === "'");
			return Ce.join("")
		}

		function Ve(we) {
			var Ce = ae();
			switch (Ce) {
				case "'":
				case '"':
					return fe(Ce), Me();
				case "true":
				case "TRUE":
					return !0;
				case "false":
				case "FALSE":
					return !1
			}
			try {
				return function($e, Fe) {
					var Ge = 1;
					switch ($e.charAt(0) === "-" && (Ge = -1, $e = $e.substring(1)), $e) {
						case "inf":
						case "INF":
						case "Inf":
							return Ge * (1 / 0);
						case "nan":
						case "NAN":
						case "Nan":
						case "NaN":
							return NaN;
						case "0":
							return 0
					}
					if (b.test($e)) return Ge * parseInt($e, 10);
					if (_.test($e)) return Ge * parseInt($e, 16);
					if (w.test($e)) return Ge * parseInt($e, 8);
					if (A.test($e)) return Ge * parseFloat($e);
					throw be($e, "number", Fe)
				}(Ce, !0)
			} catch {
				if (M.test(Ce)) return Ce;
				throw be(Ce, "value")
			}
		}

		function it(we, Ce) {
			var $e, Fe;
			do !Ce || ($e = q()) !== '"' && $e !== "'" ? we.push([Fe = pt(ae()), le("to", !0) ? pt(ae()) : Fe]) : we
				.push(Me()); while (le(",", !0));
			var Ge = {
				options: void 0,
				setOption: function(ze, Oe) {
					this.options === void 0 && (this.options = {}), this.options[ze] = Oe
				}
			};
			ye(Ge, function(ze) {
				if (ze !== "option") throw be(ze);
				ot(Ge, ze), le(";")
			}, function() {
				Ne(Ge)
			})
		}

		function pt(we, Ce) {
			switch (we) {
				case "max":
				case "MAX":
				case "Max":
					return 536870911;
				case "0":
					return 0
			}
			if (!Ce && we.charAt(0) === "-") throw be(we, "id");
			if (C.test(we)) return parseInt(we, 10);
			if (S.test(we)) return parseInt(we, 16);
			if (T.test(we)) return parseInt(we, 8);
			throw be(we, "id")
		}

		function dt() {
			if (V !== void 0) throw be("package");
			if (V = ae(), !M.test(V)) throw be(V, "name");
			De = De.define(V), le(";")
		}

		function He() {
			var we, Ce = q();
			switch (Ce) {
				case "weak":
					we = j || (j = []), ae();
					break;
				case "public":
					ae();
				default:
					we = z || (z = [])
			}
			Ce = Me(), le(";"), we.push(Ce)
		}

		function Ae() {
			if (le("="), ge = Me(), !(ke = ge === "proto3") && ge !== "proto2") throw be(ge, "syntax");
			O.setOption("syntax", ge), le(";")
		}

		function xe(we, Ce) {
			switch (Ce) {
				case "option":
					return ot(we, Ce), le(";"), !0;
				case "message":
					return Le(we, Ce), !0;
				case "enum":
					return nt(we, Ce), !0;
				case "service":
					return function($e, Fe) {
						if (!k.test(Fe = ae())) throw be(Fe, "service name");
						var Ge = new m(Fe);
						ye(Ge, function(ze) {
							if (!xe(Ge, ze)) {
								if (ze !== "rpc") throw be(ze);
								(function(Oe, Xe) {
									var rt = de(),
										ut = Xe;
									if (!k.test(Xe = ae())) throw be(Xe, "name");
									var gt, Et, Ze, Ye, ct = Xe;
									if (le("("), le("stream", !0) && (Et = !0), !M.test(Xe = ae()) || (
											gt = Xe, le(")"), le("returns"), le("("), le("stream", !
											0) && (Ye = !0), !M.test(Xe = ae()))) throw be(Xe);
									Ze = Xe, le(")");
									var yt = new g(ct, ut, gt, Ze, Et, Ye);
									yt.comment = rt, ye(yt, function(wt) {
										if (wt !== "option") throw be(wt);
										ot(yt, wt), le(";")
									}), Oe.add(yt)
								})(Ge, ze)
							}
						}), $e.add(Ge)
					}(we, Ce), !0;
				case "extend":
					return function($e, Fe) {
						if (!M.test(Fe = ae())) throw be(Fe, "reference");
						var Ge = Fe;
						ye(null, function(ze) {
							switch (ze) {
								case "required":
								case "repeated":
									Ue($e, ze, Ge);
									break;
								case "optional":
									Ue($e, ke ? "proto3_optional" : "optional", Ge);
									break;
								default:
									if (!ke || !M.test(ze)) throw be(ze);
									fe(ze), Ue($e, "optional", Ge)
							}
						})
					}(we, Ce), !0
			}
			return !1
		}

		function ye(we, Ce, $e) {
			var Fe = ce.line;
			if (we && (typeof we.comment != "string" && (we.comment = de()), we.filename = F.filename), le("{", !0)) {
				for (var Ge;
					(Ge = ae()) !== "}";) Ce(Ge);
				le(";", !0)
			} else $e && $e(), le(";"), we && (typeof we.comment != "string" || he) && (we.comment = de(Fe) || we
				.comment)
		}

		function Le(we, Ce) {
			if (!k.test(Ce = ae())) throw be(Ce, "type name");
			var $e = new a(Ce);
			ye($e, function(Fe) {
				if (!xe($e, Fe)) switch (Fe) {
					case "map":
						(function(Ge) {
							le("<");
							var ze = ae();
							if (v.mapKey[ze] === void 0) throw be(ze, "type");
							le(",");
							var Oe = ae();
							if (!M.test(Oe)) throw be(Oe, "type");
							le(">");
							var Xe = ae();
							if (!k.test(Xe)) throw be(Xe, "name");
							le("=");
							var rt = new c(Se(Xe), pt(ae()), ze, Oe);
							ye(rt, function(ut) {
								if (ut !== "option") throw be(ut);
								ot(rt, ut), le(";")
							}, function() {
								Ne(rt)
							}), Ge.add(rt)
						})($e);
						break;
					case "required":
					case "repeated":
						Ue($e, Fe);
						break;
					case "optional":
						Ue($e, ke ? "proto3_optional" : "optional");
						break;
					case "oneof":
						(function(Ge, ze) {
							if (!k.test(ze = ae())) throw be(ze, "name");
							var Oe = new d(Se(ze));
							ye(Oe, function(Xe) {
								Xe === "option" ? (ot(Oe, Xe), le(";")) : (fe(Xe), Ue(Oe,
									"optional"))
							}), Ge.add(Oe)
						})($e, Fe);
						break;
					case "extensions":
						it($e.extensions || ($e.extensions = []));
						break;
					case "reserved":
						it($e.reserved || ($e.reserved = []), !0);
						break;
					default:
						if (!ke || !M.test(Fe)) throw be(Fe);
						fe(Fe), Ue($e, "optional")
				}
			}), we.add($e)
		}

		function Ue(we, Ce, $e) {
			var Fe = ae();
			if (Fe !== "group") {
				for (; Fe.endsWith(".") || q().startsWith(".");) Fe += ae();
				if (!M.test(Fe)) throw be(Fe, "type");
				var Ge = ae();
				if (!k.test(Ge)) throw be(Ge, "name");
				Ge = Se(Ge), le("=");
				var ze = new l(Ge, pt(ae()), Fe, Ce, $e);
				if (ye(ze, function(Xe) {
						if (Xe !== "option") throw be(Xe);
						ot(ze, Xe), le(";")
					}, function() {
						Ne(ze)
					}), Ce === "proto3_optional") {
					var Oe = new d("_" + Ge);
					ze.setOption("proto3_optional", !0), Oe.add(ze), we.add(Oe)
				} else we.add(ze);
				ke || !ze.repeated || v.packed[Fe] === void 0 && v.basic[Fe] !== void 0 || ze.setOption("packed", !1, !
					0)
			} else(function(Xe, rt) {
				var ut = ae();
				if (!k.test(ut)) throw be(ut, "name");
				var gt = y.lcFirst(ut);
				ut === gt && (ut = y.ucFirst(ut)), le("=");
				var Et = pt(ae()),
					Ze = new a(ut);
				Ze.group = !0;
				var Ye = new l(gt, Et, ut, rt);
				Ye.filename = F.filename, ye(Ze, function(ct) {
					switch (ct) {
						case "option":
							ot(Ze, ct), le(";");
							break;
						case "required":
						case "repeated":
							Ue(Ze, ct);
							break;
						case "optional":
							Ue(Ze, ke ? "proto3_optional" : "optional");
							break;
						case "message":
							Le(Ze, ct);
							break;
						case "enum":
							nt(Ze, ct);
							break;
						default:
							throw be(ct)
					}
				}), Xe.add(Ze).add(Ye)
			})(we, Ce)
		}

		function nt(we, Ce) {
			if (!k.test(Ce = ae())) throw be(Ce, "name");
			var $e = new f(Ce);
			ye($e, function(Fe) {
				switch (Fe) {
					case "option":
						ot($e, Fe), le(";");
						break;
					case "reserved":
						it($e.reserved || ($e.reserved = []), !0);
						break;
					default:
						(function(Ge, ze) {
							if (!k.test(ze)) throw be(ze, "name");
							le("=");
							var Oe = pt(ae(), !0),
								Xe = {
									options: void 0,
									setOption: function(rt, ut) {
										this.options === void 0 && (this.options = {}), this.options[
											rt] = ut
									}
								};
							ye(Xe, function(rt) {
								if (rt !== "option") throw be(rt);
								ot(Xe, rt), le(";")
							}, function() {
								Ne(Xe)
							}), Ge.add(ze, Oe, Xe.comment, Xe.options)
						})($e, Fe)
				}
			}), we.add($e)
		}

		function ot(we, Ce) {
			var $e = le("(", !0);
			if (!M.test(Ce = ae())) throw be(Ce, "name");
			var Fe, Ge = Ce,
				ze = Ge;
			$e && (le(")"), ze = Ge = "(" + Ge + ")", Ce = q(), D.test(Ce) && (Fe = Ce.slice(1), Ge += Ce, ae())), le(
					"="),
				function(Oe, Xe, rt, ut) {
					Oe.setParsedOption && Oe.setParsedOption(Xe, rt, ut)
				}(we, ze, at(we, Ge), Fe)
		}

		function at(we, Ce) {
			if (le("{", !0)) {
				for (var $e = {}; !le("}", !0);) {
					if (!k.test(me = ae())) throw be(me, "name");
					if (me === null) throw be(me, "end of input");
					var Fe, Ge = me;
					if (le(":", !0), q() === "{") Fe = at(we, Ce + "." + me);
					else if (q() === "[") {
						var ze;
						if (Fe = [], le("[", !0)) {
							do ze = Ve(), Fe.push(ze); while (le(",", !0));
							le("]"), ze !== void 0 && Je(we, Ce + "." + me, ze)
						}
					} else Fe = Ve(), Je(we, Ce + "." + me, Fe);
					var Oe = $e[Ge];
					Oe && (Fe = [].concat(Oe).concat(Fe)), $e[Ge] = Fe, le(",", !0), le(";", !0)
				}
				return $e
			}
			var Xe = Ve();
			return Je(we, Ce, Xe), Xe
		}

		function Je(we, Ce, $e) {
			we.setOption && we.setOption(Ce, $e)
		}

		function Ne(we) {
			if (le("[", !0)) {
				do ot(we, "option"); while (le(",", !0));
				le("]")
			}
			return we
		}
		for (;
			(me = ae()) !== null;) switch (me) {
			case "package":
				if (!_e) throw be(me);
				dt();
				break;
			case "import":
				if (!_e) throw be(me);
				He();
				break;
			case "syntax":
				if (!_e) throw be(me);
				Ae();
				break;
			case "option":
				ot(De, me), le(";");
				break;
			default:
				if (xe(De, me)) {
					_e = !1;
					continue
				}
				throw be(me)
		}
		return F.filename = null, {
			package: V,
			imports: z,
			weakImports: j,
			syntax: ge,
			root: O
		}
	}
	return parse_1
}

function requireCommon() {
	if (hasRequiredCommon) return common_1;
	hasRequiredCommon = 1, common_1 = a;
	var o, s = /\/|\./;

	function a(l, c) {
		s.test(l) || (l = "google/protobuf/" + l + ".proto", c = {
			nested: {
				google: {
					nested: {
						protobuf: {
							nested: c
						}
					}
				}
			}
		}), a[l] = c
	}
	return a("any", {
		Any: {
			fields: {
				type_url: {
					type: "string",
					id: 1
				},
				value: {
					type: "bytes",
					id: 2
				}
			}
		}
	}), a("duration", {
		Duration: o = {
			fields: {
				seconds: {
					type: "int64",
					id: 1
				},
				nanos: {
					type: "int32",
					id: 2
				}
			}
		}
	}), a("timestamp", {
		Timestamp: o
	}), a("empty", {
		Empty: {
			fields: {}
		}
	}), a("struct", {
		Struct: {
			fields: {
				fields: {
					keyType: "string",
					type: "Value",
					id: 1
				}
			}
		},
		Value: {
			oneofs: {
				kind: {
					oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]
				}
			},
			fields: {
				nullValue: {
					type: "NullValue",
					id: 1
				},
				numberValue: {
					type: "double",
					id: 2
				},
				stringValue: {
					type: "string",
					id: 3
				},
				boolValue: {
					type: "bool",
					id: 4
				},
				structValue: {
					type: "Struct",
					id: 5
				},
				listValue: {
					type: "ListValue",
					id: 6
				}
			}
		},
		NullValue: {
			values: {
				NULL_VALUE: 0
			}
		},
		ListValue: {
			fields: {
				values: {
					rule: "repeated",
					type: "Value",
					id: 1
				}
			}
		}
	}), a("wrappers", {
		DoubleValue: {
			fields: {
				value: {
					type: "double",
					id: 1
				}
			}
		},
		FloatValue: {
			fields: {
				value: {
					type: "float",
					id: 1
				}
			}
		},
		Int64Value: {
			fields: {
				value: {
					type: "int64",
					id: 1
				}
			}
		},
		UInt64Value: {
			fields: {
				value: {
					type: "uint64",
					id: 1
				}
			}
		},
		Int32Value: {
			fields: {
				value: {
					type: "int32",
					id: 1
				}
			}
		},
		UInt32Value: {
			fields: {
				value: {
					type: "uint32",
					id: 1
				}
			}
		},
		BoolValue: {
			fields: {
				value: {
					type: "bool",
					id: 1
				}
			}
		},
		StringValue: {
			fields: {
				value: {
					type: "string",
					id: 1
				}
			}
		},
		BytesValue: {
			fields: {
				value: {
					type: "bytes",
					id: 1
				}
			}
		}
	}), a("field_mask", {
		FieldMask: {
			fields: {
				paths: {
					rule: "repeated",
					type: "string",
					id: 1
				}
			}
		}
	}), a.get = function(l) {
		return a[l] || null
	}, common_1
}

function requireSrc() {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	var o = src.exports = requireIndexLight();
	return o.build = "full", o.tokenize = requireTokenize(), o.parse = requireParse(), o.common = requireCommon(), o
		.Root._configure(o.Type, o.parse, o.common), src.exports
}

function requireProtobufjs() {
	return hasRequiredProtobufjs ? protobufjs : (hasRequiredProtobufjs = 1, protobufjs = requireSrc())
}
const nested = {
		google: {
			nested: {
				protobuf: {
					nested: {
						FileDescriptorSet: {
							fields: {
								file: {
									rule: "repeated",
									type: "FileDescriptorProto",
									id: 1
								}
							}
						},
						FileDescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								package: {
									type: "string",
									id: 2
								},
								dependency: {
									rule: "repeated",
									type: "string",
									id: 3
								},
								publicDependency: {
									rule: "repeated",
									type: "int32",
									id: 10,
									options: {
										packed: !1
									}
								},
								weakDependency: {
									rule: "repeated",
									type: "int32",
									id: 11,
									options: {
										packed: !1
									}
								},
								messageType: {
									rule: "repeated",
									type: "DescriptorProto",
									id: 4
								},
								enumType: {
									rule: "repeated",
									type: "EnumDescriptorProto",
									id: 5
								},
								service: {
									rule: "repeated",
									type: "ServiceDescriptorProto",
									id: 6
								},
								extension: {
									rule: "repeated",
									type: "FieldDescriptorProto",
									id: 7
								},
								options: {
									type: "FileOptions",
									id: 8
								},
								sourceCodeInfo: {
									type: "SourceCodeInfo",
									id: 9
								},
								syntax: {
									type: "string",
									id: 12
								}
							}
						},
						DescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								field: {
									rule: "repeated",
									type: "FieldDescriptorProto",
									id: 2
								},
								extension: {
									rule: "repeated",
									type: "FieldDescriptorProto",
									id: 6
								},
								nestedType: {
									rule: "repeated",
									type: "DescriptorProto",
									id: 3
								},
								enumType: {
									rule: "repeated",
									type: "EnumDescriptorProto",
									id: 4
								},
								extensionRange: {
									rule: "repeated",
									type: "ExtensionRange",
									id: 5
								},
								oneofDecl: {
									rule: "repeated",
									type: "OneofDescriptorProto",
									id: 8
								},
								options: {
									type: "MessageOptions",
									id: 7
								},
								reservedRange: {
									rule: "repeated",
									type: "ReservedRange",
									id: 9
								},
								reservedName: {
									rule: "repeated",
									type: "string",
									id: 10
								}
							},
							nested: {
								ExtensionRange: {
									fields: {
										start: {
											type: "int32",
											id: 1
										},
										end: {
											type: "int32",
											id: 2
										}
									}
								},
								ReservedRange: {
									fields: {
										start: {
											type: "int32",
											id: 1
										},
										end: {
											type: "int32",
											id: 2
										}
									}
								}
							}
						},
						FieldDescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								number: {
									type: "int32",
									id: 3
								},
								label: {
									type: "Label",
									id: 4
								},
								type: {
									type: "Type",
									id: 5
								},
								typeName: {
									type: "string",
									id: 6
								},
								extendee: {
									type: "string",
									id: 2
								},
								defaultValue: {
									type: "string",
									id: 7
								},
								oneofIndex: {
									type: "int32",
									id: 9
								},
								jsonName: {
									type: "string",
									id: 10
								},
								options: {
									type: "FieldOptions",
									id: 8
								}
							},
							nested: {
								Type: {
									values: {
										TYPE_DOUBLE: 1,
										TYPE_FLOAT: 2,
										TYPE_INT64: 3,
										TYPE_UINT64: 4,
										TYPE_INT32: 5,
										TYPE_FIXED64: 6,
										TYPE_FIXED32: 7,
										TYPE_BOOL: 8,
										TYPE_STRING: 9,
										TYPE_GROUP: 10,
										TYPE_MESSAGE: 11,
										TYPE_BYTES: 12,
										TYPE_UINT32: 13,
										TYPE_ENUM: 14,
										TYPE_SFIXED32: 15,
										TYPE_SFIXED64: 16,
										TYPE_SINT32: 17,
										TYPE_SINT64: 18
									}
								},
								Label: {
									values: {
										LABEL_OPTIONAL: 1,
										LABEL_REQUIRED: 2,
										LABEL_REPEATED: 3
									}
								}
							}
						},
						OneofDescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								options: {
									type: "OneofOptions",
									id: 2
								}
							}
						},
						EnumDescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								value: {
									rule: "repeated",
									type: "EnumValueDescriptorProto",
									id: 2
								},
								options: {
									type: "EnumOptions",
									id: 3
								}
							}
						},
						EnumValueDescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								number: {
									type: "int32",
									id: 2
								},
								options: {
									type: "EnumValueOptions",
									id: 3
								}
							}
						},
						ServiceDescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								method: {
									rule: "repeated",
									type: "MethodDescriptorProto",
									id: 2
								},
								options: {
									type: "ServiceOptions",
									id: 3
								}
							}
						},
						MethodDescriptorProto: {
							fields: {
								name: {
									type: "string",
									id: 1
								},
								inputType: {
									type: "string",
									id: 2
								},
								outputType: {
									type: "string",
									id: 3
								},
								options: {
									type: "MethodOptions",
									id: 4
								},
								clientStreaming: {
									type: "bool",
									id: 5
								},
								serverStreaming: {
									type: "bool",
									id: 6
								}
							}
						},
						FileOptions: {
							fields: {
								javaPackage: {
									type: "string",
									id: 1
								},
								javaOuterClassname: {
									type: "string",
									id: 8
								},
								javaMultipleFiles: {
									type: "bool",
									id: 10
								},
								javaGenerateEqualsAndHash: {
									type: "bool",
									id: 20,
									options: {
										deprecated: !0
									}
								},
								javaStringCheckUtf8: {
									type: "bool",
									id: 27
								},
								optimizeFor: {
									type: "OptimizeMode",
									id: 9,
									options: {
										default: "SPEED"
									}
								},
								goPackage: {
									type: "string",
									id: 11
								},
								ccGenericServices: {
									type: "bool",
									id: 16
								},
								javaGenericServices: {
									type: "bool",
									id: 17
								},
								pyGenericServices: {
									type: "bool",
									id: 18
								},
								deprecated: {
									type: "bool",
									id: 23
								},
								ccEnableArenas: {
									type: "bool",
									id: 31
								},
								objcClassPrefix: {
									type: "string",
									id: 36
								},
								csharpNamespace: {
									type: "string",
									id: 37
								},
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							],
							reserved: [
								[38, 38]
							],
							nested: {
								OptimizeMode: {
									values: {
										SPEED: 1,
										CODE_SIZE: 2,
										LITE_RUNTIME: 3
									}
								}
							}
						},
						MessageOptions: {
							fields: {
								messageSetWireFormat: {
									type: "bool",
									id: 1
								},
								noStandardDescriptorAccessor: {
									type: "bool",
									id: 2
								},
								deprecated: {
									type: "bool",
									id: 3
								},
								mapEntry: {
									type: "bool",
									id: 7
								},
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							],
							reserved: [
								[8, 8]
							]
						},
						FieldOptions: {
							fields: {
								ctype: {
									type: "CType",
									id: 1,
									options: {
										default: "STRING"
									}
								},
								packed: {
									type: "bool",
									id: 2
								},
								jstype: {
									type: "JSType",
									id: 6,
									options: {
										default: "JS_NORMAL"
									}
								},
								lazy: {
									type: "bool",
									id: 5
								},
								deprecated: {
									type: "bool",
									id: 3
								},
								weak: {
									type: "bool",
									id: 10
								},
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							],
							reserved: [
								[4, 4]
							],
							nested: {
								CType: {
									values: {
										STRING: 0,
										CORD: 1,
										STRING_PIECE: 2
									}
								},
								JSType: {
									values: {
										JS_NORMAL: 0,
										JS_STRING: 1,
										JS_NUMBER: 2
									}
								}
							}
						},
						OneofOptions: {
							fields: {
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							]
						},
						EnumOptions: {
							fields: {
								allowAlias: {
									type: "bool",
									id: 2
								},
								deprecated: {
									type: "bool",
									id: 3
								},
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							]
						},
						EnumValueOptions: {
							fields: {
								deprecated: {
									type: "bool",
									id: 1
								},
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							]
						},
						ServiceOptions: {
							fields: {
								deprecated: {
									type: "bool",
									id: 33
								},
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							]
						},
						MethodOptions: {
							fields: {
								deprecated: {
									type: "bool",
									id: 33
								},
								uninterpretedOption: {
									rule: "repeated",
									type: "UninterpretedOption",
									id: 999
								}
							},
							extensions: [
								[1e3, 536870911]
							]
						},
						UninterpretedOption: {
							fields: {
								name: {
									rule: "repeated",
									type: "NamePart",
									id: 2
								},
								identifierValue: {
									type: "string",
									id: 3
								},
								positiveIntValue: {
									type: "uint64",
									id: 4
								},
								negativeIntValue: {
									type: "int64",
									id: 5
								},
								doubleValue: {
									type: "double",
									id: 6
								},
								stringValue: {
									type: "bytes",
									id: 7
								},
								aggregateValue: {
									type: "string",
									id: 8
								}
							},
							nested: {
								NamePart: {
									fields: {
										namePart: {
											rule: "required",
											type: "string",
											id: 1
										},
										isExtension: {
											rule: "required",
											type: "bool",
											id: 2
										}
									}
								}
							}
						},
						SourceCodeInfo: {
							fields: {
								location: {
									rule: "repeated",
									type: "Location",
									id: 1
								}
							},
							nested: {
								Location: {
									fields: {
										path: {
											rule: "repeated",
											type: "int32",
											id: 1
										},
										span: {
											rule: "repeated",
											type: "int32",
											id: 2
										},
										leadingComments: {
											type: "string",
											id: 3
										},
										trailingComments: {
											type: "string",
											id: 4
										},
										leadingDetachedComments: {
											rule: "repeated",
											type: "string",
											id: 6
										}
									}
								}
							}
						},
						GeneratedCodeInfo: {
							fields: {
								annotation: {
									rule: "repeated",
									type: "Annotation",
									id: 1
								}
							},
							nested: {
								Annotation: {
									fields: {
										path: {
											rule: "repeated",
											type: "int32",
											id: 1
										},
										sourceFile: {
											type: "string",
											id: 2
										},
										begin: {
											type: "int32",
											id: 3
										},
										end: {
											type: "int32",
											id: 4
										}
									}
								}
							}
						}
					}
				}
			}
		}
	},
	require$$1 = {
		nested
	};
var hasRequiredDescriptor;

function requireDescriptor() {
	return hasRequiredDescriptor || (hasRequiredDescriptor = 1, function(o, s) {
		var a = requireProtobufjs();
		o.exports = s = a.descriptor = a.Root.fromJSON(require$$1).lookup(".google.protobuf");
		var l = a.Namespace,
			c = a.Root,
			d = a.Enum,
			f = a.Type,
			m = a.Field,
			g = a.MapField,
			v = a.OneOf,
			y = a.Service,
			b = a.Method;

		function C(O, U, V) {
			var z = s.FileDescriptorProto.create({
				name: O.filename || (O.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto"
			});
			V && (z.syntax = V), O instanceof c || (z.package = O.fullName.substring(1));
			for (var j, ge = 0; ge < O.nestedArray.length; ++ge)(j = O._nestedArray[ge]) instanceof f ? z
				.messageType.push(j.toDescriptor(V)) : j instanceof d ? z.enumType.push(j.toDescriptor()) :
				j instanceof m ? z.extension.push(j.toDescriptor(V)) : j instanceof y ? z.service.push(j
					.toDescriptor()) : j instanceof l && C(j, U, V);
			z.options = F(O.options, s.FileOptions), z.messageType.length + z.enumType.length + z.extension
				.length + z.service.length && U.push(z)
		}
		c.fromDescriptor = function(O) {
			typeof O.length == "number" && (O = s.FileDescriptorSet.decode(O));
			var U = new c;
			if (O.file)
				for (var V, z, j, ge = 0; ge < O.file.length; ++ge) {
					if (z = U, (V = O.file[ge]).package && V.package.length && (z = U.define(V.package)), V
						.name && V.name.length && U.files.push(z.filename = V.name), V.messageType)
						for (j = 0; j < V.messageType.length; ++j) z.add(f.fromDescriptor(V.messageType[j],
							V.syntax));
					if (V.enumType)
						for (j = 0; j < V.enumType.length; ++j) z.add(d.fromDescriptor(V.enumType[j]));
					if (V.extension)
						for (j = 0; j < V.extension.length; ++j) z.add(m.fromDescriptor(V.extension[j]));
					if (V.service)
						for (j = 0; j < V.service.length; ++j) z.add(y.fromDescriptor(V.service[j]));
					var me = D(V.options, s.FileOptions);
					if (me) {
						var he = Object.keys(me);
						for (j = 0; j < he.length; ++j) z.setOption(he[j], me[he[j]])
					}
				}
			return U
		}, c.prototype.toDescriptor = function(O) {
			var U = s.FileDescriptorSet.create();
			return C(this, U.file, O), U
		};
		var _ = 0;
		f.fromDescriptor = function(O, U) {
			typeof O.length == "number" && (O = s.DescriptorProto.decode(O));
			var V, z = new f(O.name.length ? O.name : "Type" + _++, D(O.options, s.MessageOptions));
			if (O.oneofDecl)
				for (V = 0; V < O.oneofDecl.length; ++V) z.add(v.fromDescriptor(O.oneofDecl[V]));
			if (O.field)
				for (V = 0; V < O.field.length; ++V) {
					var j = m.fromDescriptor(O.field[V], U);
					z.add(j), O.field[V].hasOwnProperty("oneofIndex") && z.oneofsArray[O.field[V]
						.oneofIndex].add(j)
				}
			if (O.extension)
				for (V = 0; V < O.extension.length; ++V) z.add(m.fromDescriptor(O.extension[V], U));
			if (O.nestedType)
				for (V = 0; V < O.nestedType.length; ++V) z.add(f.fromDescriptor(O.nestedType[V], U)), O
					.nestedType[V].options && O.nestedType[V].options.mapEntry && z.setOption("map_entry", !
						0);
			if (O.enumType)
				for (V = 0; V < O.enumType.length; ++V) z.add(d.fromDescriptor(O.enumType[V]));
			if (O.extensionRange && O.extensionRange.length)
				for (z.extensions = [], V = 0; V < O.extensionRange.length; ++V) z.extensions.push([O
					.extensionRange[V].start, O.extensionRange[V].end
				]);
			if (O.reservedRange && O.reservedRange.length || O.reservedName && O.reservedName.length) {
				if (z.reserved = [], O.reservedRange)
					for (V = 0; V < O.reservedRange.length; ++V) z.reserved.push([O.reservedRange[V].start,
						O.reservedRange[V].end
					]);
				if (O.reservedName)
					for (V = 0; V < O.reservedName.length; ++V) z.reserved.push(O.reservedName[V])
			}
			return z
		}, f.prototype.toDescriptor = function(O) {
			var U, V = s.DescriptorProto.create({
				name: this.name
			});
			for (U = 0; U < this.fieldsArray.length; ++U) {
				var z;
				if (V.field.push(z = this._fieldsArray[U].toDescriptor(O)), this._fieldsArray[
					U] instanceof g) {
					var j = M(this._fieldsArray[U].keyType, this._fieldsArray[U].resolvedKeyType),
						ge = M(this._fieldsArray[U].type, this._fieldsArray[U].resolvedType),
						me = ge === 11 || ge === 14 ? this._fieldsArray[U].resolvedType && R(this.parent,
							this._fieldsArray[U].resolvedType) || this._fieldsArray[U].type : void 0;
					V.nestedType.push(s.DescriptorProto.create({
						name: z.typeName,
						field: [s.FieldDescriptorProto.create({
							name: "key",
							number: 1,
							label: 1,
							type: j
						}), s.FieldDescriptorProto.create({
							name: "value",
							number: 2,
							label: 1,
							type: ge,
							typeName: me
						})],
						options: s.MessageOptions.create({
							mapEntry: !0
						})
					}))
				}
			}
			for (U = 0; U < this.oneofsArray.length; ++U) V.oneofDecl.push(this._oneofsArray[U]
				.toDescriptor());
			for (U = 0; U < this.nestedArray.length; ++U) this._nestedArray[U] instanceof m ? V.field.push(
					this._nestedArray[U].toDescriptor(O)) : this._nestedArray[U] instanceof f ? V.nestedType
				.push(this._nestedArray[U].toDescriptor(O)) : this._nestedArray[U] instanceof d && V
				.enumType.push(this._nestedArray[U].toDescriptor());
			if (this.extensions)
				for (U = 0; U < this.extensions.length; ++U) V.extensionRange.push(s.DescriptorProto
					.ExtensionRange.create({
						start: this.extensions[U][0],
						end: this.extensions[U][1]
					}));
			if (this.reserved)
				for (U = 0; U < this.reserved.length; ++U) typeof this.reserved[U] == "string" ? V
					.reservedName.push(this.reserved[U]) : V.reservedRange.push(s.DescriptorProto
						.ReservedRange.create({
							start: this.reserved[U][0],
							end: this.reserved[U][1]
						}));
			return V.options = F(this.options, s.MessageOptions), V
		};
		var S = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
		m.fromDescriptor = function(O, U) {
			if (typeof O.length == "number" && (O = s.DescriptorProto.decode(O)), typeof O.number !=
				"number") throw Error("missing field id");
			var V, z;
			switch (V = O.typeName && O.typeName.length ? O.typeName : function(he) {
					switch (he) {
						case 1:
							return "double";
						case 2:
							return "float";
						case 3:
							return "int64";
						case 4:
							return "uint64";
						case 5:
							return "int32";
						case 6:
							return "fixed64";
						case 7:
							return "fixed32";
						case 8:
							return "bool";
						case 9:
							return "string";
						case 12:
							return "bytes";
						case 13:
							return "uint32";
						case 15:
							return "sfixed32";
						case 16:
							return "sfixed64";
						case 17:
							return "sint32";
						case 18:
							return "sint64"
					}
					throw Error("illegal type: " + he)
				}(O.type), O.label) {
				case 1:
					z = void 0;
					break;
				case 2:
					z = "required";
					break;
				case 3:
					z = "repeated";
					break;
				default:
					throw Error("illegal label: " + O.label)
			}
			var j = O.extendee;
			O.extendee !== void 0 && (j = j.length ? j : void 0);
			var ge = new m(O.name.length ? O.name : "field" + O.number, O.number, V, z, j);
			if (ge.options = D(O.options, s.FieldOptions), O.defaultValue && O.defaultValue.length) {
				var me = O.defaultValue;
				switch (me) {
					case "true":
					case "TRUE":
						me = !0;
						break;
					case "false":
					case "FALSE":
						me = !1;
						break;
					default:
						S.exec(me) && (me = parseInt(me))
				}
				ge.setOption("default", me)
			}
			return function(he) {
				switch (he) {
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
					case 13:
					case 14:
					case 15:
					case 16:
					case 17:
					case 18:
						return !0
				}
				return !1
			}(O.type) && (U === "proto3" ? O.options && !O.options.packed && ge.setOption("packed", !
				1) : O.options && O.options.packed || ge.setOption("packed", !1)), ge
		}, m.prototype.toDescriptor = function(O) {
			var U = s.FieldDescriptorProto.create({
				name: this.name,
				number: this.id
			});
			if (this.map) U.type = 11, U.typeName = a.util.ucFirst(this.name), U.label = 3;
			else {
				switch (U.type = M(this.type, this.resolve().resolvedType)) {
					case 10:
					case 11:
					case 14:
						U.typeName = this.resolvedType ? R(this.parent, this.resolvedType) : this.type
				}
				switch (this.rule) {
					case "repeated":
						U.label = 3;
						break;
					case "required":
						U.label = 2;
						break;
					default:
						U.label = 1
				}
			}
			if (U.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend, this
				.partOf && (U.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(
				"missing oneof");
			return this.options && (U.options = F(this.options, s.FieldOptions), this.options.default !=
					null && (U.defaultValue = String(this.options.default))), O === "proto3" ? this
				.packed || ((U.options || (U.options = s.FieldOptions.create())).packed = !1) : this
				.packed && ((U.options || (U.options = s.FieldOptions.create())).packed = !0), U
		};
		var w = 0;
		d.fromDescriptor = function(O) {
			typeof O.length == "number" && (O = s.EnumDescriptorProto.decode(O));
			var U = {};
			if (O.value)
				for (var V = 0; V < O.value.length; ++V) {
					var z = O.value[V].name,
						j = O.value[V].number || 0;
					U[z && z.length ? z : "NAME" + j] = j
				}
			return new d(O.name && O.name.length ? O.name : "Enum" + w++, U, D(O.options, s.EnumOptions))
		}, d.prototype.toDescriptor = function() {
			for (var O = [], U = 0, V = Object.keys(this.values); U < V.length; ++U) O.push(s
				.EnumValueDescriptorProto.create({
					name: V[U],
					number: this.values[V[U]]
				}));
			return s.EnumDescriptorProto.create({
				name: this.name,
				value: O,
				options: F(this.options, s.EnumOptions)
			})
		};
		var T = 0;
		v.fromDescriptor = function(O) {
			return typeof O.length == "number" && (O = s.OneofDescriptorProto.decode(O)), new v(O.name && O
				.name.length ? O.name : "oneof" + T++)
		}, v.prototype.toDescriptor = function() {
			return s.OneofDescriptorProto.create({
				name: this.name
			})
		};
		var A = 0;
		y.fromDescriptor = function(O) {
			typeof O.length == "number" && (O = s.ServiceDescriptorProto.decode(O));
			var U = new y(O.name && O.name.length ? O.name : "Service" + A++, D(O.options, s
				.ServiceOptions));
			if (O.method)
				for (var V = 0; V < O.method.length; ++V) U.add(b.fromDescriptor(O.method[V]));
			return U
		}, y.prototype.toDescriptor = function() {
			for (var O = [], U = 0; U < this.methodsArray.length; ++U) O.push(this._methodsArray[U]
				.toDescriptor());
			return s.ServiceDescriptorProto.create({
				name: this.name,
				method: O,
				options: F(this.options, s.ServiceOptions)
			})
		};
		var k = 0;

		function M(O, U) {
			switch (O) {
				case "double":
					return 1;
				case "float":
					return 2;
				case "int64":
					return 3;
				case "uint64":
					return 4;
				case "int32":
					return 5;
				case "fixed64":
					return 6;
				case "fixed32":
					return 7;
				case "bool":
					return 8;
				case "string":
					return 9;
				case "bytes":
					return 12;
				case "uint32":
					return 13;
				case "sfixed32":
					return 15;
				case "sfixed64":
					return 16;
				case "sint32":
					return 17;
				case "sint64":
					return 18
			}
			if (U instanceof d) return 14;
			if (U instanceof f) return U.group ? 10 : 11;
			throw Error("illegal type: " + O)
		}

		function D(O, U) {
			if (O) {
				for (var V, z, j, ge, me = [], he = 0; he < U.fieldsArray.length; ++he)(z = (V = U._fieldsArray[
					he]).name) !== "uninterpretedOption" && O.hasOwnProperty(z) && (j = O[z], V
					.resolvedType instanceof d && typeof j == "number" && V.resolvedType.valuesById[j] !==
					void 0 && (j = V.resolvedType.valuesById[j]), me.push((ge = z).substring(0, 1) + ge
						.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function(ce, ae) {
							return "_" + ae.toLowerCase()
						}), j));
				return me.length ? a.util.toObject(me) : void 0
			}
		}

		function F(O, U) {
			if (O) {
				for (var V, z, j = [], ge = 0, me = Object.keys(O); ge < me.length; ++ge)
					if (z = O[V = me[ge]], V !== "default") {
						var he = U.fields[V];
						(he || (he = U.fields[V = a.util.camelCase(V)])) && j.push(V, z)
					} return j.length ? U.fromObject(a.util.toObject(j)) : void 0
			}
		}

		function R(O, U) {
			var V = O.fullName.split("."),
				z = U.fullName.split("."),
				j = 0,
				ge = 0,
				me = z.length - 1;
			if (!(O instanceof c) && U instanceof l)
				for (; j < V.length && ge < me && V[j] === z[ge];) {
					var he = U.lookup(V[j++], !0);
					if (he !== null && he !== U) break;
					++ge
				} else
					for (; j < V.length && ge < me && V[j] === z[ge]; ++j, ++ge);
			return z.slice(ge).join(".")
		}
		b.fromDescriptor = function(O) {
			return typeof O.length == "number" && (O = s.MethodDescriptorProto.decode(O)), new b(O.name && O
				.name.length ? O.name : "Method" + k++, "rpc", O.inputType, O.outputType, !!O
				.clientStreaming, !!O.serverStreaming, D(O.options, s.MethodOptions))
		}, b.prototype.toDescriptor = function() {
			return s.MethodDescriptorProto.create({
				name: this.name,
				inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this
					.requestType,
				outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this
					.responseType,
				clientStreaming: this.requestStream,
				serverStreaming: this.responseStream,
				options: F(this.options, s.MethodOptions)
			})
		}
	}(descriptor, descriptor.exports)), descriptor.exports
}
var descriptorExports = requireDescriptor();
class Topic extends EventEmitter {
	constructor(s) {
		super(), u(this, "name"), u(this, "ros"), u(this, "subscriptionId"), u(this, "eventName"), u(this,
				"isAdvertised"), u(this, "advertiseId"), u(this, "channelId"), u(this, "isSubscribed"), u(this,
				"deserializer", a => a), u(this, "serializer", a => a), this.ros = s.ros, this.name = s.name, this
			.isSubscribed = !1
	}
	processMessage(s) {
		const a = this.deserializer(s);
		this.emit("message", a)
	}
	subscribe(s) {
		this.on("message", s), this.isSubscribed || (this.isSubscribed = !0, this.ros.onTopicAdvertise(this.name,
			a => {
				if (this.channelId = a.id, this.ros.onTopicUnAdvertise(this.channelId, () => {
						this.eventName && this.ros.off(this.eventName), this.subscriptionId && this.ros
							.unsubscribe(this.subscriptionId), this.subscriptionId = void 0, this
							.eventName = void 0, this.channelId = void 0
					}), this.subscriptionId = this.ros.subscribe(this.channelId), this.eventName =
					`${TOPIC_PREFIX}${this.subscriptionId}`, a.encoding === "json") {
					const l = new TextDecoder;
					this.deserializer = c => JSON.parse(l.decode(c))
				} else if (a.encoding === "protobuf") {
					const l = protobufjsExports.Root.fromDescriptor(descriptorExports.FileDescriptorSet
						.decode(Buffer.from(a.schema, "base64"))).lookupType(a.schemaName);
					this.deserializer = c => l.decode(new Uint8Array(c.buffer, c.byteOffset, c.byteLength))
				} else if (a.encoding === "ros1") {
					const l = new MessageReader$1(distExports.parse(a.schema));
					this.deserializer = c => l.readMessage(c)
				} else if (a.encoding === "cdr") {
					const l = new distExports$1.MessageReader(distExports.parse(a.schema, {
						ros2: !0
					}));
					this.deserializer = c => l.readMessage(c)
				} else console.warn(`Unsupported encoding ${a.encoding}`);
				this.ros.on(this.eventName, this.processMessage.bind(this))
			}))
	}
	unsubscribe(s) {
		this.off("message", s);
		const a = this.listeners("message");
		this.subscriptionId !== void 0 && this.eventName && (s !== void 0 && a.length !== 0 || (this
			.removeAllListeners("message"), this.ros.offTopicAdvertise(this.name), this.channelId !==
			void 0 && this.ros.offTopicUnAdvertise(this.channelId), this.ros.off(this.eventName), this.ros
			.unsubscribe(this.subscriptionId), this.channelId = void 0, this.subscriptionId = void 0, this
			.eventName = void 0))
	}
	advertise() {
		if (!this.isAdvertised) return new Promise(s => {
			this.ros.onTopicAdvertise(this.name, a => {
				this.ros.offTopicAdvertise(this.name);
				const l = {
					topic: a.topic,
					schemaName: a.schemaName,
					encoding: a.encoding
				};
				if (this.advertiseId = this.ros.advertise(l), this.isAdvertised = !0, l
					.encoding === "json") {
					const c = new TextEncoder;
					this.serializer = d => c.encode(JSON.stringify(d))
				} else if (l.encoding === "ros1") {
					const c = new MessageWriter$1(distExports.parse(a.schema));
					this.serializer = d => c.writeMessage(d)
				} else if (l.encoding === "cdr") {
					const c = new distExports$1.MessageWriter(distExports.parse(a.schema, {
						ros2: !0
					}));
					this.serializer = d => c.writeMessage(d)
				} else console.warn(`Unsupported encoding ${l.encoding}`);
				s()
			})
		})
	}
	unadvertise() {
		this.isAdvertised && (this.isAdvertised = !1, this.advertiseId !== void 0 && (this.ros.unadvertise(this
			.advertiseId), this.advertiseId = void 0))
	}
	publish(s) {
		this.advertiseId !== void 0 && this.ros.sendMessage(this.advertiseId, this.serializer(s))
	}
}
class TFClient extends EventEmitter {
	constructor(s) {
		super(), u(this, "ros"), u(this, "tfTopic"), u(this, "tfStaticTopic"), u(this, "subscribeFrameIdSet",
				new Set), u(this, "tfFixedFrameIdSet", new Set), u(this, "tfBuffer", {}), u(this,
			"tfStaticBuffer", {}), u(this, "parentMap", {}), u(this, "childToParentMap", {}), u(this,
			"_fixedFrame"), u(this, "tfTree", []), u(this, "tfArray", []), this.ros = s.ros, this._fixedFrame = s
			.fixedFrame || "map", this.tfTopic = new Topic({
				ros: this.ros,
				name: s.tfTopic ?? "/tf"
			}), this.tfStaticTopic = new Topic({
				ros: this.ros,
				name: s.tfStaticTopic ?? "/tf_static"
			}), this.tfTopic.subscribe(this.processTFArray.bind(this)), this.tfStaticTopic.subscribe(this
				.processStaticTFArray.bind(this))
	}
	get fixedFrame() {
		return this._fixedFrame
	}
	processTFArray(s) {
		for (const {
				child_frame_id: a,
				transform: l,
				header: c
			}
			of s.transforms) {
			const d = `${c.frame_id}→${a}`;
			this.tfBuffer[d] = new Transform({
				translation: new Vector3({
					x: l.translation.x,
					y: l.translation.y,
					z: l.translation.z
				}),
				rotation: new Quaternion({
					x: l.rotation.x,
					y: l.rotation.y,
					z: l.rotation.z,
					w: l.rotation.w
				})
			}), this.updateParentMap(c.frame_id, a)
		}
		this.updateFrameTransform()
	}
	processStaticTFArray(s) {
		for (const {
				child_frame_id: a,
				transform: l,
				header: c
			}
			of s.transforms) {
			const d = `${c.frame_id}→${a}`;
			this.tfStaticBuffer[d] = new Transform({
				translation: new Vector3({
					x: l.translation.x,
					y: l.translation.y,
					z: l.translation.z
				}),
				rotation: new Quaternion({
					x: l.rotation.x,
					y: l.rotation.y,
					z: l.rotation.z,
					w: l.rotation.w
				})
			}), this.updateParentMap(c.frame_id, a)
		}
		this.updateFrameTransform()
	}
	updateParentMap(s, a) {
		this.parentMap[s] || (this.parentMap[s] = []), this.parentMap[s].includes(a) || this.parentMap[s].push(a),
			this.childToParentMap[a] = s;
		let l = !1;
		this.tfFixedFrameIdSet.has(s) || (this.tfFixedFrameIdSet.add(s), l = !0), this.tfFixedFrameIdSet.has(a) || (
			this.tfFixedFrameIdSet.add(a), l = !0), l && this.emitFixedFrames()
	}
	updateFrameTransform() {
		for (const s of this.subscribeFrameIdSet) {
			const a = this.lookupTransform(s);
			a && this.emit(s, a)
		}
		this.emit("tfUpdated")
	}
	generateTFTrees() {
		const s = new Set(Object.keys(this.parentMap));
		for (const a of Object.keys(this.childToParentMap)) s.delete(a);
		return Array.from(s).map(a => this.buildTree(a))
	}
	buildTree(s) {
		const a = {
			key: s,
			title: s,
			value: s,
			children: []
		};
		return this.parentMap[s] && (a.children = this.parentMap[s].map(l => this.buildTree(l))), a
	}
	emitFixedFrames() {
		this.tfArray = [...new Set([...this.subscribeFrameIdSet, ...this.tfFixedFrameIdSet])], this.emit(
			"fixedFrames", this.tfArray), this.tfTree = this.generateTFTrees(), this.emit("tfTreeUpdated", this
			.tfTree)
	}
	emitSubscribeFixedFrames(s, a = !1) {
		a ? this.subscribeFrameIdSet.delete(s) : this.subscribeFrameIdSet.has(s) || this.subscribeFrameIdSet.add(s),
			this.tfFixedFrameIdSet.has(s) || this.emitFixedFrames()
	}
	subscribe(s, a) {
		s[0] === "/" && (s = s.substring(1)), this.emitSubscribeFixedFrames(s), this.on(s, a)
	}
	unsubscribe(s, a) {
		s[0] === "/" && (s = s.substring(1)), this.off(s, a), this.listeners(s).length === 0 && this
			.emitSubscribeFixedFrames(s, !0)
	}
	setFixedFrame(s) {
		this._fixedFrame = s
	}
	lookupTransform(s, a = this._fixedFrame) {
		if (this.subscribeFrameIdSet.has(s) || (this.subscribeFrameIdSet.add(s), this.emitFixedFrames()), a === s)
			return new Transform({
				translation: new Vector3({
					x: 0,
					y: 0,
					z: 0
				}),
				rotation: new Quaternion({
					x: 0,
					y: 0,
					z: 0,
					w: 1
				})
			});
		const l = this._lookupTransform(a, s);
		if (l) return l;
		const c = this._lookupTransform(s, a);
		if (c) {
			const d = transformToMatrix(c),
				f = inv(d);
			return matrixToTransform(f)
		}
	}
	_lookupTransform(s, a) {
		const l = [
			[s, identity(4)]
		];
		for (; l.length > 0;) {
			const [c, d] = l.shift();
			if (c === a) return matrixToTransform(d);
			for (const f of Object.keys(this.tfBuffer).concat(Object.keys(this.tfStaticBuffer))) {
				const [m, g] = f.split("→");
				if (m === c) {
					const v = transformToMatrix(this.tfBuffer[f] || this.tfStaticBuffer[f]),
						y = multiply(d, v);
					l.push([g, y])
				}
			}
		}
	}
	transformToFrame(s, a, l = this._fixedFrame) {
		const c = this.lookupTransform(a, l);
		if (!c) return;
		const d = transformToMatrix(s),
			f = transformToMatrix(c),
			m = multiply(d, f);
		return matrixToTransform(m)
	}
}
const URDF_SPHERE = 0,
	URDF_BOX = 1,
	URDF_CYLINDER = 2,
	URDF_MESH = 3;
class UrdfBox {
	constructor(s) {
		u(this, "dimension"), u(this, "type");
		var a;
		this.type = URDF_BOX;
		const l = (a = s.xml.getAttribute("size")) == null ? void 0 : a.split(" ");
		this.dimension = l ? new Vector3({
			x: parseFloat(l[0]),
			y: parseFloat(l[1]),
			z: parseFloat(l[2])
		}) : void 0
	}
}
class UrdfColor {
	constructor(s) {
		u(this, "r"), u(this, "g"), u(this, "b"), u(this, "a");
		var a;
		const l = (a = s.xml.getAttribute("rgba")) == null ? void 0 : a.split(" ");
		l && (this.r = parseFloat(l[0]), this.g = parseFloat(l[1]), this.b = parseFloat(l[2]), this.a = parseFloat(
			l[3]))
	}
}
class UrdfCylinder {
	constructor(s) {
		u(this, "type"), u(this, "length"), u(this, "radius"), this.type = URDF_CYLINDER, this.length = parseFloat(s
			.xml.getAttribute("length")), this.radius = parseFloat(s.xml.getAttribute("radius"))
	}
}
class UrdfMesh {
	constructor(s) {
		u(this, "scale"), u(this, "type"), u(this, "filename"), this.type = URDF_MESH, this.filename = s.xml
			.getAttribute("filename");
		const a = s.xml.getAttribute("scale");
		if (a) {
			const l = a.split(" ");
			this.scale = new Vector3({
				x: parseFloat(l[0]),
				y: parseFloat(l[1]),
				z: parseFloat(l[2])
			})
		}
	}
}
class UrdfSphere {
	constructor(s) {
		u(this, "type"), u(this, "radius"), this.type = URDF_SPHERE, this.radius = parseFloat(s.xml.getAttribute(
			"radius") || "NaN")
	}
}
class UrdfMaterial {
	constructor(s) {
		u(this, "textureFilename"), u(this, "color"), u(this, "name"), this.name = s.xml.getAttribute("name");
		const a = s.xml.getElementsByTagName("texture");
		a.length > 0 && (this.textureFilename = a[0].getAttribute("filename"));
		const l = s.xml.getElementsByTagName("color");
		l.length > 0 && (this.color = new UrdfColor({
			xml: l[0]
		}))
	}
	isLink() {
		return this.color === null && this.textureFilename === null
	}
	assign(s) {
		return Object.assign(this, s)
	}
}
class UrdfVisual {
	constructor(s) {
		u(this, "origin"), u(this, "geometry"), u(this, "material"), u(this, "name");
		const a = s.xml;
		this.name = s.xml.getAttribute("name");
		const l = a.getElementsByTagName("origin");
		if (l.length === 0) this.origin = new Pose;
		else {
			const f = l[0].getAttribute("xyz");
			let m = new Vector3;
			if (f) {
				const y = f.split(" ");
				m = new Vector3({
					x: parseFloat(y[0]),
					y: parseFloat(y[1]),
					z: parseFloat(y[2])
				})
			}
			const g = l[0].getAttribute("rpy");
			let v = new Quaternion;
			if (g) {
				const y = g.split(" "),
					b = parseFloat(y[0]) / 2,
					C = parseFloat(y[1]) / 2,
					_ = parseFloat(y[2]) / 2,
					S = Math.sin(b) * Math.cos(C) * Math.cos(_) - Math.cos(b) * Math.sin(C) * Math.sin(_),
					w = Math.cos(b) * Math.sin(C) * Math.cos(_) + Math.sin(b) * Math.cos(C) * Math.sin(_),
					T = Math.cos(b) * Math.cos(C) * Math.sin(_) - Math.sin(b) * Math.sin(C) * Math.cos(_),
					A = Math.cos(b) * Math.cos(C) * Math.cos(_) + Math.sin(b) * Math.sin(C) * Math.sin(_);
				v = new Quaternion({
					x: S,
					y: w,
					z: T,
					w: A
				}), v.normalize()
			}
			this.origin = new Pose({
				position: m,
				orientation: v
			})
		}
		const c = a.getElementsByTagName("geometry");
		if (c.length > 0) {
			const f = c[0];
			let m;
			for (let g = 0; g < f.childNodes.length; g++) {
				const v = f.childNodes[g];
				if (v.nodeType === 1) {
					m = v;
					break
				}
			}
			if (m) {
				const g = m.nodeName;
				g === "sphere" ? this.geometry = new UrdfSphere({
					xml: m
				}) : g === "box" ? this.geometry = new UrdfBox({
					xml: m
				}) : g === "cylinder" ? this.geometry = new UrdfCylinder({
					xml: m
				}) : g === "mesh" ? this.geometry = new UrdfMesh({
					xml: m
				}) : console.warn("Unknown geometry type " + g)
			}
		}
		const d = a.getElementsByTagName("material");
		d.length > 0 && (this.material = new UrdfMaterial({
			xml: d[0]
		}))
	}
}
class UrdfLink {
	constructor(s) {
		u(this, "name"), u(this, "visuals"), this.name = s.xml.getAttribute("name"), this.visuals = [];
		const a = s.xml.getElementsByTagName("visual");
		for (let l = 0; l < a.length; l++) this.visuals.push(new UrdfVisual({
			xml: a[l]
		}))
	}
}
class UrdfJoint {
	constructor(s) {
		u(this, "name"), u(this, "type"), u(this, "parent"), u(this, "child"), u(this, "minval"), u(this, "maxval"),
			u(this, "origin"), this.name = s.xml.getAttribute("name"), this.type = s.xml.getAttribute("type");
		const a = s.xml.getElementsByTagName("parent");
		a.length > 0 && (this.parent = a[0].getAttribute("link"));
		const l = s.xml.getElementsByTagName("child");
		l.length > 0 && (this.child = l[0].getAttribute("link"));
		const c = s.xml.getElementsByTagName("limit");
		c.length > 0 && (this.minval = parseFloat(c[0].getAttribute("lower") || "NaN"), this.maxval = parseFloat(c[
			0].getAttribute("upper") || "NaN"));
		const d = s.xml.getElementsByTagName("origin");
		if (d.length === 0) this.origin = new Pose;
		else {
			const f = d[0].getAttribute("xyz");
			let m = new Vector3;
			if (f) {
				const y = f.split(" ");
				m = new Vector3({
					x: parseFloat(y[0]),
					y: parseFloat(y[1]),
					z: parseFloat(y[2])
				})
			}
			const g = d[0].getAttribute("rpy");
			let v = new Quaternion;
			if (g) {
				const y = g.split(" "),
					b = parseFloat(y[0]) / 2,
					C = parseFloat(y[1]) / 2,
					_ = parseFloat(y[2]) / 2,
					S = Math.sin(b) * Math.cos(C) * Math.cos(_) - Math.cos(b) * Math.sin(C) * Math.sin(_),
					w = Math.cos(b) * Math.sin(C) * Math.cos(_) + Math.sin(b) * Math.cos(C) * Math.sin(_),
					T = Math.cos(b) * Math.cos(C) * Math.sin(_) - Math.sin(b) * Math.sin(C) * Math.cos(_),
					A = Math.cos(b) * Math.cos(C) * Math.cos(_) + Math.sin(b) * Math.sin(C) * Math.sin(_);
				v = new Quaternion({
					x: S,
					y: w,
					z: T,
					w: A
				}), v.normalize()
			}
			this.origin = new Pose({
				position: m,
				orientation: v
			})
		}
	}
}
const XPATH_FIRST_ORDERED_NODE_TYPE = 9;
class UrdfModel {
	constructor(s) {
		u(this, "materials", {}), u(this, "links", {}), u(this, "joints", {}), u(this, "name");
		let a = s.xml;
		const l = s.string;
		if (l && (a = new libExports.DOMParser().parseFromString(l, libExports.MIME_TYPE.XML_TEXT).documentElement),
			!a) throw new Error("No URDF document parsed!");
		const c = a;
		this.name = c.getAttribute("name");
		for (let d = c.childNodes, f = 0; f < d.length; f++) {
			const m = d[f];
			if (m.tagName === "material") {
				const g = new UrdfMaterial({
					xml: m
				});
				this.materials[g.name] !== void 0 ? this.materials[g.name].isLink() ? this.materials[g.name].assign(
					g) : console.warn("Material " + g.name + "is not unique.") : this.materials[g.name] = g
			} else if (m.tagName === "link") {
				const g = new UrdfLink({
					xml: m
				});
				if (this.links[g.name] !== void 0) console.warn("Link " + g.name + " is not unique.");
				else {
					for (let v = 0; v < g.visuals.length; v++) {
						const y = g.visuals[v].material;
						y !== null && y.name && (this.materials[y.name] !== void 0 ? g.visuals[v].material = this
							.materials[y.name] : this.materials[y.name] = y)
					}
					this.links[g.name] = g
				}
			} else if (m.tagName === "joint") {
				const g = new UrdfJoint({
					xml: m
				});
				this.joints[g.name] = g
			}
		}
	}
}
const ROSLIB = Object.freeze(Object.defineProperty({
	__proto__: null,
	Param,
	Pose,
	Quaternion,
	Ros,
	TFClient,
	Topic,
	Transform,
	URDF_BOX,
	URDF_CYLINDER,
	URDF_MESH,
	URDF_SPHERE,
	UrdfBox,
	UrdfColor,
	UrdfCylinder,
	UrdfLink,
	UrdfMaterial,
	UrdfMesh,
	UrdfModel,
	UrdfSphere,
	UrdfVisual,
	Vector3,
	XPATH_FIRST_ORDERED_NODE_TYPE,
	debounce,
	getRandomPositiveInteger,
	loadMsgFile,
	matrixToTransform,
	sleep,
	throttle,
	transformToMatrix
}, Symbol.toStringTag, {
	value: "Module"
}));
class TFAxesClient {
	constructor(s) {
		u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "defaultHide"), u(this, "sns"), u(this,
				"lineType"), u(this, "lines", []), u(this, "textLabels", []), u(this, "lineColor"), u(this,
				"showLines"), u(this, "showLabels"), u(this, "frameVisible"), u(this, "tfTree", []), u(this,
				"tfArray", []), u(this, "processTFTreeBound"), u(this, "processTFArrayBound"), u(this,
				"processTFUpdatedBound"), this.ros = s.ros, this.tfClient = s.tfClient, this.viewer = s.viewer, this
			.tfTree = this.tfClient.tfTree, this.tfArray = this.tfClient.tfArray, this.defaultHide = s.defaultHide,
			this.sns = [], this.lines = [], this.textLabels = [], this.processTFTreeBound = debounce(a => {
				this.tfTree = a, this.processTF(this.tfTree)
			}, 500), this.processTFArrayBound = debounce(a => {
				this.tfArray = a
			}, 500), this.processTFUpdatedBound = () => {
				this.updateLines()
			}, this.setOptions(s), this.defaultHide || this.show()
	}
	setOptions(s) {
		this.lineType = s.lineType ?? "full", this.lineColor = s.lineColor ?? "#FF0000", this.showLines = s
			.showLines ?? !0, this.showLabels = s.showLabels ?? !0, this.frameVisible = s.frameVisible ?? {}, this
			.updateVisibility()
	}
	updateVisibility() {
		for (const s of this.lines) s.visible = this.showLines, s.material.color.set(this.lineColor);
		for (const s of this.textLabels) s.visible = this.showLabels;
		for (const s in this.frameVisible) {
			const a = this.sns.find(l => l.frameId === s);
			a && (a.setHidden(!this.frameVisible[s]), a.visible = this.frameVisible[s])
		}
	}
	processTF(s, a) {
		for (const l of s) {
			if (this.sns.findIndex(c => c.frameId === l.value) === -1) {
				const c = new Axes({
						shaftRadius: .025,
						headRadius: .07,
						headLength: .2,
						scale: .3,
						lineType: this.lineType
					}),
					d = new SceneNode({
						viewer: this.viewer,
						tfClient: this.tfClient,
						frameId: l.value,
						object: c
					});
				this.frameVisible[l.value] === void 0 && (this.frameVisible[l.value] = !0), d.visible = this
					.frameVisible[l.value], this.sns.push(d), this.viewer.addObject(d);
				const f = this.createTextLabel(l.value);
				f.visible = this.showLabels, d.object.add(f), this.textLabels.push(f)
			}
			if (a) {
				const c = this.sns.find(f => f.frameId === a),
					d = this.sns.find(f => f.frameId === l.value);
				if (c && d && !this.lines.find(f => f.userData.parentFrameId === a && f.userData.childFrameId === l
						.value)) {
					const f = this.createLine(c.position, d.position);
					f.userData = {
						parentFrameId: a,
						childFrameId: l.value
					}, this.viewer.scene.add(f), this.lines.push(f)
				}
			}
			l.children.length > 0 && this.processTF(l.children, l.value)
		}
	}
	createTextLabel(s) {
		const a = document.createElement("canvas"),
			l = a.getContext("2d"),
			c = "normal 200px sans-serif";
		l.font = c;
		const d = l.measureText(s).width;
		a.width = d, a.height = 300, l.font = c, l.fillStyle = "white", l.textAlign = "left", l.textBaseline =
			"middle", l.fillText(s, 0, a.height / 2);
		const f = new Texture(a);
		f.needsUpdate = !0;
		const m = new SpriteMaterial({
				map: f,
				transparent: !0,
				depthTest: !1,
				depthWrite: !1
			}),
			g = new Sprite(m);
		return g.frustumCulled = !1, g.scale.set(d / a.height * .5, .5, 1), g
	}
	createLine(s, a) {
		const l = new BufferGeometry().setFromPoints([s, a]),
			c = new LineBasicMaterial({
				color: this.lineColor
			}),
			d = new Line(l, c);
		return d.visible = this.showLines, d.frustumCulled = !1, d.position.z = .01, d
	}
	updateLines() {
		for (const s of this.lines) {
			const a = this.sns.find(c => c.frameId === s.userData.parentFrameId),
				l = this.sns.find(c => c.frameId === s.userData.childFrameId);
			a && l && this.updateLine(s, a.position, l.position)
		}
	}
	updateLine(s, a, l) {
		const c = s.geometry;
		c.setFromPoints([a, l]), c.attributes.position.needsUpdate = !0
	}
	show() {
		this.tfClient.on("tfTreeUpdated", this.processTFTreeBound), this.tfClient.on("fixedFrames", this
			.processTFArrayBound), this.tfClient.on("tfUpdated", this.processTFUpdatedBound), this.processTF(
			this.tfTree)
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.tfClient.off("tfTreeUpdated", this.processTFTreeBound), this.tfClient.off("fixedFrames", this
			.processTFArrayBound), this.tfClient.off("tfUpdated", this.processTFUpdatedBound);
		for (const s of this.sns) s.dispose(), this.viewer.removeObject(s);
		for (const s of this.lines) this.viewer.scene.remove(s), s.geometry.dispose(), s.material.dispose();
		for (const s of this.textLabels) this.viewer.scene.remove(s), s.material.dispose();
		this.sns = [], this.lines = [], this.textLabels = []
	}
}
const t = setTimeout,
	st = 18e5;
class Viewer {
	constructor(s) {
		u(this, "frustumSize", 10), u(this, "ros"), u(this, "tfClient"), u(this, "renderer"), u(this, "scene"), u(
				this, "camera3D"), u(this, "camera2D"), u(this, "camera3DControls"), u(this, "camera2DControls"), u(
				this, "directionalLight"), u(this, "selectableObjects"), u(this, "animationRequestId"), u(this,
				"isDragging", !1), u(this, "dragStartPosition", new Vector3$1), u(this, "clickType"), u(this,
				"currentArrow"), u(this, "clickCallBack", () => {}), u(this, "mountElement"), u(this, "cameraType"),
			u(this, "stopped"), u(this, "activeCamera"), u(this, "activeCameraControls"), u(this, "clock",
				new Clock), u(this, "fps", 30), u(this, "singleFrameTime", 1 / this.fps), u(this, "renderTimeStamp",
				0), u(this, "stats"), u(this, "debug", !1), this.ros = s.ros, this.tfClient = s.tfClient;
		const a = s.divID,
			l = s.elem,
			c = s.width,
			d = s.height,
			f = s.background ?? "#111111",
			m = s.antialias ?? !1,
			g = s.intensity ?? .66,
			v = s.near ?? .01,
			y = s.far ?? 1e3,
			b = s.alpha ?? 1;
		this.cameraType = s.cameraType || "3D", this.fps = s.fps ?? 30, this.singleFrameTime = 1 / this.fps, this
			.debug = s.debug ?? !1;
		const C = s.cameraPose || {
			x: 8,
			y: 8,
			z: 8
		};
		this.renderer = new WebGLRenderer({
				antialias: m,
				alpha: !0,
				logarithmicDepthBuffer: !0
			}), isMobileDevice() ? this.renderer.setPixelRatio(window.devicePixelRatio / 2) : this.renderer
			.setPixelRatio(window.devicePixelRatio), this.renderer.setClearColor(f, b), this.renderer.setSize(c, d),
			this.renderer.sortObjects = !1, this.renderer.shadowMap.enabled = !1, this.renderer.autoClear = !1, this
			.mountElement = l ?? document.getElementById(a), this.mountElement.appendChild(this.renderer
			.domElement), this.debug && (this.stats = new Stats, this.stats.showPanel(0), this.stats.dom.id =
				"stats", this.mountElement.appendChild(this.stats.dom)), this.scene = new Scene;
		const _ = c / d;
		this.camera3D = new PerspectiveCamera(75, _, v, y), this.camera3D.position.set(C.x, C.y, C.z), this.camera3D
			.up.set(0, 0, 1), this.camera3DControls = new OrbitControls(this.camera3D, this.renderer.domElement),
			this.camera3DControls.mouseButtons = {
				LEFT: MOUSE.PAN,
				MIDDLE: MOUSE.DOLLY,
				RIGHT: MOUSE.ROTATE
			}, this.camera2D = new OrthographicCamera(-this.frustumSize * _ / 2, this.frustumSize * _ / 2, this
				.frustumSize / 2, -this.frustumSize / 2, v, y), this.camera2D.position.set(0, 0, 10), this.camera2D
			.up.set(0, 1, 0), this.camera2DControls = new OrbitControls(this.camera2D, this.renderer.domElement),
			this.camera2DControls.mouseButtons = {
				LEFT: MOUSE.PAN,
				MIDDLE: MOUSE.DOLLY,
				RIGHT: MOUSE.ROTATE
			}, this.camera2DControls.enableRotate = !1, this.cameraType === "3D" ? (this.activeCamera = this
				.camera3D, this.activeCameraControls = this.camera3DControls) : (this.activeCamera = this.camera2D,
				this.activeCameraControls = this.camera2DControls), this.scene.add(new AmbientLight(5592405)), this
			.directionalLight = new DirectionalLight(16777215, g), this.directionalLight.position.set(1, 1, 1)
			.normalize(), this.scene.add(this.directionalLight), this.selectableObjects = new Group, this.scene.add(
				this.selectableObjects), this.stopped = !0, this.animationRequestId = void 0, this.renderer
			.domElement.addEventListener("mousedown", this.onMouseDown.bind(this)), this.renderer.domElement
			.addEventListener("mousemove", this.onMouseMove.bind(this)), this.renderer.domElement.addEventListener(
				"mouseup", this.onMouseUp.bind(this)), this.renderer.domElement.addEventListener("touchstart", this
				.onTouchStart.bind(this)), this.renderer.domElement.addEventListener("touchmove", this.onTouchMove
				.bind(this)), this.renderer.domElement.addEventListener("touchend", this.onTouchEnd.bind(this)),
			this.start();
		const S = this.stop;
		t(S, st)
	}
	setBackground(s, a) {
		this.renderer.setClearColor(s, a)
	}
	startClick(s, a) {
		this.clickType === void 0 && (this.clickType = s, this.clickCallBack = a, this.camera3DControls
			.enableRotate = !1, this.camera3DControls.enablePan = !1, this.camera3DControls.enableZoom = !1,
			this.camera2DControls.enablePan = !1, this.camera2DControls.enableZoom = !1)
	}
	stopClick() {
		this.isDragging = !1, this.currentArrow && (this.scene.remove(this.currentArrow), this.currentArrow =
				void 0), this.clickType = void 0, this.clickCallBack = () => {}, this.camera3DControls
			.enableRotate = !0, this.camera3DControls.enablePan = !0, this.camera3DControls.enableZoom = !0, this
			.camera2DControls.enablePan = !0, this.camera2DControls.enableZoom = !0
	}
	onMouseDown(s) {
		this.clickType && s.button === 0 && this.handleClick(s.clientX, s.clientY)
	}
	onTouchStart(s) {
		if (!this.clickType) return;
		const a = s.touches[0];
		this.handleClick(a.clientX, a.clientY)
	}
	handleClick(s, a) {
		const l = this.renderer.domElement.getBoundingClientRect(),
			c = s - l.left,
			d = a - l.top,
			f = new Vector2(c / l.width * 2 - 1, -d / l.height * 2 + 1),
			m = new Raycaster;
		m.setFromCamera(f, this.activeCamera);
		const g = this.scene.children.filter(y => y.type === "SceneNode").filter(y => y.clickable),
			v = m.intersectObjects(g, !0);
		if (v.length > 0) {
			const y = v[0].point;
			if (this.clickType === "point") {
				const b = new Vector3$1;
				b.copy(y), this.clickCallBack({
					position: b,
					orientation: {
						x: 0,
						y: 0,
						z: 0,
						w: 1
					}
				}), this.stopClick()
			} else if (this.clickType === "pose") {
				if (this.isDragging = !0, this.dragStartPosition.copy(y), this.scene.worldToLocal(this
						.dragStartPosition), this.currentArrow && this.scene.remove(this.currentArrow), this
					.currentArrow = new Arrow({
						origin: this.dragStartPosition,
						length: 1,
						shaftDiameter: .1,
						headDiameter: .2,
						material: new MeshPhongMaterial({
							color: "#00FF00"
						})
					}), this.cameraType === "3D") {
					const b = this.currentArrow.position.distanceTo(this.activeCamera.position) / (
					isMobileDevice() ? 5 : 15);
					this.currentArrow.scale.set(b, b, b)
				}
				this.scene.add(this.currentArrow)
			}
		}
	}
	onMouseMove(s) {
		this.isDragging && this.handleMove(s.clientX, s.clientY)
	}
	onTouchMove(s) {
		if (!this.isDragging) return;
		const a = s.touches[0];
		this.handleMove(a.clientX, a.clientY)
	}
	handleMove(s, a) {
		if (this.currentArrow) {
			const l = this.renderer.domElement.getBoundingClientRect(),
				c = s - l.left,
				d = a - l.top,
				f = new Vector2(c / l.width * 2 - 1, -d / l.height * 2 + 1),
				m = new Raycaster;
			m.setFromCamera(f, this.activeCamera);
			const g = new Plane(new Vector3$1(0, 0, 1), 0),
				v = new Vector3$1;
			m.ray.intersectPlane(g, v), this.scene.worldToLocal(v);
			const y = new Vector3$1().subVectors(v, this.dragStartPosition).normalize();
			this.currentArrow.rotation.z = Math.atan2(y.y, y.x) + -Math.PI / 2
		}
	}
	onMouseUp() {
		this.isDragging && this.handleUp()
	}
	onTouchEnd() {
		this.isDragging && this.handleUp()
	}
	handleUp() {
		if (this.currentArrow) {
			this.isDragging = !1;
			const s = this.currentArrow.quaternion.clone().normalize();
			this.clickCallBack({
				position: this.currentArrow.position,
				orientation: convertToROSRotation(s)
			}), this.scene.remove(this.currentArrow), this.currentArrow = void 0, this.stopClick()
		}
	}
	switch2D() {
		this.cameraType = "2D", this.activeCamera = this.camera2D, this.activeCameraControls = this.camera2DControls
	}
	switch3D() {
		this.cameraType = "3D", this.activeCamera = this.camera3D, this.activeCameraControls = this.camera3DControls
	}
	start() {
		this.stopped = !1, this.draw()
	}
	draw() {
		var s, a;
		if (this.stopped) return;
		const l = this.clock.getDelta();
		this.renderTimeStamp += l, this.renderTimeStamp > this.singleFrameTime && ((s = this.stats) == null || s
				.begin(), this.activeCameraControls.update(), this.renderer.clear(!0, !0, !0), this.renderer.render(
					this.scene, this.activeCamera), this.renderTimeStamp = this.renderTimeStamp % this
				.singleFrameTime, (a = this.stats) == null || a.end()), this.animationRequestId =
			requestAnimationFrame(this.draw.bind(this))
	}
	stop() {
		this.stopped || cancelAnimationFrame(this.animationRequestId), this.stopped = !0
	}
	destroy() {
		this.stop(), this.mountElement.removeChild(this.renderer.domElement), this.renderer.dispose()
	}
	addObject(s) {
		s.selectable ? this.selectableObjects.add(s) : this.scene.add(s)
	}
	removeObject(s) {
		s.selectable ? this.selectableObjects.remove(s) : this.scene.remove(s)
	}
	resize(s, a) {
		const l = s / a;
		this.camera3D.aspect = l, this.camera3D.updateProjectionMatrix(), this.camera2D.left = -this.frustumSize *
			l / 2, this.camera2D.right = this.frustumSize * l / 2, this.camera2D.top = this.frustumSize / 2, this
			.camera2D.bottom = -this.frustumSize / 2, this.camera2D.updateProjectionMatrix(), this.renderer.setSize(
				s, a)
	}
}
class SceneNode extends Object3D {
	constructor(s) {
		super(), u(this, "type", "SceneNode"), u(this, "viewer"), u(this, "tfClient"), u(this, "frameId"), u(this,
				"realMode"), u(this, "pose"), u(this, "tfUpdateBound"), u(this, "clickable"), u(this, "selectable"),
			u(this, "object"), u(this, "hidden", !1), this.frustumCulled = !1, this.viewer = s.viewer, this
			.tfClient = s.tfClient, this.frameId = s.frameId, this.object = s.object, this.frameId[0] === "/" && (
				this.frameId = this.frameId.substring(1)), this.realMode = s.realMode ?? !1, this.clickable = s
			.clickable ?? !1, this.selectable = s.selectable ?? !1, this.pose = s.pose ?? new Pose, this.visible =
			this.tfClient.fixedFrame === this.frameId, this.add(this.object), this.updatePose(this.pose), this
			.realMode || (this.tfUpdateBound = this.tfUpdate.bind(this), this.tfClient.subscribe(this.frameId, this
				.tfUpdateBound))
	}
	tfUpdate(s) {
		const a = new Pose(this.pose);
		a.applyTransform(s), this.updatePose(a), this.visible = !this.hidden
	}
	setHidden(s) {
		this.hidden = s
	}
	updatePose(s) {
		this.position.set(s.position.x, s.position.y, s.position.z), this.quaternion.set(s.orientation.x, s
			.orientation.y, s.orientation.z, s.orientation.w), this.updateMatrixWorld(!0)
	}
	unsubscribeTf() {
		this.tfUpdateBound && this.tfClient.unsubscribe(this.frameId, this.tfUpdateBound)
	}
	dispose() {
		for (this.unsubscribeTf(), this.traverse(s => {
				const a = s;
				a.geometry && a.geometry.dispose(), a.material && (Array.isArray(a.material) ? a.material
					.forEach(l => l.dispose()) : a.material.dispose())
			}); this.children.length > 0;) {
			const s = this.children[0];
			this.remove(s)
		}
	}
	async update() {
		if (this.realMode) {
			const s = this.tfClient.lookupTransform(this.frameId);
			if (s) {
				const a = new Pose(this.pose);
				a.applyTransform(s), this.updatePose(a), this.visible = !this.hidden
			}
		}
	}
}
class Points extends Object3D {
	constructor(s) {
		super(), u(this, "tfClient"), u(this, "viewer"), u(this, "max_pts"), u(this, "messageRatio"), u(this,
				"readMode"), u(this, "clickable"), u(this, "messageCount"), u(this, "material"), u(this, "geom"), u(
				this, "colorSrc"), u(this, "colorMap"), u(this, "object"), u(this, "sn"), u(this, "pointRatio"), u(
				this, "fields", {}), u(this, "positions"), u(this, "colors"), u(this, "getColor"), u(this,
				"positionsData"), u(this, "colorsData"), this.frustumCulled = !1, this.tfClient = s.tfClient, this
			.viewer = s.viewer, this.max_pts = s.max_pts ?? 1e4, this.pointRatio = s.pointRatio ?? 1, this
			.messageRatio = s.messageRatio ?? 1, this.messageCount = 0, this.material = s.material ?? {}, this
			.colorSrc = s.colorSrc, this.colorMap = s.colorMap, this.readMode = s.realMode ?? !0, this.clickable = s
			.clickable ?? !1, this.sn = void 0
	}
	setup(s, a, l) {
		if (this.sn === void 0) {
			l = l || [], this.fields = {};
			for (let c = 0; c < l.length; c++) this.fields[l[c].name] = l[c];
			if (this.positionsData = new Float32Array(3 * this.max_pts), this.positions = new BufferAttribute(this
					.positionsData, 3), this.geom = new BufferGeometry, this.geom.setAttribute("position", this
					.positions), !this.colorSrc && this.fields.intensity && (this.colorSrc = "intensity"), !this
				.colorSrc && this.fields.rgb && (this.colorSrc = "rgb"), this.colorSrc) {
				const c = this.fields[this.colorSrc];
				if (c) {
					this.colorsData = new Uint8Array(3 * this.max_pts), this.colors = new BufferAttribute(this
						.colorsData, 3, !0), this.geom.setAttribute("color", this.colors);
					const d = c.offset;
					this.getColor = [(m, g, v) => m.getInt8(g + d), (m, g, v) => m.getUint8(g + d), (m, g, v) => m
						.getInt16(g + d, v), (m, g, v) => m.getUint16(g + d, v), (m, g, v) => m.getInt32(g + d,
							v), (m, g, v) => m.getUint32(g + d, v), (m, g, v) => m.getFloat32(g + d, v), (m, g,
							v) => m.getFloat64(g + d, v)
					][c.datatype - 1];
					const f = (m, g, v, y, b) => {
						if (this.colorSrc === "rgb") {
							const C = _ => {
								const S = _ >> 16 & 255,
									w = _ >> 8 & 255,
									T = 255 & _;
								return new Color(S, w, T)
							};
							if (b.datatype === 5 || b.datatype === 6) return C(m);
							if (b.datatype === 7) return C(v.getUint32(y + b.offset, g))
						} else if (this.colorSrc === "intensity") return (C => {
							let _ = 5 * C + 1,
								S = Math.floor(_),
								w = _ - S;
							1 & S || (w = 1 - w);
							let T, A, k, M = 1 - w;
							return S <= 1 ? (T = M, A = 0, k = 1) : S === 2 ? (T = 0, A = M, k =
								1) : S === 3 ? (T = 0, A = 1, k = M) : S === 4 ? (T = M, A = 1, k =
									0) : (T = 1, A = M, k = 0), new Color(Math.round(255 * T), Math
									.round(255 * A), Math.round(255 * k))
						})(1 - Math.min(Math.max(m, 0), 255) / 255);
						return new Color(255, 255, 255)
					};
					this.colorMap = this.colorMap || f
				} else console.warn('unavailable field "' + this.colorSrc + '" for coloring.')
			}
			this.material.isMaterial || (this.colors && this.material.vertexColors === void 0 && (this.material
						.vertexColors = !0), this.material.vertexColors && (this.material.color = 16777215), this
					.material = new PointsMaterial(this.material), this.material.onBeforeCompile = (c, d) => {
						c.fragmentShader = c.fragmentShader.replace("void main() {", `
            void main() {
              // 计算点到中心的距离
              vec2 coord = gl_PointCoord - vec2(0.5);
              float distance = length(coord);
        
              // 只绘制圆点范围内的像素
              if (distance > 0.5) discard;
    `)
					}), this.object = new Points$1(this.geom, this.material), this.object.frustumCulled = !1, this
				.sn = new SceneNode({
					frameId: s,
					viewer: this.viewer,
					tfClient: this.tfClient,
					object: this.object,
					realMode: this.readMode,
					clickable: this.clickable
				}), this.viewer.addObject(this.sn)
		}
		return this.messageCount++ % this.messageRatio == 0
	}
	update(s) {
		var a, l;
		(a = this.sn) == null || a.update(), (l = this.geom) == null || l.setDrawRange(0, s), this.positions
			.needsUpdate = !0, this.colors && (this.colors.needsUpdate = !0)
	}
	dispose() {
		this.sn && (this.sn.dispose(), this.viewer.removeObject(this.sn))
	}
}
class PointCloud2 {
	constructor(s) {
		u(this, "ros"), u(this, "onRenderCount", () => {}), u(this, "processMessageBound"), u(this, "options"), u(
				this, "rosTopic"), u(this, "decayTimers"), u(this, "max_pts"), u(this, "pointsList", []), u(this,
				"topicName"), u(this, "decayTime"), u(this, "max_point_count"), u(this, "point_count", 0), u(this,
				"colorType"), this.ros = s.ros, this.topicName = s.topic, this.max_pts = s.max_pts = s.max_pts ??
			1e4, this.max_point_count = s.max_point_count ?? 0, this.colorType = s.colorType ?? "FlatColor", this
			.decayTime = s.decayTime ?? 0, this.decayTimers = new Map, this.onRenderCount = s.onRenderCount, s
			.realMode = s.realMode ?? !0, s.material = s.material ?? {
				size: 1,
				sizeAttenuation: !0
			}, s.material.vertexColors = this.colorType !== "FlatColor", s.material.vertexColors && (s.material
				.color = 16777215), this.options = s, this.options.clickable = !0, this.rosTopic = void 0, this
			.processMessageBound = this.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		var a;
		if (this.max_point_count > 0 && this.point_count >= this.max_point_count) return;
		let l = this.pointsList[0];
		if (this.decayTime > 0 || this.max_point_count > 0) {
			if (l = new Points(this.options), this.pointsList.push(l), this.decayTime > 0) {
				const w = setTimeout(() => {
					this.removePoints(l)
				}, 1e3 * this.decayTime);
				this.decayTimers.set(l, w)
			}
		} else l === void 0 && (l = new Points(this.options), this.pointsList[0] = l);
		if (!l.setup(s.header.frame_id, s.point_step, s.fields)) return;
		const c = l.pointRatio,
			d = this.max_pts * s.point_step,
			f = s.data.slice(0, Math.min(s.data.byteLength, d)),
			m = Math.min(s.height * s.width / c, l.positions.array.length / 3);
		this.point_count = this.decayTime > 0 || this.max_point_count > 0 ? this.point_count + m : m, (a = this
			.onRenderCount) == null || a.call(this, this.point_count);
		const g = new DataView(f.buffer),
			v = !s.is_bigendian,
			y = l.fields.x.offset,
			b = l.fields.y.offset,
			C = l.fields.z.offset;
		let _, S;
		for (let w = 0; w < m; w++) _ = w * c * s.point_step, l.positionsData && (l.positionsData[3 * w] = g
			.getFloat32(_ + y, v), l.positionsData[3 * w + 1] = g.getFloat32(_ + b, v), l.positionsData[3 * w +
				2] = g.getFloat32(_ + C, v)), l.colorsData && (S = l.colorMap(l.getColor(g, _, v), v, g, _, l
			.fields[l.colorSrc]), l.colorsData[3 * w] = S.r, l.colorsData[3 * w + 1] = S.g, l.colorsData[3 *
			w + 2] = S.b);
		l.update(m)
	}
	removePoints(s) {
		const a = this.pointsList.indexOf(s);
		a !== -1 && (this.pointsList.splice(a, 1), this.point_count -= s.positionsData.length / 3, s.dispose());
		const l = this.decayTimers.get(s);
		l && (clearTimeout(l), this.decayTimers.delete(s))
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe();
		for (const s of this.pointsList) s.dispose();
		this.pointsList = []
	}
	setOptions(s) {
		s.decayTime !== void 0 && (this.decayTime = s.decayTime), s.max_point_count !== void 0 && (this
			.max_point_count = s.max_point_count);
		let a = !1;
		s.colorType !== void 0 && this.colorType !== s.colorType && (this.colorType = s.colorType, a = !0), a && (
				this.options.material.vertexColors = this.colorType !== "FlatColor"), this.options.material
			.color !== s.color && (this.options.material.color = s.color, a = !0), this.options.material.size = s
			.size;
		for (const l of this.pointsList)
			if (l.object) {
				const c = l.object.material;
				a && (this.colorType === "FlatColor" ? (c.color.set(s.color), c.vertexColors = !1) : (c.color.set(
					16777215), c.vertexColors = !0)), c.size = s.size, c.needsUpdate = !0
			} s.topic !== void 0 && this.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this
			.hide(), this.show()))
	}
}
class AppendPointCloud2 {
	constructor(s) {
		u(this, "ros"), u(this, "max_pts"), u(this, "processMessageBound"), u(this, "options"), u(this, "rosTopic"),
			u(this, "points"), u(this, "topicName"), u(this, "max_point_count"), u(this, "point_count", 0), u(this,
				"colorType"), u(this, "onRenderCount", () => {}), this.ros = s.ros, this.topicName = s.topic, this
			.max_pts = s.max_pts = s.max_pts ?? 1e7, this.max_point_count = s.max_point_count ?? 1e7, this
			.colorType = s.colorType ?? "FlatColor", this.onRenderCount = s.onRenderCount, s.realMode = s
			.realMode ?? !0, s.material = s.material ?? {
				size: 1,
				sizeAttenuation: !0
			}, s.material.vertexColors = this.colorType !== "FlatColor", s.material.vertexColors && (s.material
				.color = 16777215), this.options = s, this.options.clickable = !0, this.rosTopic = void 0, this
			.processMessageBound = this.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.points = new Points(this.options), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		var a;
		if (this.max_point_count > 0 && this.point_count >= this.max_point_count) return;
		const l = this.points;
		if (!l.setup(s.header.frame_id, s.point_step, s.fields)) return;
		const c = l.pointRatio,
			d = this.max_pts * s.point_step,
			f = s.data.slice(0, Math.min(s.data.byteLength, d)),
			m = s.height * s.width / c,
			g = l.positions.array.length / 3 - this.point_count,
			v = Math.min(m, g);
		if (v <= 0) return;
		const y = new DataView(f.buffer),
			b = !s.is_bigendian,
			C = l.fields.x.offset,
			_ = l.fields.y.offset,
			S = l.fields.z.offset;
		let w, T;
		for (let A = 0; A < v; A++) w = A * c * s.point_step, l.positionsData && (l.positionsData[3 * (this
					.point_count + A)] = y.getFloat32(w + C, b), l.positionsData[3 * (this.point_count + A) + 1] = y
				.getFloat32(w + _, b), l.positionsData[3 * (this.point_count + A) + 2] = y.getFloat32(w + S, b)), l
			.colorsData && (T = l.colorMap(l.getColor(y, w, b), b, y, w, l.fields[l.colorSrc]), l.colorsData[3 * (
				this.point_count + A)] = T.r, l.colorsData[3 * (this.point_count + A) + 1] = T.g, l.colorsData[
				3 * (this.point_count + A) + 2] = T.b);
		this.point_count += v, (a = this.onRenderCount) == null || a.call(this, this.point_count), l.update(this
			.point_count)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		var s;
		this.unsubscribe(), (s = this.points) == null || s.dispose(), this.points = void 0
	}
	setOptions(s) {
		s.max_point_count !== void 0 && (this.max_point_count = s.max_point_count);
		let a = !1;
		s.colorType !== void 0 && this.colorType !== s.colorType && (this.colorType = s.colorType, a = !0), a && (
				this.options.material.vertexColors = this.colorType !== "FlatColor"), this.options.material
			.color !== s.color && (this.options.material.color = s.color, a = !0), this.options.material.size = s
			.size;
		const l = this.points;
		if (l.object) {
			const c = l.object.material;
			a && (this.colorType === "FlatColor" ? (c.color.set(s.color), c.vertexColors = !1) : (c.color.set(
				16777215), c.vertexColors = !0)), c.size = s.size, c.needsUpdate = !0
		}
		s.topic !== void 0 && this.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this
		.hide(), this.show()))
	}
}
class LaserScan {
	constructor(s) {
		u(this, "ros"), u(this, "processMessageBound"), u(this, "options"), u(this, "topicName"), u(this, "points"),
			u(this, "rosTopic"), this.ros = s.ros, this.topicName = s.topic || "/scan", this.rosTopic = void 0, s
			.realMode = s.realMode ?? !0, this.processMessageBound = this.processMessage.bind(this), this.options =
			s, s.defaultHide || this.show()
	}
	setOptions(s) {
		if (this.points && this.points.object) {
			const a = this.points.object.material;
			a.color.set(s.color), a.size = s.size, a.needsUpdate = !0
		}
		s.topic !== void 0 && this.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this
		.hide(), this.show()))
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.points = new Points(this.options), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		if (this.points) {
			if (!this.points.setup(s.header.frame_id)) return;
			const a = s.ranges.length;
			let l = 0;
			for (let c = 0; c < a; c += this.points.pointRatio) {
				const d = s.ranges[c];
				if (d >= s.range_min && d <= s.range_max) {
					const f = s.angle_min + c * s.angle_increment;
					this.points.positionsData && (this.points.positionsData[l++] = d * Math.cos(f), this.points
						.positionsData[l++] = d * Math.sin(f), this.points.positionsData[l++] = 0)
				}
			}
			this.points.update(l / 3)
		}
	}
	show() {
		this.dispose(), this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.points && (this.points.dispose(), this.points = void 0)
	}
}
let Image$1 = class {
	constructor(s) {
		u(this, "ros"), u(this, "renderDom"), u(this, "processMessageBound"), u(this, "topicName"), u(this,
				"rosTopic"), u(this, "canvas", null), u(this, "video", null), u(this, "context", null), u(this,
				"stream", null), this.ros = s.ros, this.renderDom = s.renderDom, this.topicName = s.topic, this
			.rosTopic = void 0, this.processMessageBound = this.processMessage.bind(this), s.defaultHide || this
			.show()
	}
	setOptions(s) {
		s.topic !== void 0 && this.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this
			.hide(), this.show()))
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.video = document.createElement("video"), this.canvas = document.createElement(
				"canvas"), this.context = this.canvas.getContext("2d"), this.stream = this.canvas
			.captureStream(), this.video.style.width = "100%", this.video.style.height = "100%", this.video
			.style.objectFit = "contain", this.video.style.display = "block", this.video.srcObject = this
			.stream, this.renderDom.append(this.video), this.rosTopic = new Topic({
				ros: this.ros,
				name: this.topicName
			}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		var a, l;
		const {
			data: c,
			width: d,
			height: f,
			encoding: m,
			is_bigendian: g
		} = s;
		this.canvas && (this.canvas.width !== d && (this.canvas.width = d), this.canvas.height !== f && (this
			.canvas.height = f));
		let v = null;
		switch (m) {
			case "rgb8":
			case "bgr8":
				v = this.convertToImageData(c, d, f, g, 3);
				break;
			case "rgba8":
			case "bgra8":
				v = this.convertToImageData(c, d, f, g, 4);
				break;
			case "mono8":
				v = this.convertGrayToImageData(c, d, f);
				break;
			default:
				return void console.error("Unsupported encoding:", m)
		}
		v && ((a = this.context) == null || a.putImageData(v, 0, 0)), (l = this.video) != null && l.paused &&
			this.video.play()
	}
	convertToImageData(s, a, l, c, d) {
		const f = new Uint8ClampedArray(a * l * 4);
		for (let m = 0; m < a * l; m++) {
			const g = m * d;
			f[4 * m] = c ? s[g] : s[g + 2], f[4 * m + 1] = s[g + 1], f[4 * m + 2] = c ? s[g + 2] : s[g], d ===
				3 ? f[4 * m + 3] = 255 : d === 4 && (f[4 * m + 3] = s[g + 3])
		}
		return new ImageData(f, a, l)
	}
	convertGrayToImageData(s, a, l) {
		const c = new Uint8ClampedArray(a * l * 4);
		for (let d = 0; d < a * l; d++) {
			const f = s[d];
			c[4 * d] = f, c[4 * d + 1] = f, c[4 * d + 2] = f, c[4 * d + 3] = 255
		}
		return new ImageData(c, a, l)
	}
	show() {
		this.dispose(), this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.video && (this.video.srcObject = null, this.renderDom.removeChild(this.video),
				this.video = null), this.stream && this.stream.getTracks().forEach(s => s.stop()), this
			.context && (this.context = null), this.canvas && (this.canvas = null)
	}
};
class Path {
	constructor(s) {
		u(this, "readMode"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "processMessageBound"),
			u(this, "offsetZ"), u(this, "color"), u(this, "linewidth"), u(this, "topicName"), u(this, "sn"), u(this,
				"rosTopic"), u(this, "line"), this.ros = s.ros, this.tfClient = s.tfClient, this.viewer = s.viewer,
			this.readMode = s.realMode ?? !1, this.topicName = s.topic ?? "/path", this.color = s.color ?? 13369599,
			this.linewidth = s.linewidth ?? 2, this.offsetZ = s.offsetZ ?? .1, this.sn = void 0, this.rosTopic =
			void 0, this.processMessageBound = this.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn));
		const a = new LineGeometry,
			l = [];
		for (let d = 0; d < s.poses.length; d++) {
			const f = s.poses[d].pose.position;
			l.push(f.x, f.y, f.z + this.offsetZ)
		}
		a.setPositions(l);
		const c = new LineMaterial({
			color: this.color,
			linewidth: this.linewidth,
			vertexColors: !1
		});
		this.line = new Line2(a, c), this.line.frustumCulled = !1, this.sn = new SceneNode({
			frameId: s.header.frame_id,
			viewer: this.viewer,
			tfClient: this.tfClient,
			realMode: this.readMode,
			object: this.line
		}), this.viewer.addObject(this.sn)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn =
			void 0)
	}
	setOptions(s) {
		if (s.color !== void 0 && (this.color = s.color, this.line)) {
			const a = this.line.material;
			a.color.set(this.color), a.needsUpdate = !0
		}
		if (s.offsetZ !== void 0 && (this.offsetZ = s.offsetZ), s.linewidth !== void 0 && (this.linewidth = s
				.linewidth, this.line)) {
			const a = this.line.material;
			a.linewidth = this.linewidth, a.needsUpdate = !0
		}
		s.topic !== void 0 && this.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this
		.hide(), this.show()))
	}
}
class PointStamped {
	constructor(s) {
		u(this, "readMode"), u(this, "options"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this,
				"processMessageBound"), u(this, "topicName"), u(this, "radius"), u(this, "offsetZ"), u(this,
				"color"), u(this, "sn"), u(this, "rosTopic"), u(this, "last_message"), this.options = s, this
			.readMode = s.realMode ?? !1, this.ros = s.ros, this.viewer = s.viewer, this.topicName = s.topic ??
			"/point", this.tfClient = s.tfClient, this.color = s.color ?? 13369599, this.radius = s.radius ?? .2,
			this.offsetZ = s.offsetZ ?? 0, this.sn = void 0, this.rosTopic = void 0, this.processMessageBound = this
			.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.last_message = s, this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn));
		const a = new SphereGeometry(this.radius),
			l = new MeshBasicMaterial({
				color: this.color
			}),
			c = new Mesh(a, l);
		c.frustumCulled = !1, c.position.set(s.point.x, s.point.y, s.point.z + this.offsetZ), this.sn =
			new SceneNode({
				frameId: s.header.frame_id,
				viewer: this.viewer,
				tfClient: this.tfClient,
				realMode: this.readMode,
				object: c
			}), this.viewer.addObject(this.sn)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.sn && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn = void 0)
	}
	setOptions(s) {
		s.radius !== void 0 && (this.radius = s.radius), s.offsetZ !== void 0 && (this.offsetZ = s.offsetZ), s
			.color !== void 0 && (this.color = s.color), s.topic !== void 0 && this.topicName !== s.topic ? (this
				.topicName = s.topic, this.rosTopic && (this.hide(), this.show())) : this.last_message && this
			.processMessage(this.last_message)
	}
}

function makeMapPalette() {
	let o = {};
	for (let s = 0; s <= 100; s++) {
		let a = 255 - 255 * s / 100;
		o[s] = [a, a, a, 255]
	}
	for (let s = 101; s <= 127; s++) o[s] = [0, 255, 0, 255];
	for (let s = 128; s <= 254; s++) o[s] = [255, 255 * (s - 128) / 126, 0, 255];
	return o[-1] = [112, 137, 134, 255], o
}

function makeCostMapPalette() {
	let o = {
		0: [0, 0, 0, 0]
	};
	for (let s = 1; s <= 98; s++) {
		let a = 255 * s / 100;
		o[s] = [a, 0, 255 - a, 255]
	}
	o[99] = [0, 255, 255, 255], o[100] = [255, 0, 255, 255];
	for (let s = 101; s <= 127; s++) o[s] = [0, 255, 0, 255];
	for (let s = 128; s <= 254; s++) o[s] = [255, 255 * (s - 128) / 126, 0, 255];
	return o[-1] = [112, 137, 134, 255], o
}

function makeRawPalette() {
	let o = {};
	for (let s = 0; s < 256; s++) o[s] = [s, s, s, 255];
	return o[-1] = [255, 255, 255, 255], o
}
const mapPalette = makeMapPalette(),
	costMapPalette = makeCostMapPalette(),
	rawPalette = makeRawPalette();
class OccupancyGrid extends Mesh {
	constructor(s) {
		const a = s.message,
			l = s.opacity ?? 1,
			c = s.zOffset ?? 0,
			d = a.info,
			f = d.origin,
			m = d.width,
			g = d.height,
			v = new PlaneGeometry(m, g),
			y = new Uint8Array(m * g * 4),
			b = new DataTexture(y, m, g, RGBAFormat);
		b.flipY = !0, b.minFilter = NearestFilter, b.magFilter = NearestFilter, b.needsUpdate = !0;
		const C = new MeshBasicMaterial({
			map: b,
			transparent: l < 1,
			opacity: l
		});
		C.side = DoubleSide, super(v, C), u(this, "mapType"), u(this, "texture"), this.frustumCulled = !1, this
			.mapType = s.type || "raw", this.quaternion.copy(new Quaternion$1(f.orientation.x, f.orientation.y, f
				.orientation.z, f.orientation.w)), this.position.x = m * d.resolution / 2 + f.position.x, this
			.position.y = g * d.resolution / 2 + f.position.y, this.position.z = f.position.z + c, this.scale.x = d
			.resolution, this.scale.y = d.resolution;
		const _ = a.data;
		this.material = C, this.texture = b;
		for (let S = 0; S < g; S++)
			for (let w = 0; w < m; w++) {
				const T = g - S - 1,
					A = w + T * m,
					k = this.getValue(A, T, w, _);
				let M = this.getColor(A, T, w, k);
				const D = 4 * (w + S * m);
				y.set(M, D)
			}
		b.needsUpdate = !0
	}
	dispose() {
		this.material.dispose(), this.texture.dispose()
	}
	getValue(s, a, l, c) {
		return c[s]
	}
	getColor(s, a, l, c) {
		return this.mapType === "costmap" ? costMapPalette[c] : this.mapType === "raw" ? rawPalette[c] : mapPalette[
			c]
	}
}
class OccupancyGridClient extends EventEmitter {
	constructor(s) {
		super(), u(this, "readMode"), u(this, "ros"), u(this, "viewer"), u(this, "offsetPose"), u(this, "zOffset"),
			u(this, "processMessageBound"), u(this, "tfClient"), u(this, "rosTopic"), u(this, "currentGrid"), u(
				this, "sceneNode"), u(this, "topicName"), u(this, "opacity"), u(this, "type"), u(this,
				"last_message"), this.readMode = s.realMode ?? !1, this.ros = s.ros, this.viewer = s.viewer, this
			.topicName = s.topic ?? "/map", this.tfClient = s.tfClient, this.offsetPose = s.offsetPose ?? new Pose,
			this.opacity = s.opacity ?? 1, this.type = s.type || "raw", this.zOffset = s.zOffset ?? 0, this
			.rosTopic = void 0, this.processMessageBound = this.processMessage.bind(this), s.defaultHide || this
			.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.last_message = s, this.sceneNode && this.currentGrid && this.sceneNode.remove(this.currentGrid);
		const a = new OccupancyGrid({
			message: s,
			type: this.type,
			opacity: this.opacity,
			zOffset: this.zOffset
		});
		this.currentGrid = a, this.sceneNode === void 0 ? (this.sceneNode = new SceneNode({
			frameId: s.header.frame_id,
			viewer: this.viewer,
			tfClient: this.tfClient,
			realMode: this.readMode,
			object: a,
			pose: this.offsetPose,
			clickable: !0
		}), this.viewer.addObject(this.sceneNode)) : this.sceneNode.add(this.currentGrid), this.emit("change")
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.currentGrid && (this.sceneNode && (this.sceneNode.dispose(), this.sceneNode.remove(
				this.currentGrid), this.viewer.removeObject(this.sceneNode), this.sceneNode = void 0), this
			.currentGrid.dispose(), this.currentGrid = void 0)
	}
	setOptions(s) {
		s.opacity !== void 0 && (this.opacity = s.opacity), s.type !== void 0 && (this.type = s.type), s.topic !==
			void 0 && this.topicName !== s.topic ? (this.topicName = s.topic, this.rosTopic && (this.hide(), this
				.show())) : this.last_message && this.processMessage(this.last_message)
	}
}
class Odometry {
	constructor(s) {
		u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "realMode"), u(this, "processMessageBound"),
			u(this, "color"), u(this, "keep"), u(this, "topicName"), u(this, "rosTopic"), u(this, "sns"), u(this,
				"options"), u(this, "positionTolerance"), u(this, "angleTolerance"), u(this, "lastPosition"), u(
				this, "lastOrientation"), this.ros = s.ros, this.tfClient = s.tfClient, this.viewer = s.viewer, this
			.topicName = s.topic ?? "/odom", this.color = s.color ?? 13369599, this.keep = s.keep ?? 100, this
			.realMode = s.realMode ?? !1, this.positionTolerance = s.positionTolerance ?? .1, this.angleTolerance =
			s.angleTolerance ?? .1, this.options = s, this.sns = [], this.processMessageBound = this.processMessage
			.bind(this), s.defaultHide || this.show()
	}
	setOptions(s) {
		if (s.keep !== void 0 && (this.keep = s.keep), s.color !== void 0) {
			this.color = s.color;
			for (const a of this.sns) a.object.material.color.set(this.color)
		}
		s.positionTolerance !== void 0 && (this.positionTolerance = s.positionTolerance), s.angleTolerance !==
			void 0 && (this.angleTolerance = s.angleTolerance), s.topic !== void 0 && this.topicName !== s.topic &&
			(this.topicName = s.topic, this.rosTopic && (this.hide(), this.show()))
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		const a = new Vector3$1(s.pose.pose.position.x, s.pose.pose.position.y, s.pose.pose.position.z),
			l = new Quaternion$1(s.pose.pose.orientation.x, s.pose.pose.orientation.y, s.pose.pose.orientation.z, s
				.pose.pose.orientation.w),
			c = !this.lastPosition || a.distanceTo(this.lastPosition) >= this.positionTolerance,
			d = !this.lastOrientation || l.angleTo(this.lastOrientation) >= this.angleTolerance;
		if (c || d) {
			this.sns.length >= this.keep && (this.sns[0].dispose(), this.viewer.removeObject(this.sns[0]), this.sns
					.shift()), this.options.origin = a, this.options.direction = new Vector3$1(1, 0, 0), this
				.options.direction.applyQuaternion(l), this.options.material = new MeshPhongMaterial({
					color: this.color
				});
			const f = new Arrow(this.options);
			this.sns.push(new SceneNode({
					frameId: s.header.frame_id,
					viewer: this.viewer,
					tfClient: this.tfClient,
					object: f,
					realMode: this.realMode
				})), this.viewer.addObject(this.sns[this.sns.length - 1]), this.lastPosition = a, this
				.lastOrientation = l
		}
	}
	show() {
		this.dispose(), this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe();
		for (const s of this.sns) s.dispose(), this.viewer.removeObject(s);
		this.sns = [], this.lastPosition = void 0, this.lastOrientation = void 0
	}
}
class PolygonStamped {
	constructor(s) {
		u(this, "readMode"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "processMessageBound"),
			u(this, "topicName"), u(this, "color"), u(this, "sn"), u(this, "rosTopic"), u(this, "line"), u(this,
				"last_message"), this.readMode = s.realMode ?? !1, this.ros = s.ros, this.viewer = s.viewer, this
			.tfClient = s.tfClient, this.topicName = s.topic ?? "/path", this.color = s.color ?? 13369599, this
			.processMessageBound = this.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.last_message = s, this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn));
		const a = [];
		for (let d = 0; d < s.polygon.points.length; d++) a.push(s.polygon.points[d].x, s.polygon.points[d].y, s
			.polygon.points[d].z);
		a.push(s.polygon.points[0].x, s.polygon.points[0].y, s.polygon.points[0].z);
		const l = new BufferGeometry;
		l.setAttribute("position", new Float32BufferAttribute(a, 3)), l.computeBoundingSphere();
		const c = new LineBasicMaterial({
			color: this.color
		});
		this.line = new Line(l, c), this.line.frustumCulled = !1, this.sn = new SceneNode({
			frameId: s.header.frame_id,
			viewer: this.viewer,
			tfClient: this.tfClient,
			realMode: this.readMode,
			object: this.line
		}), this.viewer.addObject(this.sn)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn =
			void 0)
	}
	setOptions(s) {
		s.color !== void 0 && (this.color = s.color), s.topic !== void 0 && this.topicName !== s.topic ? (this
				.topicName = s.topic, this.rosTopic && (this.hide(), this.show())) : this.last_message && this
			.processMessage(this.last_message)
	}
}
class PoseStamped {
	constructor(s) {
		u(this, "readMode"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "processMessageBound"),
			u(this, "topicName"), u(this, "color"), u(this, "sn"), u(this, "rosTopic"), u(this, "options"), u(this,
				"last_message"), this.options = s, this.readMode = s.realMode ?? !1, this.ros = s.ros, this
			.tfClient = s.tfClient, this.viewer = s.viewer, this.topicName = s.topic ?? "/pose", this.color = s
			.color ?? 13369599, this.sn = void 0, this.rosTopic = void 0, this.processMessageBound = this
			.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.last_message = s, this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn)), this
			.options.origin = new Vector3$1(s.pose.position.x, s.pose.position.y, s.pose.position.z);
		const a = new Quaternion$1(s.pose.orientation.x, s.pose.orientation.y, s.pose.orientation.z, s.pose
			.orientation.w);
		this.options.direction = new Vector3$1(1, 0, 0), this.options.direction.applyQuaternion(a), this.options
			.material = new MeshPhongMaterial({
				color: this.color
			});
		const l = new Arrow(this.options);
		this.sn = new SceneNode({
			frameId: s.header.frame_id,
			viewer: this.viewer,
			tfClient: this.tfClient,
			realMode: this.readMode,
			object: l
		}), this.viewer.addObject(this.sn)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn =
			void 0)
	}
	setOptions(s) {
		s.color !== void 0 && (this.color = s.color), s.topic !== void 0 && this.topicName !== s.topic ? (this
				.topicName = s.topic, this.rosTopic && (this.hide(), this.show())) : this.last_message && this
			.processMessage(this.last_message)
	}
}
class PoseArray {
	constructor(s) {
		u(this, "readMode"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "processMessageBound"),
			u(this, "topicName"), u(this, "color"), u(this, "length"), u(this, "sn"), u(this, "rosTopic"), u(this,
				"options"), u(this, "last_message"), this.options = s, this.readMode = s.realMode ?? !1, this.ros =
			s.ros, this.tfClient = s.tfClient, this.viewer = s.viewer, this.topicName = s.topic ?? "/particlecloud",
			this.color = s.color ?? 13369599, this.length = s.length ?? 1, this.sn = void 0, this.rosTopic = void 0,
			this.processMessageBound = this.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.last_message = s, this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn));
		const a = new Object3D;
		a.frustumCulled = !1;
		for (let l = 0; l < s.poses.length; l++) {
			const c = [],
				d = new Vector3$1(s.poses[l].position.x, s.poses[l].position.y, s.poses[l].position.z),
				f = new Quaternion$1(s.poses[l].orientation.x, s.poses[l].orientation.y, s.poses[l].orientation.z, s
					.poses[l].orientation.w),
				m = new Vector3$1(this.length, 0, 0),
				g = new Vector3$1(.8 * this.length, .2 * this.length, 0),
				v = new Vector3$1(.8 * this.length, .2 * -this.length, 0);
			m.applyQuaternion(f), g.applyQuaternion(f), v.applyQuaternion(f), c.push(d.x, d.y, d.z), c.push(m.x + d
				.x, m.y + d.y, m.z + d.z), c.push(g.x + d.x, g.y + d.y, g.z + d.z), c.push(v.x + d.x, v.y + d.y,
				v.z + d.z), c.push(m.x + d.x, m.y + d.y, m.z + d.z);
			const y = new BufferGeometry;
			y.setAttribute("position", new Float32BufferAttribute(c, 3)), y.computeBoundingSphere();
			const b = new LineBasicMaterial({
					color: this.color
				}),
				C = new Line(y, b);
			C.frustumCulled = !1, a.add(C)
		}
		this.sn = new SceneNode({
			frameId: s.header.frame_id,
			viewer: this.viewer,
			tfClient: this.tfClient,
			realMode: this.readMode,
			object: a
		}), this.viewer.addObject(this.sn)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn =
			void 0)
	}
	setOptions(s) {
		s.color !== void 0 && (this.color = s.color), s.length !== void 0 && (this.length = s.length), s.topic !==
			void 0 && this.topicName !== s.topic ? (this.topicName = s.topic, this.rosTopic && (this.hide(), this
				.show())) : this.last_message && this.processMessage(this.last_message)
	}
}
class PoseWithCovarianceStamped {
	constructor(s) {
		u(this, "readMode"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this, "processMessageBound"),
			u(this, "topicName"), u(this, "color"), u(this, "sn"), u(this, "rosTopic"), u(this, "options"), u(this,
				"last_message"), this.options = s, this.readMode = s.realMode ?? !1, this.ros = s.ros, this
			.tfClient = s.tfClient, this.viewer = s.viewer, this.topicName = s.topic ?? "/PoseWithCovariance", this
			.color = s.color ?? 13369599, this.sn = void 0, this.rosTopic = void 0, this.processMessageBound = this
			.processMessage.bind(this), s.defaultHide || this.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.last_message = s, this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn)), this
			.options.origin = new Vector3$1(s.pose.pose.position.x, s.pose.pose.position.y, s.pose.pose.position.z);
		const a = new Quaternion$1(s.pose.pose.orientation.x, s.pose.pose.orientation.y, s.pose.pose.orientation.z,
			s.pose.pose.orientation.w);
		this.options.direction = new Vector3$1(1, 0, 0), this.options.direction.applyQuaternion(a), this.options
			.material = new MeshPhongMaterial({
				color: this.color
			});
		const l = new Arrow(this.options);
		this.sn = new SceneNode({
			frameId: s.header.frame_id,
			viewer: this.viewer,
			tfClient: this.tfClient,
			realMode: this.readMode,
			object: l
		}), this.viewer.addObject(this.sn)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.sn !== void 0 && (this.sn.dispose(), this.viewer.removeObject(this.sn), this.sn =
			void 0)
	}
	setOptions(s) {
		s.color !== void 0 && (this.color = s.color), s.topic !== void 0 && this.topicName !== s.topic ? (this
				.topicName = s.topic, this.rosTopic && (this.hide(), this.show())) : this.last_message && this
			.processMessage(this.last_message)
	}
}
class OcTreeClient extends EventEmitter {
	constructor(s) {
		super(), u(this, "readMode"), u(this, "ros"), u(this, "viewer"), u(this, "offsetPose"), u(this,
				"processMessageBound"), u(this, "tfClient"), u(this, "rosTopic"), u(this, "currentMap"), u(this,
				"sceneNode"), u(this, "topicName"), u(this, "opacity"), u(this, "options", {
				opacity: void 0,
				colorMode: void 0,
				voxelRenderMode: void 0
			}), u(this, "worker"), u(this, "frameId"), this.readMode = s.realMode ?? !1, this.ros = s.ros, this
			.viewer = s.viewer, this.tfClient = s.tfClient, this.offsetPose = s.offsetPose ?? new Pose, this
			.topicName = s.topic ?? "/octomap_full", this.opacity = s.opacity ?? 1, this.rosTopic = void 0, this
			.processMessageBound = this.processMessage.bind(this), this.options = Object.assign({
				opacity: this.opacity,
				colorMode: s.colorMode,
				voxelRenderMode: s.voxelRenderMode
			}, this.options), s.defaultHide || this.show();
		const a = new URL(
			"data:text/javascript;base64,dmFyIEkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CnZhciBEID0gKGEsIHQsIGUpID0+IHQgaW4gYSA/IEkoYSwgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSA6IGFbdF0gPSBlOwp2YXIgcyA9IChhLCB0LCBlKSA9PiBEKGEsIHR5cGVvZiB0ICE9ICJzeW1ib2wiID8gdCArICIiIDogdCwgZSk7CmNsYXNzIE4gewogIGNvbnN0cnVjdG9yKCkgewogICAgcyh0aGlzLCAiY2hpbGRyZW4iLCBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0pOwogICAgcyh0aGlzLCAidmFsdWUiLCBudWxsKTsKICAgIHModGhpcywgImNvbG9yIiwgbnVsbCk7CiAgfQogIHByb2JhYmlsaXR5KHQpIHsKICAgIHJldHVybiAxIC0gMSAvICgxICsgTWF0aC5leHAodCkpOwogIH0KICBnZXRPY2N1cGFuY3koKSB7CiAgICByZXR1cm4gdGhpcy5wcm9iYWJpbGl0eSh0aGlzLnZhbHVlKTsKICB9CiAgY3JlYXRlQ2hpbGROb2RlQXQodCwgZSkgewogICAgdGhpcy5jaGlsZHJlbltlICUgOF0gPSB0OwogIH0KICBoYXNDaGlsZEF0KHQpIHsKICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3QgJSA4XSAhPT0gbnVsbDsKICB9CiAgZ2V0Q2hpbGRBdCh0KSB7CiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblt0ICUgOF07CiAgfQogIGlzTGVhZk5vZGUoKSB7CiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDg7ICsrdCkgaWYgKHRoaXMuY2hpbGRyZW5bdF0gIT09IG51bGwpIHJldHVybiAhMTsKICAgIHJldHVybiAhMDsKICB9CiAgaGFzQ2hpbGRyZW4oKSB7CiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDg7ICsrdCkgaWYgKHRoaXMuY2hpbGRyZW5bdF0gIT09IG51bGwpIHJldHVybiAhMDsKICAgIHJldHVybiAhMTsKICB9Cn0KY2xhc3MgZiB7CiAgY29uc3RydWN0b3IodCwgZSA9ICEwKSB7CiAgICBzKHRoaXMsICJsZW5ndGgiKTsKICAgIHModGhpcywgImlzTGl0dGxlRW5kaWFuIik7CiAgICBzKHRoaXMsICJkYXRhVmlldyIpOwogICAgcyh0aGlzLCAiY3Vyc29yIik7CiAgICB0aGlzLmxlbmd0aCA9IHQuYnl0ZUxlbmd0aCwgdGhpcy5pc0xpdHRsZUVuZGlhbiA9IGUsIHRoaXMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgdC5ieXRlTGVuZ3RoKSwgdGhpcy5jdXJzb3IgPSAwOwogIH0KICBnZXQgaXNFbmQoKSB7CiAgICByZXR1cm4gdGhpcy5jdXJzb3IgPj0gdGhpcy5sZW5ndGg7CiAgfQogIHJlYWRJbnQ4KCkgewogICAgdGhpcy5jaGVja0JvdW5kcygxKTsKICAgIGNvbnN0IHQgPSB0aGlzLmRhdGFWaWV3LmdldEludDgodGhpcy5jdXJzb3IpOwogICAgcmV0dXJuIHRoaXMuY3Vyc29yICs9IDEsIHQ7CiAgfQogIHJlYWRVaW50OCgpIHsKICAgIHRoaXMuY2hlY2tCb3VuZHMoMSk7CiAgICBjb25zdCB0ID0gdGhpcy5kYXRhVmlldy5nZXRVaW50OCh0aGlzLmN1cnNvcik7CiAgICByZXR1cm4gdGhpcy5jdXJzb3IgKz0gMSwgdDsKICB9CiAgcmVhZEludDE2KCkgewogICAgdGhpcy5jaGVja0JvdW5kcygyKTsKICAgIGNvbnN0IHQgPSB0aGlzLmRhdGFWaWV3LmdldEludDE2KHRoaXMuY3Vyc29yLCB0aGlzLmlzTGl0dGxlRW5kaWFuKTsKICAgIHJldHVybiB0aGlzLmN1cnNvciArPSAyLCB0OwogIH0KICByZWFkVWludDE2KCkgewogICAgdGhpcy5jaGVja0JvdW5kcygyKTsKICAgIGNvbnN0IHQgPSB0aGlzLmRhdGFWaWV3LmdldFVpbnQxNih0aGlzLmN1cnNvciwgdGhpcy5pc0xpdHRsZUVuZGlhbik7CiAgICByZXR1cm4gdGhpcy5jdXJzb3IgKz0gMiwgdDsKICB9CiAgcmVhZEludDMyKCkgewogICAgdGhpcy5jaGVja0JvdW5kcyg0KTsKICAgIGNvbnN0IHQgPSB0aGlzLmRhdGFWaWV3LmdldEludDMyKHRoaXMuY3Vyc29yLCB0aGlzLmlzTGl0dGxlRW5kaWFuKTsKICAgIHJldHVybiB0aGlzLmN1cnNvciArPSA0LCB0OwogIH0KICByZWFkVWludDMyKCkgewogICAgdGhpcy5jaGVja0JvdW5kcyg0KTsKICAgIGNvbnN0IHQgPSB0aGlzLmRhdGFWaWV3LmdldFVpbnQzMih0aGlzLmN1cnNvciwgdGhpcy5pc0xpdHRsZUVuZGlhbik7CiAgICByZXR1cm4gdGhpcy5jdXJzb3IgKz0gNCwgdDsKICB9CiAgcmVhZEZsb2F0MzIoKSB7CiAgICB0aGlzLmNoZWNrQm91bmRzKDQpOwogICAgY29uc3QgdCA9IHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLmN1cnNvciwgdGhpcy5pc0xpdHRsZUVuZGlhbik7CiAgICByZXR1cm4gdGhpcy5jdXJzb3IgKz0gNCwgdDsKICB9CiAgcmVhZEludDY0KCkgewogICAgdGhpcy5jaGVja0JvdW5kcyg4KTsKICAgIGNvbnN0IHQgPSB0aGlzLmRhdGFWaWV3LmdldEJpZ0ludDY0KHRoaXMuY3Vyc29yLCB0aGlzLmlzTGl0dGxlRW5kaWFuKTsKICAgIHJldHVybiB0aGlzLmN1cnNvciArPSA4LCB0OwogIH0KICByZWFkVWludDY0KCkgewogICAgdGhpcy5jaGVja0JvdW5kcyg4KTsKICAgIGNvbnN0IHQgPSB0aGlzLmRhdGFWaWV3LmdldEJpZ1VpbnQ2NCh0aGlzLmN1cnNvciwgdGhpcy5pc0xpdHRsZUVuZGlhbik7CiAgICByZXR1cm4gdGhpcy5jdXJzb3IgKz0gOCwgdDsKICB9CiAgcmVhZEZsb2F0NjQoKSB7CiAgICB0aGlzLmNoZWNrQm91bmRzKDgpOwogICAgY29uc3QgdCA9IHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQ2NCh0aGlzLmN1cnNvciwgdGhpcy5pc0xpdHRsZUVuZGlhbik7CiAgICByZXR1cm4gdGhpcy5jdXJzb3IgKz0gOCwgdDsKICB9CiAgc2tpcCh0KSB7CiAgICB0aGlzLmNoZWNrQm91bmRzKHQpLCB0aGlzLmN1cnNvciArPSB0OwogIH0KICBzZWVrKHQpIHsKICAgIGlmICh0IDwgMCB8fCB0ID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihgU2VlayBwb3NpdGlvbiAke3R9IG91dCBvZiBib3VuZHMgKDAtJHt0aGlzLmxlbmd0aH0pYCk7CiAgICB0aGlzLmN1cnNvciA9IHQ7CiAgfQogIGdldCBwb3NpdGlvbigpIHsKICAgIHJldHVybiB0aGlzLmN1cnNvcjsKICB9CiAgY2hlY2tCb3VuZHModCkgewogICAgaWYgKHRoaXMuY3Vyc29yICsgdCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWFkIGRhdGEgc3RyZWFtLiBPdmVyZmxvdy4gTGVuZ3RoPSR7dGhpcy5sZW5ndGh9IGN1cnNvcj0ke3RoaXMuY3Vyc29yfSB0cmllZCB0byByZWFkPSR7dH0gYnl0ZXNgKTsKICB9Cn0KY2xhc3MgZCB7CiAgY29uc3RydWN0b3IodCwgZSwgcikgewogICAgcyh0aGlzLCAiciIpOwogICAgcyh0aGlzLCAiZyIpOwogICAgcyh0aGlzLCAiYiIpOwogICAgdGhpcy5yID0gdCwgdGhpcy5nID0gZSwgdGhpcy5iID0gcjsKICB9Cn0KdmFyIEwgPSAoKGEpID0+IChhLk9DQ1VQSUVEID0gIm9jY3VwaWVkIiwgYS5GUkVFID0gImZyZWUiLCBhLkFMTCA9ICJhbGwiLCBhKSkoTCB8fCB7fSksIEMgPSAoKGEpID0+IChhLkNFTExfQ09MT1IgPSAiY2VsbENvbG9yIiwgYS5aX0FYSVNfQ09MT1IgPSAiekF4aXNDb2xvciIsIGEuUFJPQkFCSUxJVFlfQ09MT1IgPSAicHJvYmFiaWxpdHlDb2xvciIsIGEpKShDIHx8IHt9KTsKY2xhc3MgRSB7CiAgY29uc3RydWN0b3IodCkgewogICAgcyh0aGlzLCAicmVzb2x1dGlvbiIpOwogICAgcyh0aGlzLCAiY29sb3IiKTsKICAgIHModGhpcywgIm9wYWNpdHkiKTsKICAgIHModGhpcywgInZveGVsUmVuZGVyTW9kZSIpOwogICAgcyh0aGlzLCAicm9vdE5vZGUiLCBudWxsKTsKICAgIHModGhpcywgInRyZWVEZXB0aCIsIDE2KTsKICAgIHModGhpcywgInRyZWVNYXhLZXlWYWwiLCAzMjc2OCk7CiAgICBzKHRoaXMsICJCSU5BUllfVU5BTExPQ0FURUQiLCAwKTsKICAgIHModGhpcywgIkJJTkFSWV9MRUFGX0ZSRUUiLCAxKTsKICAgIHModGhpcywgIkJJTkFSWV9MRUFGX09DQ1VQSUVEIiwgMik7CiAgICBzKHRoaXMsICJCSU5BUllfSEFTX0NISUxEUkVOIiwgMyk7CiAgICBzKHRoaXMsICJCSU5BUllfQ0hJTERfQlVJTERfVEFCTEUiLCB7IFt0aGlzLkJJTkFSWV9MRUFGX0ZSRUVdOiAodCkgPT4gewogICAgICB0LnZhbHVlID0gdGhpcy5kZWZhdWx0RnJlZVZhbHVlOwogICAgfSwgW3RoaXMuQklOQVJZX0xFQUZfT0NDVVBJRURdOiAodCkgPT4gewogICAgICB0LnZhbHVlID0gdGhpcy5kZWZhdWx0T2NjdXBpZWRWYWx1ZTsKICAgIH0sIFt0aGlzLkJJTkFSWV9IQVNfQ0hJTERSRU5dOiAodCkgPT4gewogICAgICB0LnZhbHVlID0gbnVsbDsKICAgIH0gfSk7CiAgICBzKHRoaXMsICJGQUNFUyIsIFt7IG5vcm1hbDogWy0xLCAwLCAwXSwgdmVydGljZXM6IFtbMCwgMSwgMF0sIFswLCAwLCAwXSwgWzAsIDEsIDFdLCBbMCwgMCwgMV1dLCBjaGlsZEluZGV4OiBbMSwgMywgNSwgN10gfSwgeyBub3JtYWw6IFsxLCAwLCAwXSwgdmVydGljZXM6IFtbMSwgMSwgMV0sIFsxLCAwLCAxXSwgWzEsIDEsIDBdLCBbMSwgMCwgMF1dLCBjaGlsZEluZGV4OiBbMCwgMiwgNCwgNl0gfSwgeyBub3JtYWw6IFswLCAtMSwgMF0sIHZlcnRpY2VzOiBbWzEsIDAsIDFdLCBbMCwgMCwgMV0sIFsxLCAwLCAwXSwgWzAsIDAsIDBdXSwgY2hpbGRJbmRleDogWzIsIDMsIDYsIDddIH0sIHsgbm9ybWFsOiBbMCwgMSwgMF0sIHZlcnRpY2VzOiBbWzAsIDEsIDFdLCBbMSwgMSwgMV0sIFswLCAxLCAwXSwgWzEsIDEsIDBdXSwgY2hpbGRJbmRleDogWzAsIDEsIDQsIDVdIH0sIHsgbm9ybWFsOiBbMCwgMCwgLTFdLCB2ZXJ0aWNlczogW1sxLCAwLCAwXSwgWzAsIDAsIDBdLCBbMSwgMSwgMF0sIFswLCAxLCAwXV0sIGNoaWxkSW5kZXg6IFs0LCA1LCA2LCA3XSB9LCB7IG5vcm1hbDogWzAsIDAsIDFdLCB2ZXJ0aWNlczogW1swLCAwLCAxXSwgWzEsIDAsIDFdLCBbMCwgMSwgMV0sIFsxLCAxLCAxXV0sIGNoaWxkSW5kZXg6IFswLCAxLCAyLCAzXSB9XSk7CiAgICBzKHRoaXMsICJDVUJFX1ZFUlRJQ0VTIiwgW1swLCAwLCAwXSwgWzEsIDAsIDBdLCBbMSwgMSwgMF0sIFswLCAxLCAwXSwgWzAsIDAsIDFdLCBbMSwgMCwgMV0sIFsxLCAxLCAxXSwgWzAsIDEsIDFdXSk7CiAgICBzKHRoaXMsICJFREdFUyIsIFtbMCwgMV0sIFsxLCAyXSwgWzIsIDNdLCBbMywgMF0sIFs0LCA1XSwgWzUsIDZdLCBbNiwgN10sIFs3LCA0XSwgWzAsIDRdLCBbMSwgNV0sIFsyLCA2XSwgWzMsIDddXSk7CiAgICBzKHRoaXMsICJub2RlU2l6ZVRhYmxlIik7CiAgICBzKHRoaXMsICJkZWZhdWx0T2NjdXBpZWRWYWx1ZSIsIDEpOwogICAgcyh0aGlzLCAiZGVmYXVsdEZyZWVWYWx1ZSIsIC0xKTsKICAgIHRoaXMucmVzb2x1dGlvbiA9IHQucmVzb2x1dGlvbiA/PyAxLCB0aGlzLmNvbG9yID0gdC5jb2xvciA/PyBuZXcgZCgwLCAyNTUsIDApLCB0aGlzLm9wYWNpdHkgPSB0Lm9wYWNpdHkgPz8gMSwgdGhpcy52b3hlbFJlbmRlck1vZGUgPSB0LnZveGVsUmVuZGVyTW9kZSA/PyBMLk9DQ1VQSUVELCB0aGlzLnRyZWVEZXB0aCA9IHQudHJlZURlcHRoID8/IDE2LCB0aGlzLm5vZGVTaXplVGFibGUgPSBuZXcgQXJyYXkodGhpcy50cmVlRGVwdGgpOwogICAgbGV0IGUgPSB0aGlzLnJlc29sdXRpb247CiAgICBmb3IgKGxldCByID0gdGhpcy50cmVlRGVwdGggLSAxOyByID49IDA7IC0tcikgdGhpcy5ub2RlU2l6ZVRhYmxlW3JdID0gZSwgZSAqPSAyOwogIH0KICBjb21wdXRlQ29vcmRGcm9tS2V5KHQpIHsKICAgIHJldHVybiB0Lm1hcCgoZSkgPT4gdGhpcy5yZXNvbHV0aW9uICogKGUgLSB0aGlzLnRyZWVNYXhLZXlWYWwpKTsKICB9CiAgY29tcHV0ZUtleUZyb21DaGlsZElkeCh0LCBlLCByKSB7CiAgICBjb25zdCBvID0gMSA8PCB0aGlzLnRyZWVEZXB0aCAtIHIgLSAxOwogICAgcmV0dXJuIFtlWzBdICsgKDEgJiB0ID8gbyA6IDApLCBlWzFdICsgKDIgJiB0ID8gbyA6IDApLCBlWzJdICsgKDQgJiB0ID8gbyA6IDApXTsKICB9CiAgbmV3Tm9kZSgpIHsKICAgIHJldHVybiBuZXcgTigpOwogIH0KICByZWFkQmluYXJ5KHQpIHsKICAgIHRoaXMucm9vdE5vZGUgIT09IG51bGwgJiYgKHRoaXMucm9vdE5vZGUgPSBudWxsKSwgdGhpcy5yb290Tm9kZSA9IHRoaXMubmV3Tm9kZSgpOwogICAgbGV0IGUgPSBuZXcgZih0LCAhMCksIHIgPSBbXTsKICAgIGZvciAoci5wdXNoKHRoaXMucm9vdE5vZGUpOyByLmxlbmd0aCA+IDA7ICkgewogICAgICBsZXQgbyA9IHIucG9wKCk7CiAgICAgIGNvbnN0IGggPSBlLnJlYWRVaW50MTYoKTsKICAgICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgY29uc3QgbiA9IChoICYgMyA8PCAyICogaSkgPj4gMiAqIGk7CiAgICAgICAgaWYgKG4gIT09IHRoaXMuQklOQVJZX1VOQUxMT0NBVEVEKSB7CiAgICAgICAgICBsZXQgbCA9IHRoaXMubmV3Tm9kZSgpOwogICAgICAgICAgdGhpcy5CSU5BUllfQ0hJTERfQlVJTERfVEFCTEVbbl0uYmluZCh0aGlzKShsKSwgbyA9PSBudWxsIHx8IG8uY3JlYXRlQ2hpbGROb2RlQXQobCwgaSksIG4gPT09IHRoaXMuQklOQVJZX0hBU19DSElMRFJFTiAmJiByLnB1c2gobCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIHJlYWQodCkgewogICAgdGhpcy5yb290Tm9kZSAhPT0gbnVsbCAmJiAodGhpcy5yb290Tm9kZSA9IG51bGwpLCB0aGlzLnJvb3ROb2RlID0gdGhpcy5uZXdOb2RlKCk7CiAgICBsZXQgZSA9IG5ldyBmKHQsICEwKSwgciA9IFtdOwogICAgZm9yIChyLnB1c2godGhpcy5yb290Tm9kZSk7IHIubGVuZ3RoID4gMDsgKSB7CiAgICAgIGxldCBvID0gci5wb3AoKTsKICAgICAgdGhpcy5yZWFkTm9kZURhdGEoZSwgbyk7CiAgICAgIGNvbnN0IGggPSBlLnJlYWRVaW50OCgpOwogICAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyBpLS0pCiAgICAgICAgaWYgKGggJiAxIDw8IGkpIHsKICAgICAgICAgIGxldCBuID0gdGhpcy5uZXdOb2RlKCk7CiAgICAgICAgICBuLnZhbHVlID0gbnVsbCwgby5jcmVhdGVDaGlsZE5vZGVBdChuLCBpKSwgci5wdXNoKG4pOwogICAgICAgIH0KICAgIH0KICB9CiAgcmVhZE5vZGVEYXRhKHQsIGUpIHsKICAgIGNvbnNvbGUuZXJyb3IoIk5vdCBpbXBsZW1lbnRlZCIpOwogIH0KICB0cmF2ZXJzZUxlYXZlcyh0KSB7CiAgICBsZXQgZSA9IFtdOwogICAgZm9yIChlLnB1c2goeyBub2RlOiB0aGlzLnJvb3ROb2RlLCBkZXB0aDogMCwga2V5OiBbMCwgMCwgMF0gfSk7IGUubGVuZ3RoID4gMDsgKSB7CiAgICAgIGxldCByID0gZS5wb3AoKTsKICAgICAgaWYgKHIubm9kZS5pc0xlYWZOb2RlKCkpIHQoci5ub2RlLCByLmtleSwgci5kZXB0aCAtIDEpOwogICAgICBlbHNlIGZvciAobGV0IG8gPSAwOyBvIDwgODsgKytvKSBpZiAoci5ub2RlLmhhc0NoaWxkQXQobykpIHsKICAgICAgICBjb25zdCBoID0gdGhpcy5jb21wdXRlS2V5RnJvbUNoaWxkSWR4KG8sIHIua2V5LCByLmRlcHRoKTsKICAgICAgICBlLnB1c2goeyBub2RlOiByLm5vZGUuZ2V0Q2hpbGRBdChvKSwgZGVwdGg6IHIuZGVwdGggKyAxLCBrZXk6IGggfSk7CiAgICAgIH0KICAgIH0KICB9CiAgb2J0YWluQ29sb3IodCwgZSwgciwgbykgewogICAgcmV0dXJuIHRoaXMuY29sb3I7CiAgfQogIGNoZWNrT2NjdXBpZWQodCkgewogICAgcmV0dXJuIHQudmFsdWUgIT09IC0xOwogIH0KICBpbnNlcnRGYWNlKHQsIGUsIHIsIG8sIGgpIHsKICAgIGNvbnN0IGkgPSB0LnZlcnRpY2VzLmxlbmd0aCAvIDM7CiAgICBlLnZlcnRpY2VzLmZvckVhY2goKGwpID0+IHsKICAgICAgdC52ZXJ0aWNlcy5wdXNoKHJbMF0gKyBsWzBdICogbywgclsxXSArIGxbMV0gKiBvLCByWzJdICsgbFsyXSAqIG8pOwogICAgfSk7CiAgICBjb25zdCBuID0gW2guciwgaC5nLCBoLmJdOwogICAgdC5jb2xvcnMucHVzaCguLi5uLCAuLi5uLCAuLi5uLCAuLi5uKSwgdC5ub3JtYWxzLnB1c2goLi4uZS5ub3JtYWwsIC4uLmUubm9ybWFsLCAuLi5lLm5vcm1hbCwgLi4uZS5ub3JtYWwpLCB0LmluZGljZXMucHVzaChpLCBpICsgMSwgaSArIDIsIGkgKyAyLCBpICsgMSwgaSArIDMpOwogIH0KICBidWlsZEZhY2VzKCkgewogICAgY29uc29sZS5hc3NlcnQodGhpcy5yb290Tm9kZSAhPT0gbnVsbCwgIk5vIHRyZWUgZGF0YSIpOwogICAgY29uc3QgdCA9IHsgTWVzaERhdGE6IHsgdmVydGljZXM6IFtdLCBpbmRpY2VzOiBbXSwgbm9ybWFsczogW10sIGNvbG9yczogW10gfSwgTGluZURhdGE6IHsgcG9zaXRpb25zOiBbXSB9IH07CiAgICBsZXQgZSA9IDEgLyAwLCByID0gLTEgLyAwOwogICAgcmV0dXJuIHRoaXMudHJhdmVyc2VMZWF2ZXMoKG8sIGgsIGkpID0+IHsKICAgICAgY29uc3QgbiA9IHRoaXMuY29tcHV0ZUNvb3JkRnJvbUtleShoKTsKICAgICAgblsyXSA8IGUgJiYgKGUgPSBuWzJdKSwgblsyXSA+IHIgJiYgKHIgPSBuWzJdKTsKICAgIH0pLCB0aGlzLnRyYXZlcnNlTGVhdmVzKChvLCBoLCBpKSA9PiB7CiAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbXB1dGVDb29yZEZyb21LZXkoaCksIGwgPSB0aGlzLm5vZGVTaXplVGFibGVbaV0sIGMgPSB0aGlzLmNoZWNrT2NjdXBpZWQobyk7CiAgICAgIGlmICghYyAmJiB0aGlzLnZveGVsUmVuZGVyTW9kZSA9PT0gTC5PQ0NVUElFRCB8fCBjICYmIHRoaXMudm94ZWxSZW5kZXJNb2RlID09PSBMLkZSRUUpIHJldHVybjsKICAgICAgY29uc3QgdSA9IHRoaXMuQ1VCRV9WRVJUSUNFUy5tYXAoKHApID0+IFtuWzBdICsgcFswXSAqIGwsIG5bMV0gKyBwWzFdICogbCwgblsyXSArIHBbMl0gKiBsXSk7CiAgICAgIHRoaXMuRURHRVMuZm9yRWFjaCgoW3AsIEFdKSA9PiB7CiAgICAgICAgdC5MaW5lRGF0YS5wb3NpdGlvbnMucHVzaCguLi51W3BdKSwgdC5MaW5lRGF0YS5wb3NpdGlvbnMucHVzaCguLi51W0FdKTsKICAgICAgfSksIHRoaXMuRkFDRVMuZm9yRWFjaCgocCkgPT4gewogICAgICAgIHRoaXMuaW5zZXJ0RmFjZSh0Lk1lc2hEYXRhLCBwLCBuLCBsLCB0aGlzLm9idGFpbkNvbG9yKG8sIG4sIGUsIHIpKTsKICAgICAgfSk7CiAgICB9KSwgeyBNZXNoRGF0YTogeyB2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheSh0Lk1lc2hEYXRhLnZlcnRpY2VzKSwgaW5kaWNlczogbmV3IFVpbnQzMkFycmF5KHQuTWVzaERhdGEuaW5kaWNlcyksIG5vcm1hbHM6IG5ldyBGbG9hdDMyQXJyYXkodC5NZXNoRGF0YS5ub3JtYWxzKSwgY29sb3JzOiBuZXcgVWludDhBcnJheSh0Lk1lc2hEYXRhLmNvbG9ycykgfSwgTGluZURhdGE6IHsgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHQuTGluZURhdGEucG9zaXRpb25zKSB9IH07CiAgfQp9CmNsYXNzIHcgZXh0ZW5kcyBFIHsKICBjb25zdHJ1Y3RvcihlKSB7CiAgICBlLmNvbG9yTW9kZSA9IGUuY29sb3JNb2RlID8/IEMuWl9BWElTX0NPTE9SOwogICAgc3VwZXIoZSk7CiAgICBzKHRoaXMsICJvY2N1cGFuY3lUaHJlc2hvbGQiKTsKICAgIHModGhpcywgImNvbG9yTW9kZSIpOwogICAgcyh0aGlzLCAiY29sb3JGYWN0b3IiKTsKICAgIHRoaXMuZGVmYXVsdE9jY3VwaWVkVmFsdWUgPSAxLCB0aGlzLmRlZmF1bHRGcmVlVmFsdWUgPSAtMSwgdGhpcy5vY2N1cGFuY3lUaHJlc2hvbGQgPSBlLm9jY3VwYW5jeVRocmVzaG9sZCA/PyAxZS03LCB0aGlzLmNvbG9yTW9kZSA9IGUuY29sb3JNb2RlLCB0aGlzLmNvbG9yRmFjdG9yID0gZS5jb2xvckZhY3RvciA/PyAwLjg7CiAgfQogIHJlYWROb2RlRGF0YShlLCByKSB7CiAgICByLnZhbHVlID0gZS5yZWFkRmxvYXQzMigpOwogIH0KICBvYnRhaW5Db2xvcihlLCByLCBvLCBoKSB7CiAgICBpZiAodGhpcy5jb2xvck1vZGUgPT09IEMuUFJPQkFCSUxJVFlfQ09MT1IpIHsKICAgICAgY29uc3QgaSA9IGUuZ2V0T2NjdXBhbmN5KCk7CiAgICAgIHJldHVybiBuZXcgZCgyNTUgKiAoMSAtIGkpLCAyNTUgKiBpLCAwKTsKICAgIH0KICAgIHJldHVybiB0aGlzLmNvbG9yTW9kZSA9PT0gQy5aX0FYSVNfQ09MT1IgPyB0aGlzLmNhbGNaQXhpc0NvbG9yKHJbMl0sIG8sIGgpIDogdGhpcy5jb2xvcjsKICB9CiAgY2FsY1pBeGlzQ29sb3IoZSwgciwgbykgewogICAgbGV0IGgsIGksIG4sIGwsIGMgPSAxLCB1ID0gKDEgLSBNYXRoLm1pbihNYXRoLm1heCgoZSAtIHIpIC8gKG8gLSByKSwgMCksIDEpKSAqIHRoaXMuY29sb3JGYWN0b3I7CiAgICBzd2l0Y2ggKHUgLT0gTWF0aC5mbG9vcih1KSwgdSAqPSA2LCBoID0gTWF0aC5mbG9vcih1KSwgbCA9IHUgLSBoLCAxICYgaCB8fCAobCA9IDEgLSBsKSwgaSA9IDAgKiBjLCBuID0gYyAqICgxIC0gMSAqIGwpLCBjICo9IDI1NSwgaSAqPSAyNTUsIG4gKj0gMjU1LCBoKSB7CiAgICAgIGNhc2UgNjoKICAgICAgY2FzZSAwOgogICAgICAgIHJldHVybiBuZXcgZChjLCBuLCBpKTsKICAgICAgY2FzZSAxOgogICAgICAgIHJldHVybiBuZXcgZChuLCBjLCBpKTsKICAgICAgY2FzZSAyOgogICAgICAgIHJldHVybiBuZXcgZChpLCBjLCBuKTsKICAgICAgY2FzZSAzOgogICAgICAgIHJldHVybiBuZXcgZChpLCBuLCBjKTsKICAgICAgY2FzZSA0OgogICAgICAgIHJldHVybiBuZXcgZChuLCBpLCBjKTsKICAgICAgY2FzZSA1OgogICAgICAgIHJldHVybiBuZXcgZChjLCBpLCBuKTsKICAgICAgZGVmYXVsdDoKICAgICAgICByZXR1cm4gbmV3IGQoMjU1LCAxMjcuNSwgMTI3LjUpOwogICAgfQogIH0KICBjaGVja09jY3VwaWVkKGUpIHsKICAgIHJldHVybiBlLnZhbHVlID49IHRoaXMub2NjdXBhbmN5VGhyZXNob2xkOwogIH0KfQpjbGFzcyBPIGV4dGVuZHMgdyB7CiAgY29uc3RydWN0b3IoZSkgewogICAgZS5jb2xvck1vZGUgPSBlLmNvbG9yTW9kZSA/PyBDLkNFTExfQ09MT1I7CiAgICBzdXBlcihlKTsKICAgIHModGhpcywgInVzZU93bkNvbG9yIik7CiAgICB0aGlzLnVzZU93bkNvbG9yID0gQy5DRUxMX0NPTE9SID09PSBlLmNvbG9yTW9kZTsKICB9CiAgcmVhZE5vZGVEYXRhKGUsIHIpIHsKICAgIHIudmFsdWUgPSBlLnJlYWRGbG9hdDMyKCksIHIuY29sb3IgPSBuZXcgZChlLnJlYWRVaW50OCgpLCBlLnJlYWRVaW50OCgpLCBlLnJlYWRVaW50OCgpKTsKICB9CiAgb2J0YWluQ29sb3IoZSwgciwgbywgaCkgewogICAgcmV0dXJuIHRoaXMudXNlT3duQ29sb3IgPyBlLmNvbG9yIDogc3VwZXIub2J0YWluQ29sb3IoZSwgciwgbywgaCk7CiAgfQp9CnNlbGYub25tZXNzYWdlID0gKGEpID0+IHsKICBjb25zdCB7IG1lc3NhZ2U6IHQsIG9wdGlvbnM6IGUgfSA9IGEuZGF0YTsKICBsZXQgcjsKICBpZiAodC5iaW5hcnkpIHIgPSBuZXcgRShlKSwgci5yZWFkQmluYXJ5KHQuZGF0YSk7CiAgZWxzZSB7CiAgICBjb25zdCBvID0geyBPY1RyZWU6IHcsIENvbG9yT2NUcmVlOiBPIH07CiAgICB0LmlkIGluIG8gJiYgKHIgPSBuZXcgb1t0LmlkXShlKSwgci5yZWFkKHQuZGF0YSkpOwogIH0KICBpZiAocikgewogICAgY29uc3QgbyA9IHIuYnVpbGRGYWNlcygpOwogICAgc2VsZi5wb3N0TWVzc2FnZShvLCB7IHRyYW5zZmVyOiBbby5NZXNoRGF0YS52ZXJ0aWNlcy5idWZmZXIsIG8uTWVzaERhdGEubm9ybWFscy5idWZmZXIsIG8uTWVzaERhdGEuY29sb3JzLmJ1ZmZlciwgby5NZXNoRGF0YS5pbmRpY2VzLmJ1ZmZlciwgby5MaW5lRGF0YS5wb3NpdGlvbnMuYnVmZmVyXSB9KTsKICB9Cn07Cg==",
			import.meta.url).href;
		this.worker = new Worker(a, {
			type: "module"
		}), this.worker.onmessage = l => {
			const c = l.data;
			this.processGeometryData(c)
		}
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		this.loadOcTree(s)
	}
	loadOcTree(s) {
		this.frameId = s.header.frame_id;
		const a = Object.assign({
			resolution: s.resolution
		}, this.options);
		this.worker.postMessage({
			message: s,
			options: a
		}, {
			transfer: [s.data.buffer]
		})
	}
	buildGeometry(s) {
		const {
			MeshData: a,
			LineData: l
		} = s, {
			vertices: c,
			normals: d,
			colors: f,
			indices: m
		} = a, {
			positions: g
		} = l, v = new BufferGeometry, y = new MeshBasicMaterial({
			color: 16777215,
			vertexColors: !0,
			transparent: this.opacity < 1,
			opacity: this.opacity,
			side: DoubleSide
		});
		v.setAttribute("position", new Float32BufferAttribute(c, 3)), v.setAttribute("normal",
				new Float32BufferAttribute(d, 3)), v.setAttribute("color", new Uint8BufferAttribute(f, 3, !0)), v
			.setIndex(new Uint32BufferAttribute(m, 1));
		const b = new Mesh(v, y),
			C = new BufferGeometry;
		C.setAttribute("position", new Float32BufferAttribute(g, 3));
		const _ = new LineBasicMaterial({
				color: 0,
				linewidth: 2
			}),
			S = new LineSegments(C, _),
			w = new Object3D;
		return w.add(b), w.add(S), w
	}
	processGeometryData(s) {
		if (this.rosTopic === void 0) return;
		const a = this.sceneNode;
		a && (a.dispose(), this.viewer.removeObject(a)), this.currentMap = this.buildGeometry(s), this.sceneNode =
			new SceneNode({
				frameId: this.frameId,
				tfClient: this.tfClient,
				object: this.currentMap,
				pose: this.offsetPose,
				viewer: this.viewer,
				realMode: this.readMode,
				clickable: !0
			}), this.viewer.addObject(this.sceneNode)
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe(), this.currentMap && this.sceneNode && (this.sceneNode.dispose(), this.sceneNode.remove(
			this.currentMap), this.viewer.removeObject(this.sceneNode), this.sceneNode = void 0)
	}
	setOptions(s) {
		s.opacity && (this.options.opacity = s.opacity), s.colorMode && (this.options.colorMode = s.colorMode), s
			.voxelRenderMode && (this.options.voxelRenderMode = s.voxelRenderMode), s.topic !== void 0 && this
			.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this.hide(), this.show()))
	}
}
class Urdf {
	constructor(s) {
		u(this, "ros"), u(this, "viewer"), u(this, "children", []), this.ros = s.ros, this.viewer = s.viewer;
		const a = s.urdfModel,
			l = s.tfClient,
			c = s.tfPrefix ?? "",
			d = a.links;
		for (const f in d) {
			const m = d[f];
			for (let g = 0; g < m.visuals.length; g++) {
				const v = m.visuals[g];
				if (v && v.geometry) {
					const y = c + "/" + m.name;
					let b = null;
					if (v.material && v.material.color) {
						const C = v.material && v.material.color;
						b = makeColorMaterial(C.r, C.g, C.b, C.a)
					}
					if (v.geometry.type === URDF_MESH) {
						const C = v.geometry.filename;
						C && this.ros.fetchAsset(C).then(_ => {
							if (_) {
								const S = C.slice(-3).toLowerCase();
								if (MeshLoader.loaders[S]) {
									const w = new MeshResource({
										fileType: S,
										data: _,
										material: b
									});
									v.geometry.scale && w.scale.copy(v.geometry.scale);
									const T = new SceneNode({
										frameId: y,
										viewer: this.viewer,
										pose: v.origin,
										tfClient: l,
										object: w
									});
									T.name = v.name, this.viewer.addObject(T), this.children.push(T)
								} else console.warn("Could not load geometry mesh: " + C)
							}
						})
					} else {
						const C = this.createShapeMesh(v),
							_ = new SceneNode({
								frameId: y,
								viewer: this.viewer,
								pose: v.origin,
								tfClient: l,
								object: C
							});
						_.name = v.name, this.viewer.addObject(_), this.children.push(_)
					}
				}
			}
		}
	}
	createShapeMesh(s) {
		const a = makeColorMaterial(0, 0, 0, 1);
		let l;
		switch (s.geometry.type) {
			case URDF_BOX:
				const c = s.geometry.dimension,
					d = new BoxGeometry(c.x, c.y, c.z);
				l = new Mesh(d, a);
				break;
			case URDF_CYLINDER:
				const f = s.geometry.radius,
					m = s.geometry.length,
					g = new CylinderGeometry(f, f, m, 16, 1, !1);
				l = new Mesh(g, a), l.quaternion.setFromAxisAngle(new Vector3$1(1, 0, 0), .5 * Math.PI);
				break;
			case URDF_SPHERE:
				const v = new SphereGeometry(s.geometry.radius, 16);
				l = new Mesh(v, a)
		}
		return l
	}
	dispose() {
		for (const s of this.children) s.dispose(), this.viewer.removeObject(s)
	}
}
class UrdfClient {
	constructor(s) {
		u(this, "param"), u(this, "urdfFileUrl"), u(this, "urdfFileStr"), u(this, "ros"), u(this, "tfClient"), u(
				this, "viewer"), u(this, "tfPrefix"), u(this, "topicName"), u(this, "urdf"), this.ros = s.ros, this
			.tfClient = s.tfClient, this.viewer = s.viewer, this.param = s.param ?? "/robot_description", this
			.topicName = s.topic ?? "/robot_description", this.urdfFileUrl = s.urdfFileUrl ?? "", this.urdfFileStr =
			s.urdfFileStr, this.tfPrefix = s.tfPrefix ?? "", s.defaultHide || this.show()
	}
	loadUrdf(s) {
		const a = new UrdfModel({
			string: s
		});
		this.urdf = new Urdf({
			ros: this.ros,
			viewer: this.viewer,
			urdfModel: a,
			tfClient: this.tfClient,
			tfPrefix: this.tfPrefix
		})
	}
	dispose() {
		this.urdf && this.urdf.dispose()
	}
	show() {
		this.urdfFileStr ? this.loadUrdf(this.urdfFileStr) : this.urdfFileUrl.toLowerCase().endsWith(".urdf") ?
			fetch(this.urdfFileUrl).then(s => {
				if (s.ok) return s.text();
				throw new Error(
					`Failed to load url '${this.urdfFileUrl}' with error code ${s.status} : ${s.statusText}.`
					)
			}).then(s => {
				this.loadUrdf(s)
			}) : this.ros.getServerInfo(s => {
				if (s.metadata)
					if (s.metadata.ROS_DISTRO === "noetic") new Param({
						ros: this.ros,
						name: this.param
					}).get(a => {
						this.loadUrdf(a)
					});
					else {
						const a = new Topic({
							ros: this.ros,
							name: this.topicName
						});
						a.subscribe(l => {
							a.unsubscribe(), this.loadUrdf(l.data)
						})
					}
			})
	}
	hide() {
		this.dispose()
	}
	setOptions(s) {}
}
class Marker extends Object3D {
	constructor(s) {
		super(), u(this, "msgScale"), u(this, "msgColor"), u(this, "msgMesh"), u(this, "ros"), this
			.frustumCulled = !1, this.ros = s.ros;
		const a = s.message;
		a.scale ? this.msgScale = [a.scale.x, a.scale.y, a.scale.z] : this.msgScale = [1, 1, 1], this.msgColor = a
			.color, this.msgMesh = void 0, this.setPose(a.pose);
		const l = makeColorMaterial(this.msgColor.r, this.msgColor.g, this.msgColor.b, this.msgColor.a);
		switch (a.type) {
			case MARKER_ARROW:
				let c, d = a.scale.x,
					f = .23 * d,
					m = a.scale.y,
					g = .5 * m,
					v = null;
				if (a.points.length === 2) {
					v = new Vector3$1(a.points[0].x, a.points[0].y, a.points[0].z);
					const be = new Vector3$1(a.points[1].x, a.points[1].y, a.points[1].z);
					c = v.clone().negate().add(be), d = c.length(), m = a.scale.y, g = a.scale.x, a.scale.z !== 0 &&
						(f = a.scale.z)
				}
				this.add(new Arrow({
					direction: c,
					origin: v,
					length: d,
					headLength: f,
					shaftDiameter: g,
					headDiameter: m,
					material: l
				}));
				break;
			case MARKER_CUBE:
				const y = new BoxGeometry(a.scale.x, a.scale.y, a.scale.z),
					b = new Mesh(y, l);
				b.frustumCulled = !1, this.add(b);
				break;
			case MARKER_SPHERE:
				const C = new SphereGeometry(.5),
					_ = new Mesh(C, l);
				_.scale.x = a.scale.x, _.scale.y = a.scale.y, _.scale.z = a.scale.z, _.frustumCulled = !1, this.add(
					_);
				break;
			case MARKER_CYLINDER:
				const S = new CylinderGeometry(.5, .5, 1, 16, 1, !1),
					w = new Mesh(S, l);
				w.quaternion.setFromAxisAngle(new Vector3$1(1, 0, 0), .5 * Math.PI), w.scale.set(a.scale.x, a.scale
					.z, a.scale.y), w.frustumCulled = !1, this.add(w);
				break;
			case MARKER_LINE_STRIP:
				const T = new Float32Array(3 * a.points.length),
					A = new Float32Array(3 * a.points.length);
				for (let be = 0; be < a.points.length; be++) T[3 * be] = a.points[be].x, T[3 * be + 1] = a.points[
					be].y, T[3 * be + 2] = a.points[be].z, a.colors.length === a.points.length && (A[3 * be] = a
					.colors[be].r, A[3 * be + 1] = a.colors[be].g, A[3 * be + 2] = a.colors[be].b);
				const k = new BufferGeometry;
				k.setAttribute("position", new BufferAttribute(T, 3)), a.colors.length === a.points.length && k
					.setAttribute("color", new BufferAttribute(A, 3));
				const M = new LineBasicMaterial({
						linewidth: a.scale.x,
						vertexColors: a.colors.length === a.points.length
					}),
					D = new Line(k, M);
				D.frustumCulled = !1, this.add(D);
				break;
			case MARKER_LINE_LIST:
				const F = new Float32Array(3 * a.points.length),
					R = new Float32Array(3 * a.points.length);
				for (let be = 0; be < a.points.length; be++) F[3 * be] = a.points[be].x, F[3 * be + 1] = a.points[
					be].y, F[3 * be + 2] = a.points[be].z, a.colors.length === a.points.length && (R[3 * be] = a
					.colors[be].r, R[3 * be + 1] = a.colors[be].g, R[3 * be + 2] = a.colors[be].b);
				const O = new BufferGeometry;
				O.setAttribute("position", new BufferAttribute(F, 3)), a.colors.length === a.points.length && O
					.setAttribute("color", new BufferAttribute(R, 3));
				const U = new LineBasicMaterial({
						linewidth: a.scale.x,
						vertexColors: a.colors.length === a.points.length
					}),
					V = new LineSegments(O, U);
				V.frustumCulled = !1, this.add(V);
				break;
			case MARKER_CUBE_LIST:
				const z = new Object3D;
				z.frustumCulled = !1;
				const j = a.points.length,
					ge = j === a.colors.length,
					me = Math.ceil(j / 1250);
				for (let be = 0; be < j; be += me) {
					const Me = new BoxGeometry(a.scale.x, a.scale.y, a.scale.z),
						Ve = ge ? makeColorMaterial(a.colors[be].r, a.colors[be].g, a.colors[be].b, a.colors[be]
						.a) : l,
						it = new Mesh(Me, Ve);
					it.position.x = a.points[be].x, it.position.y = a.points[be].y, it.position.z = a.points[be].z,
						it.frustumCulled = !1, z.add(it)
				}
				this.add(z);
				break;
			case MARKER_SPHERE_LIST:
				const he = new Object3D;
				he.frustumCulled = !1;
				const ce = a.points.length,
					ae = ce === a.colors.length,
					fe = Math.ceil(ce / 1250);
				for (let be = 0; be < ce; be += fe) {
					const Me = new SphereGeometry(.5, 8, 8),
						Ve = ae ? makeColorMaterial(a.colors[be].r, a.colors[be].g, a.colors[be].b, a.colors[be]
						.a) : l,
						it = new Mesh(Me, Ve);
					it.scale.x = a.scale.x, it.scale.y = a.scale.y, it.scale.z = a.scale.z, it.position.x = a
						.points[be].x, it.position.y = a.points[be].y, it.position.z = a.points[be].z, it
						.frustumCulled = !1, he.add(it)
				}
				this.add(he);
				break;
			case MARKER_POINTS:
				const q = new Float32Array(3 * a.points.length),
					le = new Float32Array(3 * a.points.length);
				for (let be = 0; be < a.points.length; be++) q[3 * be] = a.points[be].x, q[3 * be + 1] = a.points[
					be].y, q[3 * be + 2] = a.points[be].z, a.colors.length === a.points.length && (le[3 * be] =
					a.colors[be].r, le[3 * be + 1] = a.colors[be].g, le[3 * be + 2] = a.colors[be].b);
				const de = new BufferGeometry;
				de.setAttribute("position", new BufferAttribute(q, 3)), a.colors.length === a.points.length && de
					.setAttribute("color", new BufferAttribute(le, 3));
				const _e = new PointsMaterial({
						size: a.scale.x,
						vertexColors: a.colors.length === a.points.length
					}),
					ke = new Points$1(de, _e);
				ke.frustumCulled = !1, this.add(ke);
				break;
			case MARKER_TEXT_VIEW_FACING:
				if (a.text.length > 0) {
					const be = this.msgColor,
						Me = document.createElement("canvas"),
						Ve = Me.getContext("2d"),
						it = 200,
						pt = "normal " + it + "px sans-serif";
					Ve.font = pt;
					const dt = Ve.measureText(a.text).width;
					Me.width = dt, Me.height = 1.5 * it, Ve.font = pt, Ve.fillStyle = "rgba(" + Math.round(255 * be
							.r) + ", " + Math.round(255 * be.g) + ", " + Math.round(255 * be.b) + ", " + be.a + ")",
						Ve.textAlign = "left", Ve.textBaseline = "middle", Ve.fillText(a.text, 0, Me.height / 2);
					const He = new Texture(Me);
					He.needsUpdate = !0;
					const Ae = new SpriteMaterial({
							map: He
						}),
						xe = new Sprite(Ae);
					xe.frustumCulled = !1;
					const ye = a.scale.x;
					xe.scale.set(dt / Me.height * ye, ye, 1), this.add(xe)
				}
				break;
			case MARKER_MESH_RESOURCE:
				let De = null;
				a.color.r === 0 && a.color.g === 0 && a.color.b === 0 && a.color.a === 0 || (De = l), this.msgMesh =
					a.mesh_resource, this.ros.fetchAsset(a.mesh_resource).then(be => {
						if (be) {
							const Me = a.mesh_resource.slice(-3).toLowerCase(),
								Ve = new MeshResource({
									data: be,
									fileType: Me,
									material: De
								});
							this.add(Ve)
						}
					});
				break;
			case MARKER_TRIANGLE_LIST:
				const Se = new TriangleList({
					material: l,
					vertices: a.points,
					colors: a.colors
				});
				Se.scale.set(a.scale.x, a.scale.y, a.scale.z), this.add(Se);
				break;
			default:
				console.error("Currently unsupported marker type: " + a.type)
		}
	}
	setPose(s) {
		this.position.set(s.position.x, s.position.y, s.position.z), this.quaternion.set(s.orientation.x, s
				.orientation.y, s.orientation.z, s.orientation.w), this.quaternion.normalize(), this
			.updateMatrixWorld()
	}
	update(s) {
		if (this.setPose(s.pose), s.color.r !== this.msgColor.r || s.color.g !== this.msgColor.g || s.color.b !==
			this.msgColor.b || s.color.a !== this.msgColor.a) {
			const l = makeColorMaterial(s.color.r, s.color.g, s.color.b, s.color.a);
			switch (s.type) {
				case MARKER_LINE_STRIP:
				case MARKER_LINE_LIST:
				case MARKER_POINTS:
					break;
				case MARKER_ARROW:
				case MARKER_CUBE:
				case MARKER_SPHERE:
				case MARKER_CYLINDER:
				case MARKER_TRIANGLE_LIST:
				case MARKER_TEXT_VIEW_FACING:
					this.traverse(d => {
						d instanceof Mesh && (d.material = l)
					});
					break;
				case MARKER_MESH_RESOURCE:
					let c = null;
					s.color.r === 0 && s.color.g === 0 && s.color.b === 0 && s.color.a === 0 || (c = l), this
						.traverse(d => {
							d instanceof Mesh && (d.material = c)
						});
					break;
				default:
					return !1
			}
			this.msgColor = s.color
		}
		const a = Math.abs(this.msgScale[0] - s.scale.x) > 1e-6 || Math.abs(this.msgScale[1] - s.scale.y) > 1e-6 ||
			Math.abs(this.msgScale[2] - s.scale.z) > 1e-6;
		switch (this.msgScale = [s.scale.x, s.scale.y, s.scale.z], s.type) {
			case MARKER_CUBE:
			case MARKER_SPHERE:
			case MARKER_CYLINDER:
			case MARKER_TEXT_VIEW_FACING:
				if (a) return !1;
				break;
			case MARKER_MESH_RESOURCE:
				if (s.mesh_resource !== this.msgMesh || a) return !1;
				break;
			case MARKER_ARROW:
			case MARKER_LINE_STRIP:
			case MARKER_LINE_LIST:
			case MARKER_CUBE_LIST:
			case MARKER_SPHERE_LIST:
			case MARKER_POINTS:
			case MARKER_TRIANGLE_LIST:
				return !1
		}
		return !0
	}
}
class MarkerClient extends EventEmitter {
	constructor(s) {
		super(), u(this, "readMode"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this,
				"processMessageBound"), u(this, "path"), u(this, "lifetime"), u(this, "topicName"), u(this,
				"rosTopic"), u(this, "markers"), u(this, "updatedTime"), this.readMode = s.realMode ?? !1, this
			.ros = s.ros, this.topicName = s.topic || "/marker", this.tfClient = s.tfClient, this.viewer = s.viewer,
			this.path = s.path || "/", this.lifetime = s.lifetime || 0, this.markers = {}, this.rosTopic = void 0,
			this.updatedTime = {}, this.processMessageBound = this.processMessage.bind(this), s.defaultHide || this
			.show()
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	checkTime(s) {
		if (new Date().getTime() - this.updatedTime[s] > this.lifetime) this.removeMarker(s), this.emit("change");
		else {
			const a = this;
			setTimeout(function() {
				a.checkTime(s)
			}, 100)
		}
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		const a = s.ns + s.id,
			l = this.markers[a];
		if (this.updatedTime[a] = new Date().getTime(), l ? this.removeMarker(a) : this.lifetime && this.checkTime(s
				.ns + s.id), s.action === 0) {
			const c = new Marker({
				message: s,
				ros: this.ros
			});
			this.markers[a] = new SceneNode({
				frameId: s.header.frame_id,
				viewer: this.viewer,
				tfClient: this.tfClient,
				realMode: this.readMode,
				object: c
			}), this.viewer.addObject(this.markers[a])
		}
		this.emit("change")
	}
	removeMarker(s) {
		const a = this.markers[s];
		a && (a.dispose(), this.viewer.removeObject(a), delete this.markers[s])
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe();
		for (const s in this.markers) this.removeMarker(s);
		this.markers = {}
	}
	setOptions(s) {
		s.topic !== void 0 && this.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this
		.hide(), this.show()))
	}
}
class MarkerArrayClient extends EventEmitter {
	constructor(s) {
		super(), u(this, "readMode"), u(this, "ros"), u(this, "tfClient"), u(this, "viewer"), u(this,
				"processMessageBound"), u(this, "path"), u(this, "topicName"), u(this, "rosTopic"), u(this,
				"markers"), this.readMode = s.realMode ?? !1, this.ros = s.ros, this.topicName = s.topic ||
			"/marker_array", this.tfClient = s.tfClient, this.viewer = s.viewer, this.path = s.path || "/", this
			.markers = {}, this.rosTopic = void 0, this.processMessageBound = this.processMessage.bind(this), s
			.defaultHide || this.show()
	}
	subscribe() {
		this.unsubscribe(), this.rosTopic = new Topic({
			ros: this.ros,
			name: this.topicName
		}), this.rosTopic.subscribe(this.processMessageBound)
	}
	processMessage(s) {
		s.markers.forEach(a => {
			const l = a.ns + a.id;
			if (a.action === 0) {
				let c = !1;
				if (l in this.markers && (c = this.markers[l].children[0].update(a), c || this.removeMarker(
						l)), !c) {
					const d = new Marker({
						message: a,
						ros: this.ros
					});
					this.markers[l] = new SceneNode({
						frameId: a.header.frame_id,
						viewer: this.viewer,
						tfClient: this.tfClient,
						realMode: this.readMode,
						object: d
					}), this.viewer.addObject(this.markers[l])
				}
			} else if (a.action === 1) console.warn(
				'Received marker message with deprecated action identifier "1"');
			else if (a.action === 2) this.removeMarker(l);
			else if (a.action === 3) {
				for (const c in this.markers) this.removeMarker(c);
				this.markers = {}
			} else console.warn('Received marker message with unknown action identifier "' + a.action + '"')
		}), this.emit("change")
	}
	unsubscribe() {
		this.rosTopic && (this.rosTopic.unsubscribe(this.processMessageBound), this.rosTopic = void 0)
	}
	removeMarker(s) {
		const a = this.markers[s];
		a && (a.dispose(), this.viewer.removeObject(a), delete this.markers[s])
	}
	show() {
		this.subscribe()
	}
	hide() {
		this.dispose()
	}
	dispose() {
		this.unsubscribe();
		for (const s in this.markers) this.removeMarker(s);
		this.markers = {}
	}
	setOptions(s) {
		s.topic !== void 0 && this.topicName !== s.topic && (this.topicName = s.topic, this.rosTopic && (this
		.hide(), this.show()))
	}
}
const ROS3D = Object.freeze(Object.defineProperty({
	__proto__: null,
	AppendPointCloud2,
	Arrow,
	Axes,
	AxesClient,
	Grid,
	GridClient,
	Image: Image$1,
	LaserScan,
	MARKER_ARROW,
	MARKER_CUBE,
	MARKER_CUBE_LIST,
	MARKER_CYLINDER,
	MARKER_LINE_LIST,
	MARKER_LINE_STRIP,
	MARKER_MESH_RESOURCE,
	MARKER_POINTS,
	MARKER_SPHERE,
	MARKER_SPHERE_LIST,
	MARKER_TEXT_VIEW_FACING,
	MARKER_TRIANGLE_LIST,
	Marker,
	MarkerArrayClient,
	MarkerClient,
	MeshLoader,
	MeshResource,
	OcTreeClient,
	OcTreeColorMode,
	OcTreeVoxelRenderMode,
	OccupancyGrid,
	OccupancyGridClient,
	Odometry,
	Path,
	PointCloud2,
	PointStamped,
	Points,
	PolygonStamped,
	PoseArray,
	PoseStamped,
	PoseWithCovarianceStamped,
	SceneNode,
	TFAxesClient,
	TriangleList,
	Urdf,
	UrdfClient,
	Viewer,
	closestAxisPoint,
	convertToROSRotation,
	costMapPalette,
	findClosestPoint,
	getRandomVibrantHexColor,
	intersectPlane,
	isMobileDevice,
	makeColorMaterial,
	mapPalette,
	rawPalette
}, Symbol.toStringTag, {
	value: "Module"
}));
window.ROS3D = ROS3D, window.ROSLIB = ROSLIB;

function I(o) {
	return getCurrentScope() ? (onScopeDispose(o), !0) : !1
}
const B = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const W = B ? window : void 0;

function x(o) {
	var s;
	const a = toValue(o);
	return (s = a == null ? void 0 : a.$el) != null ? s : a
}

function G() {
	const o = shallowRef(!1),
		s = getCurrentInstance();
	return s && onMounted(() => {
		o.value = !0
	}, s), o
}

function E(o) {
	const s = G();
	return computed(() => (s.value, !!o()))
}

function L(o, s, a = {}) {
	const {
		window: l = W,
		...c
	} = a;
	let d;
	const f = E(() => l && "ResizeObserver" in l),
		m = () => {
			d && (d.disconnect(), d = void 0)
		},
		g = computed(() => {
			const b = toValue(o);
			return Array.isArray(b) ? b.map(C => x(C)) : [x(b)]
		}),
		v = watch(g, b => {
			if (m(), f.value && l) {
				d = new ResizeObserver(s);
				for (const C of b) C && d.observe(C, c)
			}
		}, {
			immediate: !0,
			flush: "post"
		}),
		y = () => {
			m(), v()
		};
	return I(y), {
		isSupported: f,
		stop: y
	}
}
const pe = defineComponent({
		__name: "Viewer",
		props: {
			url: {
				default: `ws://${location.hostname}:8765`
			},
			fixedFrame: {
				default: "map"
			},
			background: {
				default: "#303030"
			},
			reconnectTime: {
				default: 3e3
			},
			cameraType: {
				default: "3D"
			},
			debug: {
				type: Boolean,
				default: !1
			},
			clickTopic: {}
		},
		emits: ["fixedFrames", "tfTreeUpdated", "tfUpdated", "supportViewTopics", "serverInfo"],
		setup(o, {
			expose: s,
			emit: a
		}) {
			const l = o,
				c = a,
				d = ref(null);
			let f, m, g, v;
			const y = ref(!1);
			return watch(() => l.url, () => {
				f && (f.close(), f.connect(l.url))
			}, {
				deep: !0
			}), watch(() => l.fixedFrame, () => {
				m && m.setFixedFrame(l.fixedFrame)
			}, {
				deep: !0
			}), watch(() => l.background, () => {
				g && g.setBackground(l.background, 1)
			}, {
				deep: !0
			}), watch(() => l.cameraType, () => {
				g && (l.cameraType === "2D" ? g.switch2D() : l.cameraType === "3D" && g.switch3D())
			}, {
				deep: !0
			}), watch(() => l.clickTopic, () => {
				v && (v.unadvertise(), v = void 0), l.clickTopic && f && (v = new ROSLIB.Topic({
					ros: f,
					name: l.clickTopic.topic
				}), v.advertise())
			}), s({
				startClick: b => {
					g && g.startClick(b, C => {
						if (l.clickTopic && f && m && v) {
							const _ = l.clickTopic.schemaName.split("/"),
								S = _[_.length - 1];
							if (S === "PointStamped") {
								const w = {
									header: {
										frame_id: m.fixedFrame,
										seq: 0,
										stamp: f.now()
									},
									point: C.position
								};
								v.publish(w)
							} else if (S === "PoseStamped") {
								const w = {
									header: {
										frame_id: m.fixedFrame,
										seq: 0,
										stamp: f.now()
									},
									pose: C
								};
								v.publish(w)
							} else if (S === "PoseWithCovarianceStamped") {
								const w = {
									header: {
										frame_id: m.fixedFrame,
										seq: 0,
										stamp: f.now()
									},
									pose: {
										pose: C,
										covariance: [.25, 0, 0, 0, 0, 0, 0, .25, 0, 0, 0, 0,
											0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
											0, 0, 0, 0, 0, 0, 0, 0, .06853892060437211
										]
									}
								};
								v.publish(w)
							}
						}
					})
				}
			}), onMounted(() => {
				let b;
				const C = () => {
					b !== void 0 && (clearTimeout(b), b = void 0), b = setTimeout(() => {
						console.log("FoxgloveServer 尝试重连"), f == null || f.connect(l.url)
					}, l.reconnectTime)
				};
				if (f = new ROSLIB.Ros({
						url: l.url
					}), f.on("connection", () => {
						console.log("FoxgloveServer 连接成功")
					}), f.on("error", () => {
						console.log("FoxgloveServer 连接异常"), C()
					}), f.on("close", () => {
						console.log("FoxgloveServer 断开连接"), C()
					}), f.on("supportViewTopics", _ => {
						c("supportViewTopics", _)
					}), f.on("serverInfo", _ => {
						c("serverInfo", _)
					}), m = new ROSLIB.TFClient({
						ros: f,
						fixedFrame: l.fixedFrame
					}), m.on("fixedFrames", _ => {
						c("fixedFrames", _)
					}), m.on("tfTreeUpdated", _ => {
						c("tfTreeUpdated", _)
					}), m.on("tfUpdated", () => {
						c("tfUpdated")
					}), d.value) {
					const {
						width: _,
						height: S
					} = d.value.getBoundingClientRect();
					g = new ROS3D.Viewer({
						ros: f,
						tfClient: m,
						elem: d.value,
						width: _,
						height: S,
						background: l.background,
						cameraType: l.cameraType,
						debug: l.debug
					}), provide("ros", f), provide("tfClient", m), provide("viewer", g), y.value = !0
				}
			}), onUnmounted(() => {
				g == null || g.stop(), f == null || f.close()
			}), L(d, b => {
				const C = b[0],
					{
						width: _,
						height: S
					} = C.contentRect;
				g == null || g.resize(_, S)
			}), (b, C) => (openBlock(), createElementBlock(Fragment, null, [createBaseVNode("div", {
				style: {
					width: "100%",
					height: "100%"
				},
				ref_key: "container",
				ref: d
			}, null, 512), y.value ? renderSlot(b.$slots, "default", {
				key: 0
			}) : createCommentVNode("", !0)], 64))
		}
	}),
	N = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#248EFF",
					cellSize: 1,
					numCells: 10
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.GridClient({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	Z = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					lineType: "full"
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.AxesClient({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	$ = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					lineType: "full"
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.TFAxesClient({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	X = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient");
			let l;
			return watch(() => o.options, () => {
				l && l.setOptions(o.options)
			}), onUnmounted(() => {
				l == null || l.dispose()
			}), onMounted(() => {
				l = new ROS3D.Image({
					ros: s,
					tfClient: a,
					renderDom: o.options.renderDom,
					topic: o.options.topic
				})
			}), () => null
		}
	}),
	H = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#FF0000",
					size: .01
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.LaserScan({
					ros: s,
					tfClient: a,
					viewer: l,
					topic: o.options.topic,
					material: {
						color: o.options.color,
						size: o.options.size,
						sizeAttenuation: !1,
						vertexColors: !1
					}
				})
			}), () => null
		}
	}),
	J = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					colorType: "FlatColor",
					color: "#FF0000",
					size: .01,
					decayTime: 0,
					max_point_count: 0
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.PointCloud2({
					ros: s,
					tfClient: a,
					viewer: l,
					topic: o.options.topic,
					colorType: o.options.colorType,
					decayTime: o.options.decayTime,
					max_point_count: o.options.max_point_count,
					material: {
						color: o.options.color,
						size: o.options.size,
						sizeAttenuation: !1,
						vertexColors: !1
					}
				})
			}), () => null
		}
	}),
	K = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.MarkerArrayClient({
					ros: s,
					tfClient: a,
					viewer: l,
					topic: o.options.topic
				})
			}), () => null
		}
	}),
	Q = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					topic: "/octomap_full",
					voxelRenderMode: ROS3D.OcTreeVoxelRenderMode.OCCUPIED,
					colorMode: ROS3D.OcTreeColorMode.Z_AXIS_COLOR,
					opacity: 1
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.OcTreeClient({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	Y = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					type: "map",
					opacity: .7
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.OccupancyGridClient({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	ee = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#CC00FF",
					offsetZ: .1,
					linewidth: 2
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.Path({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	te = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#CC00FF",
					offsetZ: .1,
					radius: .2
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.PointStamped({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	oe = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#CC00FF"
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.PolygonStamped({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	ne = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#CC00FF"
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.PoseStamped({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	ie = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#CC00FF",
					length: 1
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.PoseArray({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	se = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					color: "#CC00FF"
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.PoseWithCovarianceStamped({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	re = defineComponent({
		props: {
			options: {
				type: Object,
				required: !0,
				default: () => ({
					topic: "/robot_description",
					param: "/robot_description"
				})
			}
		},
		setup(o) {
			const s = inject("ros"),
				a = inject("tfClient"),
				l = inject("viewer");
			let c;
			return watch(() => o.options, () => {
				c && c.setOptions(o.options)
			}), onUnmounted(() => {
				c == null || c.dispose()
			}), onMounted(() => {
				c = new ROS3D.UrdfClient({
					ros: s,
					tfClient: a,
					viewer: l,
					...o.options
				})
			}), () => null
		}
	}),
	ue = {
		Grid: N,
		Axes: Z,
		TF: $,
		Image: X,
		LaserScan: H,
		PointCloud2: J,
		MarkerArray: K,
		Octomap: Q,
		OccupancyGrid: Y,
		Path: ee,
		PointStamped: te,
		PolygonStamped: oe,
		PoseStamped: ne,
		PoseArray: ie,
		PoseWithCovarianceStamped: se,
		URDF: re
	},
	_sfc_main$1 = defineComponent({
		__name: "GlobalOptions",
		props: {
			modelValue: {},
			fixedFrames: {}
		},
		emits: ["update:modelValue"],
		setup(o) {
			const s = o;
			return (a, l) => {
				const c = resolveComponent("a-option"),
					d = resolveComponent("a-select"),
					f = resolveComponent("a-form-item"),
					m = resolveComponent("a-color-picker"),
					g = resolveComponent("a-form"),
					v = resolveComponent("a-collapse-item");
				return openBlock(), createBlock(v, {
					header: "Global Options",
					key: "GlobalOptions"
				}, {
					default: withCtx(() => [createVNode(g, {
						model: a.modelValue,
						"auto-label-width": ""
					}, {
						default: withCtx(() => [createVNode(f, {
							label: "Fixed Frame"
						}, {
							default: withCtx(() => [createVNode(d, {
								"model-value": a
									.modelValue
									.fixedFrame,
								"allow-create": "",
								onChange: l[0] || (l[
									0] = y => a
									.$emit(
										"update:modelValue", {
											...s
											.modelValue,
											fixedFrame: y
										}))
							}, {
								default: withCtx(() => [
									(openBlock(!
											0),
										createElementBlock(
											Fragment,
											null,
											renderList(
												a
												.fixedFrames,
												y =>
												(openBlock(),
													createBlock(
														c, {
															key: y,
															value: y
														}, {
															default: withCtx(
																() => [
																	createTextVNode(
																		toDisplayString(
																			y
																			),
																		1
																		)
																]
																),
															_: 2
														},
														1032,
														[
															"value"]
														)
													)
												),
											128)
										)
								]),
								_: 1
							}, 8, ["model-value"])]),
							_: 1
						}), createVNode(f, {
							label: "Background Color"
						}, {
							default: withCtx(() => [createVNode(m, {
								"model-value": a
									.modelValue
									.background,
								format: "hex",
								"disabled-alpha": "",
								onChange: l[1] || (l[
									1] = y => {
										a.$emit("update:modelValue", {
											...
											s
											.modelValue,
											background: y
										})
									})
							}, null, 8, ["model-value"])]),
							_: 1
						})]),
						_: 1
					}, 8, ["model"])]),
					_: 1
				})
			}
		}
	}),
	_hoisted_1 = {
		class: "main-viewer"
	},
	_hoisted_2 = {
		class: "hostname-input"
	},
	_hoisted_3 = {
		class: "sider-content"
	},
	_hoisted_4 = {
		class: "controls"
	},
	_sfc_main = defineComponent({
		__name: "App",
		setup(o) {
			const s = ref(null),
				a = ref(void 0),
				l = ref("10.42.0.1"),
				c = ref(`ws://${l.value}:8765`),
				d = ref("3D"),
				f = ref([]),
				m = ref([]),
				g = ref({}),
				v = ref([]),
				y = ref(void 0),
				b = ref({
					globalOptions: {
						fixedFrame: "map",
						background: "#303030"
					},
					items: [{
						type: "Grid",
						name: "Grid",
						show: !0,
						options: {
							color: "#248EFF",
							cellSize: 1,
							numCells: 10
						}
					}, {
						type: "URDF",
						name: "URDF",
						show: !0,
						options: {}
					}, {
						type: "TF",
						name: "TF",
						show: !0,
						options: {
							lineColor: "#FF0000",
							showLines: !0,
							showLabels: !0,
							frameVisible: {}
						}
					}, {
						type: "Axes",
						name: "Axes",
						show: !1,
						options: {
							lineType: "full"
						}
					}]
				}),
				C = () => {
					d.value = d.value === "2D" ? "3D" : "2D"
				},
				_ = F => {
					y.value = F
				},
				S = () => {
					if (y.value === void 0) alert("请先选择一个主题");
					else if (a.value) {
						const F = y.value.schemaName.split("/");
						F[F.length - 1] === "PointStamped" ? a.value.startClick("point") : a.value.startClick(
							"pose")
					}
				},
				w = F => {
					f.value = F
				},
				T = F => {
					m.value = F
				},
				A = () => {
					c.value = `ws://${l.value}:8765`
				},
				k = F => {
					g.value = F, v.value = [];
					for (const R of Object.values(F)) {
						const O = R.schemaName.split("/"),
							U = O[O.length - 1],
							V = D(U);
						(U === "PointStamped" || U === "PoseStamped" || U === "PoseWithCovarianceStamped") && v
							.value.push(R), b.value.items.findIndex(j => j.name === R.topic) === -1 && b.value.items
							.push({
								name: R.topic,
								options: {
									topic: R.topic,
									...V
								},
								show: !1,
								type: U
							})
					}
				},
				M = () => {
					const F = Math.floor(Math.random() * 256),
						R = Math.floor(Math.random() * 256),
						O = Math.floor(Math.random() * 256),
						U = Math.max(F, R, O),
						V = Math.min(F, R, O);
					if (U < 200 || U - V < 50) return M();
					const z = j => j.toString(16).padStart(2, "0");
					return `#${z(F)}${z(R)}${z(O)}`
				},
				D = F => {
					if (F === "MarkerArray") return {};
					if (F === "Image") return {
						renderDom: s.value
					};
					if (F === "LaserScan") return {
						color: "#FF0000",
						size: 1
					};
					if (F === "PointCloud2") return {
						size: 1,
						decayTime: 0,
						max_point_count: 0,
						colorType: "FlatColor",
						color: "#FF0000"
					};
					if (F === "OccupancyGrid") return {
						type: "map",
						opacity: .7
					};
					if (F === "Path") return {
						color: M(),
						offsetZ: .1
					};
					if (F === "PointStamped") return {
						color: M(),
						offsetZ: 0,
						radius: .2
					};
					if (F === "PolygonStamped") return {
						color: M()
					};
					if (F === "PoseStamped") return {
						color: M()
					};
					if (F === "PoseArray") return {
						color: M(),
						length: 1
					};
					if (F === "PoseWithCovarianceStamped") return {
						color: M()
					};
					if (F === "Octomap") return {
						opacity: 1,
						colorMode: "zAxisColor",
						voxelRenderMode: "occupied"
					}
				};
			return (F, R) => {
				const O = resolveComponent("a-input"),
					U = resolveComponent("a-button"),
					V = resolveComponent("a-collapse"),
					z = resolveComponent("a-layout-sider"),
					j = resolveComponent("a-doption"),
					ge = resolveComponent("a-dropdown-button"),
					me = resolveComponent("a-layout-content"),
					he = resolveComponent("a-layout");
				return openBlock(), createElementBlock(Fragment, null, [createBaseVNode("div", _hoisted_1, [
					createBaseVNode("div", _hoisted_2, [createVNode(O, {
						modelValue: l.value,
						"onUpdate:modelValue": R[0] || (R[0] = ce => l.value = ce),
						placeholder: "输入WebSocket服务器主机名"
					}, null, 8, ["modelValue"]), createVNode(U, {
						type: "primary",
						onClick: A,
						style: {
							"margin-left": "8px"
						}
					}, {
						default: withCtx(() => R[2] || (R[2] = [createTextVNode(
							"更新连接")])),
						_: 1
					})]), createVNode(he, null, {
						default: withCtx(() => [createVNode(z, {
							width: 350
						}, {
							default: withCtx(() => [createBaseVNode("div",
								_hoisted_3, [createVNode(V, {
									"default-active-key": [
										"GlobalOptions"
									]
								}, {
									default: withCtx(
									() => [createVNode(
												_sfc_main$1, {
													"fixed-frames": f
														.value,
													modelValue: b
														.value
														.globalOptions,
													"onUpdate:modelValue": R[
															1
															] ||
														(R[1] =
															ce =>
															b
															.value
															.globalOptions =
															ce
															)
												},
												null,
												8, ["fixed-frames",
													"modelValue"
												]),
											(openBlock(
													!
													0
													),
												createElementBlock(
													Fragment,
													null,
													renderList(
														b
														.value
														.items,
														(ce,
															ae) =>
														(openBlock(),
															createBlock(
																resolveDynamicComponent(
																	unref(
																		OptionComponents
																		)[
																		ce
																		.type
																		]
																	), {
																	key: ce
																		.name,
																	modelValue: ce
																		.options,
																	"onUpdate:modelValue": fe =>
																		ce
																		.options =
																		fe,
																	show: ce
																		.show,
																	"onUpdate:show": fe =>
																		ce
																		.show =
																		fe,
																	"fixed-frame": b
																		.value
																		.globalOptions
																		.fixedFrame,
																	"fixed-frames": f
																		.value,
																	"tf-tree": m
																		.value,
																	topics: g
																		.value,
																	name: ce
																		.name,
																	index: ae
																},
																null,
																40,
																["modelValue",
																	"onUpdate:modelValue",
																	"show",
																	"onUpdate:show",
																	"fixed-frame",
																	"fixed-frames",
																	"tf-tree",
																	"topics",
																	"name",
																	"index"
																]
																)
															)
														),
													128
													)
												)
										]),
									_: 1
								})])]),
							_: 1
						}), createVNode(me, null, {
							default: withCtx(() => [createVNode(unref(pe), {
								debug: !0,
								url: c.value,
								"reconnect-time": 3e3,
								"click-topic": y.value,
								"camera-type": d.value,
								"fixed-frame": b.value
									.globalOptions
									.fixedFrame,
								background: b.value
									.globalOptions
									.background,
								onFixedFrames: w,
								onTfTreeUpdated: T,
								onSupportViewTopics: k,
								ref_key: "viewerRef",
								ref: a
							}, {
								default: withCtx(() => [(
									openBlock(!
										0),
									createElementBlock(
										Fragment,
										null,
										renderList(
											b
											.value
											.items,
											(ce,
												ae) =>
											(openBlock(),
												createElementBlock(
													Fragment, {
														key: ce
															.name
													},
													[ce.show ?
														(openBlock(),
															createBlock(
																resolveDynamicComponent(
																	unref(
																		ue
																		)[
																		ce
																		.type
																		]
																	), {
																	key: ae,
																	options: ce
																		.options
																},
																null,
																8,
																[
																	"options"]
																)
															) :
														createCommentVNode(
															"",
															!
															0
															)
													],
													64
													)
												)
											),
										128))]),
								_: 1
							}, 8, ["url", "click-topic",
								"camera-type",
								"fixed-frame", "background"
							]), createBaseVNode("div",
								_hoisted_4, [createVNode(U, {
									onClick: C,
									size: "mini"
								}, {
									default: withCtx(
									() => [createTextVNode(
											toDisplayString(
												d
												.value
												),
											1)]),
									_: 1
								}), createVNode(ge, {
									style: {
										"margin-top": "10px"
									},
									size: "mini",
									onClick: S
								}, {
									content: withCtx(
									() => [(openBlock(
												!
												0
												),
											createElementBlock(
												Fragment,
												null,
												renderList(
													v
													.value,
													ce => {
														var
														ae;
														return openBlock(),
															createBlock(
																j, {
																	key: ce
																		.topic,
																	onClick: () =>
																		_(
																			ce),
																	class: normalizeClass(
																		["click-topic",
																		{
																			active: (
																					(ae =
																						y
																						.value
																						) ==
																					null ?
																					void 0 :
																					ae
																					.topic
																					) ===
																				ce
																				.topic
																		}]
																		)
																}, {
																	default: withCtx(
																		() => [
																			createBaseVNode(
																				"div",
																				null,
																				toDisplayString(
																					ce
																					.topic
																					),
																				1
																				)
																		]
																		),
																	_: 2
																},
																1032,
																["onClick",
																	"class"
																]
																)
													}
													),
												128
												)
											)]),
									default: withCtx(
									() => [createVNode(
											unref(
												ArrowUpRight
												)
											)]),
									_: 1
								})])]),
							_: 1
						})]),
						_: 1
					})
				]), createBaseVNode("div", {
					class: "image",
					ref_key: "imageRef",
					ref: s
				}, null, 512)], 64)
			}
		}
	}),
	_export_sfc = (o, s) => {
		const a = o.__vccOpts || o;
		for (const [l, c] of s) a[l] = c;
		return a
	},
	App = _export_sfc(_sfc_main, [
		["__scopeId", "data-v-c5048645"]
	]),
	app = createApp(App);
app.use(ArcoVue);
app.mount("#app");